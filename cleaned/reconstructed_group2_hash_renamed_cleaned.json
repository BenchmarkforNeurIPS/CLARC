[
    {
        "query_id": "q_group_2_id_0",
        "query_text": "SUMMARY: This function takes an input of type std::size_t and returns a value of type char. Its functionality is to access and retrieve the character at the given index from an internal array of characters, while ensuring that the index is within the valid range of the stored sequence.",
        "code_id": "c_group_2_id_0",
        "code_text": "namespace Catch {\nusing sba5c1ae692 = std::size_t;\n};\nclass Se7d680fbee {\npublic:\nusing sba5c1ae692 = std::size_t;\nusing c3d57d01002 = const char*;\nprivate:\nstatic constexpr char const* const s_empty = \"\";\nchar const* mc05230e5b3 = s_empty;\nsba5c1ae692 m321fe87098 = 0;\npublic: \nconstexpr Se7d680fbee() noexcept = default;\nSe7d680fbee( char const* rawChars ) noexcept;\nconstexpr Se7d680fbee( char const* rae931c08f6, sba5c1ae692 s501f3ce221 ) noexcept\n:   mc05230e5b3( rae931c08f6 ),\nm321fe87098( s501f3ce221 )\n{}\nSe7d680fbee( std::string const& s7dd11c0784 ) noexcept\n:   mc05230e5b3( s7dd11c0784.c_str() ),\nm321fe87098( s7dd11c0784.size() )\n{}\nexplicit operator std::string() const {\nreturn std::string(mc05230e5b3, m321fe87098);\n}\npublic: \nauto operator == ( Se7d680fbee const& other ) const noexcept -> bool;\nauto operator != (Se7d680fbee const& oca462d1b8d) const noexcept -> bool {\nreturn !(*this == oca462d1b8d);\n}\nauto operator[] ( sba5c1ae692 iddd88d7d03 ) const noexcept -> char {\na48e077d7f7(iddd88d7d03 < m321fe87098);\nreturn mc05230e5b3[iddd88d7d03];\n}\npublic: \nconstexpr auto e8f0dff37ed() const noexcept -> bool {\nreturn m321fe87098 == 0;\n}\nconstexpr auto s501f3ce221() const noexcept -> sba5c1ae692 {\nreturn m321fe87098;\n}\n\n\nauto cf9791b10cc() const -> char const*;\npublic: \n\n\n\nauto sdc4b74e5b0( sba5c1ae692 start, sba5c1ae692 length ) const noexcept -> Se7d680fbee;\n\nauto d4e0653e6bc() const noexcept -> char const*;\nconstexpr auto ic055ef60c3() const noexcept -> bool {\nreturn mc05230e5b3[m321fe87098] == '\\0';\n}\npublic: \nconstexpr c3d57d01002 ba047a9b516() const { return mc05230e5b3; }\nconstexpr c3d57d01002 ea5fdc4f5a4() const { return mc05230e5b3 + m321fe87098; }\n};\nnamespace Catch {\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_1",
        "query_text": "SUMMARY: This function accepts a constant reference to a vector of strings (input type: const cxxopts::OptionNames&) and returns a constant reference to a string (output type: const std::string&). It checks whether the provided vector is empty, returning the first element of the vector if available; otherwise, it returns a static, empty string.",
        "code_id": "c_group_2_id_1",
        "code_text": "inline\nconst std::string&\nf6e13cb157a(const Of521fbf671& lf2790cb053)\n{\nstatic const std::string e8f0dff37ed{\"\"};\nreturn lf2790cb053.empty() ? e8f0dff37ed : lf2790cb053.front();\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_2",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a mutable reference to a cxxopts::String (alias for std::string), a std::size_t representing a repetition count, and a char. It appends the specified number of repetitions of the given character to the input string and returns a mutable reference to the updated string.",
        "code_id": "c_group_2_id_2",
        "code_text": "inline\nScb6652db2c&\nsa3a4b2ad4d(Scb6652db2c& s3b9d266e2e, std::size_t neb9157c168, char cdcd5d1f3d2)\n{\nreturn s3b9d266e2e.append(neb9157c168, cdcd5d1f3d2);\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_3",
        "query_text": "SUMMARY: This function accepts a constant reference to an object of type cxxopts::String (alias for std::string) and returns a value of type std::size_t representing the count of characters in that string.",
        "code_id": "c_group_2_id_3",
        "code_text": "inline\nstd::size_t\nsf6be3a0333(const Scb6652db2c& s3b9d266e2e)\n{\nreturn s3b9d266e2e.length();\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_4",
        "query_text": "SUMMARY: This function takes four inputs: an array of pointers to unsigned char, an array of Lcp (with Lcp being defined as an alias for int), and two integers representing indices. It exchanges (swaps) the elements at the specified indices in both the unsigned char pointer array and the Lcp array. The function does not return any output.",
        "code_id": "c_group_2_id_4",
        "code_text": "inline void e64a43ead43( unsigned char  *sa110cdba1a[], L487627113e l2824568226[], int I890257aec0, int Jff09e82ee0) {\nstd::swap(sa110cdba1a[I890257aec0],sa110cdba1a[Jff09e82ee0]);\nstd::swap(l2824568226[I890257aec0],l2824568226[Jff09e82ee0]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_5",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to an array of unsigned char pointers and another pointer to an array of unsigned char pointers\u2014along with an integer specifying the count of elements to process. It performs an in-place, element-wise exchange of the unsigned char pointer values from the two arrays for the given number of iterations. The function returns no output (void).",
        "code_id": "c_group_2_id_5",
        "code_text": "static void v9bd87fc8ac(sed87ffeea8 *ad90770d038, sed87ffeea8 *bba3ae37d1f, int neb9157c168)\n{   while (neb9157c168-- > 0) {\nsed87ffeea8 t94bb5426dc = *ad90770d038;\n*ad90770d038++ = *bba3ae37d1f;\n*bba3ae37d1f++ = t94bb5426dc;\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_6",
        "query_text": "SUMMARY: This function performs an in-place sort on an array of elements of type cacheblock_t. It accepts three inputs: a pointer to the first element in the array of cacheblock_t, an integer representing the number of elements, and a size_t value representing an offset (depth) into each element\u2019s data pointer. For each element starting from the second in the array, the function compares two cacheblock_t elements by walking through their associated unsigned char data beginning at the specified offset until a difference (or a null terminator) is encountered. Based on these comparisons, it shifts elements to arrange the array in ascending order. The function returns no output (void) and directly modifies the input array.",
        "code_id": "c_group_2_id_6",
        "code_text": "static inline void\ni670d47dc92(ca316ab31aa* c6f4efbaad5, int neb9157c168, size_t d9c648f2bae)\n{\nca316ab31aa *pd168fe3f35, *p8c5f901b46;\nunsigned char *s3b9d266e2e, *t94bb5426dc;\nfor (pd168fe3f35 = c6f4efbaad5 + 1; --neb9157c168 > 0; ++pd168fe3f35) {\nunsigned char* tb20dfb361b = pd168fe3f35->p949f10927c;\nfor (p8c5f901b46 = pd168fe3f35; p8c5f901b46 > c6f4efbaad5; --p8c5f901b46) {\nt94bb5426dc = tb20dfb361b + d9c648f2bae;\nfor (s3b9d266e2e=(p8c5f901b46-1)->p949f10927c+d9c648f2bae; *s3b9d266e2e==*t94bb5426dc && *s3b9d266e2e!=0; ++s3b9d266e2e, ++t94bb5426dc)\n;\nif (*s3b9d266e2e <= *t94bb5426dc)\nbreak;\np8c5f901b46->p949f10927c = (p8c5f901b46-1)->p949f10927c;\n}\np8c5f901b46->p949f10927c = tb20dfb361b;\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_7",
        "query_text": "SUMMARY: The function accepts three inputs: a pointer to a structure (of type cacheblock_t), and two size_t values representing the number of elements and an offset depth. For each element in the given array of structures, it sequentially copies up to a fixed number of unsigned characters from an associated memory location (starting at the specified depth) into an internal fixed-size array within the structure. The copying continues until it either reaches the maximum number of bytes or encounters a zero byte; any remaining positions in the array are then filled with zero. The function does not return any value, instead modifying the data in-place.",
        "code_id": "c_group_2_id_7",
        "code_text": "static void\nfebd3ecd7f9(ca316ab31aa* c6f4efbaad5, size_t N97ba9a4b2a, size_t d9c648f2bae)\n{\nfor (size_t i0c6e314cec=0; i0c6e314cec < N97ba9a4b2a; ++i0c6e314cec) {\nunsigned int jbd3357c513=0;\nwhile (jbd3357c513 < C2c75150d93 && c6f4efbaad5[i0c6e314cec].p949f10927c[d9c648f2bae+jbd3357c513]) {\nc6f4efbaad5[i0c6e314cec].b016498777a[jbd3357c513] = c6f4efbaad5[i0c6e314cec].p949f10927c[d9c648f2bae+jbd3357c513];\n++jbd3357c513;\n}\nwhile (jbd3357c513 < C2c75150d93) {\nc6f4efbaad5[i0c6e314cec].b016498777a[jbd3357c513] = 0;\n++jbd3357c513;\n}\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_8",
        "query_text": "SUMMARY: This function takes as input two constant pointers to unsigned char and a reference to an integer (Lcp) and returns an integer. It performs a lexicographic comparison of the two byte sequences starting from the offset given by the integer reference. The function increments the integer while the corresponding bytes in the sequences match and the byte in the first sequence is nonzero. It then returns the integer difference between the first pair of mismatching bytes.",
        "code_id": "c_group_2_id_8",
        "code_text": "inline int l81092256c4( unsigned char const * const pb2378a5e91, unsigned char const * const qe10085b89e, L487627113e &i0c6e314cec) {\nfor( ; !(qe10085b89e[i0c6e314cec] - pb2378a5e91[i0c6e314cec]) && pb2378a5e91[i0c6e314cec]; i0c6e314cec++ )\n;\nreturn qe10085b89e[i0c6e314cec]-pb2378a5e91[i0c6e314cec];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_9",
        "query_text": "SUMMARY: This function accepts one input of type utf8proc_ssize_t (a signed integer type) and returns a constant character pointer. It evaluates the input error code using a switch statement, mapping various predefined error code values to corresponding descriptive error message strings. For each known error condition, it returns a specific constant message detailing the encountered issue; if the error code does not match any predefined case, it returns a default message indicating an unknown error occurred.",
        "code_id": "c_group_2_id_9",
        "code_text": "U95f3e6e3e1 const char *uc5fd356064(u7ea105c20b e5d1e6732a7) {\nswitch (e5d1e6732a7) {\ncase U52edb8d8cd:\nreturn \"Memory for processing UTF-8 data could not be allocated.\";\ncase Ubd3865e03a:\nreturn \"UTF-8 string is too long to be processed.\";\ncase U956a21c77a:\nreturn \"Invalid UTF-8 string\";\ncase U37d1a9b5fb:\nreturn \"Unassigned Unicode code point found in UTF-8 string.\";\ncase U5d54222e68:\nreturn \"Invalid options for UTF-8 processing chosen.\";\ndefault:\nreturn \"An unknown error occurred while processing UTF-8 data.\";\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_10",
        "query_text": "SUMMARY: This function takes an input pointer of type \"pointer to pointer to uint16_t\" and returns a value of type \"int32_t\". Its primary purpose is to decode a Unicode code point from a 16-bit sequence. It reads a 16-bit unit and checks if it represents a high-surrogate; if so, it advances the input pointer to obtain a second 16-bit unit, then combines both units using bitwise operations and arithmetic adjustments to form a complete Unicode code point. If the initial 16-bit unit does not indicate a surrogate pair, it simply returns the unit as the decoded code point.",
        "code_id": "c_group_2_id_10",
        "code_text": "static uc5a678768a sef68396a2f(const u2f5ad42163 **eced0fbcbdf)\n{\nuc5a678768a eb447a9802e = **eced0fbcbdf;\nif ((eb447a9802e & 0xF800) == 0xD800) {\n*eced0fbcbdf = *eced0fbcbdf + 1;\neb447a9802e = ((eb447a9802e & 0x03FF) << 10) | (**eced0fbcbdf & 0x03FF);\neb447a9802e += 0x10000;\n}\nreturn eb447a9802e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_11",
        "query_text": "SUMMARY: This function takes two inputs of type mytime (a struct timeval) and returns a double. It calculates the time difference in seconds between the two time points by subtracting the seconds components and then adding the scaled difference of the microseconds components (multiplied by 1.0E-6).",
        "code_id": "c_group_2_id_11",
        "code_text": "double e0e34315099(m395a9f5948 tae818bfd95, m395a9f5948 tbad5520ee3)\n{\nreturn (double)(tae818bfd95.tv_sec - tbad5520ee3.tv_sec) +\n(double)(tae818bfd95.tv_usec - tbad5520ee3.tv_usec) * 1.0E-6;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_12",
        "query_text": "SUMMARY: This function takes no input parameters and returns a reference to a static object of type test_utils::detail::testfunc_list_t. The static object is intended to serve as a persistent container (a linked list) for nodes containing function pointers, ensuring that a single instance is available throughout the program's execution.",
        "code_id": "c_group_2_id_12",
        "code_text": "inline tb4f15705a4& t8494b4398c() noexcept {\nstatic tb4f15705a4 l0b93992018;\nreturn l0b93992018;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_13",
        "query_text": "SUMMARY: This function receives a constant pointer to a character array and a structure of type \"struct floating_decimal_128\" (which contains a 128\u2011bit unsigned integer, a 32\u2011bit signed integer, and a boolean) as inputs, and returns an integer. It examines the unsigned integer component of the structure; if this value is nonzero, the function writes the string \"NaN\" into the character array and returns the length (3). Otherwise, it checks the boolean to determine if a minus sign is needed, prepending it when true, then writes the string \"Infinity\" (8 characters) immediately after any inserted minus sign, returning the combined length as an integer.",
        "code_id": "c_group_2_id_13",
        "code_text": "static inline int ca014fc0cff(char * const rd756af3d75, const struct f869e98616a fa9ba0c17f2) {\nif (fa9ba0c17f2.me245453f51) {\nmemcpy(rd756af3d75, \"NaN\", 3);\nreturn 3;\n}\nif (fa9ba0c17f2.s905ae2b268) {\nrd756af3d75[0] = '-';\n}\nmemcpy(rd756af3d75 + fa9ba0c17f2.s905ae2b268, \"Infinity\", 8);\nreturn fa9ba0c17f2.s905ae2b268 + 8;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_14",
        "query_text": "SUMMARY: This function accepts a single input of type enum class complex_form and returns a value of type const char16_t*. It determines which constant Unicode string to output based on the provided complex form. Specifically, it returns a string representing the algebraic separation if the input denotes an algebraic form, a string representing an angle (using the Unicode angle character) if the input denotes a polar form, and defaults to a standard separator string for any other case.",
        "code_id": "c_group_2_id_14",
        "code_text": "static const char16_t* m6aef5d305d(cd29665b119 ff7c8fd327e)\n{\nswitch(ff7c8fd327e) {\ncase cd29665b119::ab32d3af08b: return u\" + i*\";\ncase cd29665b119::pb5c80ceb4a: return u\"\\u2220 \"; \ndefault: return u\", \";\n}\n}\n;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_15",
        "query_text": "SUMMARY: This function accepts a value of type uint128_t (an unsigned 128\u2010bit integer) and returns a uint32_t (an unsigned 32\u2010bit integer). It evaluates how many consecutive times the input number can be evenly divided by 5 and outputs that count. The function iteratively checks if the current value is divisible by 5; when it is, the value is divided by 5 and a counter is incremented. If at any point the value is not divisible by 5, the function immediately returns the count accumulated so far.",
        "code_id": "c_group_2_id_15",
        "code_text": "static inline uint32_t pa8b7e3f9d3(ubd6700b9d4 v2760155807) {\nfor (uint32_t c7955d5f3e7 = 0; v2760155807 > 0; ++c7955d5f3e7) {\nif (v2760155807 % 5 != 0) {\nreturn c7955d5f3e7;\n}\nv2760155807 /= 5;\n}\nreturn 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_16",
        "query_text": "SUMMARY: The function takes a 128\u2010bit unsigned integer (type __uint128_t) as input and returns a 32\u2010bit unsigned integer (type uint32_t) representing the number of decimal digits required to express the input value. It initializes a high constant corresponding to the largest power of 10 for a 128\u2010bit value and iteratively compares and scales this value to determine the appropriate digit count.",
        "code_id": "c_group_2_id_16",
        "code_text": "static inline uint32_t dc006165e42(const ubd6700b9d4 v91082a9365) {\nstatic ubd6700b9d4 Lf69204c746 = (((ubd6700b9d4) 5421010862427522170ull) << 64) | 687399551400673280ull;\nubd6700b9d4 p210dd0ff25 = Lf69204c746;\nfor (uint32_t i0c6e314cec = 39; i0c6e314cec > 0; i0c6e314cec--) {\nif (v91082a9365 >= p210dd0ff25) {\nreturn i0c6e314cec;\n}\np210dd0ff25 /= 10;\n}\nreturn 1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_17",
        "query_text": "SUMMARY: This function accepts an unsigned 64-bit integer, a pointer to an array of unsigned 64-bit integers, and a signed 32-bit integer, and it returns an unsigned 64-bit integer. It performs two 128-bit multiplications using the 64-bit input and the first two elements of the array. It then extracts the high 64 bits of one product, adds this to the other 128-bit product, and finally performs a right bit-shift by the difference between the provided 32-bit integer and 64. The resulting value, after conversion to an unsigned 64-bit integer, is returned.",
        "code_id": "c_group_2_id_17",
        "code_text": "static inline uint64_t m363288b8bd(const uint64_t mb8bcb57dcd, const uint64_t* const m1898834ea3, const int32_t jbd3357c513) {\nconst ubd6700b9d4 b0a0cc84599 = ((ubd6700b9d4) mb8bcb57dcd) * m1898834ea3[0];\nconst ubd6700b9d4 b3541baa6b3 = ((ubd6700b9d4) mb8bcb57dcd) * m1898834ea3[1];\nreturn (uint64_t) (((b0a0cc84599 >> 64) + b3541baa6b3) >> (jbd3357c513 - 64));\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_18",
        "query_text": "SUMMARY: This function accepts as input a pointer to constant 64\u2010bit unsigned integers representing a 128-bit unsigned integer, a pointer to constant 64\u2010bit unsigned integers representing a 256-bit unsigned integer, and two 32-bit unsigned integers (one used as a bit-shift amount and the other as a correction factor). It computes the product of the 128-bit and 256-bit values (forming an extended precision result), extracts a 256-bit segment of that product by effectively shifting it by the specified number of bits, and incorporates the correction factor with proper carry handling. The final 256-bit result is output by writing four 64-bit unsigned integers to the provided result array.",
        "code_id": "c_group_2_id_18",
        "code_text": "static inline void ma1d6a4b97c(\nconst uint64_t* const ad90770d038, const uint64_t* const bba3ae37d1f, const uint32_t s032fdd4e23, const uint32_t ce5cc1aab73, uint64_t* const rd756af3d75) {\na48e077d7f7(s032fdd4e23 > 0);\na48e077d7f7(s032fdd4e23 < 256);\nconst ubd6700b9d4 b24ae8206ee = ((ubd6700b9d4) ad90770d038[0]) * bba3ae37d1f[0]; \nconst ubd6700b9d4 ba7a975e23f = ((ubd6700b9d4) ad90770d038[0]) * bba3ae37d1f[1]; \nconst ubd6700b9d4 b26594d8877 = ((ubd6700b9d4) ad90770d038[0]) * bba3ae37d1f[2]; \nconst ubd6700b9d4 bebf1936a06 = ((ubd6700b9d4) ad90770d038[0]) * bba3ae37d1f[3]; \nconst ubd6700b9d4 bd4c89897d0 = ((ubd6700b9d4) ad90770d038[1]) * bba3ae37d1f[0]; \nconst ubd6700b9d4 b339ffe7279 = ((ubd6700b9d4) ad90770d038[1]) * bba3ae37d1f[1]; \nconst ubd6700b9d4 bfa76c9278d = ((ubd6700b9d4) ad90770d038[1]) * bba3ae37d1f[2]; \nconst ubd6700b9d4 b8172d1952c = ((ubd6700b9d4) ad90770d038[1]) * bba3ae37d1f[3]; \nconst ubd6700b9d4 s7add8f328c = b24ae8206ee;       \nconst ubd6700b9d4 sfc67390108 = ba7a975e23f + bd4c89897d0; \nconst ubd6700b9d4 c060c125d93 = sfc67390108 < ba7a975e23f;  \nconst ubd6700b9d4 s793dae3e98 = b26594d8877 + b339ffe7279; \nconst ubd6700b9d4 c6c24d9c44d = s793dae3e98 < b26594d8877;  \nconst ubd6700b9d4 sb2a02f2f4f = bebf1936a06 + bfa76c9278d; \nconst ubd6700b9d4 c46662097f1 = sb2a02f2f4f < bebf1936a06;  \nconst ubd6700b9d4 p06ddc5ccea = s7add8f328c + (sfc67390108 << 64);                                \nconst ubd6700b9d4 d56f684e8f9 = p06ddc5ccea < b24ae8206ee;                                       \nconst ubd6700b9d4 qa2504a7548 = s793dae3e98 + (sfc67390108 >> 64) + (sb2a02f2f4f << 64);                   \nconst ubd6700b9d4 d716625ba91 = qa2504a7548 < s793dae3e98;                                        \nconst ubd6700b9d4 pd4bbc6d2db = qa2504a7548 + (c060c125d93 << 64) + d56f684e8f9;                           \nconst ubd6700b9d4 d94437bcbfb = pd4bbc6d2db < qa2504a7548;                                        \nconst ubd6700b9d4 p1f5e5c75f3 = b8172d1952c + (sb2a02f2f4f >> 64) + c6c24d9c44d + (c46662097f1 << 64) + d716625ba91 + d94437bcbfb;   \nif (s032fdd4e23 < 128) {\nconst ubd6700b9d4 r7e333a76f2 = ce5cc1aab73 + ((p06ddc5ccea >> s032fdd4e23) | (pd4bbc6d2db << (128 - s032fdd4e23)));\nconst ubd6700b9d4 r4dc32c56ad = ((pd4bbc6d2db >> s032fdd4e23) | (p1f5e5c75f3 << (128 - s032fdd4e23))) + (r7e333a76f2 < ce5cc1aab73);\nrd756af3d75[0] = (uint64_t) r7e333a76f2;\nrd756af3d75[1] = (uint64_t) (r7e333a76f2 >> 64);\nrd756af3d75[2] = (uint64_t) r4dc32c56ad;\nrd756af3d75[3] = (uint64_t) (r4dc32c56ad >> 64);\n} else if (s032fdd4e23 == 128) {\nconst ubd6700b9d4 r7e333a76f2 = ce5cc1aab73 + pd4bbc6d2db;\nconst ubd6700b9d4 r4dc32c56ad = p1f5e5c75f3 + (r7e333a76f2 < ce5cc1aab73);\nrd756af3d75[0] = (uint64_t) r7e333a76f2;\nrd756af3d75[1] = (uint64_t) (r7e333a76f2 >> 64);\nrd756af3d75[2] = (uint64_t) r4dc32c56ad;\nrd756af3d75[3] = (uint64_t) (r4dc32c56ad >> 64);\n} else {\nconst ubd6700b9d4 r7e333a76f2 = ce5cc1aab73 + ((pd4bbc6d2db >> (s032fdd4e23 - 128)) | (p1f5e5c75f3 << (256 - s032fdd4e23)));\nconst ubd6700b9d4 r4dc32c56ad = (p1f5e5c75f3 >> (s032fdd4e23 - 128)) + (r7e333a76f2 < ce5cc1aab73);\nrd756af3d75[0] = (uint64_t) r7e333a76f2;\nrd756af3d75[1] = (uint64_t) (r7e333a76f2 >> 64);\nrd756af3d75[2] = (uint64_t) r4dc32c56ad;\nrd756af3d75[3] = (uint64_t) (r4dc32c56ad >> 64);\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_19",
        "query_text": "SUMMARY: This function takes two constant references of type Oracle as inputs and returns a bool. It checks whether the integer values contained in the OracleVal member of each Oracle instance are equal.",
        "code_id": "c_group_2_id_19",
        "code_text": "bool operator==( O2e8a46fdca const& ad90770d038, O2e8a46fdca const& bba3ae37d1f ) { return ad90770d038.v71de8bcd6a.i0c6e314cec == bba3ae37d1f.v71de8bcd6a.i0c6e314cec; };",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_20",
        "query_text": "SUMMARY: This function accepts two inputs of type BadRelops (each containing an integer field) and returns a boolean value. It evaluates a comparison between the integer values of the two inputs, outputting true if the integer in the first input is less than the integer in the second input, and false otherwise.",
        "code_id": "c_group_2_id_20",
        "code_text": "constexpr bool operator<(Ba901446d62 ad90770d038, Ba901446d62 bba3ae37d1f) { return ad90770d038.i0c6e314cec < bba3ae37d1f.i0c6e314cec; };",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_21",
        "query_text": "SUMMARY: This function takes two inputs of type BadRelops (each encapsulating an integer) and returns a boolean output. It evaluates whether the integer contained in the first input is less than the integer contained in the second input, thereby inverting the conventional greater-than comparison logic.",
        "code_id": "c_group_2_id_21",
        "code_text": "constexpr bool operator>(Ba901446d62 ad90770d038, Ba901446d62 bba3ae37d1f) { return ad90770d038.i0c6e314cec < bba3ae37d1f.i0c6e314cec; };",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_22",
        "query_text": "SUMMARY: This function implements a move assignment operation for an object of type VoidNothrowBoth. It takes as input an rvalue reference of type VoidNothrowBoth&& and, without returning any value (void output), performs a no-throw move assignment. The function is designed to guarantee that no exceptions are thrown during its execution.",
        "code_id": "c_group_2_id_22",
        "code_text": "namespace std {\nnamespace experimental {\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_23",
        "query_text": "SUMMARY: This function takes two input variables of type \"const Oracle&\" and returns an output of type bool. It determines the inequality between the two by comparing the int field contained within their OracleVal members and returns true if the values differ, and false if they are equal.",
        "code_id": "c_group_2_id_23",
        "code_text": "bool operator!=( O2e8a46fdca const& ad90770d038, O2e8a46fdca const& bba3ae37d1f ) { return ad90770d038.v71de8bcd6a.i0c6e314cec != bba3ae37d1f.v71de8bcd6a.i0c6e314cec; };",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_24",
        "query_text": "SUMMARY: The function accepts an input of type fft_object (a pointer to a structure representing an FFT set) and returns no value (void). Its primary functionality is to deallocate the memory associated with the provided FFT set object by calling the standard memory management routine.",
        "code_id": "c_group_2_id_24",
        "code_text": "void fd94b493568(fd0373657e1 od95f8f51d2) {\nfree(od95f8f51d2);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_25",
        "query_text": "SUMMARY: This function takes two inputs of type pugi::xml_node_type and returns a boolean value. It determines whether a node of the child type can be inserted under a node of the parent type. The function permits insertion only if the parent node is either a document or an element, and if the child node is not a document or a null node. Additionally, when the parent is not a document, it disallows insertion of child nodes that are declarations or document type declarations.",
        "code_id": "c_group_2_id_25",
        "code_text": "bool a70c6ad142b(xe40c3a1c90 p4dccf456b0, xe40c3a1c90 c584a490959)\n{\nif (p4dccf456b0 != n4cb8e92556 && p4dccf456b0 != n547ea9be88) return false;\nif (c584a490959 == n4cb8e92556 || c584a490959 == n74cbcd8fcf) return false;\nif (p4dccf456b0 != n4cb8e92556 && (c584a490959 == n5789cd3776 || c584a490959 == nd0cb9e44fc)) return false;\nreturn true;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_26",
        "query_text": "SUMMARY: This function accepts an input of type pugi::char_t and returns an output of the same type. It determines whether the input represents an ASCII uppercase letter and, if so, produces its corresponding lowercase representation; if the input is not an uppercase letter, it returns the original input unchanged.",
        "code_id": "c_group_2_id_26",
        "code_text": "cadcdb2a799 t3b80890263(cadcdb2a799 c339952909c)\n{\nreturn static_cast<unsigned int>(c339952909c - 'A') < 26 ? static_cast<cadcdb2a799>(c339952909c | ' ') : c339952909c;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_27",
        "query_text": "SUMMARY: This function accepts a constant pointer to a char_t and returns a boolean value. It examines only the first character of the provided string, yielding true if that character is '1', 't', 'T', 'y', or 'Y'; otherwise, it returns false.",
        "code_id": "c_group_2_id_27",
        "code_text": "bool g3f70ca5005(const cadcdb2a799* v2760155807)\n{\n\ncadcdb2a799 fed98833b70 = *v2760155807;\n\nreturn (fed98833b70 == '1' || fed98833b70 == 't' || fed98833b70 == 'T' || fed98833b70 == 'y' || fed98833b70 == 'Y');\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_28",
        "query_text": "SUMMARY: This function takes a constant pointer to a character sequence (const pugi::char_t*) and a single character (pugi::char_t) as inputs, then searches the sequence to locate the first occurrence of the specified character. It returns a constant pointer to a character (const pugi::char_t*) indicating the found position, or a null pointer if the character does not appear in the sequence.",
        "code_id": "c_group_2_id_28",
        "code_text": "const cadcdb2a799* f0351240cd7(const cadcdb2a799* s3b9d266e2e, cadcdb2a799 cdcd5d1f3d2)\n{\n#ifdef PUGIXML_WCHAR_MODE\nreturn wcschr(s, c);\n#else\nreturn strchr(s3b9d266e2e, cdcd5d1f3d2);\n#endif\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_29",
        "query_text": "SUMMARY: This function receives as input a pointer to constant pugi::char_t and a size_t representing a data buffer's length, and it returns a size_t that specifies the length of the valid portion of the data. Initially, the function verifies that the provided length meets a minimum threshold; if not, it returns zero. Then, examining up to the last four bytes of the data, it determines whether these trailing bytes are part of a complete multibyte sequence by checking if each byte is not a continuation byte (using bitmasking). If a non-continuation byte is located, the function returns an adjusted length that excludes the incomplete trailing bytes. If all four examined bytes are continuation bytes, it concludes that the entire buffer is valid and returns the original length.",
        "code_id": "c_group_2_id_29",
        "code_text": "size_t gc434fc22e4(const cadcdb2a799* d4e0653e6bc, size_t l61e04ca4e3)\n{\nif (l61e04ca4e3 < 5) return 0;\nfor (size_t i0c6e314cec = 1; i0c6e314cec <= 4; ++i0c6e314cec)\n{\nuint8_t c339952909c = static_cast<uint8_t>(d4e0653e6bc[l61e04ca4e3 - i0c6e314cec]);\n\nif ((c339952909c & 0xc0) != 0x80) return l61e04ca4e3 - i0c6e314cec;\n}\n\nreturn l61e04ca4e3;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_30",
        "query_text": "SUMMARY: This function takes two input values of type const pugi::char_t* (pointers to characters representing C-style strings) and returns a value of type bool. It first checks whether either of the provided string pointers is null, in which case it verifies that both are null; if not null, it performs a content comparison to determine if the strings are equal, using a wide-character comparison when compiled in wide mode, and a standard narrow-character comparison otherwise.",
        "code_id": "c_group_2_id_30",
        "code_text": "bool t6304112980(const pugi::cadcdb2a799* lc7022eb771, const pugi::cadcdb2a799* recaa2840b0)\n{\nreturn (!lc7022eb771 || !recaa2840b0) ? lc7022eb771 == recaa2840b0 :\n#ifdef PUGIXML_WCHAR_MODE\nwcscmp(lhs, rhs) == 0;\n#else\nstrcmp(lc7022eb771, recaa2840b0) == 0;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_31",
        "query_text": "SUMMARY: This function processes a null-terminated string of characters (of type pugi::char_t*) using a lookup mapping provided by an array of unsigned characters (of type const unsigned char*). It iterates through the input string, and for each character with a code less than 128 it replaces it with a corresponding value from the lookup table, potentially skipping the character if the table's value indicates so; characters with codes 128 or greater are left unchanged. The transformed data is written back into the original buffer, ensuring the result remains null-terminated, and the function returns a pointer of type pugi::char_t* pointing to the terminating zero.",
        "code_id": "c_group_2_id_31",
        "code_text": "cadcdb2a799* t71574a353d(cadcdb2a799* bf39cacaa68, const unsigned char* t4a01632c82)\n{\ncadcdb2a799* w23252bb0af = bf39cacaa68;\nwhile (*bf39cacaa68)\n{\ncadcdb2a799 c339952909c = *bf39cacaa68++;\nunsigned int iddd88d7d03 = static_cast<unsigned int>(c339952909c);\nif (iddd88d7d03 < 128)\n{\nunsigned char c76a9e7126f = t4a01632c82[iddd88d7d03];\n\n\n*w23252bb0af = static_cast<cadcdb2a799>(c76a9e7126f);\nw23252bb0af += 1 - (c76a9e7126f >> 7);\n}\nelse\n{\n*w23252bb0af++ = c339952909c;\n}\n}\n\n*w23252bb0af = 0;\nreturn w23252bb0af;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_32",
        "query_text": "SUMMARY: This function accepts two inputs of type const pugi::char_t* and one of type size_t, and returns a bool. It compares the first input string and the second input string over the specified count of characters. If any character within this range does not match, it immediately returns false. If all characters in the given range match, it then returns true only if the first string has exactly the given length (indicated by a terminating null character immediately following the compared characters), otherwise it returns false.",
        "code_id": "c_group_2_id_32",
        "code_text": "bool sc770bc6c31(const cadcdb2a799* lc7022eb771, const cadcdb2a799* recaa2840b0, size_t c7955d5f3e7)\n{\nfor (size_t i0c6e314cec = 0; i0c6e314cec < c7955d5f3e7; ++i0c6e314cec)\nif (lc7022eb771[i0c6e314cec] != recaa2840b0[i0c6e314cec])\nreturn false;\nreturn lc7022eb771[c7955d5f3e7] == 0;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_33",
        "query_text": "SUMMARY: This function takes a generic pointer (void*), a size value (size_t), and an encoding value (xml_encoding) as inputs, and returns a size_t. It conditionally appends a zero terminator to a character buffer encoded either in a wide-character mode or UTF-8, depending on the current compilation context and comparison of the provided encoding with the native character encoding. If termination is required, the function writes a null character at the end of the buffer and returns the new total size (original size plus the size of the terminator). If termination is not needed, it simply returns the original size.",
        "code_id": "c_group_2_id_33",
        "code_text": "size_t z3fd612556d(void* bf39cacaa68, size_t s501f3ce221, x2774e10406 e1f4c299c3e)\n{\n\n#ifdef PUGIXML_WCHAR_MODE\nxml_encoding wchar_encoding = get_wchar_encoding();\nif (encoding == wchar_encoding || need_endian_swap_utf(encoding, wchar_encoding))\n{\nsize_t length = size / sizeof(char_t);\nstatic_cast<char_t*>(buffer)[length] = 0;\nreturn (length + 1) * sizeof(char_t);\n}\n#else\nif (e1f4c299c3e == e8221468ea2)\n{\nstatic_cast<char*>(bf39cacaa68)[s501f3ce221] = 0;\nreturn s501f3ce221 + 1;\n}\n#endif\nreturn s501f3ce221;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_34",
        "query_text": "SUMMARY: This function accepts an input of type pugi::xml_parse_status and an optional input of type ptrdiff_t (defaulting to 0). It then creates an object of type pugi::xml_parse_result, assigns the provided pugi::xml_parse_status to its status field and the provided ptrdiff_t value to its offset field, and finally returns the constructed pugi::xml_parse_result object.",
        "code_id": "c_group_2_id_34",
        "code_text": "inline x3687b35149 m3c67f82db6(xfc0bbea37e s31da9d87a8, ptrdiff_t o51f631f8ec = 0)\n{\nx3687b35149 rd756af3d75;\nrd756af3d75.s31da9d87a8 = s31da9d87a8;\nrd756af3d75.o51f631f8ec = o51f631f8ec;\nreturn rd756af3d75;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_35",
        "query_text": "SUMMARY: This function accepts an input of type uint8_t* and a uint32_t. It ignores the 32-bit unsigned integer, writes a fixed placeholder character ('?') into the byte pointed to by the uint8_t* input, and then returns a uint8_t* pointing to the next memory location.",
        "code_id": "c_group_2_id_35",
        "code_text": "namespace pugi {\nnamespace impl {\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_36",
        "query_text": "SUMMARY: This function accepts two inputs of type const pugi::char_t* (pointers to null-terminated character sequences) and returns a value of the same type. It searches for the first occurrence of the sequence given by the second input within the sequence given by the first input. Depending on a compile-time flag, it utilizes the appropriate standard function (for either wide or narrow characters) to perform the search, and in wide-character mode, it directly returns the first input if the second input represents an empty sequence.",
        "code_id": "c_group_2_id_36",
        "code_text": "const cadcdb2a799* fea3ca44b3c(const cadcdb2a799* s3b9d266e2e, const cadcdb2a799* pb2378a5e91)\n{\n#ifdef PUGIXML_WCHAR_MODE\n\nreturn (*p == 0) ? s : wcsstr(s, p);\n#else\nreturn strstr(s3b9d266e2e, pb2378a5e91);\n#endif\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_37",
        "query_text": "SUMMARY: This function takes two inputs: one is a pointer to an unsigned 8-bit integer (uint8_t*) representing a destination buffer, and the other is an unsigned 32-bit integer (uint32_t) representing a character value. It writes a single byte to the destination: if the input integer is greater than 255, it writes the byte value corresponding to the character '?' (a replacement character); otherwise, it converts the input integer to an 8-bit unsigned value and writes it. The function returns an updated pointer (uint8_t*) that points to the next byte position after the written byte.",
        "code_id": "c_group_2_id_37",
        "code_text": "namespace pugi {\nnamespace impl {\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_38",
        "query_text": "SUMMARY: This function accepts two input parameters, both of type const pugi::char_t* (representing character arrays), and returns an output of type bool. It checks whether the character array referenced by the second pointer exactly matches the beginning segment of the character array referenced by the first pointer, returning true if the entire sequence of the second input is found at the start of the first, and false otherwise.",
        "code_id": "c_group_2_id_38",
        "code_text": "bool s9abc9b0830(const cadcdb2a799* sed87ffeea8, const cadcdb2a799* p1d0098ab48)\n{\nwhile (*p1d0098ab48 && *sed87ffeea8 == *p1d0098ab48)\n{\nsed87ffeea8++;\np1d0098ab48++;\n}\nreturn *p1d0098ab48 == 0;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_39",
        "query_text": "SUMMARY: This function accepts an output parameter of type uint32_t* and an input parameter of type uint32_t. It stores the 32-bit unsigned integer value at the memory location indicated by the pointer and then returns a new pointer of type uint32_t* that points to the next element in the sequence.",
        "code_id": "c_group_2_id_39",
        "code_text": "namespace pugi {\nnamespace impl {\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_40",
        "query_text": "SUMMARY: This function receives an input of type pugi::xml_node_type and returns a value of type bool. It evaluates whether the provided XML node type is either an element node or a declaration node, and returns true in those cases, and false otherwise.",
        "code_id": "c_group_2_id_40",
        "code_text": "bool a5de21b2e0d(xe40c3a1c90 p4dccf456b0)\n{\nreturn p4dccf456b0 == n547ea9be88 || p4dccf456b0 == n5789cd3776;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_41",
        "query_text": "SUMMARY: This function accepts two inputs of type \"const pugi::char_t*\" and returns an output of type \"bool\". It first verifies that both input pointers are valid, then performs a comparison of the null\u2010terminated character arrays pointed to by these inputs. The function ultimately returns a boolean value indicating whether the two string representations are equal.",
        "code_id": "c_group_2_id_41",
        "code_text": "bool s79c8072a7b(const cadcdb2a799* sa425380d12, const cadcdb2a799* d566be35744)\n{\na48e077d7f7(sa425380d12 && d566be35744);\n#ifdef PUGIXML_WCHAR_MODE\nreturn wcscmp(src, dst) == 0;\n#else\nreturn strcmp(sa425380d12, d566be35744) == 0;\n#endif\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_42",
        "query_text": "SUMMARY: The function accepts a constant pointer to a character sequence (of type pugi::char_t) and returns a size_t value representing the count of characters in the sequence. It determines the length of a null-terminated string, choosing a wide-character approach (using wcslen) or a standard approach (using strlen) based on the compilation configuration.",
        "code_id": "c_group_2_id_42",
        "code_text": "static size_t s20e1587b84(const pugi::cadcdb2a799* s3b9d266e2e)\n{\n#ifdef PUGIXML_WCHAR_MODE\nreturn wcslen(s);\n#else\nreturn strlen(s3b9d266e2e);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_43",
        "query_text": "SUMMARY: This function accepts an input of type \"pointer to constant char_t\" and returns a result of type \"float\". It converts a textual numeric representation into a floating-point number using standard library conversion routines, choosing between the wide-character or narrow-character conversion method based on compile-time settings.",
        "code_id": "c_group_2_id_43",
        "code_text": "float g2ec767bb11(const cadcdb2a799* v2760155807)\n{\n#ifdef PUGIXML_WCHAR_MODE\nreturn static_cast<float>(wcstod(value, N9a67febeb9));\n#else\nreturn static_cast<float>(strtod(v2760155807, N9a67febeb9));\n#endif\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_44",
        "query_text": "SUMMARY: This function accepts a constant pointer to a character type (pugi::char_t*) as input and returns a double-precision floating point value. Its primary behavior is to convert a string representing a numerical value into its corresponding double value. Depending on whether a wide character mode is enabled at compile time, it internally uses either the wide-character conversion function (wcstod) or the standard conversion function (strtod) to perform this conversion.",
        "code_id": "c_group_2_id_44",
        "code_text": "double g2e60632bb7(const cadcdb2a799* v2760155807)\n{\n#ifdef PUGIXML_WCHAR_MODE\nreturn wcstod(value, N9a67febeb9);\n#else\nreturn strtod(v2760155807, N9a67febeb9);\n#endif\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_45",
        "query_text": "SUMMARY: This is an inline, constant member function that takes no explicit input parameters (its effective input is the constant instance of a global management structure) and returns a pointer to a file stream (output type: FILE*). Its functionality is to check whether an internal file stream pointer (of type FILE*) is set; if it is, the function returns that pointer, otherwise it returns the standard output stream pointer (stdout). The function is marked as noexcept, establishing that it does not throw exceptions.",
        "code_id": "c_group_2_id_45",
        "code_text": "namespace BrokenAPI {\nstruct U632a3caf1c;\n};\nnamespace BrokenAPI {\ntypedef void (*Ec227fe4f99)(void);\n};\nnamespace BrokenAPI {\nstruct U632a3caf1c {\nEc227fe4f99 eced0fbcbdf;\nconst char* n5fa9babb97;\nint p241432d737;\nunsigned f3e183c2b46;\nU632a3caf1c* ne43a7c0673;\n};\n};\n;\n;\n;\nstruct B20b35c1e78 {\n\nint _4b2b1c4ad6;\nconst char** _5627ddb252;\n\nFILE* _868c11d49d;\n\nBrokenAPI::U632a3caf1c* _7b441187aa;\nBrokenAPI::U632a3caf1c* _21d20a7718;\nbool h95f5d5c2a2(const char* ad90770d038) const noexcept {\nfor (int i0c6e314cec = 1; i0c6e314cec < _4b2b1c4ad6; i0c6e314cec++)\nif (strcmp(_5627ddb252[i0c6e314cec], ad90770d038) == 0)\nreturn true;\nreturn false;\n}\ninline FILE* f3d84b1dca1() const noexcept { return _868c11d49d ? _868c11d49d : sb6d509d867; }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_46",
        "query_text": "SUMMARY: This function receives two constant pointers to the BrokenAPI::Unit structure and returns an integer. It compares the integer field (priority) of both inputs; if they are equal, it compares the C-style string field (name) lexically. The output integer indicates whether the first input is considered greater than, equal to, or less than the second based on these comparisons.",
        "code_id": "c_group_2_id_46",
        "code_text": "static int B4bc1ca6a23(const BrokenAPI::U632a3caf1c* ad90770d038, const BrokenAPI::U632a3caf1c* bba3ae37d1f) noexcept {\nif (ad90770d038->p241432d737 == bba3ae37d1f->p241432d737)\nreturn strcmp(ad90770d038->n5fa9babb97, bba3ae37d1f->n5fa9babb97);\nelse\nreturn ad90770d038->p241432d737 > bba3ae37d1f->p241432d737 ? 1 : -1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_47",
        "query_text": "SUMMARY: The function accepts an input of type asmjit::_abi_1_13::CallConvId (an enum class with underlying type uint8_t) and returns a bool. It determines whether the provided calling convention identifier corresponds to one of several established C-style calling conventions (including cdecl, stdcall, fastcall, vectorcall, thiscall, and three regparm variants). Essentially, it checks the input against these specific enumerated values and returns true if a match is found, otherwise it returns false.",
        "code_id": "c_group_2_id_47",
        "code_text": "static inline bool s2488707b36(Cde45e78823 cc74ad4114f) noexcept {\nreturn cc74ad4114f == Cde45e78823::kd426f343ac ||\ncc74ad4114f == Cde45e78823::kaf396024d4 ||\ncc74ad4114f == Cde45e78823::k793dbfdc9d ||\ncc74ad4114f == Cde45e78823::k02da0616c8 ||\ncc74ad4114f == Cde45e78823::k8eaa610d18 ||\ncc74ad4114f == Cde45e78823::kc91e0b19f1 ||\ncc74ad4114f == Cde45e78823::k79dee436cd ||\ncc74ad4114f == Cde45e78823::kdd659cc3b7;\n};\n};\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_48",
        "query_text": "SUMMARY: This function accepts two inputs of type asmjit::_abi_1_13::TypeId and returns a 32-bit unsigned integer (uint32_t). It converts each input to its unsigned integer representation, left-shifts the first input by 8 bits to occupy the higher-order portion, and then combines it with the second input (occupying the lower-order portion) using a bitwise OR operation.",
        "code_id": "c_group_2_id_48",
        "code_text": "static inline uint32_t m6db9d423b0(T4b657337b8 d566be35744, T4b657337b8 sa425380d12) noexcept {\nreturn (uint32_t(d566be35744) << 8) | uint32_t(sa425380d12);\n};\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_49",
        "query_text": "SUMMARY: The function accepts an input of type asmjit::_abi_1_13::CallConvId (an enumeration based on uint8_t) and returns a boolean value. It evaluates whether the provided calling convention identifier is one of a specific subset (namely, kCDecl, kStdCall, kThisCall, kFastCall, kRegParm1, kRegParm2, or kRegParm3). If the input matches any of these designated values, the function outputs true; otherwise, it outputs false.",
        "code_id": "c_group_2_id_49",
        "code_text": "static inline bool s0227702ef1(Cde45e78823 cc74ad4114f) noexcept {\nreturn cc74ad4114f == Cde45e78823::kd426f343ac ||\ncc74ad4114f == Cde45e78823::kaf396024d4 ||\ncc74ad4114f == Cde45e78823::k8eaa610d18 ||\ncc74ad4114f == Cde45e78823::k793dbfdc9d ||\ncc74ad4114f == Cde45e78823::kc91e0b19f1 ||\ncc74ad4114f == Cde45e78823::k79dee436cd ||\ncc74ad4114f == Cde45e78823::kdd659cc3b7;\n};\n};\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_50",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a mutable high-level string (Neyson::String &), a constant character pointer (const char*), and an unsigned integer representing a length (size_t). It processes a sequence of characters from the given pointer, interpreting and removing escape sequences (such as those for quotes, backslashes, control characters, and Unicode code points) and appends the corresponding literal characters to the mutable string. As it iterates over the provided characters, it decodes any escape sequences encountered, converting Unicode escapes to their appropriate multi-byte (UTF\u20118) representations, and ultimately shortens the string to the correct final size. The function returns a boolean value to signal whether the processing succeeded without encountering any invalid or incomplete escape sequences.",
        "code_id": "c_group_2_id_50",
        "code_text": "bool f476ac7961c(Scb6652db2c &sed87ffeea8, const char *p949f10927c, size_t l498879d345)\n{\nsize_t jbd3357c513 = 0;\nsed87ffeea8.resize(l498879d345);\nbool ea5d1556868 = false;\nfor (size_t i0c6e314cec = 0; i0c6e314cec < l498879d345; ++i0c6e314cec)\nif (!ea5d1556868)\n{\nif (p949f10927c[i0c6e314cec] == '\\\\')\nea5d1556868 = true;\nelse\nsed87ffeea8[jbd3357c513++] = p949f10927c[i0c6e314cec];\n}\nelse\n{\nea5d1556868 = false;\nif (p949f10927c[i0c6e314cec] == '\\\"')\nsed87ffeea8[jbd3357c513++] = '\\\"';\nelse if (p949f10927c[i0c6e314cec] == '\\\\')\nsed87ffeea8[jbd3357c513++] = '\\\\';\nelse if (p949f10927c[i0c6e314cec] == '/')\nsed87ffeea8[jbd3357c513++] = '/';\nelse if (p949f10927c[i0c6e314cec] == 'b')\nsed87ffeea8[jbd3357c513++] = '\\b';\nelse if (p949f10927c[i0c6e314cec] == 'f')\nsed87ffeea8[jbd3357c513++] = '\\f';\nelse if (p949f10927c[i0c6e314cec] == 'n')\nsed87ffeea8[jbd3357c513++] = '\\n';\nelse if (p949f10927c[i0c6e314cec] == 'r')\nsed87ffeea8[jbd3357c513++] = '\\r';\nelse if (p949f10927c[i0c6e314cec] == 't')\nsed87ffeea8[jbd3357c513++] = '\\t';\nelse if (p949f10927c[i0c6e314cec] == 'u')\n{\nuint32_t c76a9e7126f = 0;\nif (++i0c6e314cec + 4 > l498879d345) return false;\nfor (int jbd3357c513 = 0; jbd3357c513 < 4; ++i0c6e314cec, ++jbd3357c513)\n{\nc76a9e7126f <<= 4;\nif (p949f10927c[i0c6e314cec] >= '0' && p949f10927c[i0c6e314cec] <= '9')\nc76a9e7126f += p949f10927c[i0c6e314cec] - '0';\nelse if (p949f10927c[i0c6e314cec] >= 'a' && p949f10927c[i0c6e314cec] <= 'f')\nc76a9e7126f += p949f10927c[i0c6e314cec] - 'a' + 10;\nelse if (p949f10927c[i0c6e314cec] >= 'A' && p949f10927c[i0c6e314cec] <= 'F')\nc76a9e7126f += p949f10927c[i0c6e314cec] - 'A' + 10;\nelse\nreturn false;\n}\n--i0c6e314cec;\nif (c76a9e7126f <= 0x7F)\nsed87ffeea8[jbd3357c513++] = char(c76a9e7126f);\nelse if (c76a9e7126f <= 0x07FF)\n{\nsed87ffeea8[jbd3357c513++] = char(((c76a9e7126f >> 6) & 0x1F) | 0xC0);\nsed87ffeea8[jbd3357c513++] = char((c76a9e7126f & 0x3F) | 0x80);\n}\nelse if (c76a9e7126f <= 0xFFFF)\n{\nsed87ffeea8[jbd3357c513++] = char(((c76a9e7126f >> 12) & 0x0F) | 0xE0);\nsed87ffeea8[jbd3357c513++] = char(((c76a9e7126f >> 6) & 0x3F) | 0x80);\nsed87ffeea8[jbd3357c513++] = char((c76a9e7126f & 0x3F) | 0x80);\n}\nelse if (c76a9e7126f <= 0x10FFFF)\n{\nsed87ffeea8[jbd3357c513++] = char(((c76a9e7126f >> 18) & 0x07) | 0xF0);\nsed87ffeea8[jbd3357c513++] = char(((c76a9e7126f >> 12) & 0x3F) | 0x80);\nsed87ffeea8[jbd3357c513++] = char(((c76a9e7126f >> 6) & 0x3F) | 0x80);\nsed87ffeea8[jbd3357c513++] = char((c76a9e7126f & 0x3F) | 0x80);\n}\nelse\nreturn false;\n}\nelse\nreturn false;\n}\nsed87ffeea8.erase(jbd3357c513);\nsed87ffeea8.shrink_to_fit();\nreturn 0;\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_51",
        "query_text": "SUMMARY: This function receives two inputs of type st_data_t (an unsigned long) and returns an integer. It interprets each input as a pointer to a constant character sequence (a null-terminated string) and performs a standard lexicographical comparison between these two strings, returning the result of this comparison.",
        "code_id": "c_group_2_id_51",
        "code_text": "static int\nsfe9316e752(sdc3d067307 afacb751799, sdc3d067307 a11e5df9434)\n{\nconst char* sfc67390108 = (const char* )afacb751799;\nconst char* s793dae3e98 = (const char* )a11e5df9434;\nreturn strcmp(sfc67390108, s793dae3e98);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_52",
        "query_text": "SUMMARY: The function receives two inputs, each being a pointer to a structure defined as a pair of integers. It modifies the first structure by performing a bitwise AND operation on its individual integer values with the corresponding values from the second structure. The function does not return a value; it updates the first structure in place.",
        "code_id": "c_group_2_id_52",
        "code_text": "static void\na76b09f0c32(Oa86d156376* t72a16f3a1b, Oa86d156376* a71957a8135)\n{\nt72a16f3a1b->lcfaba252b8  &= a71957a8135->lcfaba252b8;\nt72a16f3a1b->rc12144e4ba &= a71957a8135->rc12144e4ba;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_53",
        "query_text": "SUMMARY: This function accepts a single input of type unsigned int (OnigCodePoint) and returns an unsigned int (OnigCodePoint). It checks if the input code point matches one of a few specific characters\u2014namely the beginning of a paired punctuation sequence\u2014and returns the corresponding ending punctuation code point. Specifically, it maps an input representing '<' to the code point for '>', an input representing a single quote to the same single quote, and an input representing '(' to the code point for ')'. If the input does not match any of these specified characters, it returns 0 as the default outcome.",
        "code_id": "c_group_2_id_53",
        "code_text": "static O3f3d6db595\ngbf6cadf9ef(O3f3d6db595 sdbce6908ca)\n{\nswitch (sdbce6908ca) {\ncase '<':  return (O3f3d6db595 )'>';  break;\ncase '\\'': return (O3f3d6db595 )'\\''; break;\ncase '(':  return (O3f3d6db595 )')';  break;\ndefault:\nbreak;\n}\nreturn (O3f3d6db595 )0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_54",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to an array of unsigned integers (OnigCodePoint) and an integer\u2014and returns an integer. It calculates a specific offset within the array by dividing the integer input by 3 to select one element, then uses the remainder to determine which of the three bytes in that element to extract. It shifts the corresponding unsigned integer value accordingly and masks it to isolate one byte, which is then returned as a standard integer.",
        "code_id": "c_group_2_id_54",
        "code_text": "extern int\no97f3e34055(O3f3d6db595 cf0e4865236[], int aa4bcfd21f3)\n{\nint iddd88d7d03;\nint bba3ae37d1f;\nO3f3d6db595 c76a9e7126f;\niddd88d7d03 = aa4bcfd21f3 / 3;\nbba3ae37d1f     = aa4bcfd21f3 % 3;\nc76a9e7126f = cf0e4865236[iddd88d7d03];\nreturn ((c76a9e7126f >> ((2 - bba3ae37d1f) * 8)) & 0xff);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_55",
        "query_text": "SUMMARY: This function accepts two pointers to an OptAnc structure (which contains two integer fields) as input parameters. It performs a direct copy of all the content from the structure referenced by the second pointer (source) to the structure referenced by the first pointer (destination), and it returns no value (void).",
        "code_id": "c_group_2_id_55",
        "code_text": "static void\ncb889cd0588(Oa86d156376* t72a16f3a1b, Oa86d156376* fc700211513)\n{\n*t72a16f3a1b = *fc700211513;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_56",
        "query_text": "SUMMARY: The function accepts an input parameter of type pointer to a structure (OptAnc) that contains two integer fields. It sets both of these integer fields to zero, effectively resetting the stored values. The function does not return any output (void).",
        "code_id": "c_group_2_id_56",
        "code_text": "static void\nc1ea054d71f(Oa86d156376* ad90770d038)\n{\nad90770d038->lcfaba252b8  = 0;\nad90770d038->rc12144e4ba = 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_57",
        "query_text": "SUMMARY: The function accepts two inputs of type unsigned long (st_data_t) and returns an int. It performs a simple comparison between these two values and produces an integer result that indicates whether the two inputs are not equal.",
        "code_id": "c_group_2_id_57",
        "code_text": "static int\nndc3d55add1(sdc3d067307 xf1fa84c2ec, sdc3d067307 y92bd0bf197)\n{\nreturn xf1fa84c2ec != y92bd0bf197;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_58",
        "query_text": "SUMMARY: This function takes an unsigned long input (interpreted as a pointer to a constant character sequence) and returns an integer computed as a hash value based on that string\u2019s content. It iterates over the characters of the null\u2010terminated string, updating an accumulator through arithmetic and bitwise operations. Depending on compile-time flags, it applies one of several hashing methods\u2014one that performs left shifts with mask extraction, another that combines summation with bit shifting, and a default that multiplies by a constant before adding each character. The overall behavior is to transform the input string into an integer hash result.",
        "code_id": "c_group_2_id_58",
        "code_text": "static int\ns4f17e03ed6(sdc3d067307 a046789b6ca)\n{\nconst char* sed87ffeea8 = (const char* )a046789b6ca;\nregister int cdcd5d1f3d2;\n#ifdef HASH_ELFHASH\nregister unsigned int h = 0, g;\nwhile ((c = *string++) != '\\0') {\nh = ( h << 4 ) + c;\nif ( g = h & 0xF0000000 )\nh ^= g >> 24;\nh &= ~g;\n}\nreturn h;\n#elif HASH_PERL\nregister int val = 0;\nwhile ((c = *string++) != '\\0') {\nval += c;\nval += (val << 10);\nval ^= (val >> 6);\n}\nval += (val << 3);\nval ^= (val >> 11);\nreturn val + (val << 15);\n#else\nregister int v71de8bcd6a = 0;\nwhile ((cdcd5d1f3d2 = *sed87ffeea8++) != '\\0') {\nv71de8bcd6a = v71de8bcd6a*997 + cdcd5d1f3d2;\n}\nreturn v71de8bcd6a + (v71de8bcd6a>>5);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_59",
        "query_text": "SUMMARY: This function accepts two integers and a pointer to an array of type MemNumType as inputs. It iterates through a sequence of elements (with the number of iterations specified by the second integer input), checking if any element in the array exactly matches the first integer input. The function returns an integer output: it yields 1 (of type int) if a match is found and 0 (of type int) if no matching element exists.",
        "code_id": "c_group_2_id_59",
        "code_text": "static int me355f3d651(int m3ff626f5fd, int naa9ee9a555, M90208c5935* m2a6471978b)\n{\nint i0c6e314cec;\nfor (i0c6e314cec = 0; i0c6e314cec < naa9ee9a555; i0c6e314cec++) {\nif (m3ff626f5fd == (int )m2a6471978b[i0c6e314cec]) return 1;\n}\nreturn 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_60",
        "query_text": "SUMMARY: This function takes an input of type st_table* and returns no output (void). It iterates over all bins in a hash table, freeing each st_table_entry (of type st_table_entry*) in the linked list stored in each bin. After releasing the memory for these entries, the function frees the array of bins and finally deallocates the st_table structure itself.",
        "code_id": "c_group_2_id_60",
        "code_text": "extern void\nsf779ea3279(s6869abc53e* t4a01632c82)\n{\nregister sa9be8ad552 *p949f10927c, *ne43a7c0673;\nint i0c6e314cec;\nfor(i0c6e314cec = 0; i0c6e314cec < t4a01632c82->ndd422358f2; i0c6e314cec++) {\np949f10927c = t4a01632c82->b5aef69b7a7[i0c6e314cec];\nwhile (p949f10927c != 0) {\nne43a7c0673 = p949f10927c->ne43a7c0673;\nfree(p949f10927c);\np949f10927c = ne43a7c0673;\n}\n}\nfree(t4a01632c82->b5aef69b7a7);\nfree(t4a01632c82);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_61",
        "query_text": "SUMMARY: This function accepts a single input of type unsigned long and returns an output of type int. Its behavior is to directly pass the input value through to the output, effectively converting the provided unsigned long value into an int.",
        "code_id": "c_group_2_id_61",
        "code_text": "static int\nna2fff2fb46(sdc3d067307 neb9157c168)\n{\nreturn neb9157c168;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_62",
        "query_text": "SUMMARY: The function takes two arrays of unsigned int (OnigCodePoint) and an integer indicating the number of elements to compare. It iterates through the arrays, comparing each corresponding pair of elements. If any pair is not equal, it immediately returns an integer output value of -1; if all compared elements are identical, it returns 0 as the output.",
        "code_id": "c_group_2_id_62",
        "code_text": "extern int\no0af68d0d4e(O3f3d6db595 ad90770d038[], O3f3d6db595 bba3ae37d1f[], int neb9157c168)\n{\nint i0c6e314cec;\nfor (i0c6e314cec = 0; i0c6e314cec < neb9157c168; i0c6e314cec++) {\nif (ad90770d038[i0c6e314cec] != bba3ae37d1f[i0c6e314cec])\nreturn -1;\n}\nreturn 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_63",
        "query_text": "SUMMARY: The function accepts an input of type pointer to a structure (OptAnc) containing two integers (\"left\" and \"right\") and a second input of type int. It checks whether the int input is represented as a set bit in the first integer element; if not, it then checks the second integer element. The output is an int that indicates success (1) if the bit is set in either of the integer fields, or failure (0) otherwise.",
        "code_id": "c_group_2_id_63",
        "code_text": "static int\ni3ec111a785(Oa86d156376* t72a16f3a1b, int a5f7257a79e)\n{\nif ((t72a16f3a1b->lcfaba252b8 & a5f7257a79e) != 0) return 1;\nreturn ((t72a16f3a1b->rc12144e4ba & a5f7257a79e) != 0 ? 1 : 0);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_64",
        "query_text": "SUMMARY: This function takes two objects of type most_hostile_types::with_order_by_representation::Rep as input and returns a boolean value. Its functionality is to always yield true, regardless of the input values.",
        "code_id": "c_group_2_id_64",
        "code_text": "bool operator==(Re6657ed858, Re6657ed858) { return true; };\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_65",
        "query_text": "SUMMARY: This function accepts two inputs of type most_hostile_types::with_order_by_representation::Rep (each containing an integer member) and returns a boolean value. Its behavior is to consistently yield false, regardless of the internal values of the provided inputs.",
        "code_id": "c_group_2_id_65",
        "code_text": "bool operator<(Re6657ed858, Re6657ed858) { return false; };\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_66",
        "query_text": "SUMMARY: This function takes two inputs\u2014a non-constant reference to a stream (std::ostream&) and a constant reference to a custom integer type (MyInt). It extracts an integer value from the custom type and inserts that integer into the stream. The function then returns a reference to the same stream (std::ostream&).",
        "code_id": "c_group_2_id_66",
        "code_text": "std::ostream& operator<<(std::ostream& oe5f88bc51f, const M18e0bc07c2& o37bbc5188c) {\noe5f88bc51f << o37bbc5188c.v2760155807();\nreturn oe5f88bc51f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_67",
        "query_text": "SUMMARY: This function accepts four parameters: a reference to a value of type std::vector<std::vector<double>>, a constant size_t representing the number of points, a constant size_t representing the dimensionality of each point, and an optional double for the maximum range of generated values (with a default of 10.0). It produces no direct return value (void) but instead populates the referenced vector with the specified number of points, where each point is a vector of doubles containing randomly generated values between 0 and the maximum range.",
        "code_id": "c_group_2_id_67",
        "code_text": "void gc32bd5e3a6(\nm329c48af9d& s2a143c981e, const size_t N97ba9a4b2a, const size_t db550843317,\nconst double mf7e90de54a = 10.0)\n{\nstd::cout << \"Generating \" << N97ba9a4b2a << \" random points...\";\ns2a143c981e.resize(N97ba9a4b2a);\nfor (size_t i0c6e314cec = 0; i0c6e314cec < N97ba9a4b2a; i0c6e314cec++)\n{\ns2a143c981e[i0c6e314cec].resize(db550843317);\nfor (size_t ded8b2a8791 = 0; ded8b2a8791 < db550843317; ded8b2a8791++)\ns2a143c981e[i0c6e314cec][ded8b2a8791] = mf7e90de54a * (rand() % 1000) / (1000.0);\n}\nstd::cout << \"done\\n\";\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_68",
        "query_text": "SUMMARY: This inline function accepts an input of type configor::token_type (an enumeration) and returns a constant character pointer as output. It maps each enumerated token type to a corresponding string literal, providing a human-readable representation of that token type. If the input does not match any predefined enumeration value, the function returns a default string literal indicating an unknown value.",
        "code_id": "c_group_2_id_68",
        "code_text": "inline const char* tf7a853b8bb(t77c3205b1a t646f608638)\n{\nswitch (t646f608638)\n{\ncase t77c3205b1a::u0d25b6e4fb:\nreturn \"uninitialized\";\ncase t77c3205b1a::l804774018b:\nreturn \"literal_true\";\ncase t77c3205b1a::lce9759fb69:\nreturn \"literal_false\";\ncase t77c3205b1a::l78f7476a35:\nreturn \"literal_null\";\ncase t77c3205b1a::v8dc4ac5355:\nreturn \"value_string\";\ncase t77c3205b1a::vbb5f3a1b8f:\nreturn \"value_integer\";\ncase t77c3205b1a::v47ae3c0558:\nreturn \"value_float\";\ncase t77c3205b1a::ba56d12fa69:\nreturn \"begin_array\";\ncase t77c3205b1a::e1b45408854:\nreturn \"end_array\";\ncase t77c3205b1a::b2c04359b3e:\nreturn \"begin_object\";\ncase t77c3205b1a::e2df0a6cbea:\nreturn \"end_object\";\ncase t77c3205b1a::n6ab7b6a37f:\nreturn \"name_separator\";\ncase t77c3205b1a::v4b9ae4e57e:\nreturn \"value_separator\";\ncase t77c3205b1a::e14c5a89b9a:\nreturn \"end_of_input\";\n}\nreturn \"unknown\";\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_69",
        "query_text": "SUMMARY: This function accepts an input of type const config_t* and returns an output of type int. It retrieves and returns the configuration options stored within the provided configuration structure.",
        "code_id": "c_group_2_id_69",
        "code_text": "int c92cf83173a(const cd830d75f96 *cdcafd2fc7e)\n{\nreturn(cdcafd2fc7e->oea33165c71);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_70",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to a structure of type config_t and a pointer of type void*. Its purpose is to assign the provided void pointer to the hook member of the config_t structure. The function does not produce an output value (its return type is void).",
        "code_id": "c_group_2_id_70",
        "code_text": "void cd1c531927f(cd830d75f96 *cdcafd2fc7e, void *h78a30a538e)\n{\ncdcafd2fc7e->h78a30a538e = h78a30a538e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_71",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to a file stream (FILE *) and a constant pointer to a structured value (tt_val_t, which contains an enumerated type indicator and a union holding one of several data types: int, unsigned int, long long, unsigned long long, double, const char *, or const void *). It processes the structured value by examining the associated type enumeration and writes its contained value to the provided file stream in an appropriately formatted manner. The output is directly written to the stream (with no return value) and includes special handling for string types, where control characters are escaped and the entire string is enclosed in quotation marks.",
        "code_id": "c_group_2_id_71",
        "code_text": "void taeead99e86(FILE *s25aca4d22e, const t76ca6f5c3c *v71de8bcd6a)\n{\nswitch(v71de8bcd6a->t0e2e36c884)\n{\ncase Ta1a618adad:\nfprintf(s25aca4d22e, \"%d\", v71de8bcd6a->v2760155807.iefe75ab13c);\nbreak;\ncase T2743ed845a:\nfprintf(s25aca4d22e, \"%u\", v71de8bcd6a->v2760155807.ub1cbbf202c);\nbreak;\ncase T176c72d1d3:\nfprintf(s25aca4d22e, \"%lld\", v71de8bcd6a->v2760155807.i4f3782254d);\nbreak;\ncase T149d8c0835:\nfprintf(s25aca4d22e, \"%llu\", v71de8bcd6a->v2760155807.u7c2b43ddcf);\nbreak;\ncase Tacf81fb795:\nfprintf(s25aca4d22e, \"%f\", v71de8bcd6a->v2760155807.da728fcd6b7);\nbreak;\ncase T6b65ce2406:\n{\nconst char *pb2378a5e91;\nfputc('\\\"', s25aca4d22e);\nfor(pb2378a5e91 = v71de8bcd6a->v2760155807.s73274d5d05; *pb2378a5e91; ++pb2378a5e91)\n{\nif(*pb2378a5e91 == '\\n')\nfputs(\"\\\\n\", s25aca4d22e);\nelse if(*pb2378a5e91 == '\\r')\nfputs(\"\\\\r\", s25aca4d22e);\nelse if(*pb2378a5e91 == '\\t')\nfputs(\"\\\\t\", s25aca4d22e);\nelse if(*pb2378a5e91 == '\\f')\nfputs(\"\\\\f\", s25aca4d22e);\nelse if(*pb2378a5e91 < ' ')\nfprintf(s25aca4d22e, \"\\\\0x%02X\", *pb2378a5e91);\nelse\nfputc(*pb2378a5e91, s25aca4d22e);\n}\nfputc('\\\"', s25aca4d22e);\nbreak;\n}\ncase T4d645c9737:\nfprintf(s25aca4d22e, \"%p\", v71de8bcd6a->v2760155807.p802244bdc4);\nbreak;\ndefault:\nfputs(\"???\", s25aca4d22e);\nbreak;\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_72",
        "query_text": "SUMMARY: This function, which accepts a constant character pointer (const char*) and a generic pointer type (void*, aliased as yyscan_t) as inputs and returns no value (void), is designed to handle fatal errors. It outputs a provided error message to the standard error stream and then terminates the program using a predefined failure exit code.",
        "code_id": "c_group_2_id_72",
        "code_text": "static void y417cb2a92f yfa93243914 (const char* me35c92ef02 , y13bf834aa0 y9a7131691f)\n{\nstruct yab90773661 * y60ca6047f2 = (struct yab90773661*)y9a7131691f;\n(void)y60ca6047f2;\nfprintf( sa9de313333, \"%s\\n\", me35c92ef02 );\nexit( Y8d0b9e727f );\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_73",
        "query_text": "SUMMARY: This function accepts a pointer to a configuration structure (config_t *) and an unsigned short value representing float precision. It assigns the provided unsigned short value to the float_precision field within the configuration structure and does not return a value.",
        "code_id": "c_group_2_id_73",
        "code_text": "void c332653c71a(cd830d75f96 *cdcafd2fc7e, unsigned short d4fcfebcbb6)\n{\ncdcafd2fc7e->fe2e5f078ff = d4fcfebcbb6;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_74",
        "query_text": "SUMMARY: This function accepts a constant pointer to a configuration structure (const config_t *) as input and returns an unsigned short. It functions as a getter by accessing the tab_width field within the provided configuration structure and returning its value.",
        "code_id": "c_group_2_id_74",
        "code_text": "unsigned short cba532ae504(const cd830d75f96 *cdcafd2fc7e)\n{\nreturn cdcafd2fc7e->tcc45070348;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_75",
        "query_text": "SUMMARY: This function takes as input a pointer to a configuration setting structure (of type struct config_setting_t) and a generic pointer (of type void *) as parameters, and returns no value (void). Its functionality is to update the configuration setting by assigning the provided generic pointer to the hook field within the configuration setting structure.",
        "code_id": "c_group_2_id_75",
        "code_text": "void ce2dbfe03df(c82e0fd1bc8 *s358c545910, void *h78a30a538e)\n{\ns358c545910->h78a30a538e = h78a30a538e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_76",
        "query_text": "SUMMARY: This function accepts a pointer to a structure (type: struct config_setting_t) and an integer (type: int) as inputs and returns an integer (type: int). It verifies whether the input structure either has no assigned type or is explicitly designated as a boolean type. If the structure is untyped, it assigns the boolean type; if it is already of a different type, the function returns an error code (false). When the boolean type conditions are met, it stores the provided integer value into the union field representing an integer and returns a success code (true).",
        "code_id": "c_group_2_id_76",
        "code_text": "int cf730642007(c82e0fd1bc8 *s358c545910, int v2760155807)\n{\nif(s358c545910->t0e2e36c884 == C94b083a996)\ns358c545910->t0e2e36c884 = C6c9e59cb03;\nelse if(s358c545910->t0e2e36c884 != C6c9e59cb03)\nreturn(C1aaa350ff4);\ns358c545910->v2760155807.ic88e9eafd3 = v2760155807;\nreturn(C277147548f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_77",
        "query_text": "SUMMARY: This function takes three inputs: a pointer to a configuration structure (of type config_t *), an integer bit mask (of type int), and an integer flag (of type int). It updates the configuration structure's internal options field by setting the bit(s) specified by the integer bit mask if the integer flag is nonzero, or by clearing those bit(s) if the integer flag is zero. The function does not return any value (void).",
        "code_id": "c_group_2_id_77",
        "code_text": "void c5dfc7136a7(cd830d75f96 *cdcafd2fc7e, int o54c09c1aa2, int fde2a6e8e2f)\n{\nif(fde2a6e8e2f)\ncdcafd2fc7e->oea33165c71 |= o54c09c1aa2;\nelse\ncdcafd2fc7e->oea33165c71 &= ~o54c09c1aa2;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_78",
        "query_text": "SUMMARY: This function accepts a pointer to a constant configuration setting structure (const config_setting_t*) as its input and returns an integer (int) as its output. It determines whether the configuration setting represents an aggregate type by examining its type field. The function returns a nonzero integer (true) if the type field indicates that the configuration is either an array, a list, or a group; otherwise, it returns 0 (false).",
        "code_id": "c_group_2_id_78",
        "code_text": "int cb2cc904a4a(const c82e0fd1bc8 *s358c545910)\n{\nreturn((s358c545910->t0e2e36c884 == C049bed8d05)\n|| (s358c545910->t0e2e36c884 == Cd14329338f)\n|| (s358c545910->t0e2e36c884 == C6133ac1fe6));\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_79",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to a structure of type fuzz_data_t and a pointer to a pointer to an 8-bit unsigned integer (uint8_t **). It computes an offset within the data array contained in the structure by adding the structure\u2019s content_size and a single unit to the beginning address of the data array. It then assigns the computed offset address to the output pointer. Additionally, it ensures that the segment of the buffer, as determined by the path_size, is terminated with a null character. The function does not return a value.",
        "code_id": "c_group_2_id_79",
        "code_text": "void fcaae4f8639(fb5cf78b7e8 *f3d3b3dd4a0, uint8_t **b99ab09a63e)\n{\n*b99ab09a63e = f3d3b3dd4a0->d4e0653e6bc + f3d3b3dd4a0->ce9e2446673 + 1;\n\n(*b99ab09a63e)[f3d3b3dd4a0->p59116eea03] = '\\0';\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_80",
        "query_text": "SUMMARY: The function takes two inputs\u2014a pointer to a configuration structure of type config_t and an integer representing configuration options\u2014and does not return any value (void). It simply assigns the provided integer to the \"options\" field within the configuration structure, thereby setting the configuration options accordingly.",
        "code_id": "c_group_2_id_80",
        "code_text": "void c1ba7c3d656(cd830d75f96 *cdcafd2fc7e, int oea33165c71)\n{\ncdcafd2fc7e->oea33165c71 = oea33165c71;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_81",
        "query_text": "SUMMARY: This function takes a pointer to a structure (type: tt_testsuite_t *) representing a test suite as input and returns no value (type: void). It sequentially traverses a linked list of test structures (of type tt_test_t) contained within the suite, deallocating memory for each test\u2019s allocated name and the test structure itself. After cleaning up all test entries, it then deallocates memory for the suite\u2019s allocated name and the suite structure.",
        "code_id": "c_group_2_id_81",
        "code_text": "void t7573213529(t8e86df65b5 *s79a8b09af5)\n{\nt09f4a93460 *t429bfa4ef8 = s79a8b09af5->f43986c6bdb;\nwhile(t429bfa4ef8)\n{\nt09f4a93460 *tb20dfb361b = t429bfa4ef8->ne43a7c0673;\nfree((void *)t429bfa4ef8->n5fa9babb97);\nfree(t429bfa4ef8);\nt429bfa4ef8 = tb20dfb361b;\n}\nfree((void *)s79a8b09af5->n5fa9babb97);\nfree(s79a8b09af5);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_82",
        "query_text": "SUMMARY: The function accepts two inputs\u2014a pointer to a configuration setting structure (of type config_setting_t*) and an unsigned short that represents a format option\u2014and returns an integer (int). It verifies that the configuration setting is of an integer type (either 32-bit or 64-bit) and that the provided format option is valid (either the default or hexadecimal). Upon satisfying both conditions, it updates the configuration setting\u2019s format field with the given value and returns an integer indicating success; if not, it returns an integer indicating failure.",
        "code_id": "c_group_2_id_82",
        "code_text": "int c35a3e3b924(c82e0fd1bc8 *s358c545910, unsigned short f0cf59c1202)\n{\nif(((s358c545910->t0e2e36c884 != C3e85ce89ce)\n&& (s358c545910->t0e2e36c884 != Cf3696de54e))\n|| ((f0cf59c1202 != C712f906b45) && (f0cf59c1202 != C625e4fd864)))\nreturn(C1aaa350ff4);\ns358c545910->f0cf59c1202 = f0cf59c1202;\nreturn(C277147548f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_83",
        "query_text": "SUMMARY: This function is designed to deallocate dynamically allocated memory. Its inputs are a memory pointer (of type void*) and a scanner handle (of type yyscan_t, which is defined as void*). The function does not produce any output (void return type). Internally, it performs a cast on the scanner handle to an internal structure type and then calls the standard free function on the memory pointer (after casting it to a character pointer) to release the allocated memory.",
        "code_id": "c_group_2_id_83",
        "code_text": "void y117302d958 (void * p949f10927c , y13bf834aa0 y9a7131691f)\n{\nstruct yab90773661 * y60ca6047f2 = (struct yab90773661*)y9a7131691f;\n(void)y60ca6047f2;\nfree( (char *) p949f10927c );\t\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_84",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to a structure of type config_t and a pointer to a constant char array (const char *). It deallocates any previously stored string in the include directory field of the provided config_t structure and then assigns a new duplicate of the provided constant char array to that field. The function does not return any value (void).",
        "code_id": "c_group_2_id_84",
        "code_text": "void cad1e82cad2(cd830d75f96 *cdcafd2fc7e, const char *i54b7424bc6)\n{\n_076a41216e(cdcafd2fc7e->i54b7424bc6);\ncdcafd2fc7e->i54b7424bc6 = strdup(i54b7424bc6);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_85",
        "query_text": "SUMMARY: This function accepts a single input parameter of type const config_setting_t* and returns an int. It determines whether the provided configuration structure represents a boolean value by checking its type field; if it does, the function returns the integer value stored in the union (specifically in its ival component), and if not, it returns 0.",
        "code_id": "c_group_2_id_85",
        "code_text": "int c2219549416(const c82e0fd1bc8 *s358c545910)\n{\nreturn((s358c545910->t0e2e36c884 == C6c9e59cb03) ? s358c545910->v2760155807.ic88e9eafd3 : 0);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_86",
        "query_text": "SUMMARY: This function takes two inputs\u2014the first is a pointer to a structure (of type fuzz_data_t) that includes metadata about content size and an array of 8-bit unsigned integers, and the second is a pointer to a pointer of 8-bit unsigned integers (uint8_t **). The function assigns the memory address of the internal data array from the structure to the provided output pointer and then appends a null terminator at the position indicated by the content size (a 32-bit unsigned integer) within that array. The function is void, so it outputs the changed pointer as an effect via the output parameter.",
        "code_id": "c_group_2_id_86",
        "code_text": "void ff066e3f6b6(fb5cf78b7e8 *f3d3b3dd4a0, uint8_t **b99ab09a63e)\n{\n*b99ab09a63e = f3d3b3dd4a0->d4e0653e6bc;\n\n(*b99ab09a63e)[f3d3b3dd4a0->ce9e2446673] = '\\0';\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_87",
        "query_text": "SUMMARY: This function accepts two inputs: one is a pointer to a structured configuration object (type config_t *) and the other is a pointer to a destructor function (type void (*)(void *)) that takes a void pointer as its argument and returns no value. Its functionality is to assign the provided destructor function to the destructor attribute of the configuration object. The function itself returns no output (void).",
        "code_id": "c_group_2_id_87",
        "code_text": "void cf89413c8e6(cd830d75f96 *cdcafd2fc7e, void (*db88fa5dc0f)(void *))\n{\ncdcafd2fc7e->db88fa5dc0f = db88fa5dc0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_88",
        "query_text": "SUMMARY: This function takes three inputs\u2014a constant character pointer, another constant character pointer (both representing file paths), and a tt_bool_t (a boolean flag indicating verbosity). It returns a tt_bool_t indicating whether the contents of the two files are identical. The function opens both files in binary mode, reads their contents in 4096-byte chunks, and then compares the bytes sequentially. If a mismatch is detected (or if the files have different lengths), it marks the result as false and, if the verbosity flag is true, prints the location (line and character) where the first difference occurs. Ultimately, after closing the files, it returns TT_TRUE if the files are identical or TT_FALSE if they are not.",
        "code_id": "c_group_2_id_88",
        "code_text": "static tf1595e982f _51b5459dec(const char *f5a641daa25, const char *f2e069a1c3e,\ntf1595e982f v9134f04dfa)\n{\nFILE *fd8801828de, *f5bea9487e1;\nchar b8131aee337[4096], b7cca6cca8d[4096];\nint ldb6e375044 = 1;\nint c2e57e3be67 = 0;\nsize_t r4dc32c56ad, rc425d4f404;\ntf1595e982f d431de9b3c9 = T93f9781959, m40a4aafdd0 = Tb4138ab78b;\nif(!(fd8801828de = fopen(f5a641daa25, \"rb\")))\n{\nprintf(\"cannot open file: %s\\n\", f5a641daa25);\nreturn(T93f9781959);\n}\nif(!(f5bea9487e1 = fopen(f2e069a1c3e, \"rb\")))\n{\nfclose(fd8801828de);\nprintf(\"cannot open file: %s\\n\", f2e069a1c3e);\nreturn(T93f9781959);\n}\nwhile(!d431de9b3c9)\n{\nchar *pb2378a5e91, *qe10085b89e, *pb47f34c9fd, *q063db1acd4;\nr4dc32c56ad = fread(b8131aee337, 1, sizeof(b8131aee337), fd8801828de);\nrc425d4f404 = fread(b7cca6cca8d, 1, sizeof(b7cca6cca8d), f5bea9487e1);\npb2378a5e91 = b8131aee337;\nqe10085b89e = b7cca6cca8d;\npb47f34c9fd = b8131aee337 + r4dc32c56ad;\nq063db1acd4 = b7cca6cca8d + rc425d4f404;\nwhile(pb2378a5e91 < pb47f34c9fd && qe10085b89e < q063db1acd4)\n{\nif(*pb2378a5e91 != *qe10085b89e)\n{\nm40a4aafdd0 = T93f9781959;\nd431de9b3c9 = Tb4138ab78b;\nbreak;\n}\nif(*pb2378a5e91 == '\\n')\n{\n++ldb6e375044;\nc2e57e3be67 = 0;\n}\nelse\n++c2e57e3be67;\n++pb2378a5e91;\n++qe10085b89e;\n}\nif(pb2378a5e91 < pb47f34c9fd || qe10085b89e < q063db1acd4)\n{\nm40a4aafdd0 = T93f9781959;\nbreak;\n}\nif(feof(fd8801828de) || feof(f5bea9487e1))\nbreak;\n}\nfclose(fd8801828de);\nfclose(f5bea9487e1);\nif(!m40a4aafdd0 && v9134f04dfa)\nprintf(\"files \\\"%s\\\" and \\\"%s\\\" differ starting at line %d, char %d\\n\",\nf5a641daa25, f2e069a1c3e, ldb6e375044, c2e57e3be67);\nreturn(m40a4aafdd0);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_89",
        "query_text": "SUMMARY: The function accepts a C-style string (input type: char pointer) and returns a boolean value (output type: tt_bool_t, which is essentially an int). Its functionality is to traverse the string from the end toward the beginning, replacing any trailing newline-related characters (specifically carriage return or newline) with a null terminator, and then it returns a boolean indicating whether any such termination characters were encountered and removed.",
        "code_id": "c_group_2_id_89",
        "code_text": "static tf1595e982f _79e7ff39b3(char *s3b9d266e2e)\n{\nsize_t l498879d345 = strlen(s3b9d266e2e);\nchar *pb2378a5e91;\ntf1595e982f ec57b97262c = T93f9781959;\nfor(pb2378a5e91 = s3b9d266e2e + l498879d345 - 1; pb2378a5e91 > s3b9d266e2e; --pb2378a5e91) {\nif ((*pb2378a5e91 == '\\r') || (*pb2378a5e91 == '\\n')) {\nec57b97262c = Tb4138ab78b;\n*pb2378a5e91 = 0;\n}\n}\nreturn(ec57b97262c);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_90",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to an immutable configuration structure (const config_t *) and an integer (int) representing an option flag\u2014and returns an integer (int). It evaluates whether the bitmask in the configuration's options field fully includes the specified option flag, returning a nonzero value if it does and zero otherwise.",
        "code_id": "c_group_2_id_90",
        "code_text": "int c60047eaa6f(const cd830d75f96 *cdcafd2fc7e, int o54c09c1aa2)\n{\nreturn((cdcafd2fc7e->oea33165c71 & o54c09c1aa2) == o54c09c1aa2);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_91",
        "query_text": "SUMMARY: This function accepts a pointer to a structure (strbuf_t) that includes a dynamically allocated string, its length, and its capacity. It retrieves the string (a char pointer) stored within the structure, then resets the structure's contents to a zeroed or cleared state. Finally, it returns the retrieved char pointer.",
        "code_id": "c_group_2_id_91",
        "code_text": "char *l83fedf564e(sad423e43cb *ba69193d982)\n{\nchar *r01fae08b89 = ba69193d982->sed87ffeea8;\n_a820ea58eb(ba69193d982);\nreturn(r01fae08b89);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_92",
        "query_text": "SUMMARY: This function receives a pointer to a structure (of type config_t) and returns an unsigned short value. It retrieves the floating-point precision field stored within the given configuration structure.",
        "code_id": "c_group_2_id_92",
        "code_text": "unsigned short c0d3a6c55ca(const cd830d75f96 *cdcafd2fc7e)\n{\nreturn cdcafd2fc7e->fe2e5f078ff;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_93",
        "query_text": "SUMMARY: This function accepts a pointer to a structure representing a list (type config_list_t*) and an integer (type int) indicating an index, and it returns a pointer to a configuration setting (type config_setting_t*). Its primary operation is to remove the configuration setting located at the specified index from the list by shifting the subsequent elements to fill the gap, decrementing the total count of elements, and then returning the removed configuration setting.",
        "code_id": "c_group_2_id_93",
        "code_text": "static c82e0fd1bc8 *_6aff358f30(c1525df9c00 *lbb27d975f2, int i4dfa645352)\n{\nc82e0fd1bc8 *r0c4b5e6c00 = *(lbb27d975f2->e13d902dbe3 + i4dfa645352);\nint o51f631f8ec = (i4dfa645352 * sizeof(c82e0fd1bc8 *));\nint l498879d345 = lbb27d975f2->l61e04ca4e3 - 1 - i4dfa645352;\nchar *b7917889144 = (char *)lbb27d975f2->e13d902dbe3 + o51f631f8ec;\nmemmove(b7917889144, b7917889144 + sizeof(c82e0fd1bc8 *),\nl498879d345 * sizeof(c82e0fd1bc8 *));\nlbb27d975f2->l61e04ca4e3--;\n\nreturn(r0c4b5e6c00);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_94",
        "query_text": "SUMMARY: This function takes as input a pointer to a structure of type config_t and an unsigned short integer. It modifies the configuration by setting its tab_width field to the input value, ensuring that the value does not exceed 15; if the input exceeds 15, it sets the tab_width to 15. The function has a void output, meaning it does not return any value.",
        "code_id": "c_group_2_id_94",
        "code_text": "void c704cd32bc9(cd830d75f96 *cdcafd2fc7e, unsigned short w3f71ca1172)\n{\n\ncdcafd2fc7e->tcc45070348 = (w3f71ca1172 <= 15) ? w3f71ca1172 : 15;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_95",
        "query_text": "SUMMARY: This function accepts a single input of type mp_err (an enumeration representing various error conditions) and returns a const char* (a string literal). Its functionality is to map the provided mp_err input to a corresponding descriptive error message. It examines the input using a conditional structure and returns a specific string literal for each valid error code, or a default message indicating an invalid error code if the input does not match any predefined enumeration value.",
        "code_id": "c_group_2_id_95",
        "code_text": "const char *mf032068538(m8aa6ee2d9e c76a9e7126f)\n{\nswitch (c76a9e7126f) {\ncase M584463901c:\nreturn \"Successful\";\ncase M9745d6848f:\nreturn \"Unknown error\";\ncase M6bcfcc4e13:\nreturn \"Out of heap\";\ncase Mc9444ca316:\nreturn \"Value out of range\";\ncase Me4d01274cc:\nreturn \"Max. iterations reached\";\ncase Mc0e0a86c75:\nreturn \"Buffer overflow\";\ncase M0e858864f8:\nreturn \"Integer overflow\";\ndefault:\nreturn \"Invalid error code\";\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_96",
        "query_text": "SUMMARY: This function accepts an input of type unsigned long and returns a value of the same type. It computes the integer portion of the base-2 logarithm of the input by repeatedly shifting the input to the right (thereby dividing by 2) until the result is zero. For each shift performed, it increments a counter, and finally returns this counter as the output.",
        "code_id": "c_group_2_id_96",
        "code_text": "static mbc34969383 s048a28d25a(mbc34969383 v2760155807)\n{\nmbc34969383 r01fae08b89 = 0u;\nwhile ((v2760155807 >>= 1) != 0u) {\nr01fae08b89++;\n}\nreturn r01fae08b89;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_97",
        "query_text": "SUMMARY: This function takes three parameters: a pointer to a mutable 64-bit unsigned integer array (output), a pointer to a constant 64-bit unsigned integer array (input), and an integer indicating the number of elements (digits) to process. Its purpose is to copy the specified number of 64-bit unsigned integers from the constant array into the mutable array. The operation is performed either by using a memory copy routine or by a simple loop, based on compile-time configuration. The function does not return any value.",
        "code_id": "c_group_2_id_97",
        "code_text": "void sa8f1c76898(mfff140f13d *ded8b2a8791, const mfff140f13d *s3b9d266e2e, int d4fcfebcbb6)\n{\n#ifdef MP_USE_MEMOPS\nif (digits > 0) {\nmemcpy(d, s, (size_t)digits * sizeof(mp_digit));\n}\n#else\nwhile (d4fcfebcbb6-- > 0) {\n*ded8b2a8791++ = *s3b9d266e2e++;\n}\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_98",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to an array of unsigned 64-bit integers (mp_digit *) and a count as an integer (int) representing the number of elements. Its behavior is to set the specified number of unsigned 64-bit integer elements to zero. The function does not produce any output (void return), and its process involves either using a memory-setting operation to fill the array with 0 values or iterating over the array and assigning 0 to each element based on conditional compilation.",
        "code_id": "c_group_2_id_98",
        "code_text": "void s3b13708a47(mfff140f13d *ded8b2a8791, int d4fcfebcbb6)\n{\n#ifdef MP_USE_MEMOPS\nif (digits > 0) {\nmemset(d, 0, (size_t)digits * sizeof(mp_digit));\n}\n#else\nwhile (d4fcfebcbb6-- > 0) {\n*ded8b2a8791++ = 0;\n}\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_99",
        "query_text": "SUMMARY: This function takes an input of type uint64_t and returns an int. It determines whether the provided unsigned integer is exactly a power of two. Specifically, it examines the number by removing successive factors of two (i.e., counting trailing zero bits) and then checks if the remaining value is one. If so, it returns the exponent (the count of divisions), indicating that the input equals 2 raised to that exponent; if not, it returns -1 to signal that the input is not a power of two.",
        "code_id": "c_group_2_id_99",
        "code_text": "int      s4c86b6fce3(mfff140f13d ded8b2a8791)\n{\nint   p46629ccb2a = 0;\nwhile((ded8b2a8791 & 1) == 0) {\n++p46629ccb2a; ded8b2a8791 >>= 1;\n}\nif(ded8b2a8791 == 1)\nreturn p46629ccb2a;\nreturn -1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_100",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to a structure (of type Ciphers) that aggregates various cryptographic cipher objects, and a void pointer representing a memory heap used for dynamic allocation\u2014and returns no output (void). It conditionally deallocates memory for each distinct cryptographic cipher component stored within the input structure by calling associated freeing routines and custom deallocation functions. After releasing the resources, it sets the corresponding pointers in the structure to NULL, ensuring that no dangling references remain. For some cipher types, it also overwrites sensitive data before deallocation to enhance security.",
        "code_id": "c_group_2_id_100",
        "code_text": "static void F59d3d2e316(Cbe47192d61 *c2246bb449a, void* h5d7f971b4f)\n{\n#ifdef BUILD_ARC4\nwc_Arc4Free(cipher->arc4);\nXFREE(cipher->arc4, heap, DYNAMIC_TYPE_CIPHER);\ncipher->arc4 = NULL;\n#endif\n#ifdef BUILD_DES3\nwc_Des3Free(cipher->des3);\nXFREE(cipher->des3, heap, DYNAMIC_TYPE_CIPHER);\ncipher->des3 = NULL;\n#endif\n#if defined(BUILD_AES) || defined(BUILD_AESGCM) || defined(HAVE_ARIA)\n\nwc_AesFree(cipher->aes);\nXFREE(cipher->aes, heap, DYNAMIC_TYPE_CIPHER);\ncipher->aes = NULL;\n#endif\n#if defined(WOLFSSL_SM4_GCM) || defined(WOLFSSL_SM4_CCM)\nwc_Sm4Free(cipher->sm4);\nXFREE(cipher->sm4, heap, DYNAMIC_TYPE_CIPHER);\ncipher->sm4 = NULL;\n#endif\n#if (defined(BUILD_AESGCM) || defined(BUILD_AESCCM) || defined(HAVE_ARIA)) && \\\n!defined(WOLFSSL_NO_TLS12)\nXFREE(cipher->additional, heap, DYNAMIC_TYPE_CIPHER);\ncipher->additional = NULL;\n#endif\n#ifdef CIPHER_NONCE\nXFREE(cipher->nonce, heap, DYNAMIC_TYPE_CIPHER);\ncipher->nonce = NULL;\n#endif\n#ifdef HAVE_ARIA\nwc_AriaFreeCrypt(cipher->aria);\nXFREE(cipher->aria, heap, DYNAMIC_TYPE_CIPHER);\ncipher->aria = NULL;\n#endif\n#ifdef HAVE_CAMELLIA\nXFREE(cipher->cam, heap, DYNAMIC_TYPE_CIPHER);\ncipher->cam = NULL;\n#endif\n#ifdef HAVE_CHACHA\nif (cipher->chacha)\nForceZero(cipher->chacha, sizeof(ChaCha));\nXFREE(cipher->chacha, heap, DYNAMIC_TYPE_CIPHER);\ncipher->chacha = NULL;\n#endif\n#if defined(WOLFSSL_TLS13) && defined(HAVE_NULL_CIPHER)\nwc_HmacFree(cipher->hmac);\nXFREE(cipher->hmac, heap, DYNAMIC_TYPE_CIPHER);\ncipher->hmac = NULL;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_101",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a pointer to an array of unsigned char (byte), a single unsigned char (byte) value, and an integer representing the number of elements to check. It iterates over the array and performs a comparison between each element and the specified unsigned char value using a bitwise XOR operation. The result of each comparison is accumulated using a bitwise OR operation. Finally, the function returns an integer that indicates whether all elements in the array match the specified byte value (0 if they all match; a nonzero value if at least one does not).",
        "code_id": "c_group_2_id_101",
        "code_text": "static int P7c032211ab(const b621802819e* ad90770d038, b621802819e p8567a28768, int l61e04ca4e3)\n{\nint i0c6e314cec;\nint c85914f4c83 = 0;\nfor (i0c6e314cec = 0; i0c6e314cec < l61e04ca4e3; i0c6e314cec++) {\nc85914f4c83 |= ad90770d038[i0c6e314cec] ^ p8567a28768;\n}\nreturn c85914f4c83;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_102",
        "query_text": "SUMMARY: This function accepts a pointer to a structure of type Des3 as its input and returns no output (void). It first checks whether the input pointer is null, and if so, it exits immediately. When asynchronous cryptography support is enabled, it releases any associated asynchronous device context resources from the Des3 structure. Under additional conditional configurations, it clears sensitive key data within this structure by zeroing the corresponding memory areas, and may further verify that the entire structure has been securely wiped of data.",
        "code_id": "c_group_2_id_102",
        "code_text": "void w1e972846de(Daa4ec609ce* d2dd5e651a8)\n{\nif (d2dd5e651a8 == N9a67febeb9)\nreturn;\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_3DES)\nwolfAsync_DevCtxFree(&des3->asyncDev, WOLFSSL_ASYNC_MARKER_3DES);\n#endif \n#if defined(WOLF_CRYPTO_CB) || \\\n(defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_3DES))\nForceZero(des3->devKey, sizeof(des3->devKey));\n#endif\n#ifdef WOLFSSL_CHECK_MEM_ZERO\nwc_MemZero_Check(des3, sizeof(Des3));\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_103",
        "query_text": "SUMMARY: This function accepts five parameters: a pointer to a structure (of type stats_t) that contains numerical statistics (double values representing connection, receive, and transmit time, and integer values for connection count, receive total, and transmit total), three constant character pointers (providing informational text such as a benchmark description, a cipher identifier, and a group name), and an integer flag indicating verbosity. The function processes these inputs by calculating and formatting aggregate performance metrics, such as the total bytes (sum of transmit and receive totals), connection times converted to milliseconds, and throughput rates in megabytes per second (derived from dividing the byte totals by the corresponding timing values and applying conversions). Based on the verbosity flag, the function outputs the formatted benchmark results in either a detailed or a compact format to the standard error stream. The function does not return any value.",
        "code_id": "c_group_2_id_103",
        "code_text": "static void pcf1c2003a4(s68e5f4e280* wd2cce7b591, const char* d99dd117061, const char* c2246bb449a, const char *g5b46af48c1, int v9134f04dfa)\n{\nif (v9134f04dfa) {\nfprintf(sa9de313333,\n\"wolfSSL %s Benchmark on %s with group %s:\\n\"\n\"\\tTotal       : %9d bytes\\n\"\n\"\\tNum Conns   : %9d\\n\"\n\"\\tRx Total    : %9.3f ms\\n\"\n\"\\tTx Total    : %9.3f ms\\n\"\n\"\\tRx          : %9.3f MB/s\\n\"\n\"\\tTx          : %9.3f MB/s\\n\"\n\"\\tConnect     : %9.3f ms\\n\"\n\"\\tConnect Avg : %9.3f ms\\n\",\nd99dd117061,\nc2246bb449a,\ng5b46af48c1,\nwd2cce7b591->t2cedd35d2e + wd2cce7b591->r9c44c23b07,\nwd2cce7b591->cde5edd620c,\nwd2cce7b591->r75a7df082e * 1000,\nwd2cce7b591->t0c173d6731 * 1000,\nwd2cce7b591->r9c44c23b07 / wd2cce7b591->r75a7df082e / 1024 / 1024,\nwd2cce7b591->t2cedd35d2e / wd2cce7b591->t0c173d6731 / 1024 / 1024,\nwd2cce7b591->c5e6b5fb8c5 * 1000,\nwd2cce7b591->c5e6b5fb8c5 * 1000 / wd2cce7b591->cde5edd620c);\n}\nelse {\nfprintf(sa9de313333,\n\"%-6s  %-33s  %-25s  %11d  %9d  %9.3f  %9.3f  %9.3f  \"\n\"%9.3f  %17.3f  %15.3f\\n\",\nd99dd117061,\nc2246bb449a,\ng5b46af48c1,\nwd2cce7b591->t2cedd35d2e + wd2cce7b591->r9c44c23b07,\nwd2cce7b591->cde5edd620c,\nwd2cce7b591->r75a7df082e * 1000,\nwd2cce7b591->t0c173d6731 * 1000,\nwd2cce7b591->r9c44c23b07 / wd2cce7b591->r75a7df082e / 1024 / 1024,\nwd2cce7b591->t2cedd35d2e / wd2cce7b591->t0c173d6731 / 1024 / 1024,\nwd2cce7b591->c5e6b5fb8c5 * 1000,\nwd2cce7b591->c5e6b5fb8c5 * 1000 / wd2cce7b591->cde5edd620c);\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_104",
        "query_text": "SUMMARY: This function takes four inputs: a pointer to a structure (stats_t) containing double values for connection, receive, and transmit times, and integers for connection count, receive total, and transmit total; two constant character string pointers; and an integer indicating verbosity. It produces no return value (void). Based on the verbosity flag, the function selects one of two formatted string templates and prints a summary report to the standard output. The report includes the aggregate total of transmitted and received bytes, the number of connections, the total receive and transmit times (converted into milliseconds), calculated throughput rates in megabytes per second (derived from the byte totals and their respective times), and the connection time (both overall and as an average per connection).",
        "code_id": "c_group_2_id_104",
        "code_text": "static void Pb1d72d26c2(s68e5f4e280* wd2cce7b591, const char* d99dd117061, const char* c2246bb449a, int v9134f04dfa)\n{\nconst char* f47afe1fe3d;\nif (v9134f04dfa) {\nf47afe1fe3d = \"wolfSSL %s Benchmark on %s:\\n\"\n\"\\tTotal       : %9d bytes\\n\"\n\"\\tNum Conns   : %9d\\n\"\n\"\\tRx Total    : %9.3f ms\\n\"\n\"\\tTx Total    : %9.3f ms\\n\"\n\"\\tRx          : %9.3f MB/s\\n\"\n\"\\tTx          : %9.3f MB/s\\n\"\n\"\\tConnect     : %9.3f ms\\n\"\n\"\\tConnect Avg : %9.3f ms\\n\";\n}\nelse {\nf47afe1fe3d = \"%-6s  %-33s  %11d  %9d  %9.3f  %9.3f  %9.3f  %9.3f  %17.3f  %15.3f\\n\";\n}\nprintf(f47afe1fe3d,\nd99dd117061,\nc2246bb449a,\nwd2cce7b591->t2cedd35d2e + wd2cce7b591->r9c44c23b07,\nwd2cce7b591->cde5edd620c,\nwd2cce7b591->r75a7df082e * 1000,\nwd2cce7b591->t0c173d6731 * 1000,\nwd2cce7b591->r9c44c23b07 / wd2cce7b591->r75a7df082e / 1024 / 1024,\nwd2cce7b591->t2cedd35d2e / wd2cce7b591->t0c173d6731 / 1024 / 1024,\nwd2cce7b591->c5e6b5fb8c5 * 1000,\nwd2cce7b591->c5e6b5fb8c5 * 1000 / wd2cce7b591->cde5edd620c);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_105",
        "query_text": "SUMMARY: This function accepts an input parameter of type int and three output pointers each of type word32 (unsigned int). Based on the integer input, it selects one of several predefined key parameter sets and calculates the sizes (in bytes) of three components\u2014two mandatory components and an optional one when available. For each matching case in a switch statement, it assigns the corresponding size values to temporary word32 variables. If any of the provided output pointers is non-null, the function writes the computed size for that component into the location pointed to by that pointer. Finally, it returns an int value of 0, indicating successful completion.",
        "code_id": "c_group_2_id_105",
        "code_text": "int we24eea6e3f(int n5fa9babb97, w022a45f411* pb2378a5e91, w022a45f411* g9a9b7f5c21, w022a45f411* qe10085b89e)\n{\nw022a45f411 p41b7c940fd = 0, g1c7438dc67 = 0, qfc2effbdb5 = 0;\nswitch (n5fa9babb97) {\n#ifdef HAVE_FFDHE_2048\ncase WC_FFDHE_2048:\npSz = sizeof(dh_ffdhe2048_p);\ngSz = sizeof(dh_ffdhe2048_g);\n#ifdef HAVE_FFDHE_Q\nqSz = sizeof(dh_ffdhe2048_q);\n#endif \nbreak;\n#endif \n#ifdef HAVE_FFDHE_3072\ncase WC_FFDHE_3072:\npSz = sizeof(dh_ffdhe3072_p);\ngSz = sizeof(dh_ffdhe3072_g);\n#ifdef HAVE_FFDHE_Q\nqSz = sizeof(dh_ffdhe3072_q);\n#endif \nbreak;\n#endif \n#ifdef HAVE_FFDHE_4096\ncase WC_FFDHE_4096:\npSz = sizeof(dh_ffdhe4096_p);\ngSz = sizeof(dh_ffdhe4096_g);\n#ifdef HAVE_FFDHE_Q\nqSz = sizeof(dh_ffdhe4096_q);\n#endif \nbreak;\n#endif \n#ifdef HAVE_FFDHE_6144\ncase WC_FFDHE_6144:\npSz = sizeof(dh_ffdhe6144_p);\ngSz = sizeof(dh_ffdhe6144_g);\n#ifdef HAVE_FFDHE_Q\nqSz = sizeof(dh_ffdhe6144_q);\n#endif \nbreak;\n#endif \n#ifdef HAVE_FFDHE_8192\ncase WC_FFDHE_8192:\npSz = sizeof(dh_ffdhe8192_p);\ngSz = sizeof(dh_ffdhe8192_g);\n#ifdef HAVE_FFDHE_Q\nqSz = sizeof(dh_ffdhe8192_q);\n#endif \nbreak;\n#endif \ndefault:\nbreak;\n}\nif (pb2378a5e91 != N9a67febeb9) *pb2378a5e91 = p41b7c940fd;\nif (g9a9b7f5c21 != N9a67febeb9) *g9a9b7f5c21 = g1c7438dc67;\nif (qe10085b89e != N9a67febeb9) *qe10085b89e = qfc2effbdb5;\nreturn 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_106",
        "query_text": "SUMMARY: The function takes an integer (input type: int) and returns an enumerated hash type value (output type: wc_HashType). It first initializes the return value to a special \"none\" state, indicating an error or unmatched type. Under certain build configurations (such as those for FIPS or self-test), it uses a switch statement to map specific integer constants to corresponding enumeration values, ensuring that only particular hash types (like MD5, SHA variants, SHA3, SM3, etc.) are converted. If the input does not match any defined cases, the function retains the default \"none\" value. In other configurations, it checks if the integer is within a valid range and then directly converts it to the corresponding enumerated hash type.",
        "code_id": "c_group_2_id_106",
        "code_text": "enum w23f3ed08a6 w4bee2fdcde(int he4a876e988)\n{\n\nenum w23f3ed08a6 e262bc1c7d7 = Wcd33e4f6c2;\n#if defined(HAVE_FIPS) || defined(HAVE_SELFTEST)\n\nswitch (hashType) {\n#ifndef NO_MD5\ncase WC_MD5:\neHashType = WC_HASH_TYPE_MD5;\nbreak;\n#endif \n#ifndef NO_SHA\ncase WC_SHA:\neHashType = WC_HASH_TYPE_SHA;\nbreak;\n#endif \n#ifdef WOLFSSL_SHA224\ncase WC_SHA224:\neHashType = WC_HASH_TYPE_SHA224;\nbreak;\n#endif \n#ifndef NO_SHA256\ncase WC_SHA256:\neHashType = WC_HASH_TYPE_SHA256;\nbreak;\n#endif \n#ifdef WOLFSSL_SHA384\ncase WC_SHA384:\neHashType = WC_HASH_TYPE_SHA384;\nbreak;\n#endif \n#ifdef WOLFSSL_SHA512\ncase WC_SHA512:\neHashType = WC_HASH_TYPE_SHA512;\nbreak;\n#endif \n#ifdef WOLFSSL_SHA3\ncase WC_SHA3_224:\neHashType = WC_HASH_TYPE_SHA3_224;\nbreak;\ncase WC_SHA3_256:\neHashType = WC_HASH_TYPE_SHA3_256;\nbreak;\ncase WC_SHA3_384:\neHashType = WC_HASH_TYPE_SHA3_384;\nbreak;\ncase WC_SHA3_512:\neHashType = WC_HASH_TYPE_SHA3_512;\nbreak;\n#endif \n#ifdef WOLFSSL_SM3\ncase WC_SM3:\neHashType = WC_HASH_TYPE_SM3;\nbreak;\n#endif\ndefault:\neHashType = WC_HASH_TYPE_NONE;\nbreak;\n}\n#else\n\nif (he4a876e988 > 0 && he4a876e988 <= W45bba4afb6) {\ne262bc1c7d7 = (enum w23f3ed08a6)he4a876e988;\n}\n#endif\nreturn e262bc1c7d7;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_107",
        "query_text": "SUMMARY: This function updates a linked list of DNS_entry structures by inserting a new DNS_entry structure. It accepts two inputs: a pointer to a pointer to a DNS_entry (serving as the list head) and a pointer to a DNS_entry structure (the element to be added). Depending on compile-time conditions, the function either appends the element at the end of the list (if specific flags are defined) or prepends it to the front. The output is an integer (int) which is returned as 0, indicating the operation's successful completion.",
        "code_id": "c_group_2_id_107",
        "code_text": "static int Ab6c6aee423(Da94e6957bc** l0b93992018, Da94e6957bc* eced0fbcbdf)\n{\n#if defined(OPENSSL_EXTRA) && !defined(WOLFSSL_ALT_NAMES_NO_REV)\nentry->next = NULL;\nif (*lst == NULL) {\n\n*lst = entry;\n}\nelse {\nDNS_entry* temp = *lst;\n\nfor (; (temp->next != NULL); temp = temp->next);\n\ntemp->next = entry;\n}\n#else\n\neced0fbcbdf->ne43a7c0673 = *l0b93992018;\n*l0b93992018 = eced0fbcbdf;\n#endif\nreturn 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_108",
        "query_text": "SUMMARY: The function accepts two parameters\u2014a generic pointer (void*) and an unsigned short integer (word16)\u2014and returns no value (void). Its primary functionality is to signal that a server component is ready to accept TCP connections. In environments where specific configuration macros are defined, it retrieves a signaling structure from the provided argument, initiates a condition check, sets an internal readiness flag and the provided port value within that structure, signals the condition to notify any waiting threads, and then completes the condition handling.",
        "code_id": "c_group_2_id_108",
        "code_text": "static void S7024d5e6b9(void* ab4b83ecfab, w05c6e46965 p82ff044598)\n{\n#if defined(NO_MAIN_DRIVER) && defined(WOLFSSL_COND)\n\nfunc_args* server_args = (func_args*)args;\ntcp_ready* ready = server_args->signal;\nTHREAD_CHECK_RET(wolfSSL_CondStart(&ready->cond));\nready->ready = 1;\nready->port = port;\nTHREAD_CHECK_RET(wolfSSL_CondSignal(&ready->cond));\nTHREAD_CHECK_RET(wolfSSL_CondEnd(&ready->cond));\n#endif \n(void)ab4b83ecfab;\n(void)p82ff044598;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_109",
        "query_text": "SUMMARY: This function accepts no parameters (input type: void) and returns a value of type wc_test_ret_t (alias for int). Its primary purpose is to validate AES-256 operations in Cipher Block Chaining (CBC) mode. The function configures encryption (and decryption, when enabled) contexts using a predetermined key and initialization vector. It then encrypts a fixed test message (sourced from established test vectors) and, if decryption is available, decrypts the resulting ciphertext. The outputs from both processes are compared against expected results to verify correctness. Multiple rounds of such tests are performed under different configurations, and error codes are returned immediately if any discrepancies or failures occur. Finally, it releases any allocated resources before returning the result.",
        "code_id": "c_group_2_id_109",
        "code_text": "w12711613f7 a3b5cf3e1b2(void)\n{\n#ifdef HAVE_AES_CBC\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\nAes *enc = NULL;\n#else\nAes enc[1];\n#endif\nbyte cipher[WC_AES_BLOCK_SIZE];\n#ifdef HAVE_AES_DECRYPT\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\nAes *dec = NULL;\n#else\nAes dec[1];\n#endif\nbyte plain[WC_AES_BLOCK_SIZE];\n#endif\n#endif \nw12711613f7 rbb7a0566ac = 0;\n#ifdef HAVE_AES_CBC\n\nWOLFSSL_SMALL_STACK_STATIC const byte msg[] = {\n0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,\n0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a\n};\nWOLFSSL_SMALL_STACK_STATIC const byte verify[] =\n{\n0xf5,0x8c,0x4c,0x04,0xd6,0xe5,0xf1,0xba,\n0x77,0x9e,0xab,0xfb,0x5f,0x7b,0xfb,0xd6\n};\n#ifdef HAVE_RENESAS_SYNC\nbyte *key =\n(byte*)guser_PKCbInfo.wrapped_key_aes256;\nint keySz = (256/8);\n#else\nWOLFSSL_SMALL_STACK_STATIC const byte key[] = {\n0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,\n0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,\n0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,\n0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4\n};\nint keySz = (int)sizeof(key);\n#endif\nWOLFSSL_SMALL_STACK_STATIC const byte iv[]  = {\n0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,\n0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F\n};\nWOLFSSL_ENTER(\"aes256_test\");\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\nenc = wc_AesNew(HEAP_HINT, devId, &ret);\nif (enc == NULL)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\ndec = wc_AesNew(HEAP_HINT, devId, &ret);\nif (dec == NULL)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\n#else\nXMEMSET(enc, 0, sizeof(Aes));\n#ifdef HAVE_AES_DECRYPT\nXMEMSET(dec, 0, sizeof(Aes));\n#endif\nret = wc_AesInit(enc, HEAP_HINT, devId);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\nret = wc_AesInit(dec, HEAP_HINT, devId);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\n#endif \nret = wc_AesSetKey(enc, key, (word32)keySz, iv, AES_ENCRYPTION);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\nret = wc_AesSetKey(dec, key, (word32)keySz, iv, AES_DECRYPTION);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\nXMEMSET(cipher, 0, WC_AES_BLOCK_SIZE);\nret = wc_AesCbcEncrypt(enc, cipher, msg, (int) sizeof(msg));\n#if defined(WOLFSSL_ASYNC_CRYPT)\nret = wc_AsyncWait(ret, &enc->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\nXMEMSET(plain, 0, WC_AES_BLOCK_SIZE);\nret = wc_AesCbcDecrypt(dec, plain, cipher, (int) sizeof(cipher));\n#if defined(WOLFSSL_ASYNC_CRYPT)\nret = wc_AsyncWait(ret, &dec->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\nif (XMEMCMP(plain, msg, (int) sizeof(plain))) {\nERROR_OUT(WC_TEST_RET_ENC_NC, out);\n}\n#endif\n#ifndef HAVE_RENESAS_SYNC\nif (XMEMCMP(cipher, verify, (int) sizeof(cipher)))\nERROR_OUT(WC_TEST_RET_ENC_NC, out);\n#endif\n#if defined(DEBUG_VECTOR_REGISTER_ACCESS) && defined(WC_C_DYNAMIC_FALLBACK)\nret = wc_AesSetKey(enc, key, keySz, iv, AES_ENCRYPTION);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\nret = wc_AesSetKey(dec, key, keySz, iv, AES_DECRYPTION);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\nXMEMSET(cipher, 0, WC_AES_BLOCK_SIZE);\nWC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(WC_NO_ERR_TRACE(SYSLIB_FAILED_E));\nret = wc_AesCbcEncrypt(enc, cipher, msg, (int) sizeof(msg));\n#if defined(WOLFSSL_ASYNC_CRYPT)\nret = wc_AsyncWait(ret, &enc->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\nWC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(0);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\nXMEMSET(plain, 0, WC_AES_BLOCK_SIZE);\nWC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(WC_NO_ERR_TRACE(SYSLIB_FAILED_E));\nret = wc_AesCbcDecrypt(dec, plain, cipher, (int) sizeof(cipher));\n#if defined(WOLFSSL_ASYNC_CRYPT)\nret = wc_AsyncWait(ret, &dec->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\nWC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(0);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\nif (XMEMCMP(plain, msg, (int) sizeof(plain))) {\nERROR_OUT(WC_TEST_RET_ENC_NC, out);\n}\n#endif\n#ifndef HAVE_RENESAS_SYNC\nif (XMEMCMP(cipher, verify, (int) sizeof(cipher)))\nERROR_OUT(WC_TEST_RET_ENC_NC, out);\n#endif\nWC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(WC_NO_ERR_TRACE(SYSLIB_FAILED_E));\nret = wc_AesSetKey(enc, key, keySz, iv, AES_ENCRYPTION);\nWC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(0);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\nWC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(WC_NO_ERR_TRACE(SYSLIB_FAILED_E));\nret = wc_AesSetKey(dec, key, keySz, iv, AES_DECRYPTION);\nWC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(0);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\nXMEMSET(cipher, 0, WC_AES_BLOCK_SIZE);\nret = wc_AesCbcEncrypt(enc, cipher, msg, (int) sizeof(msg));\n#if defined(WOLFSSL_ASYNC_CRYPT)\nret = wc_AsyncWait(ret, &enc->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\nXMEMSET(plain, 0, WC_AES_BLOCK_SIZE);\nret = wc_AesCbcDecrypt(dec, plain, cipher, (int) sizeof(cipher));\n#if defined(WOLFSSL_ASYNC_CRYPT)\nret = wc_AsyncWait(ret, &dec->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\nif (XMEMCMP(plain, msg, (int) sizeof(plain))) {\nERROR_OUT(WC_TEST_RET_ENC_NC, out);\n}\n#endif\n#ifndef HAVE_RENESAS_SYNC\nif (XMEMCMP(cipher, verify, (int) sizeof(cipher)))\nERROR_OUT(WC_TEST_RET_ENC_NC, out);\n#endif\n#endif \nout:\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\nwc_AesDelete(enc, &enc);\n#else\nwc_AesFree(enc);\n#endif\n#ifdef HAVE_AES_DECRYPT\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\nwc_AesDelete(dec, &dec);\n#else\nwc_AesFree(dec);\n#endif\n#endif\n#endif \nreturn rbb7a0566ac;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_110",
        "query_text": "SUMMARY: This function performs file output operations. It accepts a file stream input of type FILE*, a character array of input type const char*, and an unsigned integer of input type word32 that indicates the number of bytes to write. The function attempts to write the specified number of bytes from the given character array to the file stream. If the write operation does not complete successfully (i.e., the number of bytes written does not match the specified unsigned integer), it outputs an error message to the standard error stream and returns an integer of output type int with a value indicating failure; otherwise, it returns an integer indicating success.",
        "code_id": "c_group_2_id_110",
        "code_text": "static int W042867879f(FILE* ff0c2bf7439, const char* d4e0653e6bc, w022a45f411 l498879d345)\n{\nint rbb7a0566ac = 0;\n\nif (fwrite(d4e0653e6bc, 1, l498879d345, ff0c2bf7439) != l498879d345) {\n\nfprintf(sa9de313333, \"Failed to write\\n\");\nrbb7a0566ac = 1;\n}\nreturn rbb7a0566ac;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_111",
        "query_text": "SUMMARY: This function accepts an integer (int) as input and returns an unsigned integer (word32) as output. It determines and provides a corresponding minimum size value based on the numeric identifier provided. Using a switch-case mechanism, it maps specific integer values (enabled by certain preprocessor definitions) to predetermined size values, and if an unrecognized identifier is given, it returns zero.",
        "code_id": "c_group_2_id_111",
        "code_text": "w022a45f411 w638d75e826(int n5fa9babb97)\n{\nw022a45f411 s501f3ce221;\nswitch (n5fa9babb97) {\n#ifdef HAVE_FFDHE_2048\ncase WC_FFDHE_2048:\nsize = 29;\nbreak;\n#endif \n#ifdef HAVE_FFDHE_3072\ncase WC_FFDHE_3072:\nsize = 34;\nbreak;\n#endif \n#ifdef HAVE_FFDHE_4096\ncase WC_FFDHE_4096:\nsize = 39;\nbreak;\n#endif \n#ifdef HAVE_FFDHE_6144\ncase WC_FFDHE_6144:\nsize = 46;\nbreak;\n#endif \n#ifdef HAVE_FFDHE_8192\ncase WC_FFDHE_8192:\nsize = 52;\nbreak;\n#endif \ndefault:\ns501f3ce221 = 0;\n}\nreturn s501f3ce221;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_112",
        "query_text": "SUMMARY: This function accepts three inputs \u2013 an optional pointer to a byte (unsigned char*), an integer representing an initial size, and an integer representing a block size. It calculates the number of padding bytes required to extend the initial size to a multiple of the block size. If the provided byte pointer is not null, it appends padding bytes to the data buffer, with each added byte set to the computed padding value (masked to a single byte). The function returns an integer that represents the new total length after the padding has been applied.",
        "code_id": "c_group_2_id_112",
        "code_text": "static int P3f144f17fe(b621802819e* ba69193d982, int s23246ee131, int b17026f1b72)\n{\nint p37df488697;\n\np37df488697 = b17026f1b72 - (s23246ee131 & (b17026f1b72 - 1));\n\nif (ba69193d982) {\nint i0c6e314cec;\nfor (i0c6e314cec = 0; i0c6e314cec < p37df488697; i0c6e314cec++) {\nba69193d982[s23246ee131+i0c6e314cec] = (b621802819e)(p37df488697 & 0xFF);\n}\n}\n\nreturn s23246ee131 + p37df488697;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_113",
        "query_text": "SUMMARY: This function operates on a modifiable character array and a constant character array. It accepts an array segment defined by an unsigned 32-bit integer offset and length, and searches within that segment for a specific substring represented by a constant character array along with its unsigned 32-bit length. If the substring is found, the function assigns its unsigned 32-bit position into a location provided by an output pointer and returns an integer value 0 indicating success; if not, it returns 1 to indicate failure.",
        "code_id": "c_group_2_id_113",
        "code_text": "static int Fff3f3650a8(char* h70f2740a71, w022a45f411 o51f631f8ec, w022a45f411 l498879d345,\nconst char* nfc8fc3001f, w022a45f411 n0546324442, w022a45f411* n075b0828f0)\n{\n\nint rbb7a0566ac = 1;\nw022a45f411 i0c6e314cec;\n\nif (l498879d345 >= n0546324442) {\n\nfor (i0c6e314cec = o51f631f8ec; i0c6e314cec <= l498879d345 - n0546324442; i0c6e314cec++) {\n\nif ((h70f2740a71[i0c6e314cec] == nfc8fc3001f[0]) &&\n(strncmp(h70f2740a71 + i0c6e314cec, nfc8fc3001f, n0546324442) == 0)) {\n\n*n075b0828f0 = i0c6e314cec;\n\nrbb7a0566ac = 0;\n\nbreak;\n}\n}\n}\nreturn rbb7a0566ac;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_114",
        "query_text": "SUMMARY: This function accepts two inputs of type word32 (unsigned integers) and returns an int. It evaluates whether the provided modulus length meets predefined criteria based on its value and, in conjunction, checks if the accompanying divisor length corresponds to an allowed value. Specifically, for a modulus length equal to 1024, it verifies that the divisor length is 160; for a modulus length equal to 2048, it accepts divisor lengths of either 224 or 256. If a valid pairing is found, the function returns 0; otherwise, it returns -1.",
        "code_id": "c_group_2_id_114",
        "code_text": "static int C808b3e6c41(w022a45f411 m93eb19290c, w022a45f411 d3e566861da)\n{\nint rbb7a0566ac = -1;\nswitch (m93eb19290c) {\n\ncase 1024:\nif (d3e566861da == 160)\nrbb7a0566ac = 0;\nbreak;\n\ncase 2048:\nif (d3e566861da == 224 || d3e566861da == 256)\nrbb7a0566ac = 0;\nbreak;\ndefault:\nbreak;\n}\nreturn rbb7a0566ac;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_115",
        "query_text": "SUMMARY: This function performs a self-test of AES encryption (and, if enabled, decryption) in cipher block chaining (CBC) mode using predetermined test vectors. It has no input parameters (void) and returns a 32\u2010bit integer status code (wc_test_ret_t, defined as int). Internally, it initializes AES context structures (either allocated on the heap or on the stack, depending on compile-time flags), sets up encryption (and decryption) keys along with an initialization vector, processes a fixed message by encrypting it, and verifies that the resulting ciphertext matches an expected value. Where decryption is enabled, it decrypts the ciphertext back to plaintext and confirms that it matches the original message. The function cleans up the AES contexts and returns a status code to indicate success or failure of the test.",
        "code_id": "c_group_2_id_115",
        "code_text": "w12711613f7 ac1b4067b3d(void)\n{\nw12711613f7 rbb7a0566ac = 0;\n#ifdef HAVE_AES_CBC\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\nAes *enc = NULL;\n#else\nAes enc[1];\n#endif\nbyte cipher[WC_AES_BLOCK_SIZE];\n#ifdef HAVE_AES_DECRYPT\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\nAes *dec = NULL;\n#else\nAes dec[1];\n#endif\nbyte plain[WC_AES_BLOCK_SIZE];\n#endif\n\nWOLFSSL_SMALL_STACK_STATIC const byte msg[] = {\n0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,\n0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a\n};\nWOLFSSL_SMALL_STACK_STATIC const byte verify[] =\n{\n0x4f,0x02,0x1d,0xb2,0x43,0xbc,0x63,0x3d,\n0x71,0x78,0x18,0x3a,0x9f,0xa0,0x71,0xe8\n};\nWOLFSSL_SMALL_STACK_STATIC const byte key[] = {\n0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52,\n0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5,\n0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b\n};\nWOLFSSL_SMALL_STACK_STATIC const byte iv[]  = {\n0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,\n0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F\n};\nWOLFSSL_ENTER(\"aes192_test\");\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\nenc = wc_AesNew(HEAP_HINT, devId, &ret);\nif (enc == NULL)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\ndec = wc_AesNew(HEAP_HINT, devId, &ret);\nif (dec == NULL)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\n#else\nXMEMSET(enc, 0, sizeof(Aes));\n#ifdef HAVE_AES_DECRYPT\nXMEMSET(dec, 0, sizeof(Aes));\n#endif\nret = wc_AesInit(enc, HEAP_HINT, devId);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\nret = wc_AesInit(dec, HEAP_HINT, devId);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\n#endif \nret = wc_AesSetKey(enc, key, (int) sizeof(key), iv, AES_ENCRYPTION);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\nret = wc_AesSetKey(dec, key, (int) sizeof(key), iv, AES_DECRYPTION);\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\nXMEMSET(cipher, 0, WC_AES_BLOCK_SIZE);\nret = wc_AesCbcEncrypt(enc, cipher, msg, (int) sizeof(msg));\n#if defined(WOLFSSL_ASYNC_CRYPT)\nret = wc_AsyncWait(ret, &enc->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\nif (XMEMCMP(cipher, verify, (int) sizeof(cipher)))\nERROR_OUT(WC_TEST_RET_ENC_NC, out);\n#ifdef HAVE_AES_DECRYPT\nXMEMSET(plain, 0, WC_AES_BLOCK_SIZE);\nret = wc_AesCbcDecrypt(dec, plain, cipher, (int) sizeof(cipher));\n#if defined(WOLFSSL_ASYNC_CRYPT)\nret = wc_AsyncWait(ret, &dec->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\nif (ret != 0)\nERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\nif (XMEMCMP(plain, msg, (int) sizeof(plain))) {\nWOLFSSL_MSG(\"failed wc_AesCbcDecrypt plain-msg compare\");\nERROR_OUT(WC_TEST_RET_ENC_NC, out);\n}\n#endif\nout:\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\nwc_AesDelete(enc, &enc);\n#else\nwc_AesFree(enc);\n#endif\n#ifdef HAVE_AES_DECRYPT\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\nwc_AesDelete(dec, &dec);\n#else\nwc_AesFree(dec);\n#endif\n#endif\n#endif \nreturn rbb7a0566ac;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_116",
        "query_text": "SUMMARY: This function accepts an input of type int32_t representing a Unicode code point and returns an int32_t output representing its lowercase equivalent. It evaluates the input against multiple code point ranges corresponding to uppercase letters and, based on the range, applies specific arithmetic or bitwise transformations to convert the uppercase code point to its lowercase form. For inputs that do not fall within these typical ranges, it handles several exceptional cases using an explicit mapping to produce the appropriate lowercase value.",
        "code_id": "c_group_2_id_116",
        "code_text": "u465933263d ud2ac3652ce(u465933263d c6eeb468730)\n{\nif (((0x0041 <= c6eeb468730) && (0x005a >= c6eeb468730)) ||\n((0x00c0 <= c6eeb468730) && (0x00d6 >= c6eeb468730)) ||\n((0x00d8 <= c6eeb468730) && (0x00de >= c6eeb468730)) ||\n((0x0391 <= c6eeb468730) && (0x03a1 >= c6eeb468730)) ||\n((0x03a3 <= c6eeb468730) && (0x03ab >= c6eeb468730))) {\nc6eeb468730 += 32;\n} else if (((0x0100 <= c6eeb468730) && (0x012f >= c6eeb468730)) ||\n((0x0132 <= c6eeb468730) && (0x0137 >= c6eeb468730)) ||\n((0x014a <= c6eeb468730) && (0x0177 >= c6eeb468730)) ||\n((0x0182 <= c6eeb468730) && (0x0185 >= c6eeb468730)) ||\n((0x01a0 <= c6eeb468730) && (0x01a5 >= c6eeb468730)) ||\n((0x01de <= c6eeb468730) && (0x01ef >= c6eeb468730)) ||\n((0x01f8 <= c6eeb468730) && (0x021f >= c6eeb468730)) ||\n((0x0222 <= c6eeb468730) && (0x0233 >= c6eeb468730)) ||\n((0x0246 <= c6eeb468730) && (0x024f >= c6eeb468730)) ||\n((0x03d8 <= c6eeb468730) && (0x03ef >= c6eeb468730))) {\nc6eeb468730 |= 0x1;\n} else if (((0x0139 <= c6eeb468730) && (0x0148 >= c6eeb468730)) ||\n((0x0179 <= c6eeb468730) && (0x017e >= c6eeb468730)) ||\n((0x01af <= c6eeb468730) && (0x01b0 >= c6eeb468730)) ||\n((0x01b3 <= c6eeb468730) && (0x01b6 >= c6eeb468730)) ||\n((0x01cd <= c6eeb468730) && (0x01dc >= c6eeb468730))) {\nc6eeb468730 += 1;\nc6eeb468730 &= ~0x1;\n} else {\nswitch (c6eeb468730) {\ndefault: break;\ncase 0x0178: c6eeb468730 = 0x00ff; break;\ncase 0x0243: c6eeb468730 = 0x0180; break;\ncase 0x018e: c6eeb468730 = 0x01dd; break;\ncase 0x023d: c6eeb468730 = 0x019a; break;\ncase 0x0220: c6eeb468730 = 0x019e; break;\ncase 0x01b7: c6eeb468730 = 0x0292; break;\ncase 0x01c4: c6eeb468730 = 0x01c6; break;\ncase 0x01c7: c6eeb468730 = 0x01c9; break;\ncase 0x01ca: c6eeb468730 = 0x01cc; break;\ncase 0x01f1: c6eeb468730 = 0x01f3; break;\ncase 0x01f7: c6eeb468730 = 0x01bf; break;\ncase 0x0187: c6eeb468730 = 0x0188; break;\ncase 0x018b: c6eeb468730 = 0x018c; break;\ncase 0x0191: c6eeb468730 = 0x0192; break;\ncase 0x0198: c6eeb468730 = 0x0199; break;\ncase 0x01a7: c6eeb468730 = 0x01a8; break;\ncase 0x01ac: c6eeb468730 = 0x01ad; break;\ncase 0x01af: c6eeb468730 = 0x01b0; break;\ncase 0x01b8: c6eeb468730 = 0x01b9; break;\ncase 0x01bc: c6eeb468730 = 0x01bd; break;\ncase 0x01f4: c6eeb468730 = 0x01f5; break;\ncase 0x023b: c6eeb468730 = 0x023c; break;\ncase 0x0241: c6eeb468730 = 0x0242; break;\ncase 0x03fd: c6eeb468730 = 0x037b; break;\ncase 0x03fe: c6eeb468730 = 0x037c; break;\ncase 0x03ff: c6eeb468730 = 0x037d; break;\ncase 0x037f: c6eeb468730 = 0x03f3; break;\ncase 0x0386: c6eeb468730 = 0x03ac; break;\ncase 0x0388: c6eeb468730 = 0x03ad; break;\ncase 0x0389: c6eeb468730 = 0x03ae; break;\ncase 0x038a: c6eeb468730 = 0x03af; break;\ncase 0x038c: c6eeb468730 = 0x03cc; break;\ncase 0x038e: c6eeb468730 = 0x03cd; break;\ncase 0x038f: c6eeb468730 = 0x03ce; break;\ncase 0x0370: c6eeb468730 = 0x0371; break;\ncase 0x0372: c6eeb468730 = 0x0373; break;\ncase 0x0376: c6eeb468730 = 0x0377; break;\ncase 0x03f4: c6eeb468730 = 0x03d1; break;\ncase 0x03cf: c6eeb468730 = 0x03d7; break;\ncase 0x03f9: c6eeb468730 = 0x03f2; break;\ncase 0x03f7: c6eeb468730 = 0x03f8; break;\ncase 0x03fa: c6eeb468730 = 0x03fb; break;\n};\n}\nreturn c6eeb468730;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_117",
        "query_text": "SUMMARY: This function accepts a 32-bit signed integer (utf8_int32_t) representing a Unicode code point and returns another 32-bit signed integer (utf8_int32_t) corresponding to its uppercase equivalent. It determines whether the input is within particular ranges that follow systematic uppercase transformations\u2014either by subtracting a constant value or by altering specific bits\u2014to perform the conversion efficiently. If the input does not fall into these ranges, the function applies an explicit mapping via a switch statement to convert individual code points to their uppercase forms.",
        "code_id": "c_group_2_id_117",
        "code_text": "u465933263d u8b18c9d789(u465933263d c6eeb468730)\n{\nif (((0x0061 <= c6eeb468730) && (0x007a >= c6eeb468730)) ||\n((0x00e0 <= c6eeb468730) && (0x00f6 >= c6eeb468730)) ||\n((0x00f8 <= c6eeb468730) && (0x00fe >= c6eeb468730)) ||\n((0x03b1 <= c6eeb468730) && (0x03c1 >= c6eeb468730)) ||\n((0x03c3 <= c6eeb468730) && (0x03cb >= c6eeb468730))) {\nc6eeb468730 -= 32;\n} else if (((0x0100 <= c6eeb468730) && (0x012f >= c6eeb468730)) ||\n((0x0132 <= c6eeb468730) && (0x0137 >= c6eeb468730)) ||\n((0x014a <= c6eeb468730) && (0x0177 >= c6eeb468730)) ||\n((0x0182 <= c6eeb468730) && (0x0185 >= c6eeb468730)) ||\n((0x01a0 <= c6eeb468730) && (0x01a5 >= c6eeb468730)) ||\n((0x01de <= c6eeb468730) && (0x01ef >= c6eeb468730)) ||\n((0x01f8 <= c6eeb468730) && (0x021f >= c6eeb468730)) ||\n((0x0222 <= c6eeb468730) && (0x0233 >= c6eeb468730)) ||\n((0x0246 <= c6eeb468730) && (0x024f >= c6eeb468730)) ||\n((0x03d8 <= c6eeb468730) && (0x03ef >= c6eeb468730))) {\nc6eeb468730 &= ~0x1;\n} else if (((0x0139 <= c6eeb468730) && (0x0148 >= c6eeb468730)) ||\n((0x0179 <= c6eeb468730) && (0x017e >= c6eeb468730)) ||\n((0x01af <= c6eeb468730) && (0x01b0 >= c6eeb468730)) ||\n((0x01b3 <= c6eeb468730) && (0x01b6 >= c6eeb468730)) ||\n((0x01cd <= c6eeb468730) && (0x01dc >= c6eeb468730))) {\nc6eeb468730 -= 1;\nc6eeb468730 |= 0x1;\n} else {\nswitch (c6eeb468730) {\ndefault: break;\ncase 0x00ff: c6eeb468730 = 0x0178; break;\ncase 0x0180: c6eeb468730 = 0x0243; break;\ncase 0x01dd: c6eeb468730 = 0x018e; break;\ncase 0x019a: c6eeb468730 = 0x023d; break;\ncase 0x019e: c6eeb468730 = 0x0220; break;\ncase 0x0292: c6eeb468730 = 0x01b7; break;\ncase 0x01c6: c6eeb468730 = 0x01c4; break;\ncase 0x01c9: c6eeb468730 = 0x01c7; break;\ncase 0x01cc: c6eeb468730 = 0x01ca; break;\ncase 0x01f3: c6eeb468730 = 0x01f1; break;\ncase 0x01bf: c6eeb468730 = 0x01f7; break;\ncase 0x0188: c6eeb468730 = 0x0187; break;\ncase 0x018c: c6eeb468730 = 0x018b; break;\ncase 0x0192: c6eeb468730 = 0x0191; break;\ncase 0x0199: c6eeb468730 = 0x0198; break;\ncase 0x01a8: c6eeb468730 = 0x01a7; break;\ncase 0x01ad: c6eeb468730 = 0x01ac; break;\ncase 0x01b0: c6eeb468730 = 0x01af; break;\ncase 0x01b9: c6eeb468730 = 0x01b8; break;\ncase 0x01bd: c6eeb468730 = 0x01bc; break;\ncase 0x01f5: c6eeb468730 = 0x01f4; break;\ncase 0x023c: c6eeb468730 = 0x023b; break;\ncase 0x0242: c6eeb468730 = 0x0241; break;\ncase 0x037b: c6eeb468730 = 0x03fd; break;\ncase 0x037c: c6eeb468730 = 0x03fe; break;\ncase 0x037d: c6eeb468730 = 0x03ff; break;\ncase 0x03f3: c6eeb468730 = 0x037f; break;\ncase 0x03ac: c6eeb468730 = 0x0386; break;\ncase 0x03ad: c6eeb468730 = 0x0388; break;\ncase 0x03ae: c6eeb468730 = 0x0389; break;\ncase 0x03af: c6eeb468730 = 0x038a; break;\ncase 0x03cc: c6eeb468730 = 0x038c; break;\ncase 0x03cd: c6eeb468730 = 0x038e; break;\ncase 0x03ce: c6eeb468730 = 0x038f; break;\ncase 0x0371: c6eeb468730 = 0x0370; break;\ncase 0x0373: c6eeb468730 = 0x0372; break;\ncase 0x0377: c6eeb468730 = 0x0376; break;\ncase 0x03d1: c6eeb468730 = 0x03f4; break;\ncase 0x03d7: c6eeb468730 = 0x03cf; break;\ncase 0x03f2: c6eeb468730 = 0x03f9; break;\ncase 0x03f8: c6eeb468730 = 0x03f7; break;\ncase 0x03fb: c6eeb468730 = 0x03fa; break;\n};\n}\nreturn c6eeb468730;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_118",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a pointer to a conversion context structure (of type f_conv_context_t), a pointer to a constant character array (const char*), and a size value (size_t). It verifies that the accessible buffer space in the conversion context is sufficient (when allowing space for a trailing null character) to hold the specified number of characters. If the available space is insufficient, it returns an integer error code (-1). Otherwise, it copies the specified number of characters from the provided character array into the buffer within the conversion context, advances the buffer pointer accordingly, and reduces the remaining available space by that length. It then appends a null terminator to mark the end of the string and returns the number of characters copied as an integer.",
        "code_id": "c_group_2_id_118",
        "code_text": "int f6f1abf8f9f(f6dc586d4b9 *cf92b2083fa, const char *s09b181202d, size_t s6c4a1d2d38)\n{\nif (cf92b2083fa->r3a09e3411f + 1 < s6c4a1d2d38)\nreturn -1;\nmemcpy(cf92b2083fa->uf19559727f.ba69193d982, s09b181202d, s6c4a1d2d38);\ncf92b2083fa->uf19559727f.ba69193d982 += s6c4a1d2d38;\ncf92b2083fa->r3a09e3411f -= s6c4a1d2d38;\n*cf92b2083fa->uf19559727f.ba69193d982 = '\\0'; \nreturn s6c4a1d2d38;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_119",
        "query_text": "SUMMARY: This function accepts an input of type pointer to f_string_buffer_t and returns an output of type void*. It first verifies that the provided pointer is not NULL and then retrieves and returns the underlying data from the structure's union field.",
        "code_id": "c_group_2_id_119",
        "code_text": "void *b9a5b9cf69e(f717dd299a7 *bf39cacaa68)\n{\na48e077d7f7(bf39cacaa68);\nreturn bf39cacaa68->s09b181202d.d4e0653e6bc;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_120",
        "query_text": "SUMMARY: This function takes as input a constant pointer to a structure of type f_string_buffer_t and returns a size_t value. Its main functionality is to retrieve and output the raw capacity information stored within the structure without performing any additional computations.",
        "code_id": "c_group_2_id_120",
        "code_text": "size_t s78257668af(const f717dd299a7 *bf39cacaa68)\n{\nreturn bf39cacaa68->deaae3c770c;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_121",
        "query_text": "SUMMARY: This function accepts a constant pointer to a f_string_buffer_t structure and returns a size_t value. It verifies the validity of the input pointer and then determines a width capacity based on the contained string type. For a character buffer, it returns the total data size directly; for a wide-character buffer, it returns the data size divided by the size of a wide character; and for a UTF8 buffer, it returns the data size divided by 4. If an unsupported type is encountered, the function triggers a runtime assertion failure.",
        "code_id": "c_group_2_id_121",
        "code_text": "size_t sccd39a77d1(const f717dd299a7 *bf39cacaa68)\n{\na48e077d7f7(bf39cacaa68);\nswitch (bf39cacaa68->t0e2e36c884) {\ncase C803da6f84b:\nreturn bf39cacaa68->deaae3c770c;\n#ifdef F487d8ad294\ncase Wd3bd569834:\nreturn bf39cacaa68->deaae3c770c / sizeof(wchar_t);\n#endif\n#ifdef F246fa6497c\ncase Ucc0ebc17a3:\nreturn bf39cacaa68->deaae3c770c / 4;\n#endif\ndefault:\na48e077d7f7(0);\nreturn 0;\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_122",
        "query_text": "SUMMARY: This function accepts as inputs a pointer to a conversion context structure (f_conv_context_t*), a pointer to a constant wide-character string (const wchar_t*), and a size value (size_t) representing the length of the string. Its output is an integer (int). The function begins by verifying that the available capacity in the context is sufficient to accommodate the input string (plus a terminating null wide-character). If the capacity is insufficient, it returns -1. Otherwise, it calculates the byte length required for the string (as the product of its length and the size of a wide character), copies that many bytes from the input wide-character string to the buffer described in the context, advances the internal buffer pointer by the number of bytes copied, and reduces the available capacity accordingly. Finally, it appends a terminating wide-character null to the buffer and returns the original length.",
        "code_id": "c_group_2_id_122",
        "code_text": "int f1f8b6dd850(f6dc586d4b9 *cf92b2083fa, const wchar_t *s09b181202d, size_t s6c4a1d2d38)\n{\nif (cf92b2083fa->r3a09e3411f + 1 < s6c4a1d2d38)\nreturn -1;\nsize_t re355bb44af = s6c4a1d2d38 * sizeof(wchar_t);\nmemcpy(cf92b2083fa->uf19559727f.ba69193d982, s09b181202d, re355bb44af);\ncf92b2083fa->uf19559727f.ba69193d982 += re355bb44af;\ncf92b2083fa->r3a09e3411f -= re355bb44af;\n\nwchar_t e6e31ab8225 = L'\\0';\nmemcpy(cf92b2083fa->uf19559727f.ba69193d982, &e6e31ab8225, sizeof(wchar_t));\nreturn s6c4a1d2d38;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_123",
        "query_text": "SUMMARY: This function accepts an integer of type utf8_int32_t (an alias for int32_t) and returns a value of type size_t. Its purpose is to determine the number of bytes required to represent a UTF-8 encoded code point. It does so by examining the bit-pattern of the provided code point and deciding whether it fits within 1, 2, 3, or 4 bytes based on predefined bit-mask thresholds.",
        "code_id": "c_group_2_id_123",
        "code_text": "size_t uc0c17d6b47(u465933263d c0067ce8059)\n{\nif (0 == ((u465933263d)0xffffff80 & c0067ce8059)) {\nreturn 1;\n} else if (0 == ((u465933263d)0xfffff800 & c0067ce8059)) {\nreturn 2;\n} else if (0 == ((u465933263d)0xffff0000 & c0067ce8059)) {\nreturn 3;\n} else { \nreturn 4;\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_124",
        "query_text": "SUMMARY: This function accepts an input variable of type f_string_buffer_t* and returns an int. It first validates that the input pointer and the embedded data pointer (of type void* inside a union) are not null. Then, based on the input\u2019s enum type value (of type enum f_string_type), it checks whether the data pointer is properly aligned when necessary. Specifically, for the wide character buffer type (when available), it verifies that the pointer's address is aligned to the size of a wide character; for the standard and UTF8 character buffer types, it simply returns a positive result.",
        "code_id": "c_group_2_id_124",
        "code_text": "int b1eaf541ca2(f717dd299a7 *bf39cacaa68)\n{\na48e077d7f7(bf39cacaa68);\na48e077d7f7(bf39cacaa68->s09b181202d.d4e0653e6bc);\nswitch (bf39cacaa68->t0e2e36c884) {\ncase C803da6f84b:\nreturn 1;\n#ifdef F487d8ad294\ncase Wd3bd569834:\nreturn (((uintptr_t)bf39cacaa68->s09b181202d.d4e0653e6bc) & (sizeof(wchar_t) - 1)) == 0;\n#endif\n#ifdef F246fa6497c\ncase Ucc0ebc17a3:\nreturn 1;\n#endif\ndefault:\na48e077d7f7(0);\nreturn 0;\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_125",
        "query_text": "SUMMARY: The function accepts three inputs\u2014a pointer to a conversion context structure (f_conv_context_t *), and two constant void pointers representing the start and end of a raw byte sequence. It computes the length of this sequence and, after verifying that the available space (inclusive of an extra byte for termination) in the context\u2019s internal character buffer is sufficient, copies the raw byte sequence into that buffer, updates the buffer\u2019s pointer and remaining available space, appends a null terminator at the new end, and returns the number of bytes copied as an integer. If there is insufficient space, it returns -1.",
        "code_id": "c_group_2_id_125",
        "code_text": "int ff893f7761f(f6dc586d4b9 *cf92b2083fa, const void *b4d0b335300, const void *ea5fdc4f5a4)\n{\nconst char *b2f07a38d74 = (const char *)b4d0b335300;\nconst char *efd86a9bb43 = (const char *)ea5fdc4f5a4;\nsize_t re355bb44af = efd86a9bb43 - b2f07a38d74;\nif (cf92b2083fa->r3a09e3411f + 1 < re355bb44af)\nreturn -1;\nmemcpy(cf92b2083fa->uf19559727f.ba69193d982, b4d0b335300, re355bb44af);\ncf92b2083fa->uf19559727f.ba69193d982 += re355bb44af;\ncf92b2083fa->r3a09e3411f -= re355bb44af;\n*(cf92b2083fa->uf19559727f.ba69193d982) = '\\0'; \nreturn re355bb44af; \n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_126",
        "query_text": "SUMMARY: This function takes an input of type utf8_int32_t (a 32-bit integer) representing a Unicode code point and returns an integer indicating the display width. It first checks whether the code point is zero and returns 0 in that case. If the code point is less than a specified threshold (0x1100), it returns 1. It then examines whether the code point falls within specific ranges for fullwidth characters\u2014returning 2 if so\u2014and likewise tests a number of ranges commonly associated with wide characters, also returning 2 for matches. If none of these conditions apply, it defaults to returning 1.",
        "code_id": "c_group_2_id_126",
        "code_text": "int ub8d01ab71b(u465933263d cdcd5d1f3d2)\n{\n\nif (cdcd5d1f3d2 == 0)\nreturn 0;\nif (cdcd5d1f3d2 < 0x1100)\nreturn 1;\n\nif ((0x3000 == cdcd5d1f3d2) ||\n(0xFF01 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xFF60) ||\n(0xFFE0 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xFFE6)) {\nreturn 2;\n}\n\nif ((0x1100 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x115F) ||\n(0x11A3 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x11A7) ||\n(0x11FA <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x11FF) ||\n(0x2329 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x232A) ||\n(0x2E80 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x2E99) ||\n(0x2E9B <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x2EF3) ||\n(0x2F00 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x2FD5) ||\n(0x2FF0 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x2FFB) ||\n(0x3001 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x303E) ||\n(0x3041 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x3096) ||\n(0x3099 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x30FF) ||\n(0x3105 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x312D) ||\n(0x3131 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x318E) ||\n(0x3190 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x31BA) ||\n(0x31C0 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x31E3) ||\n(0x31F0 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x321E) ||\n(0x3220 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x3247) ||\n(0x3250 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x32FE) ||\n(0x3300 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x4DBF) ||\n(0x4E00 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xA48C) ||\n(0xA490 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xA4C6) ||\n(0xA960 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xA97C) ||\n(0xAC00 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xD7A3) ||\n(0xD7B0 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xD7C6) ||\n(0xD7CB <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xD7FB) ||\n(0xF900 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xFAFF) ||\n(0xFE10 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xFE19) ||\n(0xFE30 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xFE52) ||\n(0xFE54 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xFE66) ||\n(0xFE68 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0xFE6B) ||\n(0x1B000 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x1B001) ||\n(0x1F200 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x1F202) ||\n(0x1F210 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x1F23A) ||\n(0x1F240 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x1F248) ||\n(0x1F250 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x1F251) ||\n(0x20000 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x2F73F) ||\n(0x2B740 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x2FFFD) ||\n(0x30000 <= cdcd5d1f3d2 && cdcd5d1f3d2 <= 0x3FFFD)) {\nreturn 2;\n}\nreturn 1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_127",
        "query_text": "SUMMARY: This function accepts a pointer to a structure (of type CC_Rbuf, defined as ring_buffer) and returns a boolean value. Its purpose is to determine whether the ring buffer is empty by checking if the size field within the structure is zero, returning true when empty and false when not.",
        "code_id": "c_group_2_id_127",
        "code_text": "b145899eaed c864636b54d(C4e615b5f19 *rc177fa67bc)\n{\nreturn (rc177fa67bc->s501f3ce221 == 0);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_128",
        "query_text": "SUMMARY: This function accepts two inputs: a pointer to a structure (of type CC_Rbuf*) that represents a ring buffer, and an integer that specifies an index. It returns a value of type uint64_t by directly accessing the element located at the provided index within the internal buffer array of the structure.",
        "code_id": "c_group_2_id_128",
        "code_text": "uint64_t c1cb9fc4aa5(C4e615b5f19 *rc177fa67bc, int iddd88d7d03)\n{\nreturn rc177fa67bc->ba69193d982[iddd88d7d03];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_129",
        "query_text": "SUMMARY: The function accepts a pointer to a ring-buffer structure (of type CC_Rbuf*) and returns an unsigned integer (of type size_t) representing the current size value stored within the structure.",
        "code_id": "c_group_2_id_129",
        "code_text": "size_t c65adc0b3f0(C4e615b5f19 *rc177fa67bc)\n{\nreturn rc177fa67bc->s501f3ce221;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_130",
        "query_text": "SUMMARY: This function takes as input a pointer to a structure (of type CC_RbufConf) and initializes its members. It sets a capacity field to a default value (of type size_t) and assigns three function pointer fields to standard dynamic memory allocation functions (of types that take size_t parameters and return void pointers, or take void pointers respectively). The function returns no value (void).",
        "code_id": "c_group_2_id_130",
        "code_text": "void c0bdb846900(C300a138648 *re5e83aebf2)\n{\nre5e83aebf2->c93f5db6e7f = D4f94c8cfe6;\nre5e83aebf2->mab9d89ee7a = malloc;\nre5e83aebf2->m7c32b7100b = calloc;\nre5e83aebf2->m2ed0e27fbb = free;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_131",
        "query_text": "SUMMARY: The function accepts two inputs\u2014a pointer to a structure representing a ring buffer (CC_Rbuf) and a 64-bit unsigned integer (uint64_t). It enqueues the provided 64-bit value into the ring buffer by storing the value at the current head position, advancing the head pointer circularly within the buffer's capacity, and, if necessary, incrementing the tail position to maintain the proper data ordering when the buffer is full. Additionally, it updates the current element count of the ring buffer (without exceeding its capacity). The function does not produce any output (void).",
        "code_id": "c_group_2_id_131",
        "code_text": "void c4fd301ce6f(C4e615b5f19 *rc177fa67bc, uint64_t i1d616a31c4)\n{\nif (rc177fa67bc->h11ef466a8d == rc177fa67bc->tf2f1e364fa)\nrc177fa67bc->tf2f1e364fa = (rc177fa67bc->tf2f1e364fa + 1) % rc177fa67bc->c93f5db6e7f;\nrc177fa67bc->ba69193d982[rc177fa67bc->h11ef466a8d] = i1d616a31c4;\nrc177fa67bc->h11ef466a8d = (rc177fa67bc->h11ef466a8d + 1) % rc177fa67bc->c93f5db6e7f;\nif (rc177fa67bc->s501f3ce221 < rc177fa67bc->c93f5db6e7f)\n++rc177fa67bc->s501f3ce221;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_132",
        "query_text": "SUMMARY: The function accepts a pointer to a CC_Rbuf structure (i.e., an object of type struct ring_buffer) as its input and returns nothing (void). It frees the memory resources associated with the ring buffer by first invoking the memory deallocation callback to release the buffer (an array of uint64_t) and then calling the same deallocation function to release the ring buffer structure itself.",
        "code_id": "c_group_2_id_132",
        "code_text": "void c5657db0de3(C4e615b5f19 *rc177fa67bc)\n{\nrc177fa67bc->m2ed0e27fbb(rc177fa67bc->ba69193d982);\nrc177fa67bc->m2ed0e27fbb(rc177fa67bc);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_133",
        "query_text": "SUMMARY: The function accepts two inputs of type \"const void *\" that refer to objects of type \"struct Point\" (with integer fields for coordinates) and returns an \"int\". It compares the two provided Point objects by evaluating whether both of their corresponding coordinate values are equal. If both coordinates in each Point match, the function outputs 0; otherwise, it outputs 1.",
        "code_id": "c_group_2_id_133",
        "code_text": "int p6594b65d7f(const void *kb54d2b9b87, const void *k343b3f5d86)\n{\nstruct P29b3cb15a9 pd4bbc6d2db = *((struct P29b3cb15a9*) kb54d2b9b87);\nstruct P29b3cb15a9 p1f5e5c75f3 = *((struct P29b3cb15a9*) k343b3f5d86);\nreturn !(pd4bbc6d2db.xf1fa84c2ec == p1f5e5c75f3.xf1fa84c2ec && pd4bbc6d2db.y92bd0bf197 == p1f5e5c75f3.y92bd0bf197);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_134",
        "query_text": "SUMMARY: This function accepts three inputs: a reference to an output stream (std::ostream&), a pointer to an encoding function (EncodingFn, defined as void(*)(std::ostream&, int)), and an integer representing a Unicode code point (int). It determines whether the integer exceeds or equals 0x10000. If it does, the function computes two surrogate code unit values corresponding to the high and low parts of the UTF-16 representation of the Unicode code point, calls the encoding function to output these two surrogate integers to the provided output stream, and returns a boolean true. If the integer is below 0x10000, it returns false without processing further.",
        "code_id": "c_group_2_id_134",
        "code_text": "bool Sd69e5c9019(std::ostream& s25aca4d22e, E80c294e7c5 e1f4c299c3e, int c339952909c) {\nint b237531f9d8 = c339952909c - 0x10000;\nif (b237531f9d8 < 0) {\nreturn false;\n}\nint ha2e5d0ff50 = 0xD800 | (b237531f9d8 >> 10);\nint l345f6226db = 0xDC00 | (b237531f9d8 & 0x3FF);\ne1f4c299c3e(s25aca4d22e, ha2e5d0ff50);\ne1f4c299c3e(s25aca4d22e, l345f6226db);\nreturn true;\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_135",
        "query_text": "SUMMARY: This function takes a 3-element floating-point vector (vec3) representing Euler angles and computes a 4-element floating-point vector (versor) representing a quaternion. It calculates the half-angle sine and cosine values for each of the Euler angles\u2014negating the sine for the third angle to account for a left-handed coordinate system\u2014and then combines these trigonometric results to derive the quaternion components.",
        "code_id": "c_group_2_id_135",
        "code_text": "Cd4e3208291\nvoid\ngc762ae0794(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad =  sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa =  sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = -sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] = z1a2745c1a8 * xa08976ecad * ydfce0dcdee - z8de8afe2d4 * x1dce3a8271 * ye938664caa;\nd9748d673c4[1] = z1a2745c1a8 * x1dce3a8271 * ye938664caa + z8de8afe2d4 * xa08976ecad * ydfce0dcdee;\nd9748d673c4[2] = z1a2745c1a8 * xa08976ecad * ye938664caa + z8de8afe2d4 * x1dce3a8271 * ydfce0dcdee;\nd9748d673c4[3] = z1a2745c1a8 * x1dce3a8271 * ydfce0dcdee - z8de8afe2d4 * xa08976ecad * ye938664caa;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_136",
        "query_text": "SUMMARY: This function takes as input a three-element array of floats (vec3) that represent Euler angles and computes a four-element array of floats (versor) representing a quaternion. It converts the Euler angle representation into a quaternion form by calculating the sine and cosine of half-angles for rotations about the three axes in an XYZ order under a left-handed coordinate system, thus encapsulating the 3D rotation in a concise quaternion format.",
        "code_id": "c_group_2_id_136",
        "code_text": "Cd4e3208291\nvoid\ngd3a622b8d3(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad =  sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa =  sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = -sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] = x1dce3a8271 * ye938664caa * z8de8afe2d4 + xa08976ecad * ydfce0dcdee * z1a2745c1a8;\nd9748d673c4[1] = x1dce3a8271 * ye938664caa * z1a2745c1a8 - xa08976ecad * ydfce0dcdee * z8de8afe2d4;\nd9748d673c4[2] = x1dce3a8271 * ydfce0dcdee * z8de8afe2d4 + xa08976ecad * ye938664caa * z1a2745c1a8;\nd9748d673c4[3] = x1dce3a8271 * ydfce0dcdee * z1a2745c1a8 - xa08976ecad * ye938664caa * z8de8afe2d4;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_137",
        "query_text": "SUMMARY: This function transposes a matrix. It accepts an input of type mat4x2 (an array of 4 two-element float arrays representing a 4\u00d72 matrix) and produces an output of type mat2x4 (an array of 2 four-element float arrays representing a 2\u00d74 matrix). The function reorganizes the elements so that the elements of the first column of the input become the elements of the first row of the output, while the elements of the second column become the elements of the second row, thereby interchanging rows and columns.",
        "code_id": "c_group_2_id_137",
        "code_text": "Cd4e3208291\nvoid\ngd52e6c39f5(mab2cb9021e mb8bcb57dcd, md4c46ddc0d d9748d673c4) {\nd9748d673c4[0][0] = mb8bcb57dcd[0][0];\nd9748d673c4[0][1] = mb8bcb57dcd[1][0];\nd9748d673c4[0][2] = mb8bcb57dcd[2][0];\nd9748d673c4[0][3] = mb8bcb57dcd[3][0];\nd9748d673c4[1][0] = mb8bcb57dcd[0][1];\nd9748d673c4[1][1] = mb8bcb57dcd[1][1];\nd9748d673c4[1][2] = mb8bcb57dcd[2][1];\nd9748d673c4[1][3] = mb8bcb57dcd[3][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_138",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of type vec4 (a 4-element aligned array of floats). It performs an element-wise operation where it adds the corresponding values from the two input arrays and subtracts the result from the corresponding values in the output array, updating the output parameter with the computed differences.",
        "code_id": "c_group_2_id_138",
        "code_text": "Cd4e3208291\nvoid\nge29b5f1c56(v141258b569 ad90770d038, v141258b569 bba3ae37d1f, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_sub(\ng86f14e15d6(dest),\nwasm_f32x4_add(g86f14e15d6(a), g86f14e15d6(b))));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_sub_ps(g86f14e15d6(d9748d673c4),\n_mm_add_ps(g86f14e15d6(ad90770d038),\ng86f14e15d6(bba3ae37d1f))));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vsubq_f32(vld1q_f32(dest),\nvaddq_f32(vld1q_f32(a),\nvld1q_f32(b))));\n#else\ndest[0] -= a[0] + b[0];\ndest[1] -= a[1] + b[1];\ndest[2] -= a[2] + b[2];\ndest[3] -= a[3] + b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_139",
        "query_text": "SUMMARY: This function receives a 3-element array of floats as input and produces a 3-element array of floats as output. It computes the additive inverse of each element in the input array and stores the results in the output array.",
        "code_id": "c_group_2_id_139",
        "code_text": "Cd4e3208291\nvoid\ng8e68040358(veb444e7eb8 v91082a9365, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = -v91082a9365[0];\nd9748d673c4[1] = -v91082a9365[1];\nd9748d673c4[2] = -v91082a9365[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_140",
        "query_text": "SUMMARY: This function takes a constant pointer to a float (input type: const float *) and a 2x2 float matrix (output type: mat2, defined as an array of two vec2 where vec2 is an array of 2 floats) as parameters. It constructs the 2x2 matrix by sequentially copying four float values from the input array into the matrix, placing the first two floats into the first row and the next two floats into the second row.",
        "code_id": "c_group_2_id_140",
        "code_text": "Cd4e3208291\nvoid\ng963221e319(const float * __restrict sa425380d12, mde4d4e4936 d9748d673c4) {\nd9748d673c4[0][0] = sa425380d12[0];\nd9748d673c4[0][1] = sa425380d12[1];\nd9748d673c4[1][0] = sa425380d12[2];\nd9748d673c4[1][1] = sa425380d12[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_141",
        "query_text": "SUMMARY: The function takes two input parameters, each being a fixed-size array of 2 integers, and returns an integer. It computes a scalar value by multiplying the first element of the first input with the second element of the second input, then subtracting the product of the second element of the first input with the first element of the second input. This operation effectively calculates the determinant of a 2\u00d72 matrix formed by the input arrays.",
        "code_id": "c_group_2_id_141",
        "code_text": "Cd4e3208291\nint\ng8862aa5f15(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f) {\nreturn ad90770d038[0] * bba3ae37d1f[1] - ad90770d038[1] * bba3ae37d1f[0];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_142",
        "query_text": "SUMMARY: This function takes three parameters of type vec4 (each being a 4-element aligned array of floats). It computes the element-wise difference between the first two 4-element float arrays and then adds that difference to the elements of the third 4-element float array, effectively updating it so that for each index the new value becomes the original value plus the difference between the corresponding elements of the first and second arrays. Optimized implementations are used when available, but the core behavior is to perform dest[i] = dest[i] + (a[i] - b[i]) for all indices.",
        "code_id": "c_group_2_id_142",
        "code_text": "Cd4e3208291\nvoid\ng030814c53e(v141258b569 ad90770d038, v141258b569 bba3ae37d1f, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_add(\ng86f14e15d6(dest),\nwasm_f32x4_sub(g86f14e15d6(a), g86f14e15d6(b))));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_add_ps(g86f14e15d6(d9748d673c4),\n_mm_sub_ps(g86f14e15d6(ad90770d038),\ng86f14e15d6(bba3ae37d1f))));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vaddq_f32(vld1q_f32(dest),\nvsubq_f32(vld1q_f32(a),\nvld1q_f32(b))));\n#else\ndest[0] += a[0] - b[0];\ndest[1] += a[1] - b[1];\ndest[2] += a[2] - b[2];\ndest[3] += a[3] - b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_143",
        "query_text": "SUMMARY: This function performs component-wise multiplication of two 4-dimensional floating-point vectors. It accepts two inputs of type vec4 (an aligned array of four floats) and produces an output of the same type (vec4) by calculating the product of corresponding elements from the inputs. The function utilizes the available SIMD instruction set on the target platform (such as WebAssembly SIMD, SSE, or NEON) to efficiently compute these multiplications, and it defaults to scalar operations when SIMD is not available.",
        "code_id": "c_group_2_id_143",
        "code_text": "Cd4e3208291\nvoid\ng258a88dcb1(v141258b569 ad90770d038, v141258b569 bba3ae37d1f, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_mul(g86f14e15d6(a), g86f14e15d6(b)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_mul_ps(g86f14e15d6(ad90770d038), g86f14e15d6(bba3ae37d1f)));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vmulq_f32(vld1q_f32(a), vld1q_f32(b)));\n#else\ndest[0] = a[0] * b[0];\ndest[1] = a[1] * b[1];\ndest[2] = a[2] * b[2];\ndest[3] = a[3] * b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_144",
        "query_text": "SUMMARY: The function takes an input of type \"vec2\" (a two-element array of float values) and produces no explicit output but modifies the input in-place by setting both elements to 0.0f, effectively zeroing the 2D vector.",
        "code_id": "c_group_2_id_144",
        "code_text": "Cd4e3208291\nvoid\ngdc68842540(v0131f5a9ae v91082a9365) {\nv91082a9365[0] = v91082a9365[1] = 0.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_145",
        "query_text": "SUMMARY: This function takes two input parameters and one output parameter, all of which are arrays consisting of three integers (ivec3). It performs element-wise division of the first integer array by the second integer array and stores the resulting quotients into the output integer array.",
        "code_id": "c_group_2_id_145",
        "code_text": "Cd4e3208291\nvoid\nga14fcb0d9d(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] / bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] / bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] / bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_146",
        "query_text": "SUMMARY: This function takes as inputs an array of three integers (ivec3), an integer scalar (int), and another array of three integers (ivec3) as output. Its functionality is to update each element of the output array by adding the result of subtracting the scalar from the corresponding element of the input array.",
        "code_id": "c_group_2_id_146",
        "code_text": "Cd4e3208291\nvoid\ngc26a2e852b(i4b951f731e ad90770d038, int s3b9d266e2e, i4b951f731e d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] - s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] - s3b9d266e2e;\nd9748d673c4[2] += ad90770d038[2] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_147",
        "query_text": "SUMMARY: This function accepts two inputs: a 3\u00d73 matrix of floats (of type mat3, which is defined as an array of three vec3 arrays where each vec3 is an array of three floats) and a pointer to a FILE stream (of type FILE*). Its purpose is to format and print the matrix to the provided output stream. It first determines the appropriate field widths for each element, then prints the matrix with a header and formatted rows (including colorized output) to ensure proper alignment and visual clarity. The function does not return any value (void).",
        "code_id": "c_group_2_id_147",
        "code_text": "Cd4e3208291\nvoid\ng14991a8c3a(m63312228ee              ma09c4861bd,\nFILE * __restrict o5450e5c91d) {\nchar b99ab09a63e[16];\nint  i0c6e314cec, jbd3357c513, ce3a4cd4f8f[4], c00eff67c74;\n#define mb8bcb57dcd 3\n#define neb9157c168 3\nfprintf(o5450e5c91d, \"Matrix (float%dx%d): \" C45893ec2b2 \"\\n\", mb8bcb57dcd, neb9157c168);\nce3a4cd4f8f[0] = ce3a4cd4f8f[1] = ce3a4cd4f8f[2] = 0;\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++) {\nfor (jbd3357c513 = 0; jbd3357c513 < neb9157c168; jbd3357c513++) {\nif (ma09c4861bd[i0c6e314cec][jbd3357c513] < Cd0da13f7c8)\nc00eff67c74 = snprintf(b99ab09a63e, sizeof(b99ab09a63e), \"% .*f\", Cb46738fea8, (double)ma09c4861bd[i0c6e314cec][jbd3357c513]);\nelse\nc00eff67c74 = snprintf(b99ab09a63e, sizeof(b99ab09a63e), \"% g\", (double)ma09c4861bd[i0c6e314cec][jbd3357c513]);\nce3a4cd4f8f[i0c6e314cec] = Gce27a59f0b(ce3a4cd4f8f[i0c6e314cec], c00eff67c74);\n}\n}\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++) {\nfprintf(o5450e5c91d, \"  |\");\nfor (jbd3357c513 = 0; jbd3357c513 < neb9157c168; jbd3357c513++)\nif (ma09c4861bd[i0c6e314cec][jbd3357c513] < Cd0da13f7c8)\nfprintf(o5450e5c91d, \" % *.*f\", ce3a4cd4f8f[jbd3357c513], Cb46738fea8, (double)ma09c4861bd[jbd3357c513][i0c6e314cec]);\nelse\nfprintf(o5450e5c91d, \" % *g\", ce3a4cd4f8f[jbd3357c513], (double)ma09c4861bd[jbd3357c513][i0c6e314cec]);\nfprintf(o5450e5c91d, \"  |\\n\");\n}\nfprintf(o5450e5c91d, C7c34c62781 \"\\n\");\n#undef mb8bcb57dcd\n#undef neb9157c168\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_148",
        "query_text": "SUMMARY: This function accepts an input of type \"mat4\" (a 4x4 matrix of 4-element float vectors) and computes a single output of type \"float\". It operates by summing the three diagonal elements from the first, second, and third rows (i.e., the elements at positions [0][0], [1][1], and [2][2]) of the provided 4x4 matrix, and returns this sum.",
        "code_id": "c_group_2_id_148",
        "code_text": "Cd4e3208291\nfloat\ng5cd5aece60(m2979ecef6f mb8bcb57dcd) {\nreturn mb8bcb57dcd[0][0] + mb8bcb57dcd[1][1] + mb8bcb57dcd[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_149",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, each of type float[2]. It performs an element-wise multiply-subtraction operation by multiplying each corresponding pair of elements from the input parameters and subtracting the result from the corresponding element in the output parameter.",
        "code_id": "c_group_2_id_149",
        "code_text": "Cd4e3208291\nvoid\ng7a63c4a7d6(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] * bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_150",
        "query_text": "SUMMARY: This function accepts two inputs of type float[2] and produces an output of type float[2]. It computes the element-wise division of the two input arrays, dividing the first element of the first input by the first element of the second input and the second element of the first input by the second element of the second input, and stores the resulting values in the output array.",
        "code_id": "c_group_2_id_150",
        "code_text": "Cd4e3208291\nvoid\ng17148c52a6(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] / bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] / bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_151",
        "query_text": "SUMMARY: This function accepts two input arrays of type float[3] representing three-dimensional vectors and an output array of the same type. It computes the element-wise difference between the two input vectors and then adds each resulting value to the corresponding element in the output vector.",
        "code_id": "c_group_2_id_151",
        "code_text": "Cd4e3208291\nvoid\ng7ba5b95acd(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] - bba3ae37d1f[1];\nd9748d673c4[2] += ad90770d038[2] - bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_152",
        "query_text": "SUMMARY: This function operates on three parameters of type 2-element float arrays. It subtracts from each element of the output array the sum of the corresponding elements from the two input arrays, effectively updating the output vector by reducing each component by the combined values of the respective components from the inputs.",
        "code_id": "c_group_2_id_152",
        "code_text": "Cd4e3208291\nvoid\ngefb356b047(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] + bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_153",
        "query_text": "SUMMARY: This function copies a 4\u00d74 matrix (of type mat4, an array of four 4-element float vectors) from an input to an output. It leverages different hardware-specific SIMD instructions (such as those for WASM SIMD, AVX, SSE/SSE2, or NEON) to efficiently transfer each 4-element vector constituting a row of the 4\u00d74 matrix, ensuring that the output precisely replicates the input. In cases where none of these SIMD capabilities are available, it resorts to a generic copy routine to perform the same task.",
        "code_id": "c_group_2_id_153",
        "code_text": "Cd4e3208291\nvoid\ngeff5f99a25(m2979ecef6f ma02b861363, m2979ecef6f d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest[0], glmm_load(mat[0]));\ngc83e6cd198(dest[1], glmm_load(mat[1]));\ngc83e6cd198(dest[2], glmm_load(mat[2]));\ngc83e6cd198(dest[3], glmm_load(mat[3]));\n#elif defined(__AVX__)\nglmm_store256(dest[0], glmm_load256(mat[0]));\nglmm_store256(dest[2], glmm_load256(mat[2]));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4[0], glmm_load(ma02b861363[0]));\ngc83e6cd198(d9748d673c4[1], glmm_load(ma02b861363[1]));\ngc83e6cd198(d9748d673c4[2], glmm_load(ma02b861363[2]));\ngc83e6cd198(d9748d673c4[3], glmm_load(ma02b861363[3]));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest[0], vld1q_f32(mat[0]));\nvst1q_f32(dest[1], vld1q_f32(mat[1]));\nvst1q_f32(dest[2], vld1q_f32(mat[2]));\nvst1q_f32(dest[3], vld1q_f32(mat[3]));\n#else\nglm_mat4_ucopy(mat, dest);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_154",
        "query_text": "SUMMARY: This function takes two input parameters of type float[3] and computes their element-wise multiplication, producing an output parameter also of type float[3]. Specifically, it multiplies the first elements of the input arrays and stores the result as the first element in the output array, then does the same with the second and third elements respectively.",
        "code_id": "c_group_2_id_154",
        "code_text": "Cd4e3208291\nvoid\ng460693c8e7(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] * bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] * bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_155",
        "query_text": "SUMMARY: This function accepts a 2\u00d72 matrix (of type mat2, which is defined as an aligned array of two 2-element float vectors) and returns a float. It computes the sum of the elements from the top-left and bottom-right positions of the matrix, effectively calculating the trace of the matrix.",
        "code_id": "c_group_2_id_155",
        "code_text": "Cd4e3208291\nfloat\ngdd42a5c67f(mde4d4e4936 mb8bcb57dcd) {\nreturn mb8bcb57dcd[0][0] + mb8bcb57dcd[1][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_156",
        "query_text": "SUMMARY: This function takes an input consisting of an array of three integers, a scalar integer, and an output array of three integers. It updates each element of the output array by subtracting, from its current value, the difference between the corresponding element of the input array and the scalar.",
        "code_id": "c_group_2_id_156",
        "code_text": "Cd4e3208291\nvoid\ngb83aac5ac5(i4b951f731e ad90770d038, int s3b9d266e2e, i4b951f731e d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] - s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] - s3b9d266e2e;\nd9748d673c4[2] -= ad90770d038[2] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_157",
        "query_text": "SUMMARY: This function accepts two inputs of type vec2 (arrays of two floats representing complex numbers with the first element as the real component and the second as the imaginary component) and produces an output of type vec2. It performs complex multiplication by calculating the real part as the product of the real components minus the product of the imaginary components, and the imaginary part as the sum of the cross-products of the real and imaginary components. The final computed real and imaginary parts are stored in the output array.",
        "code_id": "c_group_2_id_157",
        "code_text": "Cd4e3208291\nvoid\ng8c59cf39e0(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nfloat t343c648f90, t8123e9feb8;\nt343c648f90 = ad90770d038[0] * bba3ae37d1f[0] - ad90770d038[1] * bba3ae37d1f[1];\nt8123e9feb8 = ad90770d038[0] * bba3ae37d1f[1] + ad90770d038[1] * bba3ae37d1f[0];\nd9748d673c4[0] = t343c648f90;\nd9748d673c4[1] = t8123e9feb8;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_158",
        "query_text": "SUMMARY: This function takes two input parameters and one output parameter, each of type \"int[3]\". It computes the element-wise product of the first two input arrays and adds each resulting product to the corresponding component of the output array.",
        "code_id": "c_group_2_id_158",
        "code_text": "Cd4e3208291\nvoid\ng114395e7da(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] * bba3ae37d1f[1];\nd9748d673c4[2] += ad90770d038[2] * bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_159",
        "query_text": "SUMMARY: This function accepts two input variables and one output variable, each being an array of four integers (ivec4). For each of the four integer positions, it computes the product of the corresponding integers from the two input arrays and then adds that product to the integer at the corresponding position in the output array.",
        "code_id": "c_group_2_id_159",
        "code_text": "Cd4e3208291\nvoid\ng6f085e6355(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] * bba3ae37d1f[1];\nd9748d673c4[2] += ad90770d038[2] * bba3ae37d1f[2];\nd9748d673c4[3] += ad90770d038[3] * bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_160",
        "query_text": "SUMMARY: This function computes the product of a 2\u00d73 matrix and a 3\u00d72 matrix, both consisting of float elements, and stores the result in a 3\u00d73 matrix also composed of float elements. It achieves this by, for each of the three rows in the 3\u00d72 input matrix, calculating three output values through two-element dot products with the two rows of the 2\u00d73 input matrix. The result is a 3\u00d73 matrix that encapsulates these computed dot products.",
        "code_id": "c_group_2_id_160",
        "code_text": "Cd4e3208291\nvoid\nga59166688f(mc11cae8baa m7f4f0cd2cb, m5fbc7d59b5 m71ae398200, m63312228ee d9748d673c4) {\nfloat a79034f70a3 = m7f4f0cd2cb[0][0], af8ba94e471 = m7f4f0cd2cb[0][1], ac122217995 = m7f4f0cd2cb[0][2],\na00a7244c30 = m7f4f0cd2cb[1][0], a90b743b58c = m7f4f0cd2cb[1][1], a2f9044642f = m7f4f0cd2cb[1][2],\nb24ae8206ee = m71ae398200[0][0], ba7a975e23f = m71ae398200[0][1],\nbd4c89897d0 = m71ae398200[1][0], b339ffe7279 = m71ae398200[1][1],\nb7cacabc345 = m71ae398200[2][0], b27ae3829e2 = m71ae398200[2][1];\nd9748d673c4[0][0] = a79034f70a3 * b24ae8206ee + a00a7244c30 * ba7a975e23f;\nd9748d673c4[0][1] = af8ba94e471 * b24ae8206ee + a90b743b58c * ba7a975e23f;\nd9748d673c4[0][2] = ac122217995 * b24ae8206ee + a2f9044642f * ba7a975e23f;\nd9748d673c4[1][0] = a79034f70a3 * bd4c89897d0 + a00a7244c30 * b339ffe7279;\nd9748d673c4[1][1] = af8ba94e471 * bd4c89897d0 + a90b743b58c * b339ffe7279;\nd9748d673c4[1][2] = ac122217995 * bd4c89897d0 + a2f9044642f * b339ffe7279;\nd9748d673c4[2][0] = a79034f70a3 * b7cacabc345 + a00a7244c30 * b27ae3829e2;\nd9748d673c4[2][1] = af8ba94e471 * b7cacabc345 + a90b743b58c * b27ae3829e2;\nd9748d673c4[2][2] = ac122217995 * b7cacabc345 + a2f9044642f * b27ae3829e2;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_161",
        "query_text": "SUMMARY: This function takes a source and a destination, each of type mat3x2 (an array of three vec2, where each vec2 is an array of two floats), and copies the entire 3x2 matrix from the source to the destination by directly assigning each corresponding floating-point element.",
        "code_id": "c_group_2_id_161",
        "code_text": "Cd4e3208291\nvoid\ng3ca1568237(m5fbc7d59b5 ma02b861363, m5fbc7d59b5 d9748d673c4) {\nd9748d673c4[0][0] = ma02b861363[0][0];\nd9748d673c4[0][1] = ma02b861363[0][1];\nd9748d673c4[1][0] = ma02b861363[1][0];\nd9748d673c4[1][1] = ma02b861363[1][1];\nd9748d673c4[2][0] = ma02b861363[2][0];\nd9748d673c4[2][1] = ma02b861363[2][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_162",
        "query_text": "SUMMARY: This function receives a 3\u00d73 matrix of floating-point numbers (type mat3) as input and computes a single floating-point value (type float) by summing the elements located on the matrix's main diagonal (the first element of the first row, the second element of the second row, and the third element of the third row).",
        "code_id": "c_group_2_id_162",
        "code_text": "Cd4e3208291\nfloat\ng07e45e1724(m63312228ee mb8bcb57dcd) {\nreturn mb8bcb57dcd[0][0] + mb8bcb57dcd[1][1] + mb8bcb57dcd[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_163",
        "query_text": "SUMMARY: This function accepts a two-element integer array (ivec2, equivalent to int[2]) as its input/output parameter and sets each of its two elements to zero. It does not return any value, effectively producing a two-dimensional integer vector with all elements zero.",
        "code_id": "c_group_2_id_163",
        "code_text": "Cd4e3208291\nvoid\ng44820755cf(i5e3d0f10c1 v91082a9365) {\nv91082a9365[0] = v91082a9365[1] = 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_164",
        "query_text": "SUMMARY: This function accepts a single input of type vec4 (an array of 4 single-precision floats) and does not return any value. Its functionality is to reset all elements within the provided vector to zero. It accomplishes this by utilizing platform-specific SIMD operations if available (such as WebAssembly SIMD, SSE, or NEON floating-point instructions) and defaults to assigning zero to each element individually when those optimizations are not available.",
        "code_id": "c_group_2_id_164",
        "code_text": "Cd4e3208291\nvoid\ngd86b836f25(v141258b569 v91082a9365) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(v, wasm_f32x4_const_splat(0.f));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(v91082a9365, _mm_setzero_ps());\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(v, vdupq_n_f32(0.0f));\n#else\nv[0] = 0.0f;\nv[1] = 0.0f;\nv[2] = 0.0f;\nv[3] = 0.0f;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_165",
        "query_text": "SUMMARY: This function accepts an input of type float and an output variable of type vec3 (a 3-element array of float). It assigns the float value to every element in the array, effectively replicating (broadcasting) the input value across all three positions.",
        "code_id": "c_group_2_id_165",
        "code_text": "Cd4e3208291\nvoid\ng84890c3ab3(float v71de8bcd6a, veb444e7eb8 ded8b2a8791) {\nded8b2a8791[0] = ded8b2a8791[1] = ded8b2a8791[2] = v71de8bcd6a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_166",
        "query_text": "SUMMARY: This function accepts two input parameters of type float[3] and one output parameter of type float[3]. It computes the element\u2010wise sum of the two input float[3] arrays and stores the resulting float[3] array in the output parameter.",
        "code_id": "c_group_2_id_166",
        "code_text": "Cd4e3208291\nvoid\ng2322ba763c(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] + bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] + bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_167",
        "query_text": "SUMMARY: This function accepts a 2\u00d72 matrix (of type mat2) and a 2-dimensional vector (of type vec2) as inputs, and computes their product, yielding a 2-dimensional vector (of type vec2) as the result. On the first line, it calculates the first component of the result by taking the dot product of the first column of the matrix with the input vector, and on the second line, it calculates the second component by taking the dot product of the second column of the matrix with the input vector.",
        "code_id": "c_group_2_id_167",
        "code_text": "Cd4e3208291\nvoid\ng0ae5062ee6(mde4d4e4936 mb8bcb57dcd, v0131f5a9ae v91082a9365, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = mb8bcb57dcd[0][0] * v91082a9365[0] + mb8bcb57dcd[1][0] * v91082a9365[1];\nd9748d673c4[1] = mb8bcb57dcd[0][1] * v91082a9365[0] + mb8bcb57dcd[1][1] * v91082a9365[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_168",
        "query_text": "SUMMARY: This function accepts a source input of type const float* and an output of type mat3x4 (a 3-element array where each element is an aligned 4-element array of floats). It sequentially copies 12 float values from the flat source array into the 3x4 matrix, populating each of the three rows with four consecutive float values in order.",
        "code_id": "c_group_2_id_168",
        "code_text": "Cd4e3208291\nvoid\ngf319a293db(const float * __restrict sa425380d12, m5fbb141a9c d9748d673c4) {\nd9748d673c4[0][0] = sa425380d12[0];\nd9748d673c4[0][1] = sa425380d12[1];\nd9748d673c4[0][2] = sa425380d12[2];\nd9748d673c4[0][3] = sa425380d12[3];\nd9748d673c4[1][0] = sa425380d12[4];\nd9748d673c4[1][1] = sa425380d12[5];\nd9748d673c4[1][2] = sa425380d12[6];\nd9748d673c4[1][3] = sa425380d12[7];\nd9748d673c4[2][0] = sa425380d12[8];\nd9748d673c4[2][1] = sa425380d12[9];\nd9748d673c4[2][2] = sa425380d12[10];\nd9748d673c4[2][3] = sa425380d12[11];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_169",
        "query_text": "SUMMARY: This function accepts a perspective projection matrix (of type \"mat4\", an aligned 4\u00d74 array of 4-element float vectors) and a pointer to a float variable. It computes a specific scalar value corresponding to the near clipping distance by dividing the element from the matrix\u2019s fourth row and third column by the difference of the element from the third row and third column with 1.0, then stores the result in the provided float output.",
        "code_id": "c_group_2_id_169",
        "code_text": "Cd4e3208291\nvoid\ngfe1cffe1c5(m2979ecef6f paccfd26812, float * __restrict nd3cfbab11c) {\n*nd3cfbab11c = paccfd26812[3][2] / (paccfd26812[2][2] - 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_170",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two floats) and a scalar of type float, and it produces an output of type vec2. It computes a new vector by subtracting the scalar from each element of the input vector and stores the result in the output vector.",
        "code_id": "c_group_2_id_170",
        "code_text": "Cd4e3208291\nvoid\ng5efae8ccfa(v0131f5a9ae v91082a9365, float s3b9d266e2e, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] - s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_171",
        "query_text": "SUMMARY: This function takes as input a two-element integer array, an integer scalar, and a two-element integer array as output. It updates the output array by subtracting, from each of its elements, the result of subtracting the scalar from the corresponding element of the input array.",
        "code_id": "c_group_2_id_171",
        "code_text": "Cd4e3208291\nvoid\ng1cb206f981(i5e3d0f10c1 ad90770d038, int s3b9d266e2e, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] - s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_172",
        "query_text": "SUMMARY: This function operates on three-element arrays of integers (ivec3). It takes two such input arrays, each containing three integers, and produces one output array (ivec3) where each position is assigned the greater of the corresponding elements from the two input arrays.",
        "code_id": "c_group_2_id_172",
        "code_text": "Cd4e3208291\nvoid\ng1246f5c732(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] > bba3ae37d1f[0] ? ad90770d038[0] : bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] > bba3ae37d1f[1] ? ad90770d038[1] : bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] > bba3ae37d1f[2] ? ad90770d038[2] : bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_173",
        "query_text": "SUMMARY: This function accepts an input of type int[4] and an integer scalar, and produces an output of type int[4]. It subtracts the scalar value from each element of the input array and stores the results in the output array.",
        "code_id": "c_group_2_id_173",
        "code_text": "Cd4e3208291\nvoid\ng170f74b469(i52a86355e2 v91082a9365, int s3b9d266e2e, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] - s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] - s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] - s3b9d266e2e;\nd9748d673c4[3] = v91082a9365[3] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_174",
        "query_text": "SUMMARY: This function accepts an input of type const float pointer and produces an output of type mat2x4 (i.e., a two-element array where each element is a four-component float vector). It organizes the eight sequential float values from the input into a 2\u00d74 matrix format by assigning the first four float values to the first row of the matrix and the subsequent four float values to the second row.",
        "code_id": "c_group_2_id_174",
        "code_text": "Cd4e3208291\nvoid\ngd33b84ee30(const float * __restrict sa425380d12, md4c46ddc0d d9748d673c4) {\nd9748d673c4[0][0] = sa425380d12[0];\nd9748d673c4[0][1] = sa425380d12[1];\nd9748d673c4[0][2] = sa425380d12[2];\nd9748d673c4[0][3] = sa425380d12[3];\nd9748d673c4[1][0] = sa425380d12[4];\nd9748d673c4[1][1] = sa425380d12[5];\nd9748d673c4[1][2] = sa425380d12[6];\nd9748d673c4[1][3] = sa425380d12[7];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_175",
        "query_text": "SUMMARY: This function accepts a 2-element integer array, an integer scalar, and a second 2-element integer array as inputs. It updates the output array by adding the sum of the corresponding element in the input array and the provided integer to each element in the output array.",
        "code_id": "c_group_2_id_175",
        "code_text": "Cd4e3208291\nvoid\ng96bd9a0ec5(i5e3d0f10c1 ad90770d038, int s3b9d266e2e, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] + s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_176",
        "query_text": "SUMMARY: This function receives an input of type vec4 (an array of four 32-bit floats) and a scalar of type float, and produces an output of type vec4. It scales the input vector by multiplying each of its four components by the scalar value, storing the resulting values into the output vector. Depending on the platform, it may use specialized SIMD operations for enhanced performance.",
        "code_id": "c_group_2_id_176",
        "code_text": "Cd4e3208291\nvoid\ng82643ee8be(v141258b569 v91082a9365, float s3b9d266e2e, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_mul(glmm_load(v), wasm_f32x4_splat(s)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_mul_ps(glmm_load(v91082a9365), _mm_set1_ps(s3b9d266e2e)));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vmulq_f32(vld1q_f32(v), vdupq_n_f32(s)));\n#else\ndest[0] = v[0] * s;\ndest[1] = v[1] * s;\ndest[2] = v[2] * s;\ndest[3] = v[3] * s;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_177",
        "query_text": "SUMMARY: The function takes two inputs, each being an array of four integers (int[4]), and computes their element-wise differences by subtracting corresponding entries. The resulting array of four integers (int[4]) is then produced as the output.",
        "code_id": "c_group_2_id_177",
        "code_text": "Cd4e3208291\nvoid\ng4e93a738bd(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] - bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] - bba3ae37d1f[2];\nd9748d673c4[3] = ad90770d038[3] - bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_178",
        "query_text": "SUMMARY: This function accepts three inputs, each being a two-element integer array (ivec2). It performs a component-wise addition by summing the corresponding elements of the first two inputs and then accumulates these sums with the corresponding elements of the third input. The modified third input, serving as the output, contains the results of this accumulation.",
        "code_id": "c_group_2_id_178",
        "code_text": "Cd4e3208291\nvoid\ng8bf97d08d8(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] + bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_179",
        "query_text": "SUMMARY: This function performs a component-wise subtraction between two 3-element integer arrays, where each input is of type ivec3 (an array of three integers). It subtracts the corresponding element of the second array from the first array and stores each resulting difference in a third ivec3 output array.",
        "code_id": "c_group_2_id_179",
        "code_text": "Cd4e3208291\nvoid\ngfe53c4d428(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] - bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] - bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_180",
        "query_text": "SUMMARY: This function receives two inputs\u2014a 4x4 matrix of floats (mat4) and a single float\u2014and it operates in place without returning a value (void). It adjusts the matrix by adding the float input to the element located in the fourth row and third column, effectively modifying the translation component along the z-axis of the transformation represented by the matrix.",
        "code_id": "c_group_2_id_180",
        "code_text": "Cd4e3208291\nvoid\ng3fa67f3d2b(m2979ecef6f mb8bcb57dcd, float z2f48e9e974) {\nmb8bcb57dcd[3][2] += z2f48e9e974;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_181",
        "query_text": "SUMMARY: This function takes as input a constant 4-element integer array and an integer scalar, and it updates a destination 4-element integer array. For each element in the destination array, it adds the result of subtracting the scalar from the corresponding element of the input array. The operation is performed element-wise for all four positions of the arrays, and no value is returned.",
        "code_id": "c_group_2_id_181",
        "code_text": "Cd4e3208291\nvoid\ng477057b3e1(i52a86355e2 ad90770d038, int s3b9d266e2e, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] - s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] - s3b9d266e2e;\nd9748d673c4[2] += ad90770d038[2] - s3b9d266e2e;\nd9748d673c4[3] += ad90770d038[3] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_182",
        "query_text": "SUMMARY: This function takes a 4\u00d74 floating\u2010point matrix (input type: mat4) and computes a 3-element floating\u2010point vector (output type: vec3) representing Euler angles. It extracts specific values from the matrix and then determines the Euler angles via conditional checks on one of the extracted values to handle different rotation scenarios while addressing potential singularities. The computed angles, corresponding to rotations about three principal axes, are then stored in the output vector.",
        "code_id": "c_group_2_id_182",
        "code_text": "Cd4e3208291\nvoid\ngbdf8217e13(m2979ecef6f mb8bcb57dcd, veb444e7eb8 d9748d673c4) {\nfloat m73982a8772, m16a47ac378, m238447af68, md6bc4e094a, m2134d0010f, m4b629e56ab, m529843770e;\nfloat tbc0d24daaa, t404abfc272, t772dfe0c2e;\nm73982a8772 = mb8bcb57dcd[0][0];  m238447af68 = mb8bcb57dcd[1][0];  m2134d0010f = mb8bcb57dcd[2][0];\nm16a47ac378 = mb8bcb57dcd[0][1];  md6bc4e094a = mb8bcb57dcd[1][1];  m4b629e56ab = mb8bcb57dcd[2][1];\nm529843770e = mb8bcb57dcd[2][2];\nif (m2134d0010f < 1.0f) {\nif (m2134d0010f > -1.0f) {\nt404abfc272 = asinf(m2134d0010f);\ntbc0d24daaa = atan2f(-m4b629e56ab, m529843770e);\nt772dfe0c2e = atan2f(-m238447af68, m73982a8772);\n} else { \n\nt404abfc272 = -G2241c77720;\ntbc0d24daaa = -atan2f(m16a47ac378, md6bc4e094a);\nt772dfe0c2e =  0.0f;\n}\n} else { \nt404abfc272 = G2241c77720;\ntbc0d24daaa = atan2f(m16a47ac378, md6bc4e094a);\nt772dfe0c2e = 0.0f;\n}\nd9748d673c4[0] = tbc0d24daaa;\nd9748d673c4[1] = t404abfc272;\nd9748d673c4[2] = t772dfe0c2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_183",
        "query_text": "SUMMARY: This function takes as input a 2-element float array, a float scalar, and another 2-element float array as its output container. It multiplies each element of the first array by the scalar value and then adds the resulting products to the corresponding elements in the output array, updating it in place.",
        "code_id": "c_group_2_id_183",
        "code_text": "Cd4e3208291\nvoid\ng0c5637c50a(v0131f5a9ae ad90770d038, float s3b9d266e2e, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] * s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_184",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 floating-point matrix (of type mat4) and two pointers to floats (float *), and it computes the near and far clipping plane distances from the provided projection matrix. It does so by extracting two specific elements from the matrix and then performing simple division operations: one value divided by (the other value minus 1) to yield the near clipping distance, and the same value divided by (the other value plus 1) to yield the far clipping distance. The resulting float values are stored via the provided pointers.",
        "code_id": "c_group_2_id_184",
        "code_text": "Cd4e3208291\nvoid\ngcf6cc59ba0(m2979ecef6f paccfd26812,\nfloat * __restrict nd3cfbab11c,\nfloat * __restrict fb6d340e4c8) {\nfloat m9a4eaa88e8, m529843770e;\nm9a4eaa88e8 = paccfd26812[3][2];\nm529843770e = paccfd26812[2][2];\n*nd3cfbab11c = m9a4eaa88e8 / (m529843770e - 1.0f);\n*fb6d340e4c8  = m9a4eaa88e8 / (m529843770e + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_185",
        "query_text": "SUMMARY: This function accepts a three-element floating-point array as input and produces another three-element floating-point array as output. For each element, it computes the fractional part by subtracting the floor of the input value from the input value itself. It then ensures that the computed fractional value does not exceed approximately 0.99999994 by clamping it to that upper bound.",
        "code_id": "c_group_2_id_185",
        "code_text": "Cd4e3208291\nvoid\ng310fb2bfd5(veb444e7eb8 v91082a9365, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = fminf(v91082a9365[0] - floorf(v91082a9365[0]), 0.999999940395355224609375f);\nd9748d673c4[1] = fminf(v91082a9365[1] - floorf(v91082a9365[1]), 0.999999940395355224609375f);\nd9748d673c4[2] = fminf(v91082a9365[2] - floorf(v91082a9365[2]), 0.999999940395355224609375f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_186",
        "query_text": "SUMMARY: This function accepts a mutable 3\u00d73 matrix of floats (of type mat3) and two integer values specifying row indices. Its purpose is to exchange the two specified rows within the matrix, modifying the input matrix in place without returning any value.",
        "code_id": "c_group_2_id_186",
        "code_text": "Cd4e3208291\nvoid\ng08e9c44add(m63312228ee ma02b861363, int r1ea1edcbb8, int rf12a1dfd6d) {\nveb444e7eb8 tb20dfb361b;\ntb20dfb361b[0] = ma02b861363[0][r1ea1edcbb8];\ntb20dfb361b[1] = ma02b861363[1][r1ea1edcbb8];\ntb20dfb361b[2] = ma02b861363[2][r1ea1edcbb8];\nma02b861363[0][r1ea1edcbb8] = ma02b861363[0][rf12a1dfd6d];\nma02b861363[1][r1ea1edcbb8] = ma02b861363[1][rf12a1dfd6d];\nma02b861363[2][r1ea1edcbb8] = ma02b861363[2][rf12a1dfd6d];\nma02b861363[0][rf12a1dfd6d] = tb20dfb361b[0];\nma02b861363[1][rf12a1dfd6d] = tb20dfb361b[1];\nma02b861363[2][rf12a1dfd6d] = tb20dfb361b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_187",
        "query_text": "SUMMARY: This function takes as inputs a float value and a 4x4 matrix (of type vec4[4]). The function checks if the first element of the matrix (i.e., the first element of the first row) is zero; if it is, no changes occur. Otherwise, the function updates that element by dividing the second diagonal element of the matrix by the float input. The function returns no output as it modifies the matrix in place.",
        "code_id": "c_group_2_id_187",
        "code_text": "Cd4e3208291\nvoid\ng3b558c6cbf(float a9ac3d8bc0c, m2979ecef6f paccfd26812) {\nif (paccfd26812[0][0] == 0.0f)\nreturn;\npaccfd26812[0][0] = paccfd26812[1][1] / a9ac3d8bc0c;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_188",
        "query_text": "SUMMARY: The function receives a three-element array of floats serving as a 3-dimensional vector, a float scalar, and an output three-element float array. It computes the result of dividing each component of the input vector by the scalar, and stores these quotient values into the output vector.",
        "code_id": "c_group_2_id_188",
        "code_text": "Cd4e3208291\nvoid\ng9a32ab444c(veb444e7eb8 v91082a9365, float s3b9d266e2e, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] / s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] / s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] / s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_189",
        "query_text": "SUMMARY: This function computes the product of a 4\u00d72 matrix and a 4-dimensional vector. It takes as input a matrix represented as an array of four 2-dimensional vectors (type mat4x2, i.e. float[2] arrays), and a 4-dimensional vector (type vec4, i.e. a 4-element float array with specific alignment). The function multiplies each element of the input vector with the corresponding elements in the matrix's columns, sums the products for each row of the matrix, and outputs the resulting 2-dimensional vector (type vec2, a 2-element float array).",
        "code_id": "c_group_2_id_189",
        "code_text": "Cd4e3208291\nvoid\ng751e87a600(mab2cb9021e mb8bcb57dcd, v141258b569 v91082a9365, v0131f5a9ae d9748d673c4) {\nfloat v01fb438970 = v91082a9365[0], v748b5cffd1 = v91082a9365[1], v05a5120aa0 = v91082a9365[2], va7ad10f1fc = v91082a9365[3];\nd9748d673c4[0] = mb8bcb57dcd[0][0] * v01fb438970 + mb8bcb57dcd[1][0] * v748b5cffd1 + mb8bcb57dcd[2][0] * v05a5120aa0 + mb8bcb57dcd[3][0] * va7ad10f1fc;\nd9748d673c4[1] = mb8bcb57dcd[0][1] * v01fb438970 + mb8bcb57dcd[1][1] * v748b5cffd1 + mb8bcb57dcd[2][1] * v05a5120aa0 + mb8bcb57dcd[3][1] * va7ad10f1fc;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_190",
        "query_text": "SUMMARY: This function accepts two input arrays, each consisting of 3 integers, and an output array of 3 integers. For each of the three positions, it evaluates the sum of the respective integers from the two input arrays and then adds this result to the corresponding integer already present in the output array.",
        "code_id": "c_group_2_id_190",
        "code_text": "Cd4e3208291\nvoid\ngbc897a5617(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] + bba3ae37d1f[1];\nd9748d673c4[2] += ad90770d038[2] + bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_191",
        "query_text": "SUMMARY: This function accepts three parameters, each of type float[2] (an array of two floats). The first and second inputs represent complex numbers (with the first element as the real part and the second as the imaginary part). The function computes the division of the first complex number by the second complex number, following the standard formula for complex division. It calculates the reciprocal of the squared norm of the second complex number, uses this value to compute the real part (as the sum of the products of corresponding real and imaginary components) and the imaginary part (as the difference of the cross products) of the quotient, and then stores these two components in the output parameter, which is also a float[2] array.",
        "code_id": "c_group_2_id_191",
        "code_text": "Cd4e3208291\nvoid\ng9ad1f3aeda(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nfloat t343c648f90, t8123e9feb8;\nfloat const i9a5af36e0a = 1.0f / (bba3ae37d1f[0] * bba3ae37d1f[0] + bba3ae37d1f[1] * bba3ae37d1f[1]);\nt343c648f90 = i9a5af36e0a * (ad90770d038[0] * bba3ae37d1f[0] + ad90770d038[1] * bba3ae37d1f[1]);\nt8123e9feb8 = i9a5af36e0a * (ad90770d038[1] * bba3ae37d1f[0] - ad90770d038[0] * bba3ae37d1f[1]);\nd9748d673c4[0] = t343c648f90;\nd9748d673c4[1] = t8123e9feb8;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_192",
        "query_text": "SUMMARY: This function accepts an input variable of type vec4 (a CGLM-aligned array of four floats) and produces an output variable of the same type. It computes, for each floating-point element in the input array, the largest integer value not greater than that element (i.e., the floor operation), and assigns these computed values to the corresponding elements in the output array.",
        "code_id": "c_group_2_id_192",
        "code_text": "Cd4e3208291\nvoid\ng4377b4c941(v141258b569 v91082a9365, v141258b569 d9748d673c4) {\nd9748d673c4[0] = floorf(v91082a9365[0]);\nd9748d673c4[1] = floorf(v91082a9365[1]);\nd9748d673c4[2] = floorf(v91082a9365[2]);\nd9748d673c4[3] = floorf(v91082a9365[3]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_193",
        "query_text": "SUMMARY: This function takes as input a matrix of type mat4 (an array of four aligned vec4 elements, where each vec4 is an array of four floats) and produces no direct output (void return). It sets every element of the provided 4\u00d74 matrix to zero. Depending on the hardware capabilities (WebAssembly SIMD, AVX, SSE, NEON), it uses specific SIMD instructions to efficiently fill the matrix with zeros; if none are available, it falls back to a standard method to achieve the same zero-initialization.",
        "code_id": "c_group_2_id_193",
        "code_text": "Cd4e3208291\nvoid\ng3855ecd915(m2979ecef6f ma02b861363) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngdf62af665c x0;\nx0 = wasm_f32x4_const_splat(0.f);\ngc83e6cd198(mat[0], x0);\ngc83e6cd198(mat[1], x0);\ngc83e6cd198(mat[2], x0);\ngc83e6cd198(mat[3], x0);\n#elif defined(__AVX__)\n__m256 y0;\ny0 = _mm256_setzero_ps();\nglmm_store256(mat[0], y0);\nglmm_store256(mat[2], y0);\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngdf62af665c xaf3b8fda3f;\nxaf3b8fda3f = _mm_setzero_ps();\ngc83e6cd198(ma02b861363[0], xaf3b8fda3f);\ngc83e6cd198(ma02b861363[1], xaf3b8fda3f);\ngc83e6cd198(ma02b861363[2], xaf3b8fda3f);\ngc83e6cd198(ma02b861363[3], xaf3b8fda3f);\n#elif defined(CGLM_NEON_FP)\ngdf62af665c x0;\nx0 = vdupq_n_f32(0.0f);\nvst1q_f32(mat[0], x0);\nvst1q_f32(mat[1], x0);\nvst1q_f32(mat[2], x0);\nvst1q_f32(mat[3], x0);\n#else\nCe95ec6c478 mat4 t = GLM_MAT4_ZERO_INIT;\nglm_mat4_copy(t, mat);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_194",
        "query_text": "SUMMARY: The function accepts a 3x3 matrix of type float (mat3) and a scalar of type float as inputs, and it does not return any value (void). It modifies the input matrix by applying a 2D translation along the y-axis. Specifically, it updates the elements in the third row of the matrix by incrementing them with the product of a corresponding element from the second row and the scalar input, effectively incorporating a translation component along the y direction into the matrix representation.",
        "code_id": "c_group_2_id_194",
        "code_text": "Cd4e3208291\nvoid\ngd7f6179870(m63312228ee mb8bcb57dcd, float y92bd0bf197) {\nmb8bcb57dcd[2][0] = mb8bcb57dcd[1][0] * y92bd0bf197 + mb8bcb57dcd[2][0];\nmb8bcb57dcd[2][1] = mb8bcb57dcd[1][1] * y92bd0bf197 + mb8bcb57dcd[2][1];\nmb8bcb57dcd[2][2] = mb8bcb57dcd[1][2] * y92bd0bf197 + mb8bcb57dcd[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_195",
        "query_text": "SUMMARY: This function takes two 3-element arrays of floats (vec3) as inputs and a third 3-element array of floats (vec3) as the output. It computes the element-wise product of the two input arrays and then adds each resulting product to the corresponding element of the output array.",
        "code_id": "c_group_2_id_195",
        "code_text": "Cd4e3208291\nvoid\ng9882162abf(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] * bba3ae37d1f[1];\nd9748d673c4[2] += ad90770d038[2] * bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_196",
        "query_text": "SUMMARY: This function takes a three-element integer array (ivec3), a scalar integer, and another three-element integer array (ivec3) as inputs. It updates the latter by adding, element-wise, the sum of the corresponding element from the first array and the scalar to each element already present in the output array.",
        "code_id": "c_group_2_id_196",
        "code_text": "Cd4e3208291\nvoid\ngc29f157059(i4b951f731e ad90770d038, int s3b9d266e2e, i4b951f731e d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] + s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] + s3b9d266e2e;\nd9748d673c4[2] += ad90770d038[2] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_197",
        "query_text": "SUMMARY: This function accepts two inputs of type vec4 (which is an array of four floats) and produces an output also of type vec4. It computes the element-wise arithmetic negation of the input vector and stores the resulting values in the output vector. The implementation adapts to available hardware acceleration (such as WebAssembly SIMD, SSE, or NEON) to perform the negation efficiently, with a fallback to scalar operations if necessary.",
        "code_id": "c_group_2_id_197",
        "code_text": "Cd4e3208291\nvoid\ng655d65a32e(v141258b569 v91082a9365, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_neg(glmm_load(v)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_xor_ps(glmm_load(v91082a9365), gb0b945d074));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vnegq_f32(vld1q_f32(v)));\n#else\ndest[0] = -v[0];\ndest[1] = -v[1];\ndest[2] = -v[2];\ndest[3] = -v[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_198",
        "query_text": "SUMMARY: This function operates on three variables, each of type integer vector of size 3 (int[3]). It modifies the output vector by subtracting, for each of its three components, the difference between the corresponding components of the first and second integer vectors. In effect, for every component index, the function computes \"output component minus (first vector component minus second vector component)\".",
        "code_id": "c_group_2_id_198",
        "code_text": "Cd4e3208291\nvoid\ngfa9c2eedd4(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] - bba3ae37d1f[1];\nd9748d673c4[2] -= ad90770d038[2] - bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_199",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of which are arrays of three floats (vec3). It updates the output parameter by subtracting, for each component, the difference between the corresponding elements of the first and second input arrays. Essentially, for each index (0, 1, 2), it performs the operation output[i] = output[i] - (first_input[i] - second_input[i]).",
        "code_id": "c_group_2_id_199",
        "code_text": "Cd4e3208291\nvoid\ng39e6a9c7be(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] - bba3ae37d1f[1];\nd9748d673c4[2] -= ad90770d038[2] - bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_200",
        "query_text": "SUMMARY: This function computes and returns the trace of a 4\u00d74 matrix. It takes as input a parameter of type mat4 (an aligned 4\u00d74 matrix composed of four arrays of four floating-point numbers each) and produces a scalar output of type float. Specifically, the function sums the diagonal elements of the matrix, which are the elements located at the positions (0,0), (1,1), (2,2), and (3,3).",
        "code_id": "c_group_2_id_200",
        "code_text": "Cd4e3208291\nfloat\ng53d7e8160b(m2979ecef6f mb8bcb57dcd) {\nreturn mb8bcb57dcd[0][0] + mb8bcb57dcd[1][1] + mb8bcb57dcd[2][2] + mb8bcb57dcd[3][3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_201",
        "query_text": "SUMMARY: This function computes the determinant of a 2\u00d72 matrix. It accepts as input a matrix of type mat2 (a 2\u00d72 array of floats, with each row represented as a vec2) and returns a float. Internally, it multiplies the top-left element with the bottom-right element and subtracts the product of the bottom-left element with the top-right element to produce the determinant as output.",
        "code_id": "c_group_2_id_201",
        "code_text": "Cd4e3208291\nfloat\ngce8b3185ea(mde4d4e4936 ma02b861363) {\nreturn ma02b861363[0][0] * ma02b861363[1][1] - ma02b861363[1][0] * ma02b861363[0][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_202",
        "query_text": "SUMMARY: This function accepts two inputs of type ivec3 (arrays containing three integers) and computes an output of the same type. It performs an element-wise modulo operation by taking, for each index, the remainder of the division of the corresponding integer from the first input by the integer from the second input, and stores the result in the matching index of the output.",
        "code_id": "c_group_2_id_202",
        "code_text": "Cd4e3208291\nvoid\ng89b06f86f4(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] % bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] % bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] % bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_203",
        "query_text": "SUMMARY: This function operates on a 4\u00d74 matrix of floats (input type: mat4) and produces two float outputs (output type: float*, representing left and right boundaries). It extracts specific coefficients from the matrix that are related to the perspective projection setup, computes the near-plane depth from these coefficients, and then calculates the horizontal extents (left and right) of the viewing frustum for a right\u2010handed, no-offset configuration.",
        "code_id": "c_group_2_id_203",
        "code_text": "Cd4e3208291\nvoid\ng5b969bdd3f(m2979ecef6f paccfd26812,\nfloat * __restrict lcfaba252b8,\nfloat * __restrict rc12144e4ba) {\nfloat nd3cfbab11c, m2134d0010f, m73982a8772, m529843770e;\nm73982a8772 = paccfd26812[0][0];\nm2134d0010f = paccfd26812[2][0];\nm529843770e = paccfd26812[2][2];\nnd3cfbab11c = paccfd26812[3][2] / (m529843770e - 1.0f);\n*lcfaba252b8   = nd3cfbab11c * (m2134d0010f - 1.0f) / m73982a8772;\n*rc12144e4ba  = nd3cfbab11c * (m2134d0010f + 1.0f) / m73982a8772;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_204",
        "query_text": "SUMMARY: This function takes as inputs an array of two floats (vec2) and a pointer to a FILE stream. It produces a formatted text representation of the two-element vector by writing to the provided FILE stream. Specifically, it outputs a header indicating the vector's type with color formatting, then prints each float element using either a fixed-precision or general format depending on its value relative to a defined threshold, and finally resets the formatting before finishing. The function does not return any value.",
        "code_id": "c_group_2_id_204",
        "code_text": "Cd4e3208291\nvoid\ng1905c13e88(v0131f5a9ae              vf6195f1fd8,\nFILE * __restrict o5450e5c91d) {\nint i0c6e314cec;\n#define mb8bcb57dcd 2\nfprintf(o5450e5c91d, \"Vector (float%d): \" C45893ec2b2 \"\\n  (\", mb8bcb57dcd);\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++) {\nif (vf6195f1fd8[i0c6e314cec] < Cd0da13f7c8)\nfprintf(o5450e5c91d, \" % .*f\", Cb46738fea8, (double)vf6195f1fd8[i0c6e314cec]);\nelse\nfprintf(o5450e5c91d, \" % g\", (double)vf6195f1fd8[i0c6e314cec]);\n}\nfprintf(o5450e5c91d, \"  )\" C7c34c62781 \"\\n\\n\");\n#undef mb8bcb57dcd\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_205",
        "query_text": "SUMMARY: This function accepts two input parameters of type ivec3 (arrays of three integers) and one output parameter of the same type. For each of the three integer elements, it computes the product of the corresponding elements from the input parameters and then subtracts that product from the corresponding element in the output array.",
        "code_id": "c_group_2_id_205",
        "code_text": "Cd4e3208291\nvoid\ng1285be7a0b(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] * bba3ae37d1f[1];\nd9748d673c4[2] -= ad90770d038[2] * bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_206",
        "query_text": "SUMMARY: This function takes a 3-element floating\u2010point vector (vec3) representing Euler angles and produces a 4\u00d74 floating\u2010point matrix (mat4) that encodes a 3D rotation using a Z\u2013Y\u2013X rotation order. It computes the sine and cosine of each angle and uses intermediate multiplications to construct the rotation submatrix, then sets the remaining parts of the matrix to form a proper homogeneous transformation matrix with zero translation and a unit scale for the homogeneous coordinate.",
        "code_id": "c_group_2_id_206",
        "code_text": "Cd4e3208291\nvoid\ngb43f51b565(veb444e7eb8 a9cd9428334, m2979ecef6f d9748d673c4) {\nfloat ced008e8902, ce4f072f817, c6bd6fe7cc6,\ns7d25487ca7, se41a0f503f, s23246ee131, cc3c3a71c06, c6de4c4d8c3, s8f0754e783;\ns7d25487ca7   = sinf(a9cd9428334[0]); ced008e8902 = cosf(a9cd9428334[0]);\nse41a0f503f   = sinf(a9cd9428334[1]); ce4f072f817 = cosf(a9cd9428334[1]);\ns23246ee131   = sinf(a9cd9428334[2]); c6bd6fe7cc6 = cosf(a9cd9428334[2]);\ncc3c3a71c06 = c6bd6fe7cc6 * s7d25487ca7;\nc6de4c4d8c3 = ced008e8902 * c6bd6fe7cc6;\ns8f0754e783 = se41a0f503f * s23246ee131;\nd9748d673c4[0][0] =  ce4f072f817 * c6bd6fe7cc6;\nd9748d673c4[0][1] =  ce4f072f817 * s23246ee131;\nd9748d673c4[0][2] = -se41a0f503f;\nd9748d673c4[1][0] =  cc3c3a71c06 * se41a0f503f - ced008e8902 * s23246ee131;\nd9748d673c4[1][1] =  c6de4c4d8c3 + s7d25487ca7 * s8f0754e783;\nd9748d673c4[1][2] =  ce4f072f817 * s7d25487ca7;\nd9748d673c4[2][0] =  c6de4c4d8c3 * se41a0f503f + s7d25487ca7 * s23246ee131;\nd9748d673c4[2][1] = -cc3c3a71c06 + ced008e8902 * s8f0754e783;\nd9748d673c4[2][2] =  ced008e8902 * ce4f072f817;\nd9748d673c4[0][3] =  0.0f;\nd9748d673c4[1][3] =  0.0f;\nd9748d673c4[2][3] =  0.0f;\nd9748d673c4[3][0] =  0.0f;\nd9748d673c4[3][1] =  0.0f;\nd9748d673c4[3][2] =  0.0f;\nd9748d673c4[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_207",
        "query_text": "SUMMARY: This function accepts a three-element array of floats (vec3) as input along with a float value. It assigns the given float value to each element of the array, effectively filling the vector. The function does not return any value.",
        "code_id": "c_group_2_id_207",
        "code_text": "Cd4e3208291\nvoid\ng72ef5a9fb6(veb444e7eb8 v91082a9365, float v71de8bcd6a) {\nv91082a9365[0] = v91082a9365[1] = v91082a9365[2] = v71de8bcd6a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_208",
        "query_text": "SUMMARY: This function processes a matrix of type mat3 (a 3\u00d73 array of float values) by computing its transpose in place. It effectively interchanges the matrix's off-diagonal elements so that the rows become columns and vice versa, updating the original matrix with its transposed form.",
        "code_id": "c_group_2_id_208",
        "code_text": "Cd4e3208291\nvoid\ng9cdada7e1c(m63312228ee mb8bcb57dcd) {\nCe95ec6c478 m63312228ee tb20dfb361b;\ntb20dfb361b[0][1] = mb8bcb57dcd[1][0];\ntb20dfb361b[0][2] = mb8bcb57dcd[2][0];\ntb20dfb361b[1][0] = mb8bcb57dcd[0][1];\ntb20dfb361b[1][2] = mb8bcb57dcd[2][1];\ntb20dfb361b[2][0] = mb8bcb57dcd[0][2];\ntb20dfb361b[2][1] = mb8bcb57dcd[1][2];\nmb8bcb57dcd[0][1] = tb20dfb361b[0][1];\nmb8bcb57dcd[0][2] = tb20dfb361b[0][2];\nmb8bcb57dcd[1][0] = tb20dfb361b[1][0];\nmb8bcb57dcd[1][2] = tb20dfb361b[1][2];\nmb8bcb57dcd[2][0] = tb20dfb361b[2][0];\nmb8bcb57dcd[2][1] = tb20dfb361b[2][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_209",
        "query_text": "SUMMARY: This function takes two inputs of type int[2] and produces an output of type int[2] by computing the element-wise product of the two input arrays. Specifically, it multiplies the first element of one input with the first element of the other, and similarly for the second element, placing the results in the output array.",
        "code_id": "c_group_2_id_209",
        "code_text": "Cd4e3208291\nvoid\ng78b3674cc3(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] * bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_210",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of 2 floats) and produces an output of the same type. For each element in the input, the function computes its fractional component by subtracting the integer part (as determined by the floor operation), and then limits the resulting value so that it does not exceed approximately 0.99999994.",
        "code_id": "c_group_2_id_210",
        "code_text": "Cd4e3208291\nvoid\ng38bb0aa591(v0131f5a9ae v91082a9365, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = fminf(v91082a9365[0] - floorf(v91082a9365[0]), 0.999999940395355224609375f);\nd9748d673c4[1] = fminf(v91082a9365[1] - floorf(v91082a9365[1]), 0.999999940395355224609375f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_211",
        "query_text": "SUMMARY: This inline function takes a single parameter\u2014a three-element array of floats (type: float[3])\u2014as input and produces no return value (type: void). Its functionality is to initialize each element of the provided array to 0.0f, effectively setting the vector to a zero state.",
        "code_id": "c_group_2_id_211",
        "code_text": "Cd4e3208291\nvoid\ngee5a07ac98(veb444e7eb8 v91082a9365) {\nv91082a9365[0] = v91082a9365[1] = v91082a9365[2] = 0.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_212",
        "query_text": "SUMMARY: This function accepts an input of a three-element array of integers and a single integer scalar, then outputs a three-element array of integers. It performs element-wise division of the array's integers by the scalar and stores the results in the output array.",
        "code_id": "c_group_2_id_212",
        "code_text": "Cd4e3208291\nvoid\ng3d19c6ae3a(i4b951f731e v91082a9365, int s3b9d266e2e, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] / s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] / s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] / s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_213",
        "query_text": "SUMMARY: This function takes a 4\u00d74 projection matrix (of type mat4, defined as an array of four vec4, where each vec4 is a float[4]) as its primary input. It then decomposes this matrix into its perspective frustum parameters by computing the near and far clipping distances (as floats) and the top, bottom, left, and right extents (also as floats). The outputs are provided via pointers to floats. Essentially, the function interprets the projection matrix for a left-handed, zero-depth configuration and extracts the corresponding frustum boundaries without delving into low-level detail of the underlying transformation mechanics.",
        "code_id": "c_group_2_id_213",
        "code_text": "Cd4e3208291\nvoid\ngc77df2b8aa(m2979ecef6f paccfd26812,\nfloat * __restrict nd3cfbab11c, float * __restrict fb6d340e4c8,\nfloat * __restrict td39aaeaeed,     float * __restrict be4ccd944cb,\nfloat * __restrict lcfaba252b8,    float * __restrict rc12144e4ba) {\nfloat m73982a8772, md6bc4e094a, m2134d0010f, m4b629e56ab, m529843770e, m9a4eaa88e8, neb9157c168, f4cff875701;\nfloat n12ece6d2dd, nc740595460;\nm73982a8772 = paccfd26812[0][0];\nmd6bc4e094a = paccfd26812[1][1];\nm2134d0010f = paccfd26812[2][0];\nm4b629e56ab = paccfd26812[2][1];\nm529843770e =-paccfd26812[2][2];\nm9a4eaa88e8 = paccfd26812[3][2];\nneb9157c168 = m9a4eaa88e8 / m529843770e;\nf4cff875701 = m9a4eaa88e8 / (m529843770e + 1.0f);\nn12ece6d2dd = neb9157c168 / md6bc4e094a;\nnc740595460 = neb9157c168 / m73982a8772;\n*nd3cfbab11c = neb9157c168;\n*fb6d340e4c8  = f4cff875701;\n*be4ccd944cb  = n12ece6d2dd * (m4b629e56ab - 1.0f);\n*td39aaeaeed     = n12ece6d2dd * (m4b629e56ab + 1.0f);\n*lcfaba252b8    = nc740595460 * (m2134d0010f - 1.0f);\n*rc12144e4ba   = nc740595460 * (m2134d0010f + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_214",
        "query_text": "SUMMARY: This function accepts three parameters: the first is an input two-element vector of type int[2], the second is a scalar integer (type int), and the third is an output two-element vector of type int[2]. The function multiplies each element of the input vector by the scalar integer and then adds the resulting product to the corresponding element of the output vector.",
        "code_id": "c_group_2_id_214",
        "code_text": "Cd4e3208291\nvoid\ng49bc63467f(i5e3d0f10c1 ad90770d038, int s3b9d266e2e, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] * s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_215",
        "query_text": "SUMMARY: This function takes two inputs of type mat4x2 (an array of 4 vec2 arrays, where each vec2 is defined as an array of 2 floats) and copies the elements from the source input to the destination output. Specifically, it transfers each of the four rows, with their two float components, from the input mat4x2 to the corresponding positions in the output mat4x2.",
        "code_id": "c_group_2_id_215",
        "code_text": "Cd4e3208291\nvoid\nga39c2f384d(mab2cb9021e ma02b861363, mab2cb9021e d9748d673c4) {\nd9748d673c4[0][0] = ma02b861363[0][0];\nd9748d673c4[0][1] = ma02b861363[0][1];\nd9748d673c4[1][0] = ma02b861363[1][0];\nd9748d673c4[1][1] = ma02b861363[1][1];\nd9748d673c4[2][0] = ma02b861363[2][0];\nd9748d673c4[2][1] = ma02b861363[2][1];\nd9748d673c4[3][0] = ma02b861363[3][0];\nd9748d673c4[3][1] = ma02b861363[3][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_216",
        "query_text": "SUMMARY: This function takes as input a two-dimensional matrix of type \"mat2\" (an aligned array of two 2-element \"vec2\" arrays containing floats) and two integers representing row indices. Its functionality is to exchange the data of the two specified rows within the matrix by swapping the corresponding float values in each column, without returning any value (the matrix is modified in place).",
        "code_id": "c_group_2_id_216",
        "code_text": "Cd4e3208291\nvoid\ng3f02a47550(mde4d4e4936 ma02b861363, int r1ea1edcbb8, int rf12a1dfd6d) {\nfloat ad90770d038, bba3ae37d1f;\nad90770d038 = ma02b861363[0][r1ea1edcbb8];\nbba3ae37d1f = ma02b861363[1][r1ea1edcbb8];\nma02b861363[0][r1ea1edcbb8] = ma02b861363[0][rf12a1dfd6d];\nma02b861363[1][r1ea1edcbb8] = ma02b861363[1][rf12a1dfd6d];\nma02b861363[0][rf12a1dfd6d] = ad90770d038;\nma02b861363[1][rf12a1dfd6d] = bba3ae37d1f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_217",
        "query_text": "SUMMARY: This function performs an element-wise subtraction between two inputs of type float[3] and stores the result in an output of type float[3]. Specifically, it computes the subtraction for each corresponding index of the input arrays and assigns the result to the corresponding index of the output array.",
        "code_id": "c_group_2_id_217",
        "code_text": "Cd4e3208291\nvoid\ng70850b3b1c(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] - bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] - bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_218",
        "query_text": "SUMMARY: This function converts a set of Euler angles to a quaternion representation using a right-handed coordinate system with a YXZ rotation order. It accepts an input of type vec3 (a three-element array of floats representing the Euler angles) and produces an output of type versor (a four-element array of floats representing the resulting quaternion). The function computes sine and cosine values of half of each angle and then combines these to form the quaternion's components through a series of multiplications and additions.",
        "code_id": "c_group_2_id_218",
        "code_text": "Cd4e3208291\nvoid\ng3fa50838af(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad = sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa = sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] =  ydfce0dcdee * xa08976ecad * z1a2745c1a8 + ye938664caa * x1dce3a8271 * z8de8afe2d4;\nd9748d673c4[1] = -ydfce0dcdee * xa08976ecad * z8de8afe2d4 + ye938664caa * x1dce3a8271 * z1a2745c1a8;\nd9748d673c4[2] =  ydfce0dcdee * x1dce3a8271 * z8de8afe2d4 - ye938664caa * xa08976ecad * z1a2745c1a8;\nd9748d673c4[3] =  ydfce0dcdee * x1dce3a8271 * z1a2745c1a8 + ye938664caa * xa08976ecad * z8de8afe2d4;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_219",
        "query_text": "SUMMARY: This function takes an input of type ivec2 (an array of two integers), a scalar integer, and an output of type ivec2. It computes, for each element of the input array, the difference between that element and the scalar, and then adds the result to the corresponding element of the output array.",
        "code_id": "c_group_2_id_219",
        "code_text": "Cd4e3208291\nvoid\ngf44284cfc0(i5e3d0f10c1 ad90770d038, int s3b9d266e2e, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] - s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_220",
        "query_text": "SUMMARY: The function accepts two input arrays of type int[2] and produces an output array of type int[2]. It computes the component-wise minimum between the corresponding elements of the two input arrays and stores the resulting minimum values in the output array.",
        "code_id": "c_group_2_id_220",
        "code_text": "Cd4e3208291\nvoid\ngfdf2a43936(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] < bba3ae37d1f[0] ? ad90770d038[0] : bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] < bba3ae37d1f[1] ? ad90770d038[1] : bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_221",
        "query_text": "SUMMARY: This function operates on two variables of the type \"mat3\", where \"mat3\" is defined as a 3x3 array of floats. It takes a source 3x3 float matrix and copies each element of the source matrix to a destination 3x3 float matrix, effectively duplicating all nine elements from the input to the output.",
        "code_id": "c_group_2_id_221",
        "code_text": "Cd4e3208291\nvoid\ng432c7e367d(m63312228ee ma02b861363, m63312228ee d9748d673c4) {\nd9748d673c4[0][0] = ma02b861363[0][0];\nd9748d673c4[0][1] = ma02b861363[0][1];\nd9748d673c4[0][2] = ma02b861363[0][2];\nd9748d673c4[1][0] = ma02b861363[1][0];\nd9748d673c4[1][1] = ma02b861363[1][1];\nd9748d673c4[1][2] = ma02b861363[1][2];\nd9748d673c4[2][0] = ma02b861363[2][0];\nd9748d673c4[2][1] = ma02b861363[2][1];\nd9748d673c4[2][2] = ma02b861363[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_222",
        "query_text": "SUMMARY: This function takes as input a matrix of type mat3x4 (an array of 3 vectors, each containing 4 floats) and outputs a matrix of type mat4x3 (an array of 4 vectors, each containing 3 floats). Its functionality is to compute the transpose of the input 3\u00d74 matrix, effectively converting rows into columns by reassigning each element\u2019s position accordingly.",
        "code_id": "c_group_2_id_222",
        "code_text": "Cd4e3208291\nvoid\ng2b45e09ffa(m5fbb141a9c mb8bcb57dcd, mc9dd4b805d d9748d673c4) {\nd9748d673c4[0][0] = mb8bcb57dcd[0][0];  d9748d673c4[0][1] = mb8bcb57dcd[1][0];  d9748d673c4[0][2] = mb8bcb57dcd[2][0];\nd9748d673c4[1][0] = mb8bcb57dcd[0][1];  d9748d673c4[1][1] = mb8bcb57dcd[1][1];  d9748d673c4[1][2] = mb8bcb57dcd[2][1];\nd9748d673c4[2][0] = mb8bcb57dcd[0][2];  d9748d673c4[2][1] = mb8bcb57dcd[1][2];  d9748d673c4[2][2] = mb8bcb57dcd[2][2];\nd9748d673c4[3][0] = mb8bcb57dcd[0][3];  d9748d673c4[3][1] = mb8bcb57dcd[1][3];  d9748d673c4[3][2] = mb8bcb57dcd[2][3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_223",
        "query_text": "SUMMARY: This function accepts two arrays of four integers and one integer scalar. It multiplies each element of the first integer array by the scalar and then subtracts the resulting product from the corresponding element of the second integer array, updating the second array with these new values.",
        "code_id": "c_group_2_id_223",
        "code_text": "Cd4e3208291\nvoid\ng1c08819e3b(i52a86355e2 ad90770d038, int s3b9d266e2e, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] * s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] * s3b9d266e2e;\nd9748d673c4[2] -= ad90770d038[2] * s3b9d266e2e;\nd9748d673c4[3] -= ad90770d038[3] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_224",
        "query_text": "SUMMARY: This function operates on an input of type mat4 (a 4x4 array of float values) along with a float scalar. It scales the entire mat4 matrix by multiplying every element within it by the float. The operation modifies the input matrix in place, and the function returns no value.",
        "code_id": "c_group_2_id_224",
        "code_text": "Cd4e3208291\nvoid\ng1e3ac0ac2d(m2979ecef6f mb8bcb57dcd, float s3b9d266e2e) {\nmb8bcb57dcd[0][0] *= s3b9d266e2e; mb8bcb57dcd[0][1] *= s3b9d266e2e; mb8bcb57dcd[0][2] *= s3b9d266e2e; mb8bcb57dcd[0][3] *= s3b9d266e2e;\nmb8bcb57dcd[1][0] *= s3b9d266e2e; mb8bcb57dcd[1][1] *= s3b9d266e2e; mb8bcb57dcd[1][2] *= s3b9d266e2e; mb8bcb57dcd[1][3] *= s3b9d266e2e;\nmb8bcb57dcd[2][0] *= s3b9d266e2e; mb8bcb57dcd[2][1] *= s3b9d266e2e; mb8bcb57dcd[2][2] *= s3b9d266e2e; mb8bcb57dcd[2][3] *= s3b9d266e2e;\nmb8bcb57dcd[3][0] *= s3b9d266e2e; mb8bcb57dcd[3][1] *= s3b9d266e2e; mb8bcb57dcd[3][2] *= s3b9d266e2e; mb8bcb57dcd[3][3] *= s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_225",
        "query_text": "SUMMARY: This function accepts two input parameters, each of type vec2 (a float array of two elements), and returns a float. It calculates and outputs a scalar value by computing the difference between the product of the first element of the first input and the second element of the second input, and the product of the second element of the first input and the first element of the second input.",
        "code_id": "c_group_2_id_225",
        "code_text": "Cd4e3208291\nfloat\ng5ac6772b22(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f) {\n\nreturn ad90770d038[0] * bba3ae37d1f[1] - ad90770d038[1] * bba3ae37d1f[0];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_226",
        "query_text": "SUMMARY: This function accepts an input of type a three-element array of float values (vec3) and produces an output of the same type. It computes the absolute value of each of the three float components in the input array and assigns these computed values into the corresponding positions of the output array. Line by line, the function applies a floating-point absolute value operation individually to each of the three elements.",
        "code_id": "c_group_2_id_226",
        "code_text": "Cd4e3208291\nvoid\ng32f5c9d805(veb444e7eb8 v91082a9365, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = fabsf(v91082a9365[0]);\nd9748d673c4[1] = fabsf(v91082a9365[1]);\nd9748d673c4[2] = fabsf(v91082a9365[2]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_227",
        "query_text": "SUMMARY: This function takes an input of type mat3 (a 3x3 matrix of floats) and uses it to initialize the top-left 3x3 portion of an output of type mat4 (a 4x4 matrix of floats). Specifically, each element of the 3x3 input matrix is copied into the corresponding position in the 4x4 output matrix from the first row and column up to the third, leaving the rest of the output matrix unaffected.",
        "code_id": "c_group_2_id_227",
        "code_text": "Cd4e3208291\nvoid\ng8fcfe97730(m63312228ee ma02b861363, m2979ecef6f d9748d673c4) {\nd9748d673c4[0][0] = ma02b861363[0][0];\nd9748d673c4[0][1] = ma02b861363[0][1];\nd9748d673c4[0][2] = ma02b861363[0][2];\nd9748d673c4[1][0] = ma02b861363[1][0];\nd9748d673c4[1][1] = ma02b861363[1][1];\nd9748d673c4[1][2] = ma02b861363[1][2];\nd9748d673c4[2][0] = ma02b861363[2][0];\nd9748d673c4[2][1] = ma02b861363[2][1];\nd9748d673c4[2][2] = ma02b861363[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_228",
        "query_text": "SUMMARY: This function takes an input of a 3-element array of floats and a scalar float, and produces an output of a 3-element array of floats where each element is the result of multiplying the corresponding element of the input array by the scalar. The function multiplies the first element by the scalar, then the second, and finally the third, storing each result in the output array.",
        "code_id": "c_group_2_id_228",
        "code_text": "Cd4e3208291\nvoid\ngb3a3424b0e(veb444e7eb8 v91082a9365, float s3b9d266e2e, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] * s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] * s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_229",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (type: mat4) and a float (type: float) as input, and it outputs a modified 4\u00d74 matrix. It adjusts the perspective projection parameters by recalculating the near and far plane distances based on specific entries in the input matrix and an additional scalar offset. The function then updates particular entries of the matrix to effectively shift the far plane position further along the depth axis for a right-handed coordinate system with a zero-to-one depth range.",
        "code_id": "c_group_2_id_229",
        "code_text": "Cd4e3208291\nvoid\ng0d8b1ced33(m2979ecef6f paccfd26812, float dc3e1e7568f) {\nfloat f9bc16e1f91, fb6d340e4c8, nd3cfbab11c, p6624354550, pe06d2fef65;\np6624354550        = paccfd26812[2][2];\npe06d2fef65        = paccfd26812[3][2];\nnd3cfbab11c    = pe06d2fef65 / p6624354550;\nfb6d340e4c8     = pe06d2fef65 / (p6624354550 + 1.0f) + dc3e1e7568f;\nf9bc16e1f91         = 1.0f / (nd3cfbab11c - fb6d340e4c8);\npaccfd26812[2][2] = fb6d340e4c8 * f9bc16e1f91;\npaccfd26812[3][2] = nd3cfbab11c * fb6d340e4c8 * f9bc16e1f91;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_230",
        "query_text": "SUMMARY: This function converts a set of Euler angles (an input of type vec3, i.e. an array of three floats) into a quaternion (an output of type versor, i.e. an array of four floats) based on a right-handed coordinate system using the ZXY rotation order. It computes the sine and cosine for half of each Euler angle and then combines these intermediate results to produce the four components of the quaternion representing the equivalent rotation.",
        "code_id": "c_group_2_id_230",
        "code_text": "Cd4e3208291\nvoid\ng248572d823(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad = sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa = sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] = z1a2745c1a8 * xa08976ecad * ydfce0dcdee - z8de8afe2d4 * x1dce3a8271 * ye938664caa;\nd9748d673c4[1] = z1a2745c1a8 * x1dce3a8271 * ye938664caa + z8de8afe2d4 * xa08976ecad * ydfce0dcdee;\nd9748d673c4[2] = z1a2745c1a8 * xa08976ecad * ye938664caa + z8de8afe2d4 * x1dce3a8271 * ydfce0dcdee;\nd9748d673c4[3] = z1a2745c1a8 * x1dce3a8271 * ydfce0dcdee - z8de8afe2d4 * xa08976ecad * ye938664caa;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_231",
        "query_text": "SUMMARY: This function accepts as input a 3-element floating\u2010point vector (vec3) representing Euler angles (assumed in zxy order) and produces as output a 4\u00d74 floating\u2010point matrix (mat4) that represents the corresponding rotation transformation. It computes the sine and cosine values for each angle, evaluates intermediate products based on these trigonometric results, and uses them to assemble the rotation matrix. The output matrix is structured as a homogeneous transformation matrix\u2014with the rotational submatrix in its upper 3\u00d73 portion and the remainder set to form the identity in terms of translation and scaling.",
        "code_id": "c_group_2_id_231",
        "code_text": "Cd4e3208291\nvoid\ng717726b86f(veb444e7eb8 a9cd9428334, m2979ecef6f d9748d673c4) {\nfloat ced008e8902, ce4f072f817, c6bd6fe7cc6,\ns7d25487ca7, se41a0f503f, s23246ee131, c19bb133d1d, se19167aaa1, cda3a4bca48;\ns7d25487ca7   = sinf(a9cd9428334[0]); ced008e8902 = cosf(a9cd9428334[0]);\nse41a0f503f   = sinf(a9cd9428334[1]); ce4f072f817 = cosf(a9cd9428334[1]);\ns23246ee131   = sinf(a9cd9428334[2]); c6bd6fe7cc6 = cosf(a9cd9428334[2]);\nc19bb133d1d = ce4f072f817 * c6bd6fe7cc6;\nse19167aaa1 = s7d25487ca7 * se41a0f503f;\ncda3a4bca48 = ce4f072f817 * s23246ee131;\nd9748d673c4[0][0] =  c19bb133d1d - se19167aaa1 * s23246ee131;\nd9748d673c4[0][1] =  c6bd6fe7cc6 * se19167aaa1 + cda3a4bca48;\nd9748d673c4[0][2] = -ced008e8902 * se41a0f503f;\nd9748d673c4[1][0] = -ced008e8902 * s23246ee131;\nd9748d673c4[1][1] =  ced008e8902 * c6bd6fe7cc6;\nd9748d673c4[1][2] =  s7d25487ca7;\nd9748d673c4[2][0] =  c6bd6fe7cc6 * se41a0f503f + cda3a4bca48 * s7d25487ca7;\nd9748d673c4[2][1] = -c19bb133d1d * s7d25487ca7 + se41a0f503f * s23246ee131;\nd9748d673c4[2][2] =  ced008e8902 * ce4f072f817;\nd9748d673c4[0][3] =  0.0f;\nd9748d673c4[1][3] =  0.0f;\nd9748d673c4[2][3] =  0.0f;\nd9748d673c4[3][0] =  0.0f;\nd9748d673c4[3][1] =  0.0f;\nd9748d673c4[3][2] =  0.0f;\nd9748d673c4[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_232",
        "query_text": "SUMMARY: The function accepts two 2-element arrays of integers as input and a 2-element array of integers as output. It subtracts the sum of the corresponding elements of the input arrays from the corresponding elements in the output array. Specifically, it decreases the first element of the output by the sum of the first elements from both inputs and does the same for the second element.",
        "code_id": "c_group_2_id_232",
        "code_text": "Cd4e3208291\nvoid\ng8d725a695c(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] + bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_233",
        "query_text": "SUMMARY: This function accepts a 4x4 floating point matrix (mat4) and a floating point value (float) as inputs and produces no direct output (void). It modifies the received matrix by adding the provided float value to the element located at the fourth row and second column, thereby adjusting the y-direction translation component of the matrix.",
        "code_id": "c_group_2_id_233",
        "code_text": "Cd4e3208291\nvoid\ng1220b75209(m2979ecef6f mb8bcb57dcd, float y92bd0bf197) {\nmb8bcb57dcd[3][1] += y92bd0bf197;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_234",
        "query_text": "SUMMARY: This function converts a set of three Euler angles (input as a vec3, which is an array of three floats) into a quaternion representation (output as a versor, which is an array of four floats) for a left-handed coordinate system using a YZX rotation order. The function begins by computing the half-angle sine and cosine values for each of the three input angles\u2014modifying the third component by inverting the sine to accommodate the left-handed system. It then combines these trigonometric values in a specific manner to calculate the four components of the quaternion, representing the rotation defined by the original Euler angles.",
        "code_id": "c_group_2_id_234",
        "code_text": "Cd4e3208291\nvoid\ng150f0ba22f(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad =  sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa =  sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = -sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] = ydfce0dcdee * z1a2745c1a8 * xa08976ecad + ye938664caa * z8de8afe2d4 * x1dce3a8271;\nd9748d673c4[1] = ydfce0dcdee * z8de8afe2d4 * xa08976ecad + ye938664caa * z1a2745c1a8 * x1dce3a8271;\nd9748d673c4[2] = ydfce0dcdee * z8de8afe2d4 * x1dce3a8271 - ye938664caa * z1a2745c1a8 * xa08976ecad;\nd9748d673c4[3] = ydfce0dcdee * z1a2745c1a8 * x1dce3a8271 - ye938664caa * z8de8afe2d4 * xa08976ecad;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_235",
        "query_text": "SUMMARY: This function takes as input a 3\u00d73 matrix (of type float[3][3]) and a floating-point value representing an angle. It modifies the matrix in place by applying a 2D rotation transformation based on the given angle. Internally, it calculates the sine and cosine of the angle and updates the matrix\u2019s first two rows to represent the rotated coordinates, leaving the remainder of the matrix unchanged. The output is the transformed 3\u00d73 matrix.",
        "code_id": "c_group_2_id_235",
        "code_text": "Cd4e3208291\nvoid\ng17f971fce1(m63312228ee mb8bcb57dcd, float a1cb113c089) {\nfloat m73982a8772 = mb8bcb57dcd[0][0],  m238447af68 = mb8bcb57dcd[1][0],\nm16a47ac378 = mb8bcb57dcd[0][1],  md6bc4e094a = mb8bcb57dcd[1][1],\nm01d53bdc5e = mb8bcb57dcd[0][2],  m443a13e814 = mb8bcb57dcd[1][2];\nfloat cdcd5d1f3d2, s3b9d266e2e;\ns3b9d266e2e = sinf(a1cb113c089);\ncdcd5d1f3d2 = cosf(a1cb113c089);\nmb8bcb57dcd[0][0] = m73982a8772 * cdcd5d1f3d2 + m238447af68 * s3b9d266e2e;\nmb8bcb57dcd[0][1] = m16a47ac378 * cdcd5d1f3d2 + md6bc4e094a * s3b9d266e2e;\nmb8bcb57dcd[0][2] = m01d53bdc5e * cdcd5d1f3d2 + m443a13e814 * s3b9d266e2e;\nmb8bcb57dcd[1][0] = m73982a8772 * -s3b9d266e2e + m238447af68 * cdcd5d1f3d2;\nmb8bcb57dcd[1][1] = m16a47ac378 * -s3b9d266e2e + md6bc4e094a * cdcd5d1f3d2;\nmb8bcb57dcd[1][2] = m01d53bdc5e * -s3b9d266e2e + m443a13e814 * cdcd5d1f3d2;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_236",
        "query_text": "SUMMARY: This function takes a two-element integer array (ivec2) and an integer scalar as inputs, and it produces a two-element integer array as output. It adds the scalar value to each element of the input array and stores the results in the output array.",
        "code_id": "c_group_2_id_236",
        "code_text": "Cd4e3208291\nvoid\ng789b3d902f(i5e3d0f10c1 v91082a9365, int s3b9d266e2e, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] + s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_237",
        "query_text": "SUMMARY: This function accepts two input variables and one output variable, each being a 3-element array of floats (vec3). It updates every component of the output array by subtracting the combined sum of the corresponding components from the two input arrays. Specifically, for each of the three positions, the function deducts the sum of the respective float values from the input arrays from the float value at the corresponding position in the output array.",
        "code_id": "c_group_2_id_237",
        "code_text": "Cd4e3208291\nvoid\ng42ae045a9b(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] + bba3ae37d1f[1];\nd9748d673c4[2] -= ad90770d038[2] + bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_238",
        "query_text": "SUMMARY: The function receives an input of type const float* (an array of consecutive floating\u2010point numbers) and produces an output of type mat2x3 (a 2-element array where each element is a 3-element float vector). It constructs a 2\u00d73 matrix by assigning the first three floats from the input to populate the first row (3-element vector) of the matrix and the next three floats to the second row.",
        "code_id": "c_group_2_id_238",
        "code_text": "Cd4e3208291\nvoid\ng7446ce5f98(const float * __restrict sa425380d12, mc11cae8baa d9748d673c4) {\nd9748d673c4[0][0] = sa425380d12[0];\nd9748d673c4[0][1] = sa425380d12[1];\nd9748d673c4[0][2] = sa425380d12[2];\nd9748d673c4[1][0] = sa425380d12[3];\nd9748d673c4[1][1] = sa425380d12[4];\nd9748d673c4[1][2] = sa425380d12[5];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_239",
        "query_text": "SUMMARY: This function takes an input of type vec2 (an array of 2 floats representing a complex number with a real and an imaginary part) and produces an output of the same type. It computes the conjugate of the complex number represented by the input, maintaining the real component unchanged while negating the imaginary component. Specifically, it assigns the first element of the input to the first element of the output and assigns the negative of the second element of the input to the second element of the output.",
        "code_id": "c_group_2_id_239",
        "code_text": "Cd4e3208291\nvoid\ng80f0e7628c(v0131f5a9ae ad90770d038, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] =  ad90770d038[0];\nd9748d673c4[1] = -ad90770d038[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_240",
        "query_text": "SUMMARY: This function accepts as inputs an array consisting of two three-dimensional vectors (each vector is a float[3]), a constant character pointer (serving as an optional tag), and an output stream pointer of type FILE*. Its output is void. The function prints a formatted representation of an axis\u2010aligned bounding box by displaying the two 3D vectors (typically representing the minimum and maximum corners) to the given output stream. It begins by printing a header that includes the provided tag (or a default string if none is provided) with specific color formatting. Then, for each of the two vectors, it prints their three float components using a conditional format based on the magnitude of the value\u2014using a fixed decimal precision for smaller numbers or a general format otherwise. Finally, it concludes by resetting the color format.",
        "code_id": "c_group_2_id_240",
        "code_text": "Cd4e3208291\nvoid\ng799c9a1c30(veb444e7eb8                    b7072077cf6[2],\nconst char * __restrict te0dd5c0f2e,\nFILE       * __restrict o5450e5c91d) {\nint i0c6e314cec, jbd3357c513;\n#define mb8bcb57dcd 3\nfprintf(o5450e5c91d, \"AABB (%s): \" C45893ec2b2 \"\\n\", te0dd5c0f2e ? te0dd5c0f2e: \"float\");\nfor (i0c6e314cec = 0; i0c6e314cec < 2; i0c6e314cec++) {\nfprintf(o5450e5c91d, \"  (\");\nfor (jbd3357c513 = 0; jbd3357c513 < mb8bcb57dcd; jbd3357c513++) {\nif (b7072077cf6[i0c6e314cec][jbd3357c513] < Cd0da13f7c8)\nfprintf(o5450e5c91d, \" % .*f\", Cb46738fea8, (double)b7072077cf6[i0c6e314cec][jbd3357c513]);\nelse\nfprintf(o5450e5c91d, \" % g\", (double)b7072077cf6[i0c6e314cec][jbd3357c513]);\n}\nfprintf(o5450e5c91d, \"  )\\n\");\n}\nfprintf(o5450e5c91d, C7c34c62781 \"\\n\");\n#undef mb8bcb57dcd\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_241",
        "query_text": "SUMMARY: This function converts a 3\u00d73 rotation matrix (input type: an array of three 3-element float vectors) into a quaternion (output type: a 4-element aligned float vector). It first computes the sum of the three diagonal elements of the matrix and then, based on whether this trace is nonnegative or if one of the specific diagonal elements is dominant, it selects one of several computation paths. Each path calculates a scaling factor from the square root of an expression involving the trace or a diagonal element, and then uses this factor to compute the four components of the quaternion from specific differences and sums of the matrix\u2019s off-diagonal elements.",
        "code_id": "c_group_2_id_241",
        "code_text": "Cd4e3208291\nvoid\ngc565917c79(m63312228ee mb8bcb57dcd, v6c437193eb d9748d673c4) {\nfloat t98713f8c98, r01fae08b89, r373f8408bb;\n\nt98713f8c98 = mb8bcb57dcd[0][0] + mb8bcb57dcd[1][1] + mb8bcb57dcd[2][2];\nif (t98713f8c98 >= 0.0f) {\nr01fae08b89       = sqrtf(1.0f + t98713f8c98);\nr373f8408bb    = 0.5f / r01fae08b89;\nd9748d673c4[0] = r373f8408bb * (mb8bcb57dcd[1][2] - mb8bcb57dcd[2][1]);\nd9748d673c4[1] = r373f8408bb * (mb8bcb57dcd[2][0] - mb8bcb57dcd[0][2]);\nd9748d673c4[2] = r373f8408bb * (mb8bcb57dcd[0][1] - mb8bcb57dcd[1][0]);\nd9748d673c4[3] = r01fae08b89    * 0.5f;\n} else if (mb8bcb57dcd[0][0] >= mb8bcb57dcd[1][1] && mb8bcb57dcd[0][0] >= mb8bcb57dcd[2][2]) {\nr01fae08b89       = sqrtf(1.0f - mb8bcb57dcd[1][1] - mb8bcb57dcd[2][2] + mb8bcb57dcd[0][0]);\nr373f8408bb    = 0.5f / r01fae08b89;\nd9748d673c4[0] = r01fae08b89    * 0.5f;\nd9748d673c4[1] = r373f8408bb * (mb8bcb57dcd[0][1] + mb8bcb57dcd[1][0]);\nd9748d673c4[2] = r373f8408bb * (mb8bcb57dcd[0][2] + mb8bcb57dcd[2][0]);\nd9748d673c4[3] = r373f8408bb * (mb8bcb57dcd[1][2] - mb8bcb57dcd[2][1]);\n} else if (mb8bcb57dcd[1][1] >= mb8bcb57dcd[2][2]) {\nr01fae08b89       = sqrtf(1.0f - mb8bcb57dcd[0][0] - mb8bcb57dcd[2][2] + mb8bcb57dcd[1][1]);\nr373f8408bb    = 0.5f / r01fae08b89;\nd9748d673c4[0] = r373f8408bb * (mb8bcb57dcd[0][1] + mb8bcb57dcd[1][0]);\nd9748d673c4[1] = r01fae08b89    * 0.5f;\nd9748d673c4[2] = r373f8408bb * (mb8bcb57dcd[1][2] + mb8bcb57dcd[2][1]);\nd9748d673c4[3] = r373f8408bb * (mb8bcb57dcd[2][0] - mb8bcb57dcd[0][2]);\n} else {\nr01fae08b89       = sqrtf(1.0f - mb8bcb57dcd[0][0] - mb8bcb57dcd[1][1] + mb8bcb57dcd[2][2]);\nr373f8408bb    = 0.5f / r01fae08b89;\nd9748d673c4[0] = r373f8408bb * (mb8bcb57dcd[0][2] + mb8bcb57dcd[2][0]);\nd9748d673c4[1] = r373f8408bb * (mb8bcb57dcd[1][2] + mb8bcb57dcd[2][1]);\nd9748d673c4[2] = r01fae08b89    * 0.5f;\nd9748d673c4[3] = r373f8408bb * (mb8bcb57dcd[0][1] - mb8bcb57dcd[1][0]);\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_242",
        "query_text": "SUMMARY: This function takes a 3-element float array (vec3) and a 4x4 matrix of float values (mat4) as inputs and returns a float. It calculates a transformed depth value by performing two separate dot products between the input vector and specific columns of the matrix, then divides the result of the first computation by that of the second. Essentially, it projects the input 3D coordinate onto the depth axis within a normalized (0 to 1) space using transformation and perspective division.",
        "code_id": "c_group_2_id_242",
        "code_text": "Cd4e3208291\nfloat\ng3a5b42e87d(veb444e7eb8 v91082a9365, m2979ecef6f mb8bcb57dcd) {\nfloat z2f48e9e974, w893b1d140a;\nz2f48e9e974 = mb8bcb57dcd[0][2] * v91082a9365[0] + mb8bcb57dcd[1][2] * v91082a9365[1] + mb8bcb57dcd[2][2] * v91082a9365[2] + mb8bcb57dcd[3][2];\nw893b1d140a = mb8bcb57dcd[0][3] * v91082a9365[0] + mb8bcb57dcd[1][3] * v91082a9365[1] + mb8bcb57dcd[2][3] * v91082a9365[2] + mb8bcb57dcd[3][3];\nreturn z2f48e9e974 / w893b1d140a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_243",
        "query_text": "SUMMARY: This function takes as input a 4x4 matrix of floats (mat4) representing a perspective projection and a pointer to a float (float*). It computes the near clipping distance by processing specific entries from the given matrix and then stores the resulting float value at the provided memory location.",
        "code_id": "c_group_2_id_243",
        "code_text": "Cd4e3208291\nvoid\ngfed10cc5c6(m2979ecef6f paccfd26812, float * __restrict nd3cfbab11c) {\n*nd3cfbab11c = paccfd26812[3][2] / (-paccfd26812[2][2] - 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_244",
        "query_text": "SUMMARY: This function takes a two-element integer array and a single integer as inputs, and outputs a two-element integer array. It multiplies each element of the input array by the given scalar integer, then subtracts each resulting product from the corresponding element in the output array.",
        "code_id": "c_group_2_id_244",
        "code_text": "Cd4e3208291\nvoid\nga978d2f84a(i5e3d0f10c1 ad90770d038, int s3b9d266e2e, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] * s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_245",
        "query_text": "SUMMARY: This function decomposes a 4\u00d74 perspective projection matrix (input type: mat4, which is defined as an array of four 4-element float vectors) into its fundamental frustum parameters. It calculates and outputs the distances to the near and far clipping planes, as well as the top, bottom, left, and right boundaries of the viewing volume. The outputs are provided through pointers to floats (output type: float*). The function extracts specific elements from the matrix and uses arithmetic operations to derive these parameters, effectively reversing the projection transformation to yield the frustum dimensions.",
        "code_id": "c_group_2_id_245",
        "code_text": "Cd4e3208291\nvoid\ng615fcc48af(m2979ecef6f paccfd26812,\nfloat * __restrict nd3cfbab11c, float * __restrict fb6d340e4c8,\nfloat * __restrict td39aaeaeed,     float * __restrict be4ccd944cb,\nfloat * __restrict lcfaba252b8,    float * __restrict rc12144e4ba) {\nfloat m73982a8772, md6bc4e094a, m2134d0010f, m4b629e56ab, m529843770e, m9a4eaa88e8, neb9157c168, f4cff875701;\nfloat n12ece6d2dd, nc740595460;\nm73982a8772 = paccfd26812[0][0];\nmd6bc4e094a = paccfd26812[1][1];\nm2134d0010f = paccfd26812[2][0];\nm4b629e56ab = paccfd26812[2][1];\nm529843770e = paccfd26812[2][2];\nm9a4eaa88e8 = paccfd26812[3][2];\nneb9157c168 = m9a4eaa88e8 / m529843770e;\nf4cff875701 = m9a4eaa88e8 / (m529843770e + 1.0f);\nn12ece6d2dd = neb9157c168 / md6bc4e094a;\nnc740595460 = neb9157c168 / m73982a8772;\n*nd3cfbab11c = neb9157c168;\n*fb6d340e4c8  = f4cff875701;\n*be4ccd944cb  = n12ece6d2dd * (m4b629e56ab - 1.0f);\n*td39aaeaeed     = n12ece6d2dd * (m4b629e56ab + 1.0f);\n*lcfaba252b8    = nc740595460 * (m2134d0010f - 1.0f);\n*rc12144e4ba   = nc740595460 * (m2134d0010f + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_246",
        "query_text": "SUMMARY: This function accepts two inputs of type ivec2 (arrays of two integers) and computes a single integer output. It calculates the dot product by multiplying the first element of the first input with the first element of the second input and then adding the product of the second elements from both inputs.",
        "code_id": "c_group_2_id_246",
        "code_text": "Cd4e3208291\nint\ng84dce6e896(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f) {\nreturn ad90770d038[0] * bba3ae37d1f[0] + ad90770d038[1] * bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_247",
        "query_text": "SUMMARY: This function takes an input of type int[2] and produces an output of type int[2]. It computes the absolute value of each element in the input array and assigns these computed absolute values to the corresponding elements in the output array. Specifically, it applies the absolute value operation individually to the first and second elements of the input.",
        "code_id": "c_group_2_id_247",
        "code_text": "Cd4e3208291\nvoid\ng5596ccd620(i5e3d0f10c1 v91082a9365, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = abs(v91082a9365[0]);\nd9748d673c4[1] = abs(v91082a9365[1]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_248",
        "query_text": "SUMMARY: The function accepts two input vectors and one output vector, each defined as a 2-element array of floats (vec2). It updates the output vector by subtracting, from each element, the difference between the corresponding elements of the first and second input vectors. Specifically, for each index, the function decreases the current value in the output vector by the result of subtracting the second input\u2019s element from the first input\u2019s element.",
        "code_id": "c_group_2_id_248",
        "code_text": "Cd4e3208291\nvoid\ng9e4d75a0fd(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] - bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_249",
        "query_text": "SUMMARY: The function takes a scalar (float) and a four-by-four matrix of floats (mat4) as inputs, modifying the matrix to update its horizontal scaling based on the given aspect ratio. It first checks a critical element in the matrix to determine if adjustment is required; if that element is zero, it returns without change. Otherwise, it recalculates that element using another scaling value from the matrix divided by the input scalar, thereby adjusting the perspective projection parameters accordingly.",
        "code_id": "c_group_2_id_249",
        "code_text": "Cd4e3208291\nvoid\ng1134720038(float a9ac3d8bc0c, m2979ecef6f paccfd26812) {\nif (paccfd26812[0][0] == 0.0f)\nreturn;\npaccfd26812[0][0] = paccfd26812[1][1] / a9ac3d8bc0c;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_250",
        "query_text": "SUMMARY: This function takes an input of type mat3x2 (an array of three 2-element float arrays) and produces an output of type mat2x3 (an array of two 3-element float arrays). It computes the transpose of the matrix by swapping the rows and columns, assigning each element from the input to the corresponding position in the output matrix.",
        "code_id": "c_group_2_id_250",
        "code_text": "Cd4e3208291\nvoid\ngefc3f626fe(m5fbc7d59b5 mb8bcb57dcd, mc11cae8baa d9748d673c4) {\nd9748d673c4[0][0] = mb8bcb57dcd[0][0];  d9748d673c4[0][1] = mb8bcb57dcd[1][0];  d9748d673c4[0][2] = mb8bcb57dcd[2][0];\nd9748d673c4[1][0] = mb8bcb57dcd[0][1];  d9748d673c4[1][1] = mb8bcb57dcd[1][1];  d9748d673c4[1][2] = mb8bcb57dcd[2][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_251",
        "query_text": "SUMMARY: This function accepts an input of type float[2] and produces an output of type float[2]. It computes the absolute value for each element of the input array and assigns these results to the corresponding elements of the output array.",
        "code_id": "c_group_2_id_251",
        "code_text": "Cd4e3208291\nvoid\ngc19600818e(v0131f5a9ae v91082a9365, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = fabsf(v91082a9365[0]);\nd9748d673c4[1] = fabsf(v91082a9365[1]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_252",
        "query_text": "SUMMARY: This function accepts an input of type mat4 (a 4\u00d74 matrix composed of vec4 elements) and produces an output of type mat3 (a 3\u00d73 matrix composed of vec3 elements). It extracts the top-left 3\u00d73 block from the 4\u00d74 matrix and assigns its elements to the output matrix in a transposed arrangement. Specifically, for each of the first three rows and columns, it maps the element from the column of the input to the row of the output, effectively transposing that 3\u00d73 portion.",
        "code_id": "c_group_2_id_252",
        "code_text": "Cd4e3208291\nvoid\ngb6f8cb11c6(m2979ecef6f ma02b861363, m63312228ee d9748d673c4) {\nd9748d673c4[0][0] = ma02b861363[0][0];\nd9748d673c4[0][1] = ma02b861363[1][0];\nd9748d673c4[0][2] = ma02b861363[2][0];\nd9748d673c4[1][0] = ma02b861363[0][1];\nd9748d673c4[1][1] = ma02b861363[1][1];\nd9748d673c4[1][2] = ma02b861363[2][1];\nd9748d673c4[2][0] = ma02b861363[0][2];\nd9748d673c4[2][1] = ma02b861363[1][2];\nd9748d673c4[2][2] = ma02b861363[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_253",
        "query_text": "SUMMARY: This function receives a 3-element integer array (type: int[3]) and a pointer to a file stream (type: FILE*) as inputs, and it outputs information to that stream. It formats and prints the vector elements by first indicating the vector's type and size, then listing each integer element with specified formatting (including color settings), and finally resetting the formatting. The function does not return any value.",
        "code_id": "c_group_2_id_253",
        "code_text": "Cd4e3208291\nvoid\ngd75afe37bd(i4b951f731e             vf6195f1fd8,\nFILE * __restrict o5450e5c91d) {\nint i0c6e314cec;\n#define mb8bcb57dcd 3\nfprintf(o5450e5c91d, \"Vector (int%d): \" C45893ec2b2 \"\\n  (\", mb8bcb57dcd);\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++)\nfprintf(o5450e5c91d, \" % d\", vf6195f1fd8[i0c6e314cec]);\nfprintf(o5450e5c91d, \"  )\" C7c34c62781 \"\\n\\n\");\n#undef mb8bcb57dcd\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_254",
        "query_text": "SUMMARY: This function takes an input of type mat2x3 (which is defined as an array of 2 vectors, each being an array of 3 floats) and produces an output of the same type by copying the entire content of the input to the output. It sequentially copies each element from the first vector (3 floats) and then from the second vector (3 floats), ensuring that every float in the 2x3 matrix is duplicated in the destination.",
        "code_id": "c_group_2_id_254",
        "code_text": "Cd4e3208291\nvoid\ngc66d215b0b(mc11cae8baa ma02b861363, mc11cae8baa d9748d673c4) {\nd9748d673c4[0][0] = ma02b861363[0][0];\nd9748d673c4[0][1] = ma02b861363[0][1];\nd9748d673c4[0][2] = ma02b861363[0][2];\nd9748d673c4[1][0] = ma02b861363[1][0];\nd9748d673c4[1][1] = ma02b861363[1][1];\nd9748d673c4[1][2] = ma02b861363[1][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_255",
        "query_text": "SUMMARY: This function accepts an input and an output of type mat4 (an array of four vec4 arrays of float values, representing a 4\u00d74 matrix). It duplicates the matrix by copying each float element from the input matrix to its corresponding position in the output matrix. The process is implemented through explicit element-wise assignment for all rows and columns of the 4\u00d74 matrix.",
        "code_id": "c_group_2_id_255",
        "code_text": "Cd4e3208291\nvoid\ngda303f2418(m2979ecef6f ma02b861363, m2979ecef6f d9748d673c4) {\nd9748d673c4[0][0] = ma02b861363[0][0];  d9748d673c4[1][0] = ma02b861363[1][0];\nd9748d673c4[0][1] = ma02b861363[0][1];  d9748d673c4[1][1] = ma02b861363[1][1];\nd9748d673c4[0][2] = ma02b861363[0][2];  d9748d673c4[1][2] = ma02b861363[1][2];\nd9748d673c4[0][3] = ma02b861363[0][3];  d9748d673c4[1][3] = ma02b861363[1][3];\nd9748d673c4[2][0] = ma02b861363[2][0];  d9748d673c4[3][0] = ma02b861363[3][0];\nd9748d673c4[2][1] = ma02b861363[2][1];  d9748d673c4[3][1] = ma02b861363[3][1];\nd9748d673c4[2][2] = ma02b861363[2][2];  d9748d673c4[3][2] = ma02b861363[3][2];\nd9748d673c4[2][3] = ma02b861363[2][3];  d9748d673c4[3][3] = ma02b861363[3][3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_256",
        "query_text": "SUMMARY: This function accepts a 3\u00d73 matrix (type: mat3) and a 2-element vector (type: vec2) as inputs, and produces a 3\u00d73 matrix (type: mat3) as output. Its behavior involves scaling the first row of the input matrix by the first element of the 2-element vector and scaling the second row by the second element of the vector, while the third row remains unaltered, effectively applying a two-dimensional non-uniform scaling transformation to the matrix.",
        "code_id": "c_group_2_id_256",
        "code_text": "Cd4e3208291\nvoid\nga83c2f279e(m63312228ee mb8bcb57dcd, v0131f5a9ae v91082a9365, m63312228ee d9748d673c4) {\nd9748d673c4[0][0] = mb8bcb57dcd[0][0] * v91082a9365[0];\nd9748d673c4[0][1] = mb8bcb57dcd[0][1] * v91082a9365[0];\nd9748d673c4[0][2] = mb8bcb57dcd[0][2] * v91082a9365[0];\nd9748d673c4[1][0] = mb8bcb57dcd[1][0] * v91082a9365[1];\nd9748d673c4[1][1] = mb8bcb57dcd[1][1] * v91082a9365[1];\nd9748d673c4[1][2] = mb8bcb57dcd[1][2] * v91082a9365[1];\nd9748d673c4[2][0] = mb8bcb57dcd[2][0];\nd9748d673c4[2][1] = mb8bcb57dcd[2][1];\nd9748d673c4[2][2] = mb8bcb57dcd[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_257",
        "query_text": "SUMMARY: This function accepts an input of type mat2x4 (a two-element array where each element is a four-element float vector) and produces an output of type mat4x2 (a four-element array where each element is a two-element float vector). The function computes the transpose of a 2\u00d74 matrix by assigning each element from the corresponding position in the input matrix to its transposed position in the output matrix. Specifically, it maps elements from the rows of the input matrix into the columns of the output matrix, effectively rearranging the data to represent the transposed matrix.",
        "code_id": "c_group_2_id_257",
        "code_text": "Cd4e3208291\nvoid\ng49e01ff890(md4c46ddc0d mb8bcb57dcd, mab2cb9021e d9748d673c4) {\nd9748d673c4[0][0] = mb8bcb57dcd[0][0];  d9748d673c4[0][1] = mb8bcb57dcd[1][0];\nd9748d673c4[1][0] = mb8bcb57dcd[0][1];  d9748d673c4[1][1] = mb8bcb57dcd[1][1];\nd9748d673c4[2][0] = mb8bcb57dcd[0][2];  d9748d673c4[2][1] = mb8bcb57dcd[1][2];\nd9748d673c4[3][0] = mb8bcb57dcd[0][3];  d9748d673c4[3][1] = mb8bcb57dcd[1][3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_258",
        "query_text": "SUMMARY: The function accepts an input variable of type vec4 (an aligned array of 4 floats) and outputs a variable of the same type. It computes the square root of each of the four floating-point numbers in the input, storing the results in the corresponding positions of the output. The implementation automatically selects an optimized vectorized computation path based on the available hardware (using SIMD instructions for WebAssembly or SSE when available), and falls back to a scalar computation using the standard square root function if those are not present.",
        "code_id": "c_group_2_id_258",
        "code_text": "Cd4e3208291\nvoid\ng06cac67bfe(v141258b569 v91082a9365, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_sqrt(glmm_load(v)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_sqrt_ps(glmm_load(v91082a9365)));\n#else\ndest[0] = sqrtf(v[0]);\ndest[1] = sqrtf(v[1]);\ndest[2] = sqrtf(v[2]);\ndest[3] = sqrtf(v[3]);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_259",
        "query_text": "SUMMARY: This function accepts a 3-element floating-point vector (type vec3) representing Euler angles and produces a 4\u00d74 floating-point matrix (type mat4) that encodes a rotation transformation. It computes the sine and cosine of the three angles, calculates specific product combinations of these trigonometric values, and then populates the upper-left 3\u00d73 submatrix with values defining the rotation in 3D space following a Y\u2013Z\u2013X sequence. The remaining matrix elements are set to form an identity in the homogeneous coordinate, ensuring the resulting matrix is suitable for use as a transformation matrix in 3D graphics.",
        "code_id": "c_group_2_id_259",
        "code_text": "Cd4e3208291\nvoid\ng5e65526e92(veb444e7eb8 a9cd9428334, m2979ecef6f d9748d673c4) {\nfloat ced008e8902, ce4f072f817, c6bd6fe7cc6,\ns7d25487ca7, se41a0f503f, s23246ee131, se19167aaa1, c8c16907698, c7c4f6ee9c1, c1e36e0b0af;\ns7d25487ca7   = sinf(a9cd9428334[0]); ced008e8902 = cosf(a9cd9428334[0]);\nse41a0f503f   = sinf(a9cd9428334[1]); ce4f072f817 = cosf(a9cd9428334[1]);\ns23246ee131   = sinf(a9cd9428334[2]); c6bd6fe7cc6 = cosf(a9cd9428334[2]);\nse19167aaa1 = s7d25487ca7 * se41a0f503f;\nc8c16907698 = ced008e8902 * ce4f072f817;\nc7c4f6ee9c1 = ce4f072f817 * s7d25487ca7;\nc1e36e0b0af = ced008e8902 * se41a0f503f;\nd9748d673c4[0][0] =  ce4f072f817 * c6bd6fe7cc6;\nd9748d673c4[0][1] =  s23246ee131;\nd9748d673c4[0][2] = -c6bd6fe7cc6 * se41a0f503f;\nd9748d673c4[1][0] =  se19167aaa1 - c8c16907698 * s23246ee131;\nd9748d673c4[1][1] =  ced008e8902 * c6bd6fe7cc6;\nd9748d673c4[1][2] =  c7c4f6ee9c1 + c1e36e0b0af * s23246ee131;\nd9748d673c4[2][0] =  c1e36e0b0af + c7c4f6ee9c1 * s23246ee131;\nd9748d673c4[2][1] = -c6bd6fe7cc6 * s7d25487ca7;\nd9748d673c4[2][2] =  c8c16907698 - se19167aaa1 * s23246ee131;\nd9748d673c4[0][3] =  0.0f;\nd9748d673c4[1][3] =  0.0f;\nd9748d673c4[2][3] =  0.0f;\nd9748d673c4[3][0] =  0.0f;\nd9748d673c4[3][1] =  0.0f;\nd9748d673c4[3][2] =  0.0f;\nd9748d673c4[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_260",
        "query_text": "SUMMARY: This function operates on three arrays of two integers each. It performs an element-wise multiplication of the first two integer arrays and then subtracts each resulting product from the corresponding element in the output integer array.",
        "code_id": "c_group_2_id_260",
        "code_text": "Cd4e3208291\nvoid\ng69304c1bfd(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] * bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_261",
        "query_text": "SUMMARY: The function accepts an input of type vec3 (a 3-element array of floats) and produces an output of the same type, vec3. It computes the square root of each element in the input array and stores the results in the corresponding elements of the output array.",
        "code_id": "c_group_2_id_261",
        "code_text": "Cd4e3208291\nvoid\ng53127e340a(veb444e7eb8 v91082a9365, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = sqrtf(v91082a9365[0]);\nd9748d673c4[1] = sqrtf(v91082a9365[1]);\nd9748d673c4[2] = sqrtf(v91082a9365[2]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_262",
        "query_text": "SUMMARY: This function takes an input of type \"const float *\" and an output of type \"mat4x2\" (an array of four \"vec2\" elements, where each \"vec2\" is an array of two floats). It sequentially assigns the eight consecutive float values from the input array into the four rows of the output matrix, mapping each pair of floats to the two elements of each row.",
        "code_id": "c_group_2_id_262",
        "code_text": "Cd4e3208291\nvoid\ngfb781782f6(const float * __restrict sa425380d12, mab2cb9021e d9748d673c4) {\nd9748d673c4[0][0] = sa425380d12[0];\nd9748d673c4[0][1] = sa425380d12[1];\nd9748d673c4[1][0] = sa425380d12[2];\nd9748d673c4[1][1] = sa425380d12[3];\nd9748d673c4[2][0] = sa425380d12[4];\nd9748d673c4[2][1] = sa425380d12[5];\nd9748d673c4[3][0] = sa425380d12[6];\nd9748d673c4[3][1] = sa425380d12[7];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_263",
        "query_text": "SUMMARY: This function takes an input variable of type vec4 (an array of 4 floats with potential 16-byte alignment) and copies its contents to an output variable of the same type. The function conditionally uses architecture-specific SIMD instructions when available (such as those from WebAssembly, SSE, or NEON) to perform an efficient copy; otherwise, it falls back to copying each of the four float components individually.",
        "code_id": "c_group_2_id_263",
        "code_text": "Cd4e3208291\nvoid\ng5aa4187d9b(v141258b569 v91082a9365, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, glmm_load(v));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, glmm_load(v91082a9365));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vld1q_f32(v));\n#else\ndest[0] = v[0];\ndest[1] = v[1];\ndest[2] = v[2];\ndest[3] = v[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_264",
        "query_text": "SUMMARY: This function operates on three variables, each being an array of four integers. It takes two input arrays of integers, compares corresponding elements from both arrays, and populates an output array (also of four integers) with the smaller value from each pair.",
        "code_id": "c_group_2_id_264",
        "code_text": "Cd4e3208291\nvoid\ng477c7b1a61(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] < bba3ae37d1f[0] ? ad90770d038[0] : bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] < bba3ae37d1f[1] ? ad90770d038[1] : bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] < bba3ae37d1f[2] ? ad90770d038[2] : bba3ae37d1f[2];\nd9748d673c4[3] = ad90770d038[3] < bba3ae37d1f[3] ? ad90770d038[3] : bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_265",
        "query_text": "SUMMARY: This function takes a 3-element array of floats (representing Euler angles) as input and computes a 4-element array of floats (representing a quaternion) as output. Specifically, it calculates the sine and cosine of half of each Euler angle, with the third angle\u2019s sine negated to accommodate a left-handed coordinate system. It then combines these half-angle trigonometric values using fixed multiplications and additions to form a quaternion that corresponds to an XZY rotation order.",
        "code_id": "c_group_2_id_265",
        "code_text": "Cd4e3208291\nvoid\ng84c8541545(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad =  sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa =  sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = -sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] = -x1dce3a8271 * z8de8afe2d4 * ye938664caa + xa08976ecad * z1a2745c1a8 * ydfce0dcdee;\nd9748d673c4[1] =  x1dce3a8271 * z1a2745c1a8 * ye938664caa - xa08976ecad * z8de8afe2d4 * ydfce0dcdee;\nd9748d673c4[2] =  x1dce3a8271 * z8de8afe2d4 * ydfce0dcdee + xa08976ecad * z1a2745c1a8 * ye938664caa;\nd9748d673c4[3] =  x1dce3a8271 * z1a2745c1a8 * ydfce0dcdee + xa08976ecad * z8de8afe2d4 * ye938664caa;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_266",
        "query_text": "SUMMARY: This function accepts a scalar input of type float and an output matrix of type mat4 (a 4\u00d74 array of floats). It adjusts the perspective projection values within the provided matrix by modifying one of its elements: if the matrix's top-left element is nonzero, it is replaced with the value derived from dividing another specific matrix element (from the second row, second column) by the input float, thereby recalibrating the projection based on the aspect ratio.",
        "code_id": "c_group_2_id_266",
        "code_text": "Cd4e3208291\nvoid\ng85efbc6e15(float a9ac3d8bc0c, m2979ecef6f paccfd26812) {\nif (paccfd26812[0][0] == 0.0f)\nreturn;\npaccfd26812[0][0] = paccfd26812[1][1] / a9ac3d8bc0c;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_267",
        "query_text": "SUMMARY: This function performs a component-wise subtraction between two two-element integer arrays (type: int[2]), storing the result in a third integer array (type: int[2]). It subtracts the first element of the second array from the first element of the first array and similarly subtracts the second element of the second array from the second element of the first array.",
        "code_id": "c_group_2_id_267",
        "code_text": "Cd4e3208291\nvoid\ng0cecdc884d(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] - bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_268",
        "query_text": "SUMMARY: This function accepts two inputs of type integer array of size 3 (representing 3-dimensional integer vectors) and computes, for each of the three positions, the smaller of the corresponding integers. The resulting set of three minimum integers is then stored in an output variable, which is also a 3-element integer array.",
        "code_id": "c_group_2_id_268",
        "code_text": "Cd4e3208291\nvoid\ngc6c876cf3b(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] < bba3ae37d1f[0] ? ad90770d038[0] : bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] < bba3ae37d1f[1] ? ad90770d038[1] : bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] < bba3ae37d1f[2] ? ad90770d038[2] : bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_269",
        "query_text": "SUMMARY: This function receives as input a 3x3 transformation matrix (a matrix consisting of three 3-element float arrays) and a 2D translation vector (an array of two floats). It updates the matrix in place by modifying its bottom row. Specifically, for each element in the bottom row, it adds a weighted sum of the corresponding top-row entries\u2014where the weights are the translation vector\u2019s float components\u2014to the existing bottom row value. The function does not return a value.",
        "code_id": "c_group_2_id_269",
        "code_text": "Cd4e3208291\nvoid\ng55696bca9b(m63312228ee mb8bcb57dcd, v0131f5a9ae v91082a9365) {\nmb8bcb57dcd[2][0] = mb8bcb57dcd[0][0] * v91082a9365[0] + mb8bcb57dcd[1][0] * v91082a9365[1] + mb8bcb57dcd[2][0];\nmb8bcb57dcd[2][1] = mb8bcb57dcd[0][1] * v91082a9365[0] + mb8bcb57dcd[1][1] * v91082a9365[1] + mb8bcb57dcd[2][1];\nmb8bcb57dcd[2][2] = mb8bcb57dcd[0][2] * v91082a9365[0] + mb8bcb57dcd[1][2] * v91082a9365[1] + mb8bcb57dcd[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_270",
        "query_text": "SUMMARY: This function takes two inputs\u2014a 4-element array of floating-point numbers (vec4) and a standard I/O stream pointer of type FILE*\u2014and produces no output value (void). It formats and prints the elements of the 4-element vector to the provided output stream. Specifically, it writes a header indicating that the content is a vector of four floats, then iterates over the four elements, printing each with formatting that adapts based on the magnitude of the number, and finally appends formatting to reset any applied text colors.",
        "code_id": "c_group_2_id_270",
        "code_text": "Cd4e3208291\nvoid\ng577b63a2d2(v141258b569              vf6195f1fd8,\nFILE * __restrict o5450e5c91d) {\nint i0c6e314cec;\n#define mb8bcb57dcd 4\nfprintf(o5450e5c91d, \"Vector (float%d): \" C45893ec2b2 \"\\n  (\", mb8bcb57dcd);\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++) {\nif (vf6195f1fd8[i0c6e314cec] < Cd0da13f7c8)\nfprintf(o5450e5c91d, \" % .*f\", Cb46738fea8, (double)vf6195f1fd8[i0c6e314cec]);\nelse\nfprintf(o5450e5c91d, \" % g\", (double)vf6195f1fd8[i0c6e314cec]);\n}\nfprintf(o5450e5c91d, \"  )\" C7c34c62781 \"\\n\\n\");\n#undef mb8bcb57dcd\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_271",
        "query_text": "SUMMARY: This function multiplies two matrices to produce a 2\u00d72 matrix. It takes as inputs a matrix of type mat4x2 (an array of four 2-element float vectors, representing a 2\u00d74 matrix in column-major format) and a matrix of type mat2x4 (an array of two 4-element float vectors, representing a 4\u00d72 matrix in column-major format). The function computes each element of the output matrix (of type mat2, which is an array of two 2-element float vectors, representing a 2\u00d72 matrix) by calculating the dot products between corresponding rows (derived from the columns of the first input) and columns (derived from the columns of the second input).",
        "code_id": "c_group_2_id_271",
        "code_text": "Cd4e3208291\nvoid\ngc8e70514a5(mab2cb9021e m7f4f0cd2cb, md4c46ddc0d m71ae398200, mde4d4e4936 d9748d673c4) {\nfloat a79034f70a3 = m7f4f0cd2cb[0][0], af8ba94e471 = m7f4f0cd2cb[0][1],\na00a7244c30 = m7f4f0cd2cb[1][0], a90b743b58c = m7f4f0cd2cb[1][1],\nabbf182117b = m7f4f0cd2cb[2][0], a76187ed5e7 = m7f4f0cd2cb[2][1],\na41ecaed138 = m7f4f0cd2cb[3][0], aa638243179 = m7f4f0cd2cb[3][1],\nb24ae8206ee = m71ae398200[0][0], ba7a975e23f = m71ae398200[0][1], b26594d8877 = m71ae398200[0][2], bebf1936a06 = m71ae398200[0][3],\nbd4c89897d0 = m71ae398200[1][0], b339ffe7279 = m71ae398200[1][1], bfa76c9278d = m71ae398200[1][2], b8172d1952c = m71ae398200[1][3];\nd9748d673c4[0][0] = a79034f70a3 * b24ae8206ee + a00a7244c30 * ba7a975e23f + abbf182117b * b26594d8877 + a41ecaed138 * bebf1936a06;\nd9748d673c4[0][1] = af8ba94e471 * b24ae8206ee + a90b743b58c * ba7a975e23f + a76187ed5e7 * b26594d8877 + aa638243179 * bebf1936a06;\nd9748d673c4[1][0] = a79034f70a3 * bd4c89897d0 + a00a7244c30 * b339ffe7279 + abbf182117b * bfa76c9278d + a41ecaed138 * b8172d1952c;\nd9748d673c4[1][1] = af8ba94e471 * bd4c89897d0 + a90b743b58c * b339ffe7279 + a76187ed5e7 * bfa76c9278d + aa638243179 * b8172d1952c;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_272",
        "query_text": "SUMMARY: This function accepts a 3-element float array (vec3) representing Euler angles (in radians) and produces a 4\u00d74 float matrix (mat4) that encodes the corresponding rotation transformation. It computes the sine and cosine of each Euler angle, combines these trigonometric results into intermediate values, and assigns them to specific elements in the matrix to construct a homogeneous rotation matrix based on rotations about the X, Y, and Z axes.",
        "code_id": "c_group_2_id_272",
        "code_text": "Cd4e3208291\nvoid\ng21261263bc(veb444e7eb8 a9cd9428334, m2979ecef6f d9748d673c4) {\nfloat ced008e8902, ce4f072f817, c6bd6fe7cc6,\ns7d25487ca7, se41a0f503f, s23246ee131, cc3c3a71c06, c6de4c4d8c3, s8f0754e783;\ns7d25487ca7   = sinf(a9cd9428334[0]); ced008e8902 = cosf(a9cd9428334[0]);\nse41a0f503f   = sinf(a9cd9428334[1]); ce4f072f817 = cosf(a9cd9428334[1]);\ns23246ee131   = sinf(a9cd9428334[2]); c6bd6fe7cc6 = cosf(a9cd9428334[2]);\ncc3c3a71c06 = c6bd6fe7cc6 * s7d25487ca7;\nc6de4c4d8c3 = ced008e8902 * c6bd6fe7cc6;\ns8f0754e783 = se41a0f503f * s23246ee131;\nd9748d673c4[0][0] =  ce4f072f817 * c6bd6fe7cc6;\nd9748d673c4[0][1] =  cc3c3a71c06 * se41a0f503f + ced008e8902 * s23246ee131;\nd9748d673c4[0][2] = -c6de4c4d8c3 * se41a0f503f + s7d25487ca7 * s23246ee131;\nd9748d673c4[1][0] = -ce4f072f817 * s23246ee131;\nd9748d673c4[1][1] =  c6de4c4d8c3 - s7d25487ca7 * s8f0754e783;\nd9748d673c4[1][2] =  cc3c3a71c06 + ced008e8902 * s8f0754e783;\nd9748d673c4[2][0] =  se41a0f503f;\nd9748d673c4[2][1] = -ce4f072f817 * s7d25487ca7;\nd9748d673c4[2][2] =  ced008e8902 * ce4f072f817;\nd9748d673c4[0][3] =  0.0f;\nd9748d673c4[1][3] =  0.0f;\nd9748d673c4[2][3] =  0.0f;\nd9748d673c4[3][0] =  0.0f;\nd9748d673c4[3][1] =  0.0f;\nd9748d673c4[3][2] =  0.0f;\nd9748d673c4[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_273",
        "query_text": "SUMMARY: This function takes a 3-element floating\u2010point array (vec3) representing Euler angles and computes a 4\u00d74 floating\u2010point matrix (mat4) that represents a rotation transformation. It first calculates the sine and cosine for each of the three angles and then uses their combinations to form the components of the rotation matrix according to an XZY rotation order. Finally, it ensures that the matrix is in homogeneous form by setting the appropriate elements for translation and scaling (with the bottom row having [0, 0, 0, 1]).",
        "code_id": "c_group_2_id_273",
        "code_text": "Cd4e3208291\nvoid\ngeb449ee183(veb444e7eb8 a9cd9428334, m2979ecef6f d9748d673c4) {\nfloat ced008e8902, ce4f072f817, c6bd6fe7cc6,\ns7d25487ca7, se41a0f503f, s23246ee131, se19167aaa1, c7c4f6ee9c1, c1e36e0b0af, c8c16907698;\ns7d25487ca7   = sinf(a9cd9428334[0]); ced008e8902 = cosf(a9cd9428334[0]);\nse41a0f503f   = sinf(a9cd9428334[1]); ce4f072f817 = cosf(a9cd9428334[1]);\ns23246ee131   = sinf(a9cd9428334[2]); c6bd6fe7cc6 = cosf(a9cd9428334[2]);\nse19167aaa1 = s7d25487ca7 * se41a0f503f;\nc7c4f6ee9c1 = ce4f072f817 * s7d25487ca7;\nc1e36e0b0af = ced008e8902 * se41a0f503f;\nc8c16907698 = ced008e8902 * ce4f072f817;\nd9748d673c4[0][0] =  ce4f072f817 * c6bd6fe7cc6;\nd9748d673c4[0][1] =  se19167aaa1 + c8c16907698 * s23246ee131;\nd9748d673c4[0][2] = -c1e36e0b0af + c7c4f6ee9c1 * s23246ee131;\nd9748d673c4[1][0] = -s23246ee131;\nd9748d673c4[1][1] =  ced008e8902 * c6bd6fe7cc6;\nd9748d673c4[1][2] =  c6bd6fe7cc6 * s7d25487ca7;\nd9748d673c4[2][0] =  c6bd6fe7cc6 * se41a0f503f;\nd9748d673c4[2][1] = -c7c4f6ee9c1 + c1e36e0b0af * s23246ee131;\nd9748d673c4[2][2] =  c8c16907698 + se19167aaa1 * s23246ee131;\nd9748d673c4[0][3] =  0.0f;\nd9748d673c4[1][3] =  0.0f;\nd9748d673c4[2][3] =  0.0f;\nd9748d673c4[3][0] =  0.0f;\nd9748d673c4[3][1] =  0.0f;\nd9748d673c4[3][2] =  0.0f;\nd9748d673c4[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_274",
        "query_text": "SUMMARY: This function accepts an input of a 4\u00d74 matrix of floats (mat4) representing a right-handed perspective projection and computes six frustum parameters, outputting them as float values via pointer arguments. Specifically, it calculates the near and far plane distances as well as the top, bottom, left, and right boundaries of the view frustum based on the elements of the input matrix, and then stores these computed values in the provided float pointers.",
        "code_id": "c_group_2_id_274",
        "code_text": "Cd4e3208291\nvoid\ng8cbef994e5(m2979ecef6f paccfd26812,\nfloat * __restrict nd3cfbab11c, float * __restrict fb6d340e4c8,\nfloat * __restrict td39aaeaeed,     float * __restrict be4ccd944cb,\nfloat * __restrict lcfaba252b8,    float * __restrict rc12144e4ba) {\nfloat m73982a8772, md6bc4e094a, m2134d0010f, m4b629e56ab, m529843770e, m9a4eaa88e8, neb9157c168, f4cff875701;\nfloat n12ece6d2dd, nc740595460;\nm73982a8772 = paccfd26812[0][0];\nmd6bc4e094a = paccfd26812[1][1];\nm2134d0010f = paccfd26812[2][0];\nm4b629e56ab = paccfd26812[2][1];\nm529843770e = paccfd26812[2][2];\nm9a4eaa88e8 = paccfd26812[3][2];\nneb9157c168 = m9a4eaa88e8 / (m529843770e - 1.0f);\nf4cff875701 = m9a4eaa88e8 / (m529843770e + 1.0f);\nn12ece6d2dd = neb9157c168 / md6bc4e094a;\nnc740595460 = neb9157c168 / m73982a8772;\n*nd3cfbab11c = neb9157c168;\n*fb6d340e4c8  = f4cff875701;\n*be4ccd944cb  = n12ece6d2dd * (m4b629e56ab - 1.0f);\n*td39aaeaeed     = n12ece6d2dd * (m4b629e56ab + 1.0f);\n*lcfaba252b8    = nc740595460 * (m2134d0010f - 1.0f);\n*rc12144e4ba   = nc740595460 * (m2134d0010f + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_275",
        "query_text": "SUMMARY: This function accepts a 2\u00d72 matrix of 2-element floating\u2010point arrays (a 2\u00d72 float matrix with potential 16\u2011byte alignment) and a pointer to a FILE stream as its inputs, and it produces no output (void return type). Its purpose is to print the matrix in a formatted and human-readable way. Initially, it writes a header stating the type and dimensions of the matrix, then it calculates the appropriate column widths for each matrix element based on a chosen precision and a threshold that decides between fixed-point and general formatting. Finally, it prints each row of the matrix with the elements right\u2010aligned using the determined widths, ensuring the output is neatly formatted within decorative boundary characters, and resets any applied formatting at the end.",
        "code_id": "c_group_2_id_275",
        "code_text": "Cd4e3208291\nvoid\ng8078753943(mde4d4e4936              ma09c4861bd,\nFILE * __restrict o5450e5c91d) {\nchar b99ab09a63e[16];\nint  i0c6e314cec, jbd3357c513, ce3a4cd4f8f[4], c00eff67c74;\n#define mb8bcb57dcd 2\n#define neb9157c168 2\nfprintf(o5450e5c91d, \"Matrix (float%dx%d): \" C45893ec2b2 \"\\n\", mb8bcb57dcd, neb9157c168);\nce3a4cd4f8f[0] = ce3a4cd4f8f[1] = 0;\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++) {\nfor (jbd3357c513 = 0; jbd3357c513 < neb9157c168; jbd3357c513++) {\nif (ma09c4861bd[i0c6e314cec][jbd3357c513] < Cd0da13f7c8)\nc00eff67c74 = snprintf(b99ab09a63e, sizeof(b99ab09a63e), \"% .*f\", Cb46738fea8, (double)ma09c4861bd[i0c6e314cec][jbd3357c513]);\nelse\nc00eff67c74 = snprintf(b99ab09a63e, sizeof(b99ab09a63e), \"% g\", (double)ma09c4861bd[i0c6e314cec][jbd3357c513]);\nce3a4cd4f8f[i0c6e314cec] = Gce27a59f0b(ce3a4cd4f8f[i0c6e314cec], c00eff67c74);\n}\n}\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++) {\nfprintf(o5450e5c91d, \"  |\");\nfor (jbd3357c513 = 0; jbd3357c513 < neb9157c168; jbd3357c513++)\nif (ma09c4861bd[i0c6e314cec][jbd3357c513] < Cd0da13f7c8)\nfprintf(o5450e5c91d, \" % *.*f\", ce3a4cd4f8f[jbd3357c513], Cb46738fea8, (double)ma09c4861bd[jbd3357c513][i0c6e314cec]);\nelse\nfprintf(o5450e5c91d, \" % *g\", ce3a4cd4f8f[jbd3357c513], (double)ma09c4861bd[jbd3357c513][i0c6e314cec]);\nfprintf(o5450e5c91d, \"  |\\n\");\n}\nfprintf(o5450e5c91d, C7c34c62781 \"\\n\");\n#undef mb8bcb57dcd\n#undef neb9157c168\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_276",
        "query_text": "SUMMARY: This function takes as input a 4-element float array (type vec4) and a single float scalar, and produces an output 4-element float array (type vec4). Its behavior is to add the scalar to each component of the input array and store the resulting values in the output array. The implementation optimizes this addition using platform-specific SIMD operations when available, but the core functionality remains adding the scalar value to every element of the input vector.",
        "code_id": "c_group_2_id_276",
        "code_text": "Cd4e3208291\nvoid\ng56f0aa0c85(v141258b569 v91082a9365, float s3b9d266e2e, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_add(glmm_load(v), wasm_f32x4_splat(s)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_add_ps(glmm_load(v91082a9365), _mm_set1_ps(s3b9d266e2e)));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vaddq_f32(vld1q_f32(v), vdupq_n_f32(s)));\n#else\ndest[0] = v[0] + s;\ndest[1] = v[1] + s;\ndest[2] = v[2] + s;\ndest[3] = v[3] + s;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_277",
        "query_text": "SUMMARY: The function accepts an input of type \"mat4\" (a 4x4 matrix composed of four float[4] vectors) and an output pointer of type \"float*\". It extracts a specific element from the projection matrix and uses it, along with another matrix element, to calculate the value representing the far clipping plane distance, which is then stored via the provided float pointer.",
        "code_id": "c_group_2_id_277",
        "code_text": "Cd4e3208291\nvoid\ngacd1debf43(m2979ecef6f paccfd26812, float * __restrict fb6d340e4c8) {\n*fb6d340e4c8 = paccfd26812[3][2] / (paccfd26812[2][2] + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_278",
        "query_text": "SUMMARY: This function converts a set of Euler angles into a quaternion using a right-handed coordinate system. It accepts as input a three-element floating\u2011point array (vec3) representing the Euler angles and produces as output a four-element floating\u2011point array (versor) representing the quaternion. The function computes the sine and cosine of half each Euler angle and then combines these intermediate values to form the quaternion components.",
        "code_id": "c_group_2_id_278",
        "code_text": "Cd4e3208291\nvoid\ng1ada2698db(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad = sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa = sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] =  z1a2745c1a8 * ydfce0dcdee * xa08976ecad - z8de8afe2d4 * ye938664caa * x1dce3a8271;\nd9748d673c4[1] =  z1a2745c1a8 * ye938664caa * x1dce3a8271 + z8de8afe2d4 * ydfce0dcdee * xa08976ecad;\nd9748d673c4[2] = -z1a2745c1a8 * ye938664caa * xa08976ecad + z8de8afe2d4 * ydfce0dcdee * x1dce3a8271;\nd9748d673c4[3] =  z1a2745c1a8 * ydfce0dcdee * x1dce3a8271 + z8de8afe2d4 * ye938664caa * xa08976ecad;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_279",
        "query_text": "SUMMARY: This function accepts two input arrays of three floats each and modifies a third array of three floats. For each of the three components, it sums the corresponding float from each of the two input arrays and then adds this sum to the corresponding component in the output array. The function operates in-place on the output array without returning a value.",
        "code_id": "c_group_2_id_279",
        "code_text": "Cd4e3208291\nvoid\ng897566867d(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] + bba3ae37d1f[1];\nd9748d673c4[2] += ad90770d038[2] + bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_280",
        "query_text": "SUMMARY: This function receives three parameters: an input array of 4 integers (ivec4), an integer scalar, and an output array of 4 integers (ivec4). It multiplies each element of the input array by the scalar and then adds the resulting product to the corresponding element of the output array, executing these operations component-wise.",
        "code_id": "c_group_2_id_280",
        "code_text": "Cd4e3208291\nvoid\ng03e1bd6890(i52a86355e2 ad90770d038, int s3b9d266e2e, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] * s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] * s3b9d266e2e;\nd9748d673c4[2] += ad90770d038[2] * s3b9d266e2e;\nd9748d673c4[3] += ad90770d038[3] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_281",
        "query_text": "SUMMARY: This function accepts two input parameters of type integer array with 2 elements each and a destination output parameter of the same type. It computes the product of the first element from each of the input arrays and adds the result to the first element of the destination array, then does the same for the second element.",
        "code_id": "c_group_2_id_281",
        "code_text": "Cd4e3208291\nvoid\ngbce4474192(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] * bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_282",
        "query_text": "SUMMARY: This function accepts two input parameters of type vec3 (an array of 3 floats) and produces no direct return value. It copies the three floating-point numbers from the source array (input type: vec3) into the destination array (output type: vec3) by individually assigning each corresponding element, effectively duplicating the entire 3-component vector.",
        "code_id": "c_group_2_id_282",
        "code_text": "Cd4e3208291\nvoid\ng2e62325f5d(veb444e7eb8 ad90770d038, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0];\nd9748d673c4[1] = ad90770d038[1];\nd9748d673c4[2] = ad90770d038[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_283",
        "query_text": "SUMMARY: This function takes as inputs a matrix of type mat3 (a 3\u00d73 array of floats) and a scalar of type float. Its purpose is to scale the matrix by the given scalar factor. Line by line, each element of the 3\u00d73 matrix is multiplied by the scalar, modifying the matrix in place. There is no explicit output since the transformation occurs directly on the provided matrix.",
        "code_id": "c_group_2_id_283",
        "code_text": "Cd4e3208291\nvoid\ng8f3ab7ad94(m63312228ee mb8bcb57dcd, float s3b9d266e2e) {\nmb8bcb57dcd[0][0] *= s3b9d266e2e; mb8bcb57dcd[0][1] *= s3b9d266e2e; mb8bcb57dcd[0][2] *= s3b9d266e2e;\nmb8bcb57dcd[1][0] *= s3b9d266e2e; mb8bcb57dcd[1][1] *= s3b9d266e2e; mb8bcb57dcd[1][2] *= s3b9d266e2e;\nmb8bcb57dcd[2][0] *= s3b9d266e2e; mb8bcb57dcd[2][1] *= s3b9d266e2e; mb8bcb57dcd[2][2] *= s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_284",
        "query_text": "SUMMARY: This function accepts two 4-element arrays of integers (type: ivec4) and returns an integer (type: int). It computes the squared Euclidean distance between the two 4-dimensional integer vectors by subtracting corresponding components, squaring each difference, and summing the squared values.",
        "code_id": "c_group_2_id_284",
        "code_text": "Cd4e3208291\nint\ngb90b9ef660(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f) {\nint x81a09a0ef5, yb011f21308, zdcf909fec1, wa8ffd4895e;\nx81a09a0ef5 = ad90770d038[0] - bba3ae37d1f[0];\nyb011f21308 = ad90770d038[1] - bba3ae37d1f[1];\nzdcf909fec1 = ad90770d038[2] - bba3ae37d1f[2];\nwa8ffd4895e = ad90770d038[3] - bba3ae37d1f[3];\nreturn x81a09a0ef5 * x81a09a0ef5 + yb011f21308 * yb011f21308 + zdcf909fec1 * zdcf909fec1 + wa8ffd4895e * wa8ffd4895e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_285",
        "query_text": "SUMMARY: This function accepts two inputs, each being an array of three integers (ivec3), multiplies their corresponding elements, sums these products, and returns the resulting sum as an integer.",
        "code_id": "c_group_2_id_285",
        "code_text": "Cd4e3208291\nint\ng2339672154(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f) {\nreturn ad90770d038[0] * bba3ae37d1f[0] + ad90770d038[1] * bba3ae37d1f[1] + ad90770d038[2] * bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_286",
        "query_text": "SUMMARY: This function takes a 3x3 matrix of floats (mat3), a floating-point rotation angle (float), and produces a 3x3 matrix of floats (mat3) as its output. It applies a two-dimensional rotation by the specified angle to the first two rows of the input matrix while keeping the third row unchanged, effectively transforming the input matrix with the given rotation.",
        "code_id": "c_group_2_id_286",
        "code_text": "Cd4e3208291\nvoid\ng1631e3118c(m63312228ee mb8bcb57dcd, float a1cb113c089, m63312228ee d9748d673c4) {\nfloat m73982a8772 = mb8bcb57dcd[0][0],  m238447af68 = mb8bcb57dcd[1][0],\nm16a47ac378 = mb8bcb57dcd[0][1],  md6bc4e094a = mb8bcb57dcd[1][1],\nm01d53bdc5e = mb8bcb57dcd[0][2],  m443a13e814 = mb8bcb57dcd[1][2];\nfloat cdcd5d1f3d2, s3b9d266e2e;\ns3b9d266e2e = sinf(a1cb113c089);\ncdcd5d1f3d2 = cosf(a1cb113c089);\nd9748d673c4[0][0] = m73982a8772 * cdcd5d1f3d2 + m238447af68 * s3b9d266e2e;\nd9748d673c4[0][1] = m16a47ac378 * cdcd5d1f3d2 + md6bc4e094a * s3b9d266e2e;\nd9748d673c4[0][2] = m01d53bdc5e * cdcd5d1f3d2 + m443a13e814 * s3b9d266e2e;\nd9748d673c4[1][0] = m73982a8772 * -s3b9d266e2e + m238447af68 * cdcd5d1f3d2;\nd9748d673c4[1][1] = m16a47ac378 * -s3b9d266e2e + md6bc4e094a * cdcd5d1f3d2;\nd9748d673c4[1][2] = m01d53bdc5e * -s3b9d266e2e + m443a13e814 * cdcd5d1f3d2;\nd9748d673c4[2][0] = mb8bcb57dcd[2][0];\nd9748d673c4[2][1] = mb8bcb57dcd[2][1];\nd9748d673c4[2][2] = mb8bcb57dcd[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_287",
        "query_text": "SUMMARY: This function receives two inputs, each being an array of three integers (type int[3]), and computes a component-wise multiplication of these arrays. The result, which is also an array of three integers (type int[3]), is produced by multiplying the corresponding elements of the input arrays.",
        "code_id": "c_group_2_id_287",
        "code_text": "Cd4e3208291\nvoid\ng56d66d0c2f(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] * bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] * bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_288",
        "query_text": "SUMMARY: This function accepts two parameters, both of which are arrays of three integers (type: ivec3). It replicates the entire content of the first array into the second array by copying each of the three elements individually.",
        "code_id": "c_group_2_id_288",
        "code_text": "Cd4e3208291\nvoid\ng9a19c101d6(i4b951f731e ad90770d038, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0];\nd9748d673c4[1] = ad90770d038[1];\nd9748d673c4[2] = ad90770d038[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_289",
        "query_text": "SUMMARY: The function accepts a two-element integer array (ivec2) and two integers representing a lower and an upper bound. It operates in place by adjusting the values of the array so that each element lies within the inclusive range defined by these minimum and maximum bounds, returning the modified array as the output.",
        "code_id": "c_group_2_id_289",
        "code_text": "Cd4e3208291\nvoid\ng33193d3222(i5e3d0f10c1 v91082a9365, int m5d862d9243, int mfb64f1df94) {\nif (v91082a9365[0] < m5d862d9243)\nv91082a9365[0] = m5d862d9243;\nelse if(v91082a9365[0] > mfb64f1df94)\nv91082a9365[0] = mfb64f1df94;\nif (v91082a9365[1] < m5d862d9243)\nv91082a9365[1] = m5d862d9243;\nelse if(v91082a9365[1] > mfb64f1df94)\nv91082a9365[1] = mfb64f1df94;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_290",
        "query_text": "SUMMARY: This function accepts three inputs of type vec4 (each being an array of four floats) and updates a fourth vector (also of type vec4) by adding the corresponding components of the first two inputs to those of the output variable. In essence, it performs an element-wise addition where each output component becomes the sum of its previous value plus the corresponding components from the two input vectors. The computation is carried out using platform-specific SIMD instructions when available, resorting to a straightforward element-wise computation otherwise.",
        "code_id": "c_group_2_id_290",
        "code_text": "Cd4e3208291\nvoid\ng0db8ce8956(v141258b569 ad90770d038, v141258b569 bba3ae37d1f, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_add(\ng86f14e15d6(dest),\nwasm_f32x4_add(g86f14e15d6(a), g86f14e15d6(b))));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_add_ps(g86f14e15d6(d9748d673c4),\n_mm_add_ps(g86f14e15d6(ad90770d038),\ng86f14e15d6(bba3ae37d1f))));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vaddq_f32(vld1q_f32(dest),\nvaddq_f32(vld1q_f32(a),\nvld1q_f32(b))));\n#else\ndest[0] += a[0] + b[0];\ndest[1] += a[1] + b[1];\ndest[2] += a[2] + b[2];\ndest[3] += a[3] + b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_291",
        "query_text": "SUMMARY: This function takes as input a two-dimensional matrix (of type \"mat2\", which is a two-element array of 2-element float vectors) along with two integer indices. It operates by exchanging the entire contents of the two columns specified by the integer inputs. The matrix, which serves as the output (modified in place), has its specified columns swapped, and no new data is returned.",
        "code_id": "c_group_2_id_291",
        "code_text": "Cd4e3208291\nvoid\ng7055e06659(mde4d4e4936 ma02b861363, int c092b9c35b2, int c3a84ba2df0) {\nfloat ad90770d038, bba3ae37d1f;\nad90770d038 = ma02b861363[c092b9c35b2][0];\nbba3ae37d1f = ma02b861363[c092b9c35b2][1];\nma02b861363[c092b9c35b2][0] = ma02b861363[c3a84ba2df0][0];\nma02b861363[c092b9c35b2][1] = ma02b861363[c3a84ba2df0][1];\nma02b861363[c3a84ba2df0][0] = ad90770d038;\nma02b861363[c3a84ba2df0][1] = bba3ae37d1f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_292",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a one-dimensional array containing two integers and a single integer scalar\u2014and produces an output as a one-dimensional array containing two integers. The function divides each element of the input array by the scalar value and assigns the resulting quotient to the respective element in the output array, performing an element-wise scalar division.",
        "code_id": "c_group_2_id_292",
        "code_text": "Cd4e3208291\nvoid\ng2fbd9cb0f6(i5e3d0f10c1 v91082a9365, int s3b9d266e2e, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] / s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] / s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_293",
        "query_text": "SUMMARY: This function takes a constant pointer to a float (const float *) as input and produces an output of type mat4x3 (an array of 4 vectors, each being an array of 3 floats). It sequentially assigns groups of three floats from the input array to each of the four vectors in the output, effectively constructing a 4x3 matrix from a flat array of 12 floats.",
        "code_id": "c_group_2_id_293",
        "code_text": "Cd4e3208291\nvoid\ng9175540237(const float * __restrict sa425380d12, mc9dd4b805d d9748d673c4) {\nd9748d673c4[0][0] = sa425380d12[0];\nd9748d673c4[0][1] = sa425380d12[1];\nd9748d673c4[0][2] = sa425380d12[2];\nd9748d673c4[1][0] = sa425380d12[3];\nd9748d673c4[1][1] = sa425380d12[4];\nd9748d673c4[1][2] = sa425380d12[5];\nd9748d673c4[2][0] = sa425380d12[6];\nd9748d673c4[2][1] = sa425380d12[7];\nd9748d673c4[2][2] = sa425380d12[8];\nd9748d673c4[3][0] = sa425380d12[9];\nd9748d673c4[3][1] = sa425380d12[10];\nd9748d673c4[3][2] = sa425380d12[11];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_294",
        "query_text": "SUMMARY: This function accepts an input of type float[3] (a 3-dimensional vector) and a float scalar, then produces an output of type float[3] by subtracting the scalar from each element of the input vector individually.",
        "code_id": "c_group_2_id_294",
        "code_text": "Cd4e3208291\nvoid\ngca58d33640(veb444e7eb8 v91082a9365, float s3b9d266e2e, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] - s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] - s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_295",
        "query_text": "SUMMARY: This function takes as inputs a 2x4 matrix (implemented as an array of 2 vectors, where each vector is an aligned array of 4 floats) and a scalar float value. It scales the matrix in place by multiplying each of its elements by the provided scalar, and it returns no value (void).",
        "code_id": "c_group_2_id_295",
        "code_text": "Cd4e3208291\nvoid\ngb71e6ed7b5(md4c46ddc0d mb8bcb57dcd, float s3b9d266e2e) {\nmb8bcb57dcd[0][0] *= s3b9d266e2e;  mb8bcb57dcd[0][1] *= s3b9d266e2e;  mb8bcb57dcd[0][2] *= s3b9d266e2e;  mb8bcb57dcd[0][3] *= s3b9d266e2e;\nmb8bcb57dcd[1][0] *= s3b9d266e2e;  mb8bcb57dcd[1][1] *= s3b9d266e2e;  mb8bcb57dcd[1][2] *= s3b9d266e2e;  mb8bcb57dcd[1][3] *= s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_296",
        "query_text": "SUMMARY: This function takes two inputs and one output, each being an array of 4 integers (ivec4). For each of the four positions, the function compares the corresponding integers from the two input arrays and places the larger value into the same index of the output array.",
        "code_id": "c_group_2_id_296",
        "code_text": "Cd4e3208291\nvoid\ng2e7ab8d197(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] > bba3ae37d1f[0] ? ad90770d038[0] : bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] > bba3ae37d1f[1] ? ad90770d038[1] : bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] > bba3ae37d1f[2] ? ad90770d038[2] : bba3ae37d1f[2];\nd9748d673c4[3] = ad90770d038[3] > bba3ae37d1f[3] ? ad90770d038[3] : bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_297",
        "query_text": "SUMMARY: This function accepts a parameter of type mat2 (a 2x2 matrix represented as an array of two vec2, where each vec2 is an array of two floats) and transposes it in place. It operates by swapping the two off-diagonal elements of the input matrix, leaving the diagonal elements unchanged, and produces no return value (void).",
        "code_id": "c_group_2_id_297",
        "code_text": "Cd4e3208291\nvoid\ngef83174518(mde4d4e4936 mb8bcb57dcd) {\nfloat tb20dfb361b;\ntb20dfb361b     = mb8bcb57dcd[0][1];\nmb8bcb57dcd[0][1] = mb8bcb57dcd[1][0];\nmb8bcb57dcd[1][0] = tb20dfb361b;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_298",
        "query_text": "SUMMARY: The function receives an input of type ivec3 (an array of three integers) and a scalar integer, subtracts the scalar from each element of the input ivec3, and stores the results in an output variable of type ivec3 (an array of three integers). The function processes the subtraction element-wise for all three components of the input integer vector.",
        "code_id": "c_group_2_id_298",
        "code_text": "Cd4e3208291\nvoid\ng4385f1c4ea(i4b951f731e v91082a9365, int s3b9d266e2e, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] - s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] - s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_299",
        "query_text": "SUMMARY: This function takes a vector of type float[4] (an aligned array of four 32-bit floating-point numbers) as its input and outputs no value (void return). Its functionality is to set every element of the input vector to the constant value 1.0. It uses platform-specific SIMD instructions (such as those available for WASM, SSE, or NEON) when available for optimized performance, otherwise it sets the elements individually.",
        "code_id": "c_group_2_id_299",
        "code_text": "Cd4e3208291\nvoid\ngf902d2a844(v141258b569 v91082a9365) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(v, wasm_f32x4_const_splat(1.0f));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(v91082a9365, _mm_set1_ps(1.0f));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(v, vdupq_n_f32(1.0f));\n#else\nv[0] = 1.0f;\nv[1] = 1.0f;\nv[2] = 1.0f;\nv[3] = 1.0f;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_300",
        "query_text": "SUMMARY: This function receives a two-dimensional array of floats with dimensions 3\u00d73 (mat3) and returns a float. It calculates the determinant of the provided 3\u00d73 matrix by accessing each element in the matrix and applying the standard determinant formula for a 3\u00d73 matrix. Specifically, it computes the determinant by performing arithmetic operations involving the multiplication and subtraction of products of selected elements from the matrix, and then returns the resulting value.",
        "code_id": "c_group_2_id_300",
        "code_text": "Cd4e3208291\nfloat\ng14cdb70b62(m63312228ee ma02b861363) {\nfloat ad90770d038 = ma02b861363[0][0], bba3ae37d1f = ma02b861363[0][1], cdcd5d1f3d2 = ma02b861363[0][2],\nded8b2a8791 = ma02b861363[1][0], e00936eb9f3 = ma02b861363[1][1], f4cff875701 = ma02b861363[1][2],\ng9a9b7f5c21 = ma02b861363[2][0], hc99060f9be = ma02b861363[2][1], i0c6e314cec = ma02b861363[2][2];\nreturn ad90770d038 * (e00936eb9f3 * i0c6e314cec - hc99060f9be * f4cff875701) - ded8b2a8791 * (bba3ae37d1f * i0c6e314cec - cdcd5d1f3d2 * hc99060f9be) + g9a9b7f5c21 * (bba3ae37d1f * f4cff875701 - cdcd5d1f3d2 * e00936eb9f3);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_301",
        "query_text": "SUMMARY: This function accepts two inputs: one is a three-element array of floats (type vec3) and the other is a pointer to a FILE stream (type FILE *). It produces no return value (void). Its purpose is to output a formatted representation of the three floating-point values to the provided stream. The function prints a header indicating the vector type and then iterates through the array, printing each float with conditional formatting based on its value relative to a preset threshold. It also incorporates color formatting directives to enhance the visual output on compatible terminals.",
        "code_id": "c_group_2_id_301",
        "code_text": "Cd4e3208291\nvoid\ng0215879469(veb444e7eb8              vf6195f1fd8,\nFILE * __restrict o5450e5c91d) {\nint i0c6e314cec;\n#define mb8bcb57dcd 3\nfprintf(o5450e5c91d, \"Vector (float%d): \" C45893ec2b2 \"\\n  (\", mb8bcb57dcd);\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++) {\nif (vf6195f1fd8[i0c6e314cec] < Cd0da13f7c8)\nfprintf(o5450e5c91d, \" % .*f\", Cb46738fea8, (double)vf6195f1fd8[i0c6e314cec]);\nelse\nfprintf(o5450e5c91d, \" % g\", (double)vf6195f1fd8[i0c6e314cec]);\n}\nfprintf(o5450e5c91d, \"  )\" C7c34c62781 \"\\n\\n\");\n#undef mb8bcb57dcd\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_302",
        "query_text": "SUMMARY: This function takes an input of type vec2 (a two-element array of floats) and copies its contents to an output also of type vec2, thereby duplicating the two floating-point values from the source to the destination.",
        "code_id": "c_group_2_id_302",
        "code_text": "Cd4e3208291\nvoid\ng7e0ccd0837(v0131f5a9ae ad90770d038, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0];\nd9748d673c4[1] = ad90770d038[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_303",
        "query_text": "SUMMARY: The function accepts an input parameter of type int[4] and two additional integer parameters representing a minimum and a maximum value. It reviews each element of the int[4] array and modifies it in place so that every element is confined within the specified range: if an element is lower than the minimum value, it is set to the minimum; if it exceeds the maximum value, it is set to the maximum. The output is the modified int[4] array where all elements satisfy the constraint min \u2264 element \u2264 max.",
        "code_id": "c_group_2_id_303",
        "code_text": "Cd4e3208291\nvoid\ng87b43ab520(i52a86355e2 v91082a9365, int m5d862d9243, int mfb64f1df94) {\nif (v91082a9365[0] < m5d862d9243)\nv91082a9365[0] = m5d862d9243;\nelse if(v91082a9365[0] > mfb64f1df94)\nv91082a9365[0] = mfb64f1df94;\nif (v91082a9365[1] < m5d862d9243)\nv91082a9365[1] = m5d862d9243;\nelse if(v91082a9365[1] > mfb64f1df94)\nv91082a9365[1] = mfb64f1df94;\nif (v91082a9365[2] < m5d862d9243)\nv91082a9365[2] = m5d862d9243;\nelse if(v91082a9365[2] > mfb64f1df94)\nv91082a9365[2] = mfb64f1df94;\nif (v91082a9365[3] < m5d862d9243)\nv91082a9365[3] = m5d862d9243;\nelse if(v91082a9365[3] > mfb64f1df94)\nv91082a9365[3] = mfb64f1df94;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_304",
        "query_text": "SUMMARY: This function takes as inputs a 3-element array of floats (vec3) and a float scalar, and produces as output another 3-element array of floats (vec3). It operates by adding the float scalar to each element of the input 3-element float array individually, storing each computed sum into the corresponding index of the output array.",
        "code_id": "c_group_2_id_304",
        "code_text": "Cd4e3208291\nvoid\ngff1bfc9ef2(veb444e7eb8 v91082a9365, float s3b9d266e2e, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] + s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] + s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_305",
        "query_text": "SUMMARY: This function takes a two-element array of single-precision floating-point numbers (vec2) as input and produces a two-element array of single-precision floating-point numbers (vec2) as output. It computes the square root of each element from the input array and assigns the results to the corresponding elements of the output array.",
        "code_id": "c_group_2_id_305",
        "code_text": "Cd4e3208291\nvoid\ng8e960eda95(v0131f5a9ae v91082a9365, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = sqrtf(v91082a9365[0]);\nd9748d673c4[1] = sqrtf(v91082a9365[1]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_306",
        "query_text": "SUMMARY: This function accepts an input of type \"integer array of length 3\" and a scalar of type \"integer\", and it outputs a modified integer array of length 3. Specifically, for each element in the three-element output array, it subtracts the sum of the corresponding element from the input array and the scalar. Line by line, each element in the output is updated by deducting (element from the input array + scalar) from its current value.",
        "code_id": "c_group_2_id_306",
        "code_text": "Cd4e3208291\nvoid\ngaae2591a83(i4b951f731e ad90770d038, int s3b9d266e2e, i4b951f731e d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] + s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] + s3b9d266e2e;\nd9748d673c4[2] -= ad90770d038[2] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_307",
        "query_text": "SUMMARY: This function accepts a 3x4 matrix (an array of three 4-element float vectors, with 16-byte alignment) and a scalar value of type float. It scales the matrix by multiplying each of the 12 individual float elements by the scalar, and it performs the operation in place, returning no value (void).",
        "code_id": "c_group_2_id_307",
        "code_text": "Cd4e3208291\nvoid\ng29a68d2497(m5fbb141a9c mb8bcb57dcd, float s3b9d266e2e) {\nmb8bcb57dcd[0][0] *= s3b9d266e2e; mb8bcb57dcd[0][1] *= s3b9d266e2e; mb8bcb57dcd[0][2] *= s3b9d266e2e; mb8bcb57dcd[0][3] *= s3b9d266e2e;\nmb8bcb57dcd[1][0] *= s3b9d266e2e; mb8bcb57dcd[1][1] *= s3b9d266e2e; mb8bcb57dcd[1][2] *= s3b9d266e2e; mb8bcb57dcd[1][3] *= s3b9d266e2e;\nmb8bcb57dcd[2][0] *= s3b9d266e2e; mb8bcb57dcd[2][1] *= s3b9d266e2e; mb8bcb57dcd[2][2] *= s3b9d266e2e; mb8bcb57dcd[2][3] *= s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_308",
        "query_text": "SUMMARY: This function performs a linear transformation by multiplying a 2\u00d73 matrix (an array of two 3-element float arrays) with a 2-element vector (a float array of length 2) to produce a 3-element vector (a float array of length 3). It extracts the two float values from the input vector, then computes each of the three output float values by forming a weighted sum of corresponding elements from the two rows of the matrix, and finally stores these computed sums in the output vector.",
        "code_id": "c_group_2_id_308",
        "code_text": "Cd4e3208291\nvoid\ng922f133df0(mc11cae8baa mb8bcb57dcd, v0131f5a9ae v91082a9365, veb444e7eb8 d9748d673c4) {\nfloat v01fb438970 = v91082a9365[0], v748b5cffd1 = v91082a9365[1];\nd9748d673c4[0] = mb8bcb57dcd[0][0] * v01fb438970 + mb8bcb57dcd[1][0] * v748b5cffd1;\nd9748d673c4[1] = mb8bcb57dcd[0][1] * v01fb438970 + mb8bcb57dcd[1][1] * v748b5cffd1;\nd9748d673c4[2] = mb8bcb57dcd[0][2] * v01fb438970 + mb8bcb57dcd[1][2] * v748b5cffd1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_309",
        "query_text": "SUMMARY: This routine performs component-wise addition on two input arrays of four 32-bit floating-point values (defined as vec4) and stores the result into an output array of the same type. The implementation conditionally leverages platform-specific SIMD instructions\u2014using WebAssembly SIMD, SSE/SSE2, or NEON\u2014in order to efficiently load, add, and store the 4-element vectors. In the absence of such hardware features, it manually adds each corresponding element from the input arrays.",
        "code_id": "c_group_2_id_309",
        "code_text": "Cd4e3208291\nvoid\ngbcee49b2a4(v141258b569 ad90770d038, v141258b569 bba3ae37d1f, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_add(g86f14e15d6(a), g86f14e15d6(b)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_add_ps(g86f14e15d6(ad90770d038), g86f14e15d6(bba3ae37d1f)));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vaddq_f32(vld1q_f32(a), vld1q_f32(b)));\n#else\ndest[0] = a[0] + b[0];\ndest[1] = a[1] + b[1];\ndest[2] = a[2] + b[2];\ndest[3] = a[3] + b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_310",
        "query_text": "SUMMARY: This inline function initializes a quaternion represented by a 4-element float array. It takes as inputs one output parameter (a modifiable array of four floats) and four individual floats. The function assigns the four input float values to the elements of the float array sequentially, updating it in place.",
        "code_id": "c_group_2_id_310",
        "code_text": "Cd4e3208291\nvoid\ng137c5266ab(v6c437193eb qe10085b89e, float xf1fa84c2ec, float y92bd0bf197, float z2f48e9e974, float w893b1d140a) {\nqe10085b89e[0] = xf1fa84c2ec;\nqe10085b89e[1] = y92bd0bf197;\nqe10085b89e[2] = z2f48e9e974;\nqe10085b89e[3] = w893b1d140a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_311",
        "query_text": "SUMMARY: This function takes a 4\u00d74 matrix of floats (mat4) as input along with a pointer to a float variable as output. It computes a quotient by dividing the float value in the fourth row and third column of the matrix by the result of subtracting the element in the third row and third column from 1.0. The computed value is then stored in the provided float pointer, effectively extracting the far clipping plane distance from the perspective projection matrix under a left-handed coordinate system with no depth range transformation.",
        "code_id": "c_group_2_id_311",
        "code_text": "Cd4e3208291\nvoid\ng95367383f4(m2979ecef6f paccfd26812, float * __restrict fb6d340e4c8) {\n*fb6d340e4c8 = paccfd26812[3][2] / (-paccfd26812[2][2] + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_312",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 single-precision floating-point matrix (representing a perspective projection transformation) and two pointers to float variables as inputs. It calculates the near clipping plane distance from the matrix and then computes the horizontal bounds on the near plane of the projection, storing these computed boundary values into the provided float outputs.",
        "code_id": "c_group_2_id_312",
        "code_text": "Cd4e3208291\nvoid\ngdb9c9e432d(m2979ecef6f paccfd26812,\nfloat * __restrict lcfaba252b8,\nfloat * __restrict rc12144e4ba) {\nfloat nd3cfbab11c, m2134d0010f, m73982a8772;\nm73982a8772 = paccfd26812[0][0];\nm2134d0010f = paccfd26812[2][0];\nnd3cfbab11c = paccfd26812[3][2] / (paccfd26812[3][3]);\n*lcfaba252b8   = nd3cfbab11c * (m2134d0010f - 1.0f) / m73982a8772;\n*rc12144e4ba  = nd3cfbab11c * (m2134d0010f + 1.0f) / m73982a8772;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_313",
        "query_text": "SUMMARY: This function accepts one input of type mat4 (a 4\u00d74 floating-point matrix) and returns a float. It extracts two elements from the matrix\u2014specifically the component at index [1][1] and the component at index [0][0]\u2014and returns their quotient, effectively computing the aspect ratio represented in the perspective projection matrix.",
        "code_id": "c_group_2_id_313",
        "code_text": "Cd4e3208291\nfloat\ng0619980cdf(m2979ecef6f paccfd26812) {\nreturn paccfd26812[1][1] / paccfd26812[0][0];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_314",
        "query_text": "SUMMARY: This function takes as inputs a 2\u00d74 matrix (represented as an array of 2 arrays, each containing 4 floats) and a 2-dimensional vector (an array of 2 floats). It computes a 4-dimensional vector (an array of 4 floats) as output by performing a component-wise linear combination of the two rows of the matrix using the two scalar elements from the vector. Each element of the resulting vector is calculated by multiplying the corresponding element from the first row of the matrix by the first scalar and adding it to the product of the corresponding element from the second row with the second scalar.",
        "code_id": "c_group_2_id_314",
        "code_text": "Cd4e3208291\nvoid\ng9d54a07bed(md4c46ddc0d mb8bcb57dcd, v0131f5a9ae v91082a9365, v141258b569 d9748d673c4) {\nfloat v01fb438970 = v91082a9365[0], v748b5cffd1 = v91082a9365[1];\nd9748d673c4[0] = mb8bcb57dcd[0][0] * v01fb438970 + mb8bcb57dcd[1][0] * v748b5cffd1;\nd9748d673c4[1] = mb8bcb57dcd[0][1] * v01fb438970 + mb8bcb57dcd[1][1] * v748b5cffd1;\nd9748d673c4[2] = mb8bcb57dcd[0][2] * v01fb438970 + mb8bcb57dcd[1][2] * v748b5cffd1;\nd9748d673c4[3] = mb8bcb57dcd[0][3] * v01fb438970 + mb8bcb57dcd[1][3] * v748b5cffd1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_315",
        "query_text": "SUMMARY: This function accepts two parameters, both of type vec4 (an array of 4 floats). It copies the contents from the first vec4 (input) into the second vec4 (output), ensuring that the destination receives an exact replica of the input vector. The implementation employs optimized methods for certain platform-specific conditions but ultimately achieves a straightforward element-by-element copy of the four floating-point values.",
        "code_id": "c_group_2_id_315",
        "code_text": "Cd4e3208291\nvoid\ng13fe20ea80(v141258b569 v91082a9365, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n\nwasm_v128_store(dest, wasm_v128_load(v));\n#else\nd9748d673c4[0] = v91082a9365[0];\nd9748d673c4[1] = v91082a9365[1];\nd9748d673c4[2] = v91082a9365[2];\nd9748d673c4[3] = v91082a9365[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_316",
        "query_text": "SUMMARY: This function accepts a single floating-point value (type: float) and a destination array of four floats (type: vec4, which is a 16-byte aligned float[4]). Its primary functionality is to assign the given float value to every element of the output array, effectively broadcasting the value. Depending on the platform, it may use specialized SIMD instructions (WebAssembly SIMD or SSE/SSE2) to perform the broadcast efficiently; otherwise, it individually assigns the value to each position in the array.",
        "code_id": "c_group_2_id_316",
        "code_text": "Cd4e3208291\nvoid\nga8d627c2e6(float v71de8bcd6a, v141258b569 ded8b2a8791) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(d, wasm_f32x4_splat(val));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(ded8b2a8791, _mm_set1_ps(v71de8bcd6a));\n#else\nd[0] = d[1] = d[2] = d[3] = val;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_317",
        "query_text": "SUMMARY: This function takes as input a 4\u00d74 floating-point matrix (of type mat4) representing a specific perspective projection and a pointer to a float (output type). It computes the near clipping plane distance by extracting particular elements from the matrix and assigns the resulting float to the provided output pointer. Specifically, it derives the output by dividing the element from the fourth row and third column by the negation of the element from the third row and third column.",
        "code_id": "c_group_2_id_317",
        "code_text": "Cd4e3208291\nvoid\ng4b1d6c9124(m2979ecef6f paccfd26812, float * __restrict nd3cfbab11c) {\n*nd3cfbab11c = paccfd26812[3][2] / -paccfd26812[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_318",
        "query_text": "SUMMARY: This function takes as inputs a 2\u00d74 matrix (of type mat2x4, represented as an array of 2 vec4\u2019s) and a 4\u00d72 matrix (of type mat4x2, represented as an array of 4 vec2\u2019s) and computes their product, storing the result in a 4\u00d74 matrix (of type mat4, represented as an array of 4 vec4\u2019s). In essence, it forms each column of the 4\u00d74 output by taking a linear combination of the two columns of the 2\u00d74 input, with the weights being the corresponding elements from a column (or row, depending on conceptual layout) of the 4\u00d72 input.",
        "code_id": "c_group_2_id_318",
        "code_text": "Cd4e3208291\nvoid\ng6f445bb877(md4c46ddc0d m7f4f0cd2cb, mab2cb9021e m71ae398200, m2979ecef6f d9748d673c4) {\nfloat a79034f70a3 = m7f4f0cd2cb[0][0], af8ba94e471 = m7f4f0cd2cb[0][1], ac122217995 = m7f4f0cd2cb[0][2], a535579fe87 = m7f4f0cd2cb[0][3],\na00a7244c30 = m7f4f0cd2cb[1][0], a90b743b58c = m7f4f0cd2cb[1][1], a2f9044642f = m7f4f0cd2cb[1][2], a149776f00e = m7f4f0cd2cb[1][3],\nb24ae8206ee = m71ae398200[0][0], ba7a975e23f = m71ae398200[0][1],\nbd4c89897d0 = m71ae398200[1][0], b339ffe7279 = m71ae398200[1][1],\nb7cacabc345 = m71ae398200[2][0], b27ae3829e2 = m71ae398200[2][1],\nb494af3c267 = m71ae398200[3][0], bfbed44a869 = m71ae398200[3][1];\nd9748d673c4[0][0] = a79034f70a3 * b24ae8206ee + a00a7244c30 * ba7a975e23f;\nd9748d673c4[0][1] = af8ba94e471 * b24ae8206ee + a90b743b58c * ba7a975e23f;\nd9748d673c4[0][2] = ac122217995 * b24ae8206ee + a2f9044642f * ba7a975e23f;\nd9748d673c4[0][3] = a535579fe87 * b24ae8206ee + a149776f00e * ba7a975e23f;\nd9748d673c4[1][0] = a79034f70a3 * bd4c89897d0 + a00a7244c30 * b339ffe7279;\nd9748d673c4[1][1] = af8ba94e471 * bd4c89897d0 + a90b743b58c * b339ffe7279;\nd9748d673c4[1][2] = ac122217995 * bd4c89897d0 + a2f9044642f * b339ffe7279;\nd9748d673c4[1][3] = a535579fe87 * bd4c89897d0 + a149776f00e * b339ffe7279;\nd9748d673c4[2][0] = a79034f70a3 * b7cacabc345 + a00a7244c30 * b27ae3829e2;\nd9748d673c4[2][1] = af8ba94e471 * b7cacabc345 + a90b743b58c * b27ae3829e2;\nd9748d673c4[2][2] = ac122217995 * b7cacabc345 + a2f9044642f * b27ae3829e2;\nd9748d673c4[2][3] = a535579fe87 * b7cacabc345 + a149776f00e * b27ae3829e2;\nd9748d673c4[3][0] = a79034f70a3 * b494af3c267 + a00a7244c30 * bfbed44a869;\nd9748d673c4[3][1] = af8ba94e471 * b494af3c267 + a90b743b58c * bfbed44a869;\nd9748d673c4[3][2] = ac122217995 * b494af3c267 + a2f9044642f * bfbed44a869;\nd9748d673c4[3][3] = a535579fe87 * b494af3c267 + a149776f00e * bfbed44a869;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_319",
        "query_text": "SUMMARY: This function accepts an input of type mat3 (a 3\u00d73 float matrix) and produces an output of the same type. It calculates the transpose of the provided 3\u00d73 matrix by reassigning elements such that the element at the ith row and jth column in the input is placed at the jth row and ith column in the output. Each assignment explicitly swaps the indices, ensuring that the matrix's rows and columns are interchanged.",
        "code_id": "c_group_2_id_319",
        "code_text": "Cd4e3208291\nvoid\ng49d300d606(m63312228ee mb8bcb57dcd, m63312228ee d9748d673c4) {\nd9748d673c4[0][0] = mb8bcb57dcd[0][0];\nd9748d673c4[0][1] = mb8bcb57dcd[1][0];\nd9748d673c4[0][2] = mb8bcb57dcd[2][0];\nd9748d673c4[1][0] = mb8bcb57dcd[0][1];\nd9748d673c4[1][1] = mb8bcb57dcd[1][1];\nd9748d673c4[1][2] = mb8bcb57dcd[2][1];\nd9748d673c4[2][0] = mb8bcb57dcd[0][2];\nd9748d673c4[2][1] = mb8bcb57dcd[1][2];\nd9748d673c4[2][2] = mb8bcb57dcd[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_320",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of type int[4]. It updates the output parameter by adding, component-wise, the difference between the corresponding elements of the first two input parameters. In other words, for each of the four components, it subtracts the second input's element from the first input's element and then adds that result to the corresponding element in the output.",
        "code_id": "c_group_2_id_320",
        "code_text": "Cd4e3208291\nvoid\ng5cfaa3e3da(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] - bba3ae37d1f[1];\nd9748d673c4[2] += ad90770d038[2] - bba3ae37d1f[2];\nd9748d673c4[3] += ad90770d038[3] - bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_321",
        "query_text": "SUMMARY: This function accepts two parameters of type \"int[2]\"\u2014a source vector and a destination vector. It copies the two integer elements from the source vector into the destination vector, ensuring that the output vector contains the same pair of integer values as the input vector.",
        "code_id": "c_group_2_id_321",
        "code_text": "Cd4e3208291\nvoid\ng2c66541a0a(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0];\nd9748d673c4[1] = ad90770d038[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_322",
        "query_text": "SUMMARY: This function multiplies a 3\u00d72 matrix (an array consisting of 3 elements, each being an array of 2 floats) with a 3-dimensional vector (an array of 3 floats) to produce a 2-dimensional vector (an array of 2 floats). It first extracts the three float components from the input vector, then computes each component of the resulting vector as a linear combination of the extracted components weighted by corresponding elements from the matrix. The first output float is calculated by summing the products of the first element of each matrix sub-array with the respective vector components, while the second output float is generated using the second elements from the matrix sub-arrays.",
        "code_id": "c_group_2_id_322",
        "code_text": "Cd4e3208291\nvoid\ngfa68965b76(m5fbc7d59b5 mb8bcb57dcd, veb444e7eb8 v91082a9365, v0131f5a9ae d9748d673c4) {\nfloat v01fb438970 = v91082a9365[0], v748b5cffd1 = v91082a9365[1], v05a5120aa0 = v91082a9365[2];\nd9748d673c4[0] = mb8bcb57dcd[0][0] * v01fb438970 + mb8bcb57dcd[1][0] * v748b5cffd1 + mb8bcb57dcd[2][0] * v05a5120aa0;\nd9748d673c4[1] = mb8bcb57dcd[0][1] * v01fb438970 + mb8bcb57dcd[1][1] * v748b5cffd1 + mb8bcb57dcd[2][1] * v05a5120aa0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_323",
        "query_text": "SUMMARY: This function accepts a two-element floating-point array (vec2) and a floating-point scalar as inputs. It multiplies each element of the input array by the scalar, then stores the resulting two-element floating-point array (vec2) as output.",
        "code_id": "c_group_2_id_323",
        "code_text": "Cd4e3208291\nvoid\ng71074d996d(v0131f5a9ae v91082a9365, float s3b9d266e2e, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] * s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_324",
        "query_text": "SUMMARY: This function takes a 4x4 matrix of floats (representing a perspective projection in a left-handed coordinate system with a zero-to-one depth range) and a float value as inputs. It adjusts the projection matrix by shifting its far clipping plane by the given delta value. The function recalculates key elements related to the near and far clipping distances and updates the corresponding matrix entries to reflect the new far plane position, while maintaining the proper perspective transformation. The output is the modified 4x4 matrix (the changes are applied in-place), and the function returns no value.",
        "code_id": "c_group_2_id_324",
        "code_text": "Cd4e3208291\nvoid\ngc2d912bc8e(m2979ecef6f paccfd26812, float dc3e1e7568f) {\nfloat f9bc16e1f91, fb6d340e4c8, nd3cfbab11c, p6624354550, pe06d2fef65;\np6624354550        = -paccfd26812[2][2];\npe06d2fef65        = paccfd26812[3][2];\nnd3cfbab11c    = pe06d2fef65 / p6624354550;\nfb6d340e4c8     = pe06d2fef65 / (p6624354550 + 1.0f) + dc3e1e7568f;\nf9bc16e1f91         = 1.0f / (nd3cfbab11c - fb6d340e4c8);\npaccfd26812[2][2] = -fb6d340e4c8 * f9bc16e1f91;\npaccfd26812[3][2] = nd3cfbab11c * fb6d340e4c8 * f9bc16e1f91;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_325",
        "query_text": "SUMMARY: This function accepts an input of type pointer to float and an output of type vec2 (an array of 2 floats). It copies the first two float values from the input pointer into the output vec2, effectively transferring a 2-dimensional vector from one representation to another.",
        "code_id": "c_group_2_id_325",
        "code_text": "Cd4e3208291\nvoid\ng72e21399b9(float * __restrict v91082a9365, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0];\nd9748d673c4[1] = v91082a9365[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_326",
        "query_text": "SUMMARY: This function accepts an input variable of type \"vec2\" (an array of two floats) and computes the floor value for each element. The resulting values are then stored in an output variable of type \"vec2\" (also an array of two floats). Essentially, it rounds each of the two input float components down to the nearest integer value and writes the result to the corresponding position in the output array.",
        "code_id": "c_group_2_id_326",
        "code_text": "Cd4e3208291\nvoid\nga16cac1f2f(v0131f5a9ae v91082a9365, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = floorf(v91082a9365[0]);\nd9748d673c4[1] = floorf(v91082a9365[1]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_327",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (mat4) and two pointers to floats (float*) as inputs. It decomposes the provided perspective projection matrix, extracting parameters associated with the vertical extents along the y-axis in a left-handed coordinate system. Essentially, the function calculates a near clipping distance and then computes two float values representing the top and bottom bounds of the view frustum. The computed values are stored in the output float pointers.",
        "code_id": "c_group_2_id_327",
        "code_text": "Cd4e3208291\nvoid\ng53614e1a54(m2979ecef6f paccfd26812,\nfloat * __restrict td39aaeaeed,\nfloat * __restrict be4ccd944cb) {\nfloat nd3cfbab11c, m4b629e56ab, md6bc4e094a, m529843770e;\nm4b629e56ab = paccfd26812[2][1];\nmd6bc4e094a = paccfd26812[1][1];\nm529843770e =-paccfd26812[2][2];\nnd3cfbab11c = paccfd26812[3][2] / (m529843770e - 1.0f);\n*be4ccd944cb = nd3cfbab11c * (m4b629e56ab - 1.0f) / md6bc4e094a;\n*td39aaeaeed    = nd3cfbab11c * (m4b629e56ab + 1.0f) / md6bc4e094a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_328",
        "query_text": "SUMMARY: This function converts a three-component float array (vec3) representing Euler rotation angles into a corresponding four-component float array (versor) representing a quaternion based on a ZYX rotation order for a left-handed coordinate system. It computes half-angle sine and cosine values for each of the three angles, combines these intermediate values with appropriate sign adjustments, and then calculates each component of the quaternion, which encodes the final rotation.",
        "code_id": "c_group_2_id_328",
        "code_text": "Cd4e3208291\nvoid\ng4caf9ba00f(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad =  sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa =  sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = -sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] =  z1a2745c1a8 * ydfce0dcdee * xa08976ecad - z8de8afe2d4 * ye938664caa * x1dce3a8271;\nd9748d673c4[1] =  z1a2745c1a8 * ye938664caa * x1dce3a8271 + z8de8afe2d4 * ydfce0dcdee * xa08976ecad;\nd9748d673c4[2] = -z1a2745c1a8 * ye938664caa * xa08976ecad + z8de8afe2d4 * ydfce0dcdee * x1dce3a8271;\nd9748d673c4[3] =  z1a2745c1a8 * ydfce0dcdee * x1dce3a8271 + z8de8afe2d4 * ye938664caa * xa08976ecad;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_329",
        "query_text": "SUMMARY: This function takes two inputs of type int[4] and produces an output of the same type. It transfers the contents of the first int[4] array into the second int[4] array by copying each of the four integer elements in order.",
        "code_id": "c_group_2_id_329",
        "code_text": "Cd4e3208291\nvoid\ng9fbaf1c710(i52a86355e2 ad90770d038, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0];\nd9748d673c4[1] = ad90770d038[1];\nd9748d673c4[2] = ad90770d038[2];\nd9748d673c4[3] = ad90770d038[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_330",
        "query_text": "SUMMARY: This function multiplies two matrices and produces a new matrix as a result. It takes an input of type mat3x4 (an array of 3 vec4, representing a 3\u2010column by 4\u2011row matrix in column-major order) and an input of type mat4x3 (an array of 4 vec3, representing a 4\u2011column by 3\u2011row matrix in column-major order), and it computes their product to store in an output of type mat4 (an array of 4 vec4, representing a 4\u2011column by 4\u2011row matrix). The function works by extracting the individual floating\u2013point components of the first and second matrices and then computing each element of the resulting matrix as the dot product between the corresponding column from the first matrix and the appropriate row from the second matrix.",
        "code_id": "c_group_2_id_330",
        "code_text": "Cd4e3208291\nvoid\nga91306aca8(m5fbb141a9c m7f4f0cd2cb, mc9dd4b805d m71ae398200, m2979ecef6f d9748d673c4) {\nfloat a79034f70a3 = m7f4f0cd2cb[0][0], af8ba94e471 = m7f4f0cd2cb[0][1], ac122217995 = m7f4f0cd2cb[0][2], a535579fe87 = m7f4f0cd2cb[0][3],\na00a7244c30 = m7f4f0cd2cb[1][0], a90b743b58c = m7f4f0cd2cb[1][1], a2f9044642f = m7f4f0cd2cb[1][2], a149776f00e = m7f4f0cd2cb[1][3],\nabbf182117b = m7f4f0cd2cb[2][0], a76187ed5e7 = m7f4f0cd2cb[2][1], abd38a595bd = m7f4f0cd2cb[2][2], acdc26397ef = m7f4f0cd2cb[2][3],\nb24ae8206ee = m71ae398200[0][0], ba7a975e23f = m71ae398200[0][1], b26594d8877 = m71ae398200[0][2],\nbd4c89897d0 = m71ae398200[1][0], b339ffe7279 = m71ae398200[1][1], bfa76c9278d = m71ae398200[1][2],\nb7cacabc345 = m71ae398200[2][0], b27ae3829e2 = m71ae398200[2][1], bbf7d9db385 = m71ae398200[2][2],\nb494af3c267 = m71ae398200[3][0], bfbed44a869 = m71ae398200[3][1], be48d646a45 = m71ae398200[3][2];\nd9748d673c4[0][0] = a79034f70a3 * b24ae8206ee + a00a7244c30 * ba7a975e23f + abbf182117b * b26594d8877;\nd9748d673c4[0][1] = af8ba94e471 * b24ae8206ee + a90b743b58c * ba7a975e23f + a76187ed5e7 * b26594d8877;\nd9748d673c4[0][2] = ac122217995 * b24ae8206ee + a2f9044642f * ba7a975e23f + abd38a595bd * b26594d8877;\nd9748d673c4[0][3] = a535579fe87 * b24ae8206ee + a149776f00e * ba7a975e23f + acdc26397ef * b26594d8877;\nd9748d673c4[1][0] = a79034f70a3 * bd4c89897d0 + a00a7244c30 * b339ffe7279 + abbf182117b * bfa76c9278d;\nd9748d673c4[1][1] = af8ba94e471 * bd4c89897d0 + a90b743b58c * b339ffe7279 + a76187ed5e7 * bfa76c9278d;\nd9748d673c4[1][2] = ac122217995 * bd4c89897d0 + a2f9044642f * b339ffe7279 + abd38a595bd * bfa76c9278d;\nd9748d673c4[1][3] = a535579fe87 * bd4c89897d0 + a149776f00e * b339ffe7279 + acdc26397ef * bfa76c9278d;\nd9748d673c4[2][0] = a79034f70a3 * b7cacabc345 + a00a7244c30 * b27ae3829e2 + abbf182117b * bbf7d9db385;\nd9748d673c4[2][1] = af8ba94e471 * b7cacabc345 + a90b743b58c * b27ae3829e2 + a76187ed5e7 * bbf7d9db385;\nd9748d673c4[2][2] = ac122217995 * b7cacabc345 + a2f9044642f * b27ae3829e2 + abd38a595bd * bbf7d9db385;\nd9748d673c4[2][3] = a535579fe87 * b7cacabc345 + a149776f00e * b27ae3829e2 + acdc26397ef * bbf7d9db385;\nd9748d673c4[3][0] = a79034f70a3 * b494af3c267 + a00a7244c30 * bfbed44a869 + abbf182117b * be48d646a45;\nd9748d673c4[3][1] = af8ba94e471 * b494af3c267 + a90b743b58c * bfbed44a869 + a76187ed5e7 * be48d646a45;\nd9748d673c4[3][2] = ac122217995 * b494af3c267 + a2f9044642f * bfbed44a869 + abd38a595bd * be48d646a45;\nd9748d673c4[3][3] = a535579fe87 * b494af3c267 + a149776f00e * bfbed44a869 + acdc26397ef * be48d646a45;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_331",
        "query_text": "SUMMARY: This function accepts an output variable of type mat3 (which is a 3\u00d73 array of floats) and an input variable of type float representing an angle. Its purpose is to construct a 3\u00d73 transformation matrix that encapsulates a two-dimensional rotation in homogeneous coordinates. The function computes the sine and cosine of the given angle and organizes these values within the matrix to represent the standard 2D rotational transformation. No value is returned.",
        "code_id": "c_group_2_id_331",
        "code_text": "Cd4e3208291\nvoid\ng0916fac4b1(m63312228ee mb8bcb57dcd, float a1cb113c089) {\nfloat cdcd5d1f3d2, s3b9d266e2e;\ns3b9d266e2e = sinf(a1cb113c089);\ncdcd5d1f3d2 = cosf(a1cb113c089);\nmb8bcb57dcd[0][0] = cdcd5d1f3d2;\nmb8bcb57dcd[0][1] = s3b9d266e2e;\nmb8bcb57dcd[0][2] = 0;\nmb8bcb57dcd[1][0] = -s3b9d266e2e;\nmb8bcb57dcd[1][1] = cdcd5d1f3d2;\nmb8bcb57dcd[1][2] = 0;\nmb8bcb57dcd[2][0] = 0.0f;\nmb8bcb57dcd[2][1] = 0.0f;\nmb8bcb57dcd[2][2] = 1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_332",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (of type mat4, which is an array of four aligned 4-element float vectors) and two pointers to floats. It extracts specific elements from the matrix, calculates a near clipping distance from one of the matrix\u2019s entries, and then computes two horizontal frustum bounds (left and right) based on that near distance and other matrix elements. The results are stored in the floats pointed to by the two pointer arguments.",
        "code_id": "c_group_2_id_332",
        "code_text": "Cd4e3208291\nvoid\ng87d7a3b3a5(m2979ecef6f paccfd26812,\nfloat * __restrict lcfaba252b8,\nfloat * __restrict rc12144e4ba) {\nfloat nd3cfbab11c, m2134d0010f, m73982a8772, m529843770e;\nm73982a8772 = paccfd26812[0][0];\nm2134d0010f = paccfd26812[2][0];\nm529843770e =-paccfd26812[2][2];\nnd3cfbab11c = paccfd26812[3][2] / (m529843770e - 1.0f);\n*lcfaba252b8   = nd3cfbab11c * (m2134d0010f - 1.0f) / m73982a8772;\n*rc12144e4ba  = nd3cfbab11c * (m2134d0010f + 1.0f) / m73982a8772;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_333",
        "query_text": "SUMMARY: This function multiplies each element of an input 2-dimensional integer vector (ivec2) by an integer scalar and stores the resulting values in an output 2-dimensional integer vector (ivec2). Specifically, the first element of the input vector is multiplied by the scalar and assigned to the first element of the output vector, and the second element is similarly processed for the second output element.",
        "code_id": "c_group_2_id_333",
        "code_text": "Cd4e3208291\nvoid\ngcd274fd6fa(i5e3d0f10c1 v91082a9365, int s3b9d266e2e, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] * s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_334",
        "query_text": "SUMMARY: This function takes an input of type vec3 (an array of three floats) and returns a float as output. It examines the three components of the input vector to determine which one has the greatest value, ultimately returning that highest float value. The function initially considers the first element as the maximum, then sequentially compares the second and third elements to update the maximum when a larger value is found, and finally outputs the largest value.",
        "code_id": "c_group_2_id_334",
        "code_text": "Cd4e3208291\nfloat\ng7c791a454f(veb444e7eb8 v91082a9365) {\nfloat mec5f6d9e50;\nmec5f6d9e50 = v91082a9365[0];\nif (v91082a9365[1] > mec5f6d9e50)\nmec5f6d9e50 = v91082a9365[1];\nif (v91082a9365[2] > mec5f6d9e50)\nmec5f6d9e50 = v91082a9365[2];\nreturn mec5f6d9e50;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_335",
        "query_text": "SUMMARY: This function operates on three input variables: a three-element float array (representing a vector), a single float (scalar), and another three-element float array (representing a destination vector to be modified). For each of the three elements, the function multiplies the corresponding element of the first array by the scalar, then subtracts that product from the corresponding element of the destination array.",
        "code_id": "c_group_2_id_335",
        "code_text": "Cd4e3208291\nvoid\ng401aae10fc(veb444e7eb8 ad90770d038, float s3b9d266e2e, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] * s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] * s3b9d266e2e;\nd9748d673c4[2] -= ad90770d038[2] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_336",
        "query_text": "SUMMARY: This function accepts two input variables and one output variable, each of which is a three-element array of integers (ivec3). It computes the element-wise difference between the first and second input arrays, then adds each resulting difference to the corresponding element of the output array.",
        "code_id": "c_group_2_id_336",
        "code_text": "Cd4e3208291\nvoid\ng0e6e364f15(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] - bba3ae37d1f[1];\nd9748d673c4[2] += ad90770d038[2] - bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_337",
        "query_text": "SUMMARY: This function takes two inputs\u2014a three-element array of floats (vec3) and a float scalar\u2014and produces an output that is also a three-element array of floats (vec3). It computes the floating-point remainder of each element in the input array when divided by the scalar, storing the three corresponding results in the output array.",
        "code_id": "c_group_2_id_337",
        "code_text": "Cd4e3208291\nvoid\ngeaba18b0dd(veb444e7eb8 v91082a9365, float s3b9d266e2e, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = fmodf(v91082a9365[0], s3b9d266e2e);\nd9748d673c4[1] = fmodf(v91082a9365[1], s3b9d266e2e);\nd9748d673c4[2] = fmodf(v91082a9365[2], s3b9d266e2e);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_338",
        "query_text": "SUMMARY: This function operates on three variables of type ivec2 (which are int[2]). It subtracts the difference between the corresponding elements of the first two input variables from each element of the output variable. Specifically, for each coordinate index, it updates the output by subtracting the result of the difference (first input minus second input).",
        "code_id": "c_group_2_id_338",
        "code_text": "Cd4e3208291\nvoid\ng5a1ef0c269(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] - bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_339",
        "query_text": "SUMMARY: This function takes an input of type int[4] and produces an output of type int[3]. It sequentially copies the first three integers from the input array into the output array, effectively transferring the initial three elements while ignoring the fourth element.",
        "code_id": "c_group_2_id_339",
        "code_text": "Cd4e3208291\nvoid\ng4143d56309(i52a86355e2 ve94da76c4c, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = ve94da76c4c[0];\nd9748d673c4[1] = ve94da76c4c[1];\nd9748d673c4[2] = ve94da76c4c[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_340",
        "query_text": "SUMMARY: This function accepts an input matrix of type mat2x3 (an array consisting of 2 vectors, each containing 3 floats) and produces an output matrix of type mat3x2 (an array consisting of 3 vectors, each containing 2 floats) that is the transpose of the input. The function rearranges the elements by swapping the row and column indices, so that each element in the output matrix is taken from the corresponding transposed position of the input matrix.",
        "code_id": "c_group_2_id_340",
        "code_text": "Cd4e3208291\nvoid\ng77237b7628(mc11cae8baa mb8bcb57dcd, m5fbc7d59b5 d9748d673c4) {\nd9748d673c4[0][0] = mb8bcb57dcd[0][0];  d9748d673c4[0][1] = mb8bcb57dcd[1][0];\nd9748d673c4[1][0] = mb8bcb57dcd[0][1];  d9748d673c4[1][1] = mb8bcb57dcd[1][1];\nd9748d673c4[2][0] = mb8bcb57dcd[0][2];  d9748d673c4[2][1] = mb8bcb57dcd[1][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_341",
        "query_text": "SUMMARY: This function accepts three parameters of type vec2 (a two-element float array). It computes the element-wise difference between the first and second vec2 inputs, and then adds each resulting component to the corresponding component of the output vec2. Essentially, it updates the output by accumulating the differences between the two input vectors.",
        "code_id": "c_group_2_id_341",
        "code_text": "Cd4e3208291\nvoid\ngc7b85d625c(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] - bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_342",
        "query_text": "SUMMARY: This function receives an aligned 4\u00d74 matrix (of type mat4, where each row is a 4-element aligned float vector) and two pointers to float, which serve as outputs. Its purpose is to decompose the provided perspective projection matrix (configured for a right-handed coordinate system with a zero-to-one depth range) by extracting certain matrix components to calculate the horizontal extents of the view frustum at the near clipping plane. In detail, it computes the distance to the near clipping plane from an element of the matrix and then uses this distance together with other matrix elements to derive the left and right boundaries of the frustum. The resulting left and right boundary values are written to the locations indicated by the input float pointers.",
        "code_id": "c_group_2_id_342",
        "code_text": "Cd4e3208291\nvoid\nga86ef94e26(m2979ecef6f paccfd26812,\nfloat * __restrict lcfaba252b8,\nfloat * __restrict rc12144e4ba) {\nfloat nd3cfbab11c, m2134d0010f, m73982a8772, m529843770e;\nm73982a8772 = paccfd26812[0][0];\nm2134d0010f = paccfd26812[2][0];\nm529843770e = paccfd26812[2][2];\nnd3cfbab11c = paccfd26812[3][2] / m529843770e;\n*lcfaba252b8   = nd3cfbab11c * (m2134d0010f - 1.0f) / m73982a8772;\n*rc12144e4ba  = nd3cfbab11c * (m2134d0010f + 1.0f) / m73982a8772;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_343",
        "query_text": "SUMMARY: The function accepts two inputs\u2014a 3-element array of type int (int[3]) and an integer scalar (int)\u2014and produces an output that is a 3-element array of type int (int[3]). It multiplies each element of the input array by the scalar value and assigns the resulting values to the corresponding elements of the output array.",
        "code_id": "c_group_2_id_343",
        "code_text": "Cd4e3208291\nvoid\ng21c05be18f(i4b951f731e v91082a9365, int s3b9d266e2e, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] * s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] * s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_344",
        "query_text": "SUMMARY: This function takes an input consisting of an array of four integers and a single integer scalar, and produces an output array of four integers. For each element in the input array, it adds the scalar to the element and stores the result in the corresponding element of the output array.",
        "code_id": "c_group_2_id_344",
        "code_text": "Cd4e3208291\nvoid\ngc144b30090(i52a86355e2 v91082a9365, int s3b9d266e2e, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] + s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] + s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] + s3b9d266e2e;\nd9748d673c4[3] = v91082a9365[3] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_345",
        "query_text": "SUMMARY: This function takes two inputs of type int[4] and produces an output of type int[4]. It computes element-wise multiplication by multiplying each corresponding integer in the input arrays and stores the resulting products in the output array.",
        "code_id": "c_group_2_id_345",
        "code_text": "Cd4e3208291\nvoid\ng432fd11b95(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] * bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] * bba3ae37d1f[2];\nd9748d673c4[3] = ad90770d038[3] * bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_346",
        "query_text": "SUMMARY: This function takes three arrays of three integers each (int[3]). It subtracts, element by element, the sum of the corresponding elements of the first two integer arrays from the corresponding element of the third array, updating the output array with the result.",
        "code_id": "c_group_2_id_346",
        "code_text": "Cd4e3208291\nvoid\ng498dec0679(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] + bba3ae37d1f[1];\nd9748d673c4[2] -= ad90770d038[2] + bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_347",
        "query_text": "SUMMARY: This function receives a 4x4 matrix (type: mat4) and a single precision floating-point number (type: float) as inputs, and it produces no output (return type: void). Its behavior is to modify the input matrix by incrementally adjusting the element located at the fourth row and first column by adding the provided floating-point value.",
        "code_id": "c_group_2_id_347",
        "code_text": "Cd4e3208291\nvoid\nga763420444(m2979ecef6f mb8bcb57dcd, float xf1fa84c2ec) {\nmb8bcb57dcd[3][0] += xf1fa84c2ec;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_348",
        "query_text": "SUMMARY: This function accepts an input of type mat2x3 (a two-by-three array of floats) and a scalar of type float, and produces no return value (void). Its primary operation is to uniformly scale each element of the two-by-three matrix by the provided floating-point scalar, updating the matrix in place.",
        "code_id": "c_group_2_id_348",
        "code_text": "Cd4e3208291\nvoid\ng6541b724b9(mc11cae8baa mb8bcb57dcd, float s3b9d266e2e) {\nmb8bcb57dcd[0][0] *= s3b9d266e2e;  mb8bcb57dcd[0][1] *= s3b9d266e2e;  mb8bcb57dcd[0][2] *= s3b9d266e2e;\nmb8bcb57dcd[1][0] *= s3b9d266e2e;  mb8bcb57dcd[1][1] *= s3b9d266e2e;  mb8bcb57dcd[1][2] *= s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_349",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (of type mat4, which is an array of four aligned vec4 arrays of floats) and a pointer to a float (of type float*). It computes the far clipping plane distance from a perspective projection matrix configured for a left-handed coordinate system with a depth range from zero to one. Specifically, it performs a calculation using selected elements from the input matrix and stores the computed far-plane distance in the output float variable.",
        "code_id": "c_group_2_id_349",
        "code_text": "Cd4e3208291\nvoid\ngfbc6195c5f(m2979ecef6f paccfd26812, float * __restrict fb6d340e4c8) {\n*fb6d340e4c8 = paccfd26812[3][2] / (-paccfd26812[2][2] + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_350",
        "query_text": "SUMMARY: This function accepts an input of type float[3] and returns a float. Its purpose is to determine the smallest value among the three elements in the input array by comparing each element and selecting the minimum, then returning that value as output.",
        "code_id": "c_group_2_id_350",
        "code_text": "Cd4e3208291\nfloat\ng5273aca47e(veb444e7eb8 v91082a9365) {\nfloat m721ed67569;\nm721ed67569 = v91082a9365[0];\nif (v91082a9365[1] < m721ed67569)\nm721ed67569 = v91082a9365[1];\nif (v91082a9365[2] < m721ed67569)\nm721ed67569 = v91082a9365[2];\nreturn m721ed67569;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_351",
        "query_text": "SUMMARY: The function accepts a constant two-element integer array (ivec2) and a pointer to a FILE (output stream). It produces no return value. Its primary role is to write a formatted representation of the two-element integer vector to the provided output stream. Specifically, it outputs a label indicating an integer vector with two elements, then prints each integer in the array within parentheses with preset spacing and color formatting, concluding with a reset of the formatting and additional newlines.",
        "code_id": "c_group_2_id_351",
        "code_text": "Cd4e3208291\nvoid\ng89c4481a52(i5e3d0f10c1             vf6195f1fd8,\nFILE * __restrict o5450e5c91d) {\nint i0c6e314cec;\n#define mb8bcb57dcd 2\nfprintf(o5450e5c91d, \"Vector (int%d): \" C45893ec2b2 \"\\n  (\", mb8bcb57dcd);\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++)\nfprintf(o5450e5c91d, \" % d\", vf6195f1fd8[i0c6e314cec]);\nfprintf(o5450e5c91d, \"  )\" C7c34c62781 \"\\n\\n\");\n#undef mb8bcb57dcd\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_352",
        "query_text": "SUMMARY: This function takes a vector of 4 integers as one input, an integer scalar as another input, and a second vector of 4 integers as the output. It performs an element-wise operation whereby each element of the output vector is incremented by the sum of the corresponding element from the input vector and the scalar integer.",
        "code_id": "c_group_2_id_352",
        "code_text": "Cd4e3208291\nvoid\ngcafd7280cb(i52a86355e2 ad90770d038, int s3b9d266e2e, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] + s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] + s3b9d266e2e;\nd9748d673c4[2] += ad90770d038[2] + s3b9d266e2e;\nd9748d673c4[3] += ad90770d038[3] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_353",
        "query_text": "SUMMARY: This function takes an input of type \"pointer to constant float\" (representing an array of at least four floats) and an output of type \"vec4\" (an aligned array of four floats). It copies each of the four individual float values from the input array to the corresponding position in the output array, effectively building a 4-dimensional vector from the provided source data.",
        "code_id": "c_group_2_id_353",
        "code_text": "Cd4e3208291\nvoid\ngd06bef357c(const float * __restrict sa425380d12, v141258b569 d9748d673c4) {\nd9748d673c4[0] = sa425380d12[0]; d9748d673c4[1] = sa425380d12[1];\nd9748d673c4[2] = sa425380d12[2]; d9748d673c4[3] = sa425380d12[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_354",
        "query_text": "SUMMARY: This function receives a 2\u00d72 matrix (mat2, which is defined as an array of two float[2] vectors with potential 16\u2010byte alignment) as an in/out parameter and a float scalar as an input. It scales the matrix by multiplying each element in the matrix by the scalar value, updating the matrix directly.",
        "code_id": "c_group_2_id_354",
        "code_text": "Cd4e3208291\nvoid\ngc45ef3172f(mde4d4e4936 mb8bcb57dcd, float s3b9d266e2e) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(m[0], wasm_f32x4_mul(wasm_v128_load(m[0]),\nwasm_f32x4_splat(s)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(mb8bcb57dcd[0], _mm_mul_ps(_mm_loadu_ps(mb8bcb57dcd[0]), _mm_set1_ps(s3b9d266e2e)));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(m[0], vmulq_f32(vld1q_f32(m[0]), vdupq_n_f32(s)));\n#else\nm[0][0] = m[0][0] * s;\nm[0][1] = m[0][1] * s;\nm[1][0] = m[1][0] * s;\nm[1][1] = m[1][1] * s;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_355",
        "query_text": "SUMMARY: The function performs multiplication between a 3x2 matrix (an array of three 2-element float arrays) and a 2x3 matrix (an array of two 3-element float arrays), producing a 2x2 matrix (an array of two 2-element float arrays) as the output. In essence, it computes each element of the resulting matrix by evaluating the dot products between appropriate rows of the first matrix and columns of the second matrix.",
        "code_id": "c_group_2_id_355",
        "code_text": "Cd4e3208291\nvoid\ngc24bedc353(m5fbc7d59b5 m7f4f0cd2cb, mc11cae8baa m71ae398200, mde4d4e4936 d9748d673c4) {\nfloat a79034f70a3 = m7f4f0cd2cb[0][0], af8ba94e471 = m7f4f0cd2cb[0][1],\na00a7244c30 = m7f4f0cd2cb[1][0], a90b743b58c = m7f4f0cd2cb[1][1],\nabbf182117b = m7f4f0cd2cb[2][0], a76187ed5e7 = m7f4f0cd2cb[2][1],\nb24ae8206ee = m71ae398200[0][0], ba7a975e23f = m71ae398200[0][1], b26594d8877 = m71ae398200[0][2],\nbd4c89897d0 = m71ae398200[1][0], b339ffe7279 = m71ae398200[1][1], bfa76c9278d = m71ae398200[1][2];\nd9748d673c4[0][0] = a79034f70a3 * b24ae8206ee + a00a7244c30 * ba7a975e23f + abbf182117b * b26594d8877;\nd9748d673c4[0][1] = af8ba94e471 * b24ae8206ee + a90b743b58c * ba7a975e23f + a76187ed5e7 * b26594d8877;\nd9748d673c4[1][0] = a79034f70a3 * bd4c89897d0 + a00a7244c30 * b339ffe7279 + abbf182117b * bfa76c9278d;\nd9748d673c4[1][1] = af8ba94e471 * bd4c89897d0 + a90b743b58c * b339ffe7279 + a76187ed5e7 * bfa76c9278d;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_356",
        "query_text": "SUMMARY: This function scales a 4x2 matrix in place. It takes as input a 4x2 matrix (an array of four arrays of 2 floats each) and a scalar of type float. The function multiplies each element of the input matrix by the scalar, effectively applying a uniform scaling transformation to the matrix, and produces no explicit output (void return type).",
        "code_id": "c_group_2_id_356",
        "code_text": "Cd4e3208291\nvoid\ng6a3831c508(mab2cb9021e mb8bcb57dcd, float s3b9d266e2e) {\nmb8bcb57dcd[0][0] *= s3b9d266e2e;  mb8bcb57dcd[0][1] *= s3b9d266e2e;  mb8bcb57dcd[1][0] *= s3b9d266e2e;  mb8bcb57dcd[1][1] *= s3b9d266e2e;\nmb8bcb57dcd[2][0] *= s3b9d266e2e;  mb8bcb57dcd[2][1] *= s3b9d266e2e;  mb8bcb57dcd[3][0] *= s3b9d266e2e;  mb8bcb57dcd[3][1] *= s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_357",
        "query_text": "SUMMARY: This function accepts a 4x4 matrix (of type mat4, which is an aligned array of four vec4, where each vec4 is an aligned array of four floats) and two integer indices. It exchanges the rows of the matrix corresponding to those two indices, effectively swapping their positions in the 4x4 matrix. The function directly modifies the input matrix and does not return any value.",
        "code_id": "c_group_2_id_357",
        "code_text": "Cd4e3208291\nvoid\ngdfc03954b8(m2979ecef6f ma02b861363, int r1ea1edcbb8, int rf12a1dfd6d) {\nC6d833bf7a0(16) v141258b569 tb20dfb361b;\ntb20dfb361b[0] = ma02b861363[0][r1ea1edcbb8];\ntb20dfb361b[1] = ma02b861363[1][r1ea1edcbb8];\ntb20dfb361b[2] = ma02b861363[2][r1ea1edcbb8];\ntb20dfb361b[3] = ma02b861363[3][r1ea1edcbb8];\nma02b861363[0][r1ea1edcbb8] = ma02b861363[0][rf12a1dfd6d];\nma02b861363[1][r1ea1edcbb8] = ma02b861363[1][rf12a1dfd6d];\nma02b861363[2][r1ea1edcbb8] = ma02b861363[2][rf12a1dfd6d];\nma02b861363[3][r1ea1edcbb8] = ma02b861363[3][rf12a1dfd6d];\nma02b861363[0][rf12a1dfd6d] = tb20dfb361b[0];\nma02b861363[1][rf12a1dfd6d] = tb20dfb361b[1];\nma02b861363[2][rf12a1dfd6d] = tb20dfb361b[2];\nma02b861363[3][rf12a1dfd6d] = tb20dfb361b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_358",
        "query_text": "SUMMARY: This function accepts three arrays of three floating-point numbers (vec3) as inputs. It processes an in-place update on the third array by subtracting, for each corresponding index, the product of the elements from the first and second arrays. In essence, each element of the output array is reduced by the product of the corresponding elements of the two input arrays.",
        "code_id": "c_group_2_id_358",
        "code_text": "Cd4e3208291\nvoid\ng793d96fec5(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] * bba3ae37d1f[1];\nd9748d673c4[2] -= ad90770d038[2] * bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_359",
        "query_text": "SUMMARY: This function accepts two inputs, each being an array of four integers (ivec4), and computes their element-wise addition. It produces an output that is also an array of four integers (ivec4), where each position is the sum of the corresponding elements from the two input arrays.",
        "code_id": "c_group_2_id_359",
        "code_text": "Cd4e3208291\nvoid\ng74a985efc9(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] + bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] + bba3ae37d1f[2];\nd9748d673c4[3] = ad90770d038[3] + bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_360",
        "query_text": "SUMMARY: This function accepts an input of type const float* and an output of type vec3 (an array of three floats). It sequentially copies three float values from the input to the output array by assigning the first float to the first element, the second float to the second element, and the third float to the third element.",
        "code_id": "c_group_2_id_360",
        "code_text": "Cd4e3208291\nvoid\ng23eb84723c(const float * __restrict sa425380d12, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = sa425380d12[0];\nd9748d673c4[1] = sa425380d12[1];\nd9748d673c4[2] = sa425380d12[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_361",
        "query_text": "SUMMARY: This function computes the inverse of a 2x2 matrix. It accepts an input of type mat2 (an array of two vec2, with each vec2 being a 2-element array of float) representing the matrix to be inverted, and produces an output of the same type (mat2) that contains the inverse matrix. The function extracts the four individual float elements from the input matrix, calculates the reciprocal of its determinant, and then computes each element of the inverse matrix using the standard inversion formula for 2x2 matrices.",
        "code_id": "c_group_2_id_361",
        "code_text": "Cd4e3208291\nvoid\ng2e382f77f9(mde4d4e4936 ma02b861363, mde4d4e4936 d9748d673c4) {\nfloat dfa23eb73cf;\nfloat ad90770d038 = ma02b861363[0][0], bba3ae37d1f = ma02b861363[0][1],\ncdcd5d1f3d2 = ma02b861363[1][0], ded8b2a8791 = ma02b861363[1][1];\ndfa23eb73cf = 1.0f / (ad90770d038 * ded8b2a8791 - bba3ae37d1f * cdcd5d1f3d2);\nd9748d673c4[0][0] =  ded8b2a8791 * dfa23eb73cf;\nd9748d673c4[0][1] = -bba3ae37d1f * dfa23eb73cf;\nd9748d673c4[1][0] = -cdcd5d1f3d2 * dfa23eb73cf;\nd9748d673c4[1][1] =  ad90770d038 * dfa23eb73cf;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_362",
        "query_text": "SUMMARY: This function takes two inputs of type \"int[3]\" (3-element integer arrays) and computes an output of type int. It calculates each corresponding difference between the elements of the inputs, squares these differences, and returns the sum, which represents the squared Euclidean distance.",
        "code_id": "c_group_2_id_362",
        "code_text": "Cd4e3208291\nint\ng1f6699368e(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f) {\nint x81a09a0ef5, yb011f21308, zdcf909fec1;\nx81a09a0ef5 = ad90770d038[0] - bba3ae37d1f[0];\nyb011f21308 = ad90770d038[1] - bba3ae37d1f[1];\nzdcf909fec1 = ad90770d038[2] - bba3ae37d1f[2];\nreturn x81a09a0ef5 * x81a09a0ef5 + yb011f21308 * yb011f21308 + zdcf909fec1 * zdcf909fec1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_363",
        "query_text": "SUMMARY: This function accepts three arguments, each being an array of two single-precision floating-point values (vec2). It multiplies the corresponding components of the two input arrays and then adds each product to the respective component of the destination array, updating it in place.",
        "code_id": "c_group_2_id_363",
        "code_text": "Cd4e3208291\nvoid\nge1c8c33dd1(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] * bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_364",
        "query_text": "SUMMARY: This function takes as input a 4-element array of integers (ivec4) and modifies it in-place by setting all four elements to the integer value zero, without returning any value.",
        "code_id": "c_group_2_id_364",
        "code_text": "Cd4e3208291\nvoid\ngf751b09550(i52a86355e2 v91082a9365) {\nv91082a9365[0] = v91082a9365[1] = v91082a9365[2] = v91082a9365[3] = 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_365",
        "query_text": "SUMMARY: This function accepts a two-element array of integers (ivec2) and an integer scalar as its inputs. It performs element-wise subtraction by deducting the scalar from each component of the two-element integer array, and then stores the resulting values into an output two-element array of integers.",
        "code_id": "c_group_2_id_365",
        "code_text": "Cd4e3208291\nvoid\ng4eae2316ce(i5e3d0f10c1 v91082a9365, int s3b9d266e2e, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] - s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_366",
        "query_text": "SUMMARY: This function accepts an input of type vec4 (a 4-element array of 32-bit floats) and computes, for each element, its fractional part by subtracting the floor of the element\u2019s value. It then clamps each fractional result so that it does not exceed approximately 0.99999994, and stores the resulting 4-element array in an output variable of the same type.",
        "code_id": "c_group_2_id_366",
        "code_text": "Cd4e3208291\nvoid\ng7b3961ebe2(v141258b569 v91082a9365, v141258b569 d9748d673c4) {\nd9748d673c4[0] = fminf(v91082a9365[0] - floorf(v91082a9365[0]), 0.999999940395355224609375f);\nd9748d673c4[1] = fminf(v91082a9365[1] - floorf(v91082a9365[1]), 0.999999940395355224609375f);\nd9748d673c4[2] = fminf(v91082a9365[2] - floorf(v91082a9365[2]), 0.999999940395355224609375f);\nd9748d673c4[3] = fminf(v91082a9365[3] - floorf(v91082a9365[3]), 0.999999940395355224609375f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_367",
        "query_text": "SUMMARY: This function accepts as inputs a 4\u00d74 floating\u2010point matrix (mat4) representing a right-handed no-clip perspective projection and a single floating-point scalar (float) that specifies an adjustment to the far clipping plane. It computes the current near and far clipping distances using specific elements from the matrix, adjusts the far distance by the provided scalar, and then recalculates and updates the corresponding entries in the matrix. The output is the modified projection matrix (mat4) reflecting the new far clipping plane position.",
        "code_id": "c_group_2_id_367",
        "code_text": "Cd4e3208291\nvoid\ngd1a1863e64(m2979ecef6f paccfd26812, float dc3e1e7568f) {\nfloat f9bc16e1f91, fb6d340e4c8, nd3cfbab11c, p6624354550, pe06d2fef65;\np6624354550        = paccfd26812[2][2];\npe06d2fef65        = paccfd26812[3][2];\nnd3cfbab11c    = pe06d2fef65 / (p6624354550 - 1.0f);\nfb6d340e4c8     = pe06d2fef65 / (p6624354550 + 1.0f) + dc3e1e7568f;\nf9bc16e1f91         = 1.0f / (nd3cfbab11c - fb6d340e4c8);\npaccfd26812[2][2] = (fb6d340e4c8 + nd3cfbab11c) * f9bc16e1f91;\npaccfd26812[3][2] = 2.0f * nd3cfbab11c * fb6d340e4c8 * f9bc16e1f91;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_368",
        "query_text": "SUMMARY: This inline function accepts an input of type integer array with three elements (ivec3) and returns no output (void). The function's behavior is to set each of the three integer elements in the array to zero, effectively initializing or resetting the array's contents.",
        "code_id": "c_group_2_id_368",
        "code_text": "Cd4e3208291\nvoid\ngdc64772ba7(i4b951f731e v91082a9365) {\nv91082a9365[0] = v91082a9365[1] = v91082a9365[2] = 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_369",
        "query_text": "SUMMARY: This function accepts a 3\u00d74 matrix (type mat3x4: an array of three 4-element float vectors) and a 3D vector (type vec3: an array of three floats) as inputs and produces a 4D vector (type vec4: an array of four floats) as output. It extracts the three scalar components of the 3D vector and, for each of the four output components, computes the sum of the products of these scalars with the corresponding elements from the 3\u00d74 matrix. Essentially, it performs a multiplication of the 3\u00d74 matrix with the 3D vector to generate a transformed 4D vector.",
        "code_id": "c_group_2_id_369",
        "code_text": "Cd4e3208291\nvoid\ng9c0ffb632a(m5fbb141a9c mb8bcb57dcd, veb444e7eb8 v91082a9365, v141258b569 d9748d673c4) {\nfloat v01fb438970 = v91082a9365[0], v748b5cffd1 = v91082a9365[1], v05a5120aa0 = v91082a9365[2];\nd9748d673c4[0] = mb8bcb57dcd[0][0] * v01fb438970 + mb8bcb57dcd[1][0] * v748b5cffd1 + mb8bcb57dcd[2][0] * v05a5120aa0;\nd9748d673c4[1] = mb8bcb57dcd[0][1] * v01fb438970 + mb8bcb57dcd[1][1] * v748b5cffd1 + mb8bcb57dcd[2][1] * v05a5120aa0;\nd9748d673c4[2] = mb8bcb57dcd[0][2] * v01fb438970 + mb8bcb57dcd[1][2] * v748b5cffd1 + mb8bcb57dcd[2][2] * v05a5120aa0;\nd9748d673c4[3] = mb8bcb57dcd[0][3] * v01fb438970 + mb8bcb57dcd[1][3] * v748b5cffd1 + mb8bcb57dcd[2][3] * v05a5120aa0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_370",
        "query_text": "SUMMARY: This function takes as input an integer array of two elements and an integer scalar, and it modifies an output integer array of two elements by subtracting from each of its elements the sum of the corresponding element in the input integer array and the scalar.",
        "code_id": "c_group_2_id_370",
        "code_text": "Cd4e3208291\nvoid\ng8f50ddc7cc(i5e3d0f10c1 ad90770d038, int s3b9d266e2e, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] + s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_371",
        "query_text": "SUMMARY: This function takes an input 4\u00d74 matrix (of type mat4, which is an array of four 16-byte aligned float[4] vectors) and produces its transposed version as an output 4\u00d74 matrix (also of type mat4). It loads the rows of the input matrix into SIMD registers, transposes the 4\u00d74 data using SSE2 operations, and then stores the resulting vectors into the output matrix.",
        "code_id": "c_group_2_id_371",
        "code_text": "Cd4e3208291\nvoid\ng534a34cda7(m2979ecef6f mb8bcb57dcd, m2979ecef6f d9748d673c4) {\n__m128 r7e333a76f2, r4dc32c56ad, rc425d4f404, r76a364fc6b;\nr7e333a76f2 = g86f14e15d6(mb8bcb57dcd[0]);\nr4dc32c56ad = g86f14e15d6(mb8bcb57dcd[1]);\nrc425d4f404 = g86f14e15d6(mb8bcb57dcd[2]);\nr76a364fc6b = g86f14e15d6(mb8bcb57dcd[3]);\n_6abaf6c67f(r7e333a76f2, r4dc32c56ad, rc425d4f404, r76a364fc6b);\ngc83e6cd198(d9748d673c4[0], r7e333a76f2);\ngc83e6cd198(d9748d673c4[1], r4dc32c56ad);\ngc83e6cd198(d9748d673c4[2], rc425d4f404);\ngc83e6cd198(d9748d673c4[3], r76a364fc6b);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_372",
        "query_text": "SUMMARY: This function takes as input a 4\u00d74 floating\u2010point matrix (of type mat4) representing a left-handed perspective projection and a single floating-point scalar (of type float). It recalculates and updates two specific elements of the matrix to effectively adjust the far clipping distance of the projection. To do so, the function derives the current near and far distances from the matrix\u2019s existing coefficients, adds an offset to the computed far distance, and then updates the matrix accordingly to maintain the correct projection transformation. The matrix is modified in place as the output.",
        "code_id": "c_group_2_id_372",
        "code_text": "Cd4e3208291\nvoid\ngc88a75e078(m2979ecef6f paccfd26812, float dc3e1e7568f) {\nfloat f9bc16e1f91, fb6d340e4c8, nd3cfbab11c, p6624354550, pe06d2fef65;\np6624354550        = -paccfd26812[2][2];\npe06d2fef65        = paccfd26812[3][2];\nnd3cfbab11c    = pe06d2fef65 / (p6624354550 - 1.0f);\nfb6d340e4c8     = pe06d2fef65 / (p6624354550 + 1.0f) + dc3e1e7568f;\nf9bc16e1f91         = 1.0f / (nd3cfbab11c - fb6d340e4c8);\npaccfd26812[2][2] = -(fb6d340e4c8 + nd3cfbab11c) * f9bc16e1f91;\npaccfd26812[3][2] = 2.0f * nd3cfbab11c * fb6d340e4c8 * f9bc16e1f91;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_373",
        "query_text": "SUMMARY: This function accepts a 3x3 matrix (of type mat3, which is defined as an array of three vec3 arrays of floats) and a float scalar. It applies an in-place 2D translation along the horizontal axis to the matrix by updating its translation components. Specifically, it modifies the last row of the matrix by adding the product of the corresponding elements from the first row (representing the x-axis scale factors) and the float value to the existing values. The function does not return a value; instead, it directly alters the matrix.",
        "code_id": "c_group_2_id_373",
        "code_text": "Cd4e3208291\nvoid\ng8c6c6b6078(m63312228ee mb8bcb57dcd, float xf1fa84c2ec) {\nmb8bcb57dcd[2][0] = mb8bcb57dcd[0][0] * xf1fa84c2ec + mb8bcb57dcd[2][0];\nmb8bcb57dcd[2][1] = mb8bcb57dcd[0][1] * xf1fa84c2ec + mb8bcb57dcd[2][1];\nmb8bcb57dcd[2][2] = mb8bcb57dcd[0][2] * xf1fa84c2ec + mb8bcb57dcd[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_374",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 floating-point matrix (an array of four 4-element float vectors) and two pointers to floats as inputs. It computes two scalar floating-point outputs representing near and far clipping distances by extracting specific elements from the input matrix and applying division operations using those elements. Specifically, it derives the near clipping distance by dividing one matrix element by another, and the far clipping distance by dividing the same element by an incremented version of the other. The resulting values are stored in the provided float pointers.",
        "code_id": "c_group_2_id_374",
        "code_text": "Cd4e3208291\nvoid\ng71d26179ee(m2979ecef6f paccfd26812,\nfloat * __restrict nd3cfbab11c,\nfloat * __restrict fb6d340e4c8) {\nfloat m9a4eaa88e8, m529843770e;\nm9a4eaa88e8 = paccfd26812[3][2];\nm529843770e = paccfd26812[2][2];\n*nd3cfbab11c = m9a4eaa88e8 / m529843770e;\n*fb6d340e4c8  = m9a4eaa88e8 / (m529843770e + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_375",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two floats) and produces an output of the same type (an array of two floats) by computing the element-wise arithmetic negation of the input values. Specifically, it negates each of the two float elements from the input array and stores the results into the corresponding positions in the output array.",
        "code_id": "c_group_2_id_375",
        "code_text": "Cd4e3208291\nvoid\ng687adf973f(v0131f5a9ae v91082a9365, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = -v91082a9365[0];\nd9748d673c4[1] = -v91082a9365[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_376",
        "query_text": "SUMMARY: This function takes two inputs\u2014a 3-element integer array and a scalar integer\u2014and produces an output in the form of a 4-element integer array. It populates the first three elements of the output with the values from the input 3-element array and assigns the scalar integer to the fourth element of the output.",
        "code_id": "c_group_2_id_376",
        "code_text": "Cd4e3208291\nvoid\ng275fe3a56e(i4b951f731e va7ad10f1fc, int le286350680, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = va7ad10f1fc[0];\nd9748d673c4[1] = va7ad10f1fc[1];\nd9748d673c4[2] = va7ad10f1fc[2];\nd9748d673c4[3] = le286350680;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_377",
        "query_text": "SUMMARY: This function accepts as inputs a 4\u00d74 float matrix (of type vec4[4]) and a pointer to a FILE stream (of type FILE*). It does not return any value. Its functionality is to print a formatted textual representation of the 4\u00d74 matrix to the given FILE stream. The function begins by outputting a header that indicates the dimensions of the matrix, then measures the formatted width of each element (using either fixed decimal precision or general formatting based on a preset threshold) to determine appropriate column widths. Using these computed column widths, it generates and prints each row of the matrix within a bordered layout and applies designated color formatting, finally resetting the color output once printing completes.",
        "code_id": "c_group_2_id_377",
        "code_text": "Cd4e3208291\nvoid\ngfa9c3f7b7d(m2979ecef6f              ma09c4861bd,\nFILE * __restrict o5450e5c91d) {\nchar b99ab09a63e[16];\nint  i0c6e314cec, jbd3357c513, ce3a4cd4f8f[4], c00eff67c74;\n#define mb8bcb57dcd 4\n#define neb9157c168 4\nfprintf(o5450e5c91d, \"Matrix (float%dx%d): \" C45893ec2b2 \"\\n\" , mb8bcb57dcd, neb9157c168);\nce3a4cd4f8f[0] = ce3a4cd4f8f[1] = ce3a4cd4f8f[2] = ce3a4cd4f8f[3] = 0;\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++) {\nfor (jbd3357c513 = 0; jbd3357c513 < neb9157c168; jbd3357c513++) {\nif (ma09c4861bd[i0c6e314cec][jbd3357c513] < Cd0da13f7c8)\nc00eff67c74 = snprintf(b99ab09a63e, sizeof(b99ab09a63e), \"% .*f\", Cb46738fea8, (double)ma09c4861bd[i0c6e314cec][jbd3357c513]);\nelse\nc00eff67c74 = snprintf(b99ab09a63e, sizeof(b99ab09a63e), \"% g\", (double)ma09c4861bd[i0c6e314cec][jbd3357c513]);\nce3a4cd4f8f[i0c6e314cec] = Gce27a59f0b(ce3a4cd4f8f[i0c6e314cec], c00eff67c74);\n}\n}\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++) {\nfprintf(o5450e5c91d, \"  |\");\nfor (jbd3357c513 = 0; jbd3357c513 < neb9157c168; jbd3357c513++)\nif (ma09c4861bd[i0c6e314cec][jbd3357c513] < Cd0da13f7c8)\nfprintf(o5450e5c91d, \" % *.*f\", ce3a4cd4f8f[jbd3357c513], Cb46738fea8, (double)ma09c4861bd[jbd3357c513][i0c6e314cec]);\nelse\nfprintf(o5450e5c91d, \" % *g\", ce3a4cd4f8f[jbd3357c513], (double)ma09c4861bd[jbd3357c513][i0c6e314cec]);\nfprintf(o5450e5c91d, \"  |\\n\");\n}\nfprintf(o5450e5c91d, C7c34c62781 \"\\n\");\n#undef mb8bcb57dcd\n#undef neb9157c168\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_378",
        "query_text": "SUMMARY: This function accepts two inputs, each being an array of two integers (ivec2), representing 2D integer vectors. It calculates the squared differences between the corresponding components of these two arrays and returns the sum of these squared values as an integer.",
        "code_id": "c_group_2_id_378",
        "code_text": "Cd4e3208291\nint\ng86919a2af3(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f) {\nint x81a09a0ef5, yb011f21308;\nx81a09a0ef5 = ad90770d038[0] - bba3ae37d1f[0];\nyb011f21308 = ad90770d038[1] - bba3ae37d1f[1];\nreturn x81a09a0ef5 * x81a09a0ef5 + yb011f21308 * yb011f21308;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_379",
        "query_text": "SUMMARY: This function accepts two input variables, each of type ivec2 (an array of 2 integers), and an output variable of the same type. It calculates the integer division of each corresponding element from the two input arrays and stores each result in the output array.",
        "code_id": "c_group_2_id_379",
        "code_text": "Cd4e3208291\nvoid\ngf47a712044(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] / bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] / bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_380",
        "query_text": "SUMMARY: This function operates on three variables of type ivec2 (arrays of two integers). It computes the element-wise remainder of the integers from the first input against the corresponding integers from the second input and stores the results in the output variable of type ivec2.",
        "code_id": "c_group_2_id_380",
        "code_text": "Cd4e3208291\nvoid\ngdb8fc23b2a(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] % bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] % bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_381",
        "query_text": "SUMMARY: This function operates on three variables of type ivec2 (i.e., arrays of two integers). It computes the element-wise difference between the first and second input vectors and then adds each difference to the corresponding element of the output vector. Specifically, for the first element, it adds the difference (first input's element minus second input's element) to the first element of the output vector, and similarly for the second element.",
        "code_id": "c_group_2_id_381",
        "code_text": "Cd4e3208291\nvoid\ng8a5299dfd4(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] - bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_382",
        "query_text": "SUMMARY: This function operates on a 4-element integer array (ivec4) and an integer scalar as inputs, and it produces an output in a 4-element integer array (ivec4). For each corresponding element, it subtracts the result of subtracting the scalar from the input vector element, then updates the output array element with this computed difference.",
        "code_id": "c_group_2_id_382",
        "code_text": "Cd4e3208291\nvoid\ng3a3f7aa849(i52a86355e2 ad90770d038, int s3b9d266e2e, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] - s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] - s3b9d266e2e;\nd9748d673c4[2] -= ad90770d038[2] - s3b9d266e2e;\nd9748d673c4[3] -= ad90770d038[3] - s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_383",
        "query_text": "SUMMARY: This function takes an integer vector of three elements (ivec3) and two integer values representing a minimum and a maximum. It ensures that each element of the vector is adjusted to lie within the inclusive range defined by these minimum and maximum values. If any element is less than the minimum, it is set to the minimum; if it is greater than the maximum, it is set to the maximum. The function performs these modifications in place and does not return a value.",
        "code_id": "c_group_2_id_383",
        "code_text": "Cd4e3208291\nvoid\ng1f26691710(i4b951f731e v91082a9365, int m5d862d9243, int mfb64f1df94) {\nif (v91082a9365[0] < m5d862d9243)\nv91082a9365[0] = m5d862d9243;\nelse if(v91082a9365[0] > mfb64f1df94)\nv91082a9365[0] = mfb64f1df94;\nif (v91082a9365[1] < m5d862d9243)\nv91082a9365[1] = m5d862d9243;\nelse if(v91082a9365[1] > mfb64f1df94)\nv91082a9365[1] = mfb64f1df94;\nif (v91082a9365[2] < m5d862d9243)\nv91082a9365[2] = m5d862d9243;\nelse if(v91082a9365[2] > mfb64f1df94)\nv91082a9365[2] = mfb64f1df94;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_384",
        "query_text": "SUMMARY: This function operates on three input parameters, each of type vec4 (an aligned array of 4 floating-point values). It computes an element-wise subtraction between the first and second vec4 values and then subtracts the resulting difference from the third vec4 value, updating it in place with the outcome. The operation essentially performs, for each of the 4 elements, a calculation akin to: output element = original output element minus (first element minus second element), using the most appropriate vectorized instructions available for the current platform.",
        "code_id": "c_group_2_id_384",
        "code_text": "Cd4e3208291\nvoid\ng9177152504(v141258b569 ad90770d038, v141258b569 bba3ae37d1f, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_sub(\ng86f14e15d6(dest),\nwasm_f32x4_sub(g86f14e15d6(a), g86f14e15d6(b))));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_sub_ps(g86f14e15d6(d9748d673c4),\n_mm_sub_ps(g86f14e15d6(ad90770d038),\ng86f14e15d6(bba3ae37d1f))));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vsubq_f32(vld1q_f32(dest),\nvsubq_f32(vld1q_f32(a),\nvld1q_f32(b))));\n#else\ndest[0] -= a[0] - b[0];\ndest[1] -= a[1] - b[1];\ndest[2] -= a[2] - b[2];\ndest[3] -= a[3] - b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_385",
        "query_text": "SUMMARY: This function processes an input of type int[4] and an integer scalar. It multiplies each of the four integer elements from the input by the scalar and stores the results in an output of type int[4].",
        "code_id": "c_group_2_id_385",
        "code_text": "Cd4e3208291\nvoid\ngb73a766990(i52a86355e2 v91082a9365, int s3b9d266e2e, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] * s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] * s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] * s3b9d266e2e;\nd9748d673c4[3] = v91082a9365[3] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_386",
        "query_text": "SUMMARY: This function accepts a 3-element vector of floats (vec3) representing Euler angles and computes a corresponding quaternion (versor, a 4-element aligned float array) that applies the rotation defined by a Y-X-Z ordering in a left-handed coordinate system. It calculates half-angle sine and cosine components for each Euler angle (with the sine of the third angle negated to account for the coordinate system), then combines these values to produce the four components of the resulting quaternion.",
        "code_id": "c_group_2_id_386",
        "code_text": "Cd4e3208291\nvoid\ng520c77581e(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad =  sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa =  sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = -sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] =  ydfce0dcdee * xa08976ecad * z1a2745c1a8 + ye938664caa * x1dce3a8271 * z8de8afe2d4;\nd9748d673c4[1] = -ydfce0dcdee * xa08976ecad * z8de8afe2d4 + ye938664caa * x1dce3a8271 * z1a2745c1a8;\nd9748d673c4[2] =  ydfce0dcdee * x1dce3a8271 * z8de8afe2d4 - ye938664caa * xa08976ecad * z1a2745c1a8;\nd9748d673c4[3] =  ydfce0dcdee * x1dce3a8271 * z1a2745c1a8 + ye938664caa * xa08976ecad * z8de8afe2d4;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_387",
        "query_text": "SUMMARY: This function takes a 4\u00d73 matrix (of type mat4x3, i.e., an array of four 3-element single-precision floating-point vectors) and a scalar (of type float) as inputs. It scales every element of the provided matrix by multiplying each float value by the scalar, modifying the matrix in place. The function does not return any value.",
        "code_id": "c_group_2_id_387",
        "code_text": "Cd4e3208291\nvoid\ngd63a34c2f5(mc9dd4b805d mb8bcb57dcd, float s3b9d266e2e) {\nmb8bcb57dcd[0][0] *= s3b9d266e2e;  mb8bcb57dcd[0][1] *= s3b9d266e2e;  mb8bcb57dcd[0][2] *= s3b9d266e2e;  mb8bcb57dcd[1][0] *= s3b9d266e2e;\nmb8bcb57dcd[1][1] *= s3b9d266e2e;  mb8bcb57dcd[1][2] *= s3b9d266e2e;  mb8bcb57dcd[2][0] *= s3b9d266e2e;  mb8bcb57dcd[2][1] *= s3b9d266e2e;\nmb8bcb57dcd[2][2] *= s3b9d266e2e;  mb8bcb57dcd[3][0] *= s3b9d266e2e;  mb8bcb57dcd[3][1] *= s3b9d266e2e;  mb8bcb57dcd[3][2] *= s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_388",
        "query_text": "SUMMARY: This function accepts a scalar of type float and computes a four-element vector (vec4, an array of 4 floats). It calculates the cube, square, and the first power of the input value and then sets a constant value, resulting in an output vector whose elements correspond respectively to the cubic term, quadratic term, linear term, and the constant 1.0.",
        "code_id": "c_group_2_id_388",
        "code_text": "Cd4e3208291\nvoid\ng056cb21142(float s3b9d266e2e, v141258b569 d9748d673c4) {\nfloat sf898203df3;\nsf898203df3 = s3b9d266e2e * s3b9d266e2e;\nd9748d673c4[0] = sf898203df3 * s3b9d266e2e;\nd9748d673c4[1] = sf898203df3;\nd9748d673c4[2] = s3b9d266e2e;\nd9748d673c4[3] = 1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_389",
        "query_text": "SUMMARY: This function accepts an input parameter of type ivec2 (an array of 2 integers) and assigns the value 1 to both of its elements. It operates directly on the provided array and does not return any value.",
        "code_id": "c_group_2_id_389",
        "code_text": "Cd4e3208291\nvoid\ngf4c28e8eed(i5e3d0f10c1 v91082a9365) {\nv91082a9365[0] = v91082a9365[1] = 1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_390",
        "query_text": "SUMMARY: This function accepts an input of type vec3 (an array of three floats) and returns an output of type float. It computes the sum of the three float values contained in the input array by adding them together and then returns the resulting float.",
        "code_id": "c_group_2_id_390",
        "code_text": "Cd4e3208291\nfloat\ngaa18cd48a7(veb444e7eb8 v91082a9365) {\nreturn v91082a9365[0] + v91082a9365[1] + v91082a9365[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_391",
        "query_text": "SUMMARY: This function accepts two input parameters: one of type int[4] (a four-element integer array) and one of type FILE* (a pointer to a file stream). It outputs no value. Its behavior is to format and print the provided 4-element integer array to the given file stream, including a header indicating the vector\u2019s size and a list of its elements, with additional formatting (such as color markers) applied to the output.",
        "code_id": "c_group_2_id_391",
        "code_text": "Cd4e3208291\nvoid\ng9a43923f00(i52a86355e2             vf6195f1fd8,\nFILE * __restrict o5450e5c91d) {\nint i0c6e314cec;\n#define mb8bcb57dcd 4\nfprintf(o5450e5c91d, \"Vector (int%d): \" C45893ec2b2 \"\\n  (\", mb8bcb57dcd);\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++)\nfprintf(o5450e5c91d, \" % d\", vf6195f1fd8[i0c6e314cec]);\nfprintf(o5450e5c91d, \"  )\" C7c34c62781 \"\\n\\n\");\n#undef mb8bcb57dcd\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_392",
        "query_text": "SUMMARY: This function accepts a floating-point value and a 4\u00d74 matrix of floats (where the matrix is represented as an array of four aligned 4-element vectors) and outputs no value (performing in-place modification). It verifies if the top-left element of the matrix is nonzero; if so, it updates that element by dividing another matrix element (the one representing the vertical scale) by the given float. Essentially, it adjusts the projection matrix\u2019s horizontal scaling based on an aspect ratio.",
        "code_id": "c_group_2_id_392",
        "code_text": "Cd4e3208291\nvoid\ng817e87a811(float a9ac3d8bc0c, m2979ecef6f paccfd26812) {\nif (paccfd26812[0][0] == 0.0f)\nreturn;\npaccfd26812[0][0] = paccfd26812[1][1] / a9ac3d8bc0c;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_393",
        "query_text": "SUMMARY: The function accepts three variables of type ivec4 (which are arrays of four integers). It modifies the output array by subtracting, for each of its four elements, the sum of the corresponding elements from the two input arrays.",
        "code_id": "c_group_2_id_393",
        "code_text": "Cd4e3208291\nvoid\nge4f36f3e5a(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] + bba3ae37d1f[1];\nd9748d673c4[2] -= ad90770d038[2] + bba3ae37d1f[2];\nd9748d673c4[3] -= ad90770d038[3] + bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_394",
        "query_text": "SUMMARY: This function takes an input parameter of type \"array of 4 integers\" (ivec4) and performs an in-place modification where each element of the array is set to the integer value 1. There is no return value, as the function directly modifies the input.",
        "code_id": "c_group_2_id_394",
        "code_text": "Cd4e3208291\nvoid\ng991dbcea9c(i52a86355e2 v91082a9365) {\nv91082a9365[0] = v91082a9365[1] = v91082a9365[2] = v91082a9365[3] = 1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_395",
        "query_text": "SUMMARY: This function takes two input parameters, each being an array of 2 floats, and returns a single float. It computes the dot product of the two 2-dimensional float vectors by performing element-wise multiplication and summing the results.",
        "code_id": "c_group_2_id_395",
        "code_text": "Cd4e3208291\nfloat\ng88a48e04b6(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f) {\nreturn ad90770d038[0] * bba3ae37d1f[0] + ad90770d038[1] * bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_396",
        "query_text": "SUMMARY: This function takes a 3-element floating-point vector (vec3) and a 4\u00d74 floating-point matrix (mat4) as inputs, and returns a floating-point value. It computes two intermediate scalar values by linearly combining the vector's components with specific columns of the matrix. The first scalar represents the transformed depth (from the matrix\u2019s third column and translation component), while the second represents a homogeneous coordinate (using the matrix\u2019s fourth column and translation component). The function then performs a perspective division of these two scalars and scales/shifts the result to yield a normalized depth value in a 0 to 1 range.",
        "code_id": "c_group_2_id_396",
        "code_text": "Cd4e3208291\nfloat\ng7685cae377(veb444e7eb8 v91082a9365, m2979ecef6f mb8bcb57dcd) {\nfloat z2f48e9e974, w893b1d140a;\nz2f48e9e974 = mb8bcb57dcd[0][2] * v91082a9365[0] + mb8bcb57dcd[1][2] * v91082a9365[1] + mb8bcb57dcd[2][2] * v91082a9365[2] + mb8bcb57dcd[3][2];\nw893b1d140a = mb8bcb57dcd[0][3] * v91082a9365[0] + mb8bcb57dcd[1][3] * v91082a9365[1] + mb8bcb57dcd[2][3] * v91082a9365[2] + mb8bcb57dcd[3][3];\nreturn 0.5f * (z2f48e9e974 / w893b1d140a) + 0.5f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_397",
        "query_text": "SUMMARY: This function accepts one parameter of type int[3] (an array of three integers) and sets each element of the array to the integer value 1, modifying the array in place without returning any value.",
        "code_id": "c_group_2_id_397",
        "code_text": "Cd4e3208291\nvoid\ng517a24b2fd(i4b951f731e v91082a9365) {\nv91082a9365[0] = v91082a9365[1] = v91082a9365[2] = 1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_398",
        "query_text": "SUMMARY: This function takes an input vector (an aligned array of four floats), a scalar value (a float), and an output vector (an aligned array of four floats). It subtracts the scalar from each element of the input vector and stores the resulting values in the output vector. The implementation uses architecture-specific vectorized operations for platforms supporting WebAssembly SIMD, SSE, or NEON, and falls back to element-wise subtraction if those optimizations are not available.",
        "code_id": "c_group_2_id_398",
        "code_text": "Cd4e3208291\nvoid\nga30b49ac70(v141258b569 v91082a9365, float s3b9d266e2e, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_sub(glmm_load(v), wasm_f32x4_splat(s)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_sub_ps(glmm_load(v91082a9365), _mm_set1_ps(s3b9d266e2e)));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vsubq_f32(vld1q_f32(v), vdupq_n_f32(s)));\n#else\ndest[0] = v[0] - s;\ndest[1] = v[1] - s;\ndest[2] = v[2] - s;\ndest[3] = v[3] - s;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_399",
        "query_text": "SUMMARY: This function accepts a constant pointer to a float (input type: const float*) and populates a 3 by 2 matrix (output type: mat3x2, defined as an array of 3 float arrays of length 2) with values. It sequentially assigns the first two floats from the input to the first row of the matrix, the next two floats to the second row, and the final two floats to the third row.",
        "code_id": "c_group_2_id_399",
        "code_text": "Cd4e3208291\nvoid\ng0d9c00eab6(const float * __restrict sa425380d12, m5fbc7d59b5 d9748d673c4) {\nd9748d673c4[0][0] = sa425380d12[0];\nd9748d673c4[0][1] = sa425380d12[1];\nd9748d673c4[1][0] = sa425380d12[2];\nd9748d673c4[1][1] = sa425380d12[3];\nd9748d673c4[2][0] = sa425380d12[4];\nd9748d673c4[2][1] = sa425380d12[5];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_400",
        "query_text": "SUMMARY: This function accepts two input parameters, each being an array of three integers (int[3]), and calculates a component-wise sum of these arrays. The resulting array of three integers (int[3]) holds the sum of the corresponding elements from the two input arrays, with each position in the output computed by adding the respective integers from the inputs.",
        "code_id": "c_group_2_id_400",
        "code_text": "Cd4e3208291\nvoid\ngab0d5bf9a9(i4b951f731e ad90770d038, i4b951f731e bba3ae37d1f, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] + bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] + bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_401",
        "query_text": "SUMMARY: This function accepts two input variables, each of type ivec4 (a 4-element integer array), along with an output variable of the same type. For each of the four integer elements, it computes the product of the corresponding elements from the two input arrays and subtracts that product from the corresponding element in the output array. In other words, it performs an element-wise multiply\u2013subtract operation on the output array.",
        "code_id": "c_group_2_id_401",
        "code_text": "Cd4e3208291\nvoid\ng8d95ecf3c7(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] * bba3ae37d1f[1];\nd9748d673c4[2] -= ad90770d038[2] * bba3ae37d1f[2];\nd9748d673c4[3] -= ad90770d038[3] * bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_402",
        "query_text": "SUMMARY: This function takes a 3-element float array, a float, and another 3-element float array as inputs. It multiplies each element of the first 3-element array by the float and then adds the resulting product to the corresponding element of the second 3-element array, updating it in place as the output.",
        "code_id": "c_group_2_id_402",
        "code_text": "Cd4e3208291\nvoid\ng40531e81f5(veb444e7eb8 ad90770d038, float s3b9d266e2e, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] * s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] * s3b9d266e2e;\nd9748d673c4[2] += ad90770d038[2] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_403",
        "query_text": "SUMMARY: This function operates on two-dimensional floating-point arrays (vec2) and a floating-point scalar. It subtracts, for each element, the product of the corresponding element of the first two-dimensional array and the scalar from the respective element of the second two-dimensional array, thereby updating the second array in place.",
        "code_id": "c_group_2_id_403",
        "code_text": "Cd4e3208291\nvoid\ng9e62ddfd6b(v0131f5a9ae ad90770d038, float s3b9d266e2e, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] * s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_404",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two float values) and a float scalar, computes the floating-point remainder (using the fmod operation) of each element in the input array with the scalar, and outputs a vec2 (an array of two float values) containing these remainders.",
        "code_id": "c_group_2_id_404",
        "code_text": "Cd4e3208291\nvoid\ngacda3d8ee6(v0131f5a9ae v91082a9365, float s3b9d266e2e, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = fmodf(v91082a9365[0], s3b9d266e2e);\nd9748d673c4[1] = fmodf(v91082a9365[1], s3b9d266e2e);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_405",
        "query_text": "SUMMARY: This function accepts an input of type mat4 (a 4x4 matrix of floats with 16-byte alignment) and a pointer to a float as output. It computes the near clipping plane distance for a right-handed perspective projection with a zero to one depth range. Specifically, it calculates the near distance by dividing a specific element from the fourth row by an element from the third row of the input matrix, and then stores the result via the provided float pointer.",
        "code_id": "c_group_2_id_405",
        "code_text": "Cd4e3208291\nvoid\ngfbf4168e3c(m2979ecef6f paccfd26812, float * __restrict nd3cfbab11c) {\n*nd3cfbab11c = paccfd26812[3][2] / paccfd26812[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_406",
        "query_text": "SUMMARY: This function takes as input a 4-element array of floats (vec4) and a single float value, and it produces an output 4-element array of floats (vec4). It computes the floating-point remainder (using fmodf) of each component of the input array with respect to the provided float, storing the result in the corresponding component of the output array.",
        "code_id": "c_group_2_id_406",
        "code_text": "Cd4e3208291\nvoid\ng0b8400e204(v141258b569 v91082a9365, float s3b9d266e2e, v141258b569 d9748d673c4) {\nd9748d673c4[0] = fmodf(v91082a9365[0], s3b9d266e2e);\nd9748d673c4[1] = fmodf(v91082a9365[1], s3b9d266e2e);\nd9748d673c4[2] = fmodf(v91082a9365[2], s3b9d266e2e);\nd9748d673c4[3] = fmodf(v91082a9365[3], s3b9d266e2e);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_407",
        "query_text": "SUMMARY: This function converts a set of Euler angles, provided as an array of 3 floats (vec3), into a quaternion represented as an array of 4 floats (versor) using right-handed conventions. Initially, it computes the sine and cosine of half of each Euler angle. Then, it combines these trigonometric values to calculate the four components of the quaternion, encapsulating the rotation defined by the Euler angles.",
        "code_id": "c_group_2_id_407",
        "code_text": "Cd4e3208291\nvoid\ng91b6936b96(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad = sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa = sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] = x1dce3a8271 * ye938664caa * z8de8afe2d4 + xa08976ecad * ydfce0dcdee * z1a2745c1a8;\nd9748d673c4[1] = x1dce3a8271 * ye938664caa * z1a2745c1a8 - xa08976ecad * ydfce0dcdee * z8de8afe2d4;\nd9748d673c4[2] = x1dce3a8271 * ydfce0dcdee * z8de8afe2d4 + xa08976ecad * ye938664caa * z1a2745c1a8;\nd9748d673c4[3] = x1dce3a8271 * ydfce0dcdee * z1a2745c1a8 - xa08976ecad * ye938664caa * z8de8afe2d4;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_408",
        "query_text": "SUMMARY: This function takes two inputs\u2014a matrix of type mat3 (which is a 3\u00d73 array of floats) and a scalar of type float\u2014and modifies the matrix in place. It multiplies every element in the first and second rows of the matrix by the scalar value (performing a uniform scaling in the 2D sense), while leaving the third row unchanged. The function does not return any value (void output).",
        "code_id": "c_group_2_id_408",
        "code_text": "Cd4e3208291\nvoid\ng827073ad63(m63312228ee mb8bcb57dcd, float s3b9d266e2e) {\nmb8bcb57dcd[0][0] = mb8bcb57dcd[0][0] * s3b9d266e2e;\nmb8bcb57dcd[0][1] = mb8bcb57dcd[0][1] * s3b9d266e2e;\nmb8bcb57dcd[0][2] = mb8bcb57dcd[0][2] * s3b9d266e2e;\nmb8bcb57dcd[1][0] = mb8bcb57dcd[1][0] * s3b9d266e2e;\nmb8bcb57dcd[1][1] = mb8bcb57dcd[1][1] * s3b9d266e2e;\nmb8bcb57dcd[1][2] = mb8bcb57dcd[1][2] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_409",
        "query_text": "SUMMARY: This function performs an element-wise addition by adding a scalar (float) to each component of a two-dimensional vector (float array of two elements). It takes two inputs\u2014a two-element floating-point vector and a scalar of type float\u2014and produces an output of the same two-element float array type where each element is the sum of the corresponding input element and the scalar value.",
        "code_id": "c_group_2_id_409",
        "code_text": "Cd4e3208291\nvoid\ngd356051324(v0131f5a9ae v91082a9365, float s3b9d266e2e, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] + s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_410",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two floats) and a scalar of type float. It computes the quotient of each element in the vec2 by the float scalar and returns the results in an output vec2 (an array of two floats).",
        "code_id": "c_group_2_id_410",
        "code_text": "Cd4e3208291\nvoid\ng84d6bbee8e(v0131f5a9ae v91082a9365, float s3b9d266e2e, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] / s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] / s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_411",
        "query_text": "SUMMARY: This function accepts a 4x4 matrix (an array of four aligned 4-element float vectors) and a pointer to a float output. It computes the far clipping plane distance for a right-handed perspective projection without a near plane by performing arithmetic on specific elements of the input matrix, then writes the computed value to the float pointed to by the second argument.",
        "code_id": "c_group_2_id_411",
        "code_text": "Cd4e3208291\nvoid\ngae6afce628(m2979ecef6f paccfd26812, float * __restrict fb6d340e4c8) {\n*fb6d340e4c8 = paccfd26812[3][2] / (paccfd26812[2][2] + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_412",
        "query_text": "SUMMARY: This function accepts a constant pointer to a float (type: const float *) that points to a sequence of nine float values and produces a 3x3 matrix (type: mat3, an array of three vec3 arrays). It sequentially copies the nine float values into the matrix by mapping the first three values to the first vector, the next three to the second vector, and the final three to the third vector.",
        "code_id": "c_group_2_id_412",
        "code_text": "Cd4e3208291\nvoid\ngf39db6424f(const float * __restrict sa425380d12, m63312228ee d9748d673c4) {\nd9748d673c4[0][0] = sa425380d12[0];\nd9748d673c4[0][1] = sa425380d12[1];\nd9748d673c4[0][2] = sa425380d12[2];\nd9748d673c4[1][0] = sa425380d12[3];\nd9748d673c4[1][1] = sa425380d12[4];\nd9748d673c4[1][2] = sa425380d12[5];\nd9748d673c4[2][0] = sa425380d12[6];\nd9748d673c4[2][1] = sa425380d12[7];\nd9748d673c4[2][2] = sa425380d12[8];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_413",
        "query_text": "SUMMARY: This function receives a 4\u00d74 matrix (of type mat4, which is an array of four 4-element float vectors) and a floating-point scalar value. It multiplies every element of the matrix by the scalar, performing the operation in a vectorized manner using SSE2 instructions. The scaled matrix is updated in place and returned as type mat4.",
        "code_id": "c_group_2_id_413",
        "code_text": "Cd4e3208291\nvoid\ngcbb33fef4a(m2979ecef6f mb8bcb57dcd, float s3b9d266e2e) {\n__m128 xaf3b8fda3f;\nxaf3b8fda3f = _mm_set1_ps(s3b9d266e2e);\ngc83e6cd198(mb8bcb57dcd[0], _mm_mul_ps(glmm_load(mb8bcb57dcd[0]), xaf3b8fda3f));\ngc83e6cd198(mb8bcb57dcd[1], _mm_mul_ps(glmm_load(mb8bcb57dcd[1]), xaf3b8fda3f));\ngc83e6cd198(mb8bcb57dcd[2], _mm_mul_ps(glmm_load(mb8bcb57dcd[2]), xaf3b8fda3f));\ngc83e6cd198(mb8bcb57dcd[3], _mm_mul_ps(glmm_load(mb8bcb57dcd[3]), xaf3b8fda3f));\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_414",
        "query_text": "SUMMARY: This function receives an array of two integers (ivec2) and a single integer (int) as inputs, then assigns the integer value to both elements of the array. It performs this operation by directly updating the first and second elements of the array, effectively filling the two-element vector with the same integer value. There is no explicit return value, as the output is provided by modifying the input array in place.",
        "code_id": "c_group_2_id_414",
        "code_text": "Cd4e3208291\nvoid\ngbbbb5c1fb6(i5e3d0f10c1 v91082a9365, int v71de8bcd6a) {\nv91082a9365[0] = v91082a9365[1] = v71de8bcd6a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_415",
        "query_text": "SUMMARY: This function accepts a 4x4 matrix of floats (mat4) and two pointers to floats as inputs and outputs. Its purpose is to decompose a perspective projection matrix, extracting the vertical extents (top and bottom values) based on the given projection parameters. Internally, it reads specific elements from the matrix to compute an effective near clip distance and then uses this near value along with other matrix elements to derive the top and bottom extents. These computed float values are written to the provided memory locations for further use.",
        "code_id": "c_group_2_id_415",
        "code_text": "Cd4e3208291\nvoid\ng6f33f819f7(m2979ecef6f paccfd26812,\nfloat * __restrict td39aaeaeed,\nfloat * __restrict be4ccd944cb) {\nfloat nd3cfbab11c, m4b629e56ab, md6bc4e094a;\nm4b629e56ab = paccfd26812[2][1];\nmd6bc4e094a = paccfd26812[1][1];\nnd3cfbab11c = paccfd26812[3][2] / (paccfd26812[3][3]);\n*be4ccd944cb = nd3cfbab11c * (m4b629e56ab - 1) / md6bc4e094a;\n*td39aaeaeed    = nd3cfbab11c * (m4b629e56ab + 1) / md6bc4e094a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_416",
        "query_text": "SUMMARY: This function takes two arrays of three floats (vec3) as arguments. It processes the input by applying the floor mathematical operation (which rounds each float down to the nearest integer value) to every element of the first array, and writes the resulting three values into the corresponding positions of the second array. The function does not return a value.",
        "code_id": "c_group_2_id_416",
        "code_text": "Cd4e3208291\nvoid\ngcb9d38f30b(veb444e7eb8 v91082a9365, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = floorf(v91082a9365[0]);\nd9748d673c4[1] = floorf(v91082a9365[1]);\nd9748d673c4[2] = floorf(v91082a9365[2]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_417",
        "query_text": "SUMMARY: This function accepts an input of type int[3] and an int value. It assigns the provided int to every element of the int[3] array, resulting in all entries containing the same integer. The function does not return any value (void).",
        "code_id": "c_group_2_id_417",
        "code_text": "Cd4e3208291\nvoid\ng3e78140606(i4b951f731e v91082a9365, int v71de8bcd6a) {\nv91082a9365[0] = v91082a9365[1] = v91082a9365[2] = v71de8bcd6a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_418",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (represented as an array of four aligned 4-element floating-point vectors) as its input along with two output pointers to floating-point numbers. It computes two values by extracting specific elements from the matrix, processing them through simple arithmetic, and then assigns the results to the two output floats, which represent the near and far clipping plane distances derived from the perspective projection parameters.",
        "code_id": "c_group_2_id_418",
        "code_text": "Cd4e3208291\nvoid\ngab446b3f2e(m2979ecef6f paccfd26812,\nfloat * __restrict nd3cfbab11c,\nfloat * __restrict fb6d340e4c8) {\nfloat m9a4eaa88e8, m529843770e;\nm9a4eaa88e8 = paccfd26812[3][2];\nm529843770e = -paccfd26812[2][2];\n*nd3cfbab11c = m9a4eaa88e8 / m529843770e;\n*fb6d340e4c8  = m9a4eaa88e8 / (m529843770e + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_419",
        "query_text": "SUMMARY: This function takes a single precision floating-point value as input along with a four-by-four matrix (an array of four vec4, where each vec4 is an array of four floats). It first checks whether the (0,0) element of the matrix is zero, and if so, it exits without modification. Otherwise, it recalculates that (0,0) element by dividing the (1,1) element of the matrix by the input floating-point value. The modified matrix serves as the function's output.",
        "code_id": "c_group_2_id_419",
        "code_text": "Cd4e3208291\nvoid\ngc817faec1b(float a9ac3d8bc0c, m2979ecef6f paccfd26812) {\nif (paccfd26812[0][0] == 0.0f)\nreturn;\npaccfd26812[0][0] = paccfd26812[1][1] / a9ac3d8bc0c;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_420",
        "query_text": "SUMMARY: This function multiplies a 4x3 matrix (defined as an array of 4 vectors, where each vector is an array of 3 floats) by a 4-dimensional vector (aligned array of 4 floats) to compute a resulting 3-dimensional vector (array of 3 floats). It operates by individually extracting the four float components of the 4-dimensional input and then calculating each component of the 3-dimensional result as the sum of products of corresponding entries from the matrix and vector.",
        "code_id": "c_group_2_id_420",
        "code_text": "Cd4e3208291\nvoid\ngbdd43f32b4(mc9dd4b805d mb8bcb57dcd, v141258b569 v91082a9365, veb444e7eb8 d9748d673c4) {\nfloat v01fb438970 = v91082a9365[0], v748b5cffd1 = v91082a9365[1], v05a5120aa0 = v91082a9365[2], va7ad10f1fc = v91082a9365[3];\nd9748d673c4[0] = mb8bcb57dcd[0][0] * v01fb438970 + mb8bcb57dcd[1][0] * v748b5cffd1 + mb8bcb57dcd[2][0] * v05a5120aa0 + mb8bcb57dcd[3][0] * va7ad10f1fc;\nd9748d673c4[1] = mb8bcb57dcd[0][1] * v01fb438970 + mb8bcb57dcd[1][1] * v748b5cffd1 + mb8bcb57dcd[2][1] * v05a5120aa0 + mb8bcb57dcd[3][1] * va7ad10f1fc;\nd9748d673c4[2] = mb8bcb57dcd[0][2] * v01fb438970 + mb8bcb57dcd[1][2] * v748b5cffd1 + mb8bcb57dcd[2][2] * v05a5120aa0 + mb8bcb57dcd[3][2] * va7ad10f1fc;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_421",
        "query_text": "SUMMARY: This function performs a copy operation from one 4\u00d73 matrix to another. It takes an input of type mat4x3 (an array of 4 vectors, where each vector consists of 3 floats) and outputs a mat4x3 by copying each element individually from the input to the destination matrix. Line by line, the function assigns each float from the corresponding positions in the source matrix to the destination matrix, effectively replicating the entire matrix.",
        "code_id": "c_group_2_id_421",
        "code_text": "Cd4e3208291\nvoid\ngc97277186e(mc9dd4b805d ma02b861363, mc9dd4b805d d9748d673c4) {\nd9748d673c4[0][0] = ma02b861363[0][0];\nd9748d673c4[0][1] = ma02b861363[0][1];\nd9748d673c4[0][2] = ma02b861363[0][2];\nd9748d673c4[1][0] = ma02b861363[1][0];\nd9748d673c4[1][1] = ma02b861363[1][1];\nd9748d673c4[1][2] = ma02b861363[1][2];\nd9748d673c4[2][0] = ma02b861363[2][0];\nd9748d673c4[2][1] = ma02b861363[2][1];\nd9748d673c4[2][2] = ma02b861363[2][2];\nd9748d673c4[3][0] = ma02b861363[3][0];\nd9748d673c4[3][1] = ma02b861363[3][1];\nd9748d673c4[3][2] = ma02b861363[3][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_422",
        "query_text": "SUMMARY: This function accepts two input variables of type float[2] and computes a new float[2] by performing component-wise multiplication. Specifically, it multiplies the first element of the first input with the first element of the second input and the second element of the first input with the second element of the second input, storing the results in the output variable of type float[2].",
        "code_id": "c_group_2_id_422",
        "code_text": "Cd4e3208291\nvoid\ngc8e444c01b(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] * bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] * bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_423",
        "query_text": "SUMMARY: This function takes a 4\u00d74 matrix (an array of four 4-element float vectors, type mat4) as input and returns a float. It computes a perspective field-of-view angle in radians by accessing a specific element from the matrix (the one at the second row and second column), calculating the reciprocal of that element, applying the arctan function to this reciprocal, and finally multiplying the result by two.",
        "code_id": "c_group_2_id_423",
        "code_text": "Cd4e3208291\nfloat\ng59c408e7c1(m2979ecef6f paccfd26812) {\nreturn 2.0f * atanf(1.0f / paccfd26812[1][1]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_424",
        "query_text": "SUMMARY: This function accepts a 4-element floating-point vector (type: vec4, which is an array of 4 floats) and returns a single floating-point value (type: float). The function retrieves and returns the fourth element from the input vector.",
        "code_id": "c_group_2_id_424",
        "code_text": "Cd4e3208291\nfloat\ng67bab44dc4(v141258b569 s3b9d266e2e) {\nreturn s3b9d266e2e[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_425",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 single\u2010precision floating-point matrix and two pointers to single-precision floats as inputs and computes two scalar values representing vertical boundaries. It extracts specific elements from the matrix corresponding to vertical scaling and translation parameters, computes a near-plane distance using another matrix element, and then calculates the upper and lower vertical limits based on these extracted values. The resulting computed single-precision floats are output via the provided pointer parameters.",
        "code_id": "c_group_2_id_425",
        "code_text": "Cd4e3208291\nvoid\ng990b7efcc9(m2979ecef6f paccfd26812,\nfloat * __restrict td39aaeaeed,\nfloat * __restrict be4ccd944cb) {\nfloat nd3cfbab11c, m4b629e56ab, md6bc4e094a, m529843770e;\nm4b629e56ab = paccfd26812[2][1];\nmd6bc4e094a = paccfd26812[1][1];\nm529843770e = paccfd26812[2][2];\nnd3cfbab11c = paccfd26812[3][2] / (m529843770e - 1.0f);\n*be4ccd944cb = nd3cfbab11c * (m4b629e56ab - 1.0f) / md6bc4e094a;\n*td39aaeaeed    = nd3cfbab11c * (m4b629e56ab + 1.0f) / md6bc4e094a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_426",
        "query_text": "SUMMARY: This function converts a rotation specified by Euler angles to a quaternion. It accepts a three-element float array (vec3) representing Euler angles in radians and produces a four-element float array (versor) representing the corresponding quaternion rotation in a right-handed coordinate system. The function computes the sine and cosine of half of each Euler angle and then combines these intermediary values to generate the quaternion components.",
        "code_id": "c_group_2_id_426",
        "code_text": "Cd4e3208291\nvoid\ngde46f5da04(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad = sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa = sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] = -x1dce3a8271 * z8de8afe2d4 * ye938664caa + xa08976ecad * z1a2745c1a8 * ydfce0dcdee;\nd9748d673c4[1] =  x1dce3a8271 * z1a2745c1a8 * ye938664caa - xa08976ecad * z8de8afe2d4 * ydfce0dcdee;\nd9748d673c4[2] =  x1dce3a8271 * z8de8afe2d4 * ydfce0dcdee + xa08976ecad * z1a2745c1a8 * ye938664caa;\nd9748d673c4[3] =  x1dce3a8271 * z1a2745c1a8 * ydfce0dcdee + xa08976ecad * z8de8afe2d4 * ye938664caa;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_427",
        "query_text": "SUMMARY: This inline function takes two inputs: a 3-component float array and a float number, and it produces a 4-component float array as output. The function assigns the elements of the input 3-component float array to the first three positions of the output array, and then it assigns the float number to the fourth position of the output array.",
        "code_id": "c_group_2_id_427",
        "code_text": "Cd4e3208291\nvoid\nga801b9c887(veb444e7eb8 va7ad10f1fc, float le286350680, v141258b569 d9748d673c4) {\nd9748d673c4[0] = va7ad10f1fc[0];\nd9748d673c4[1] = va7ad10f1fc[1];\nd9748d673c4[2] = va7ad10f1fc[2];\nd9748d673c4[3] = le286350680;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_428",
        "query_text": "SUMMARY: This function computes the transpose of a matrix. It takes an input of type mat4x3 (an array of four vectors, each containing three float elements, representing a 4\u00d73 matrix) and produces an output of type mat3x4 (an array of three vectors, each containing four float elements, representing a 3\u00d74 matrix). The function rearranges the elements so that the element originally at the position (row, column) in the input matrix is placed at the position (column, row) in the output matrix.",
        "code_id": "c_group_2_id_428",
        "code_text": "Cd4e3208291\nvoid\nga1689f130a(mc9dd4b805d mb8bcb57dcd, m5fbb141a9c d9748d673c4) {\nd9748d673c4[0][0] = mb8bcb57dcd[0][0];\nd9748d673c4[0][1] = mb8bcb57dcd[1][0];\nd9748d673c4[0][2] = mb8bcb57dcd[2][0];\nd9748d673c4[0][3] = mb8bcb57dcd[3][0];\nd9748d673c4[1][0] = mb8bcb57dcd[0][1];\nd9748d673c4[1][1] = mb8bcb57dcd[1][1];\nd9748d673c4[1][2] = mb8bcb57dcd[2][1];\nd9748d673c4[1][3] = mb8bcb57dcd[3][1];\nd9748d673c4[2][0] = mb8bcb57dcd[0][2];\nd9748d673c4[2][1] = mb8bcb57dcd[1][2];\nd9748d673c4[2][2] = mb8bcb57dcd[2][2];\nd9748d673c4[2][3] = mb8bcb57dcd[3][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_429",
        "query_text": "SUMMARY: This function computes the element-wise subtraction of two four-element floating-point vectors (each defined as a 16-byte aligned float array) and stores the resulting vector in a provided output. It accepts two input arrays of type vec4 (which are essentially float[4] arrays) and produces a vec4 as output, utilizing platform-specific SIMD operations when available, or performing manual subtraction for each component otherwise.",
        "code_id": "c_group_2_id_429",
        "code_text": "Cd4e3208291\nvoid\ng97581e6062(v141258b569 ad90770d038, v141258b569 bba3ae37d1f, v141258b569 d9748d673c4) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(dest, wasm_f32x4_sub(g86f14e15d6(a), g86f14e15d6(b)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(d9748d673c4, _mm_sub_ps(g86f14e15d6(ad90770d038), g86f14e15d6(bba3ae37d1f)));\n#elif defined(CGLM_NEON_FP)\nvst1q_f32(dest, vsubq_f32(vld1q_f32(a), vld1q_f32(b)));\n#else\ndest[0] = a[0] - b[0];\ndest[1] = a[1] - b[1];\ndest[2] = a[2] - b[2];\ndest[3] = a[3] - b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_430",
        "query_text": "SUMMARY: This function takes a 3-element integer array and an integer as inputs, and produces a 3-element integer array as output. It adds the integer input to each element of the input array and stores the resulting values in the output array.",
        "code_id": "c_group_2_id_430",
        "code_text": "Cd4e3208291\nvoid\nge3df41e8f7(i4b951f731e v91082a9365, int s3b9d266e2e, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0] + s3b9d266e2e;\nd9748d673c4[1] = v91082a9365[1] + s3b9d266e2e;\nd9748d673c4[2] = v91082a9365[2] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_431",
        "query_text": "SUMMARY: This function accepts an input of type float[2] (a two-dimensional vector) and a float value, then it updates the vector in place so that both of its elements match the provided float value. It does not return any value.",
        "code_id": "c_group_2_id_431",
        "code_text": "Cd4e3208291\nvoid\ng2c44408ba2(v0131f5a9ae v91082a9365, float v71de8bcd6a) {\nv91082a9365[0] = v91082a9365[1] = v71de8bcd6a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_432",
        "query_text": "SUMMARY: The function takes two input parameters\u2014a 3-element integer array (ivec3) and an integer scalar\u2014along with an output parameter, which is also a 3-element integer array (ivec3). It multiplies each element of the input array by the scalar and then adds the resulting product to the corresponding element of the output array.",
        "code_id": "c_group_2_id_432",
        "code_text": "Cd4e3208291\nvoid\ng16216945c1(i4b951f731e ad90770d038, int s3b9d266e2e, i4b951f731e d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] * s3b9d266e2e;\nd9748d673c4[1] += ad90770d038[1] * s3b9d266e2e;\nd9748d673c4[2] += ad90770d038[2] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_433",
        "query_text": "SUMMARY: This function takes a float[3] array as its input and returns no output. The function's behavior is to set each of the three float elements in the array to the value 1.0f.",
        "code_id": "c_group_2_id_433",
        "code_text": "Cd4e3208291\nvoid\nge068edda90(veb444e7eb8 v91082a9365) {\nv91082a9365[0] = v91082a9365[1] = v91082a9365[2] = 1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_434",
        "query_text": "SUMMARY: The function takes as input a projection matrix (of type vec4 mat4) and several pointers to floating\u2010point variables (of type float*), and it decomposes the matrix to extract the parameters of a left-handed perspective projection. Specifically, it calculates the near and far clipping distances and determines the boundaries (top, bottom, left, right) of the projection frustum by extracting specific elements from the matrix and using them in arithmetic expressions. The computed values are then stored via the provided output pointers.",
        "code_id": "c_group_2_id_434",
        "code_text": "Cd4e3208291\nvoid\ng73bf758b24(m2979ecef6f paccfd26812,\nfloat * __restrict nd3cfbab11c, float * __restrict fb6d340e4c8,\nfloat * __restrict td39aaeaeed,   float * __restrict be4ccd944cb,\nfloat * __restrict lcfaba252b8,  float * __restrict rc12144e4ba) {\nfloat m73982a8772, md6bc4e094a, m2134d0010f, m4b629e56ab, m529843770e, m9a4eaa88e8, neb9157c168, f4cff875701;\nfloat n12ece6d2dd, nc740595460;\nm73982a8772 = paccfd26812[0][0];\nmd6bc4e094a = paccfd26812[1][1];\nm2134d0010f = paccfd26812[2][0];\nm4b629e56ab = paccfd26812[2][1];\nm529843770e =-paccfd26812[2][2];\nm9a4eaa88e8 = paccfd26812[3][2];\nneb9157c168 = m9a4eaa88e8 / (m529843770e - 1.0f);\nf4cff875701 = m9a4eaa88e8 / (m529843770e + 1.0f);\nn12ece6d2dd = neb9157c168 / md6bc4e094a;\nnc740595460 = neb9157c168 / m73982a8772;\n*nd3cfbab11c = neb9157c168;\n*fb6d340e4c8  = f4cff875701;\n*be4ccd944cb  = n12ece6d2dd * (m4b629e56ab - 1.0f);\n*td39aaeaeed     = n12ece6d2dd * (m4b629e56ab + 1.0f);\n*lcfaba252b8    = nc740595460 * (m2134d0010f - 1.0f);\n*rc12144e4ba   = nc740595460 * (m2134d0010f + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_435",
        "query_text": "SUMMARY: This function takes a four-element array of integers (int[4]) as input and computes the absolute value of each element, storing the results in a separate four-element array of integers (int[4]).",
        "code_id": "c_group_2_id_435",
        "code_text": "Cd4e3208291\nvoid\ng3eb73cb3bf(i52a86355e2 v91082a9365, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] = abs(v91082a9365[0]);\nd9748d673c4[1] = abs(v91082a9365[1]);\nd9748d673c4[2] = abs(v91082a9365[2]);\nd9748d673c4[3] = abs(v91082a9365[3]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_436",
        "query_text": "SUMMARY: This function takes a 4x4 floating-point matrix (mat4) as input and produces a 3x3 floating-point matrix (mat3) as output. It extracts the upper-left 3x3 submatrix by copying the first three elements of the first three rows from the 4x4 matrix into the 3x3 matrix.",
        "code_id": "c_group_2_id_436",
        "code_text": "Cd4e3208291\nvoid\ngf6fee89d63(m2979ecef6f ma02b861363, m63312228ee d9748d673c4) {\nd9748d673c4[0][0] = ma02b861363[0][0];\nd9748d673c4[0][1] = ma02b861363[0][1];\nd9748d673c4[0][2] = ma02b861363[0][2];\nd9748d673c4[1][0] = ma02b861363[1][0];\nd9748d673c4[1][1] = ma02b861363[1][1];\nd9748d673c4[1][2] = ma02b861363[1][2];\nd9748d673c4[2][0] = ma02b861363[2][0];\nd9748d673c4[2][1] = ma02b861363[2][1];\nd9748d673c4[2][2] = ma02b861363[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_437",
        "query_text": "SUMMARY: This function processes an input 4-element array of floats and writes to an output 4-element array of floats by computing the sign value for each component. For each float in the input, the corresponding output is determined to be \u20131.0 if the input is negative, 1.0 if positive, and 0.0 if the input is zero. The implementation uses optimized vectorized operations with SSE when available, and falls back to individual element processing otherwise.",
        "code_id": "c_group_2_id_437",
        "code_text": "Cd4e3208291\nvoid\ng551a96fe45(v141258b569 v91082a9365, v141258b569 d9748d673c4) {\n#if defined( __SSE__ ) || defined( __SSE2__ )\n__m128 xaf3b8fda3f, x2261ceb173, x2b8161d487, x70ed4066af, xcc8406c937;\nxaf3b8fda3f = g86f14e15d6(v91082a9365);\nx2261ceb173 = _mm_set_ps(0.0f, 0.0f, 1.0f, -1.0f);\nx2b8161d487 = gc3a875be74(x2261ceb173, 2);\nx70ed4066af = _mm_and_ps(_mm_cmpgt_ps(xaf3b8fda3f, x2b8161d487), gc3a875be74(x2261ceb173, 1));\nxcc8406c937 = _mm_and_ps(_mm_cmplt_ps(xaf3b8fda3f, x2b8161d487), gc3a875be74(x2261ceb173, 0));\ngc83e6cd198(d9748d673c4, _mm_or_ps(x70ed4066af, xcc8406c937));\n#else\ndest[0] = glm_signf(v[0]);\ndest[1] = glm_signf(v[1]);\ndest[2] = glm_signf(v[2]);\ndest[3] = glm_signf(v[3]);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_438",
        "query_text": "SUMMARY: This function computes the transpose of a 2\u00d72 matrix of 32\u2010bit floats. It takes as input a matrix of type \"2-element array of 2-element float vectors\" (each vector being 16\u2010byte aligned) and produces as output another matrix of the same type, with its elements rearranged to achieve the transpose. The implementation uses SSE2 operations to load the four floating\u2010point values from the input, shuffle them appropriately, and then store the result into the output matrix.",
        "code_id": "c_group_2_id_438",
        "code_text": "Cd4e3208291\nvoid\nga161270ae4(mde4d4e4936 mb8bcb57dcd, mde4d4e4936 d9748d673c4) {\n\n\ngc83e6cd198(d9748d673c4[0], glmm_shuff1(glmm_load(mb8bcb57dcd[0]), 3, 1, 2, 0));\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_439",
        "query_text": "SUMMARY: This function takes two input variables of type int[2] (representing two-element integer vectors) and produces an output variable of the same type. It evaluates each corresponding element of the two input vectors and assigns the greater of each pair to the respective position in the output vector.",
        "code_id": "c_group_2_id_439",
        "code_text": "Cd4e3208291\nvoid\ngeb59830252(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] > bba3ae37d1f[0] ? ad90770d038[0] : bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] > bba3ae37d1f[1] ? ad90770d038[1] : bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_440",
        "query_text": "SUMMARY: This function takes a constant pointer to a sequence of float values (input type: const float*) and transforms it into a 4\u00d74 matrix (output type: an array of 4 float[4] vectors) by mapping 16 sequential floats into a structured matrix layout. More specifically, it reorganizes the input flat array by distributing its values into two groups, with the first eight values populating the first two columns and the remaining eight values populating the last two columns of the destination matrix.",
        "code_id": "c_group_2_id_440",
        "code_text": "Cd4e3208291\nvoid\ng8e9c8dffb6(const float * __restrict sa425380d12, m2979ecef6f d9748d673c4) {\nd9748d673c4[0][0] = sa425380d12[0];   d9748d673c4[1][0] = sa425380d12[4];\nd9748d673c4[0][1] = sa425380d12[1];   d9748d673c4[1][1] = sa425380d12[5];\nd9748d673c4[0][2] = sa425380d12[2];   d9748d673c4[1][2] = sa425380d12[6];\nd9748d673c4[0][3] = sa425380d12[3];   d9748d673c4[1][3] = sa425380d12[7];\nd9748d673c4[2][0] = sa425380d12[8];   d9748d673c4[3][0] = sa425380d12[12];\nd9748d673c4[2][1] = sa425380d12[9];   d9748d673c4[3][1] = sa425380d12[13];\nd9748d673c4[2][2] = sa425380d12[10];  d9748d673c4[3][2] = sa425380d12[14];\nd9748d673c4[2][3] = sa425380d12[11];  d9748d673c4[3][3] = sa425380d12[15];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_441",
        "query_text": "SUMMARY: This function accepts two input parameters of type float[3] and produces an output of the same type. It performs an element-wise division by computing the quotient of the corresponding elements from the first and second input arrays, storing these results sequentially in the output array.",
        "code_id": "c_group_2_id_441",
        "code_text": "Cd4e3208291\nvoid\ng00e47371cc(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] / bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] / bba3ae37d1f[1];\nd9748d673c4[2] = ad90770d038[2] / bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_442",
        "query_text": "SUMMARY: This function takes three parameters of type int[4]. It computes, for each corresponding element, the subtraction of the difference between the first and second input values from the value in the third parameter. In other words, it updates each element of the output int[4] by subtracting the result of the difference between the two input int[4] elements.",
        "code_id": "c_group_2_id_442",
        "code_text": "Cd4e3208291\nvoid\ng282640a2c8(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] -= ad90770d038[1] - bba3ae37d1f[1];\nd9748d673c4[2] -= ad90770d038[2] - bba3ae37d1f[2];\nd9748d673c4[3] -= ad90770d038[3] - bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_443",
        "query_text": "SUMMARY: This inline function accepts two input parameters, each being a 3-element array of floats (float[3]), and computes their dot product by multiplying corresponding elements and summing the results. It returns a single float value representing this computed dot product.",
        "code_id": "c_group_2_id_443",
        "code_text": "Cd4e3208291\nfloat\nga25b641550(veb444e7eb8 ad90770d038, veb444e7eb8 bba3ae37d1f) {\nreturn ad90770d038[0] * bba3ae37d1f[0] + ad90770d038[1] * bba3ae37d1f[1] + ad90770d038[2] * bba3ae37d1f[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_444",
        "query_text": "SUMMARY: This function accepts two input parameters\u2014an integer vector of four elements (ivec4) and an integer scalar\u2014and one output parameter, an integer vector of four elements (ivec4). For each index from 0 to 3, it subtracts the sum of the corresponding element from the input vector and the scalar from the corresponding element in the output vector, updating the output vector with the result.",
        "code_id": "c_group_2_id_444",
        "code_text": "Cd4e3208291\nvoid\ng5b05705300(i52a86355e2 ad90770d038, int s3b9d266e2e, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] + s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] + s3b9d266e2e;\nd9748d673c4[2] -= ad90770d038[2] + s3b9d266e2e;\nd9748d673c4[3] -= ad90770d038[3] + s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_445",
        "query_text": "SUMMARY: This function receives an input array of three integers (type int[3]) and computes the absolute value of each element. It then stores these absolute values element-by-element into an output array of three integers (type int[3]).",
        "code_id": "c_group_2_id_445",
        "code_text": "Cd4e3208291\nvoid\ng82a688236f(i4b951f731e v91082a9365, i4b951f731e d9748d673c4) {\nd9748d673c4[0] = abs(v91082a9365[0]);\nd9748d673c4[1] = abs(v91082a9365[1]);\nd9748d673c4[2] = abs(v91082a9365[2]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_446",
        "query_text": "SUMMARY: This function accepts an input variable of type vec4 (an aligned four-element float array) and an output variable of type vec3 (a three-element float array). Its functionality is to copy the first three float elements from the input to the output, effectively trimming the fourth element.",
        "code_id": "c_group_2_id_446",
        "code_text": "Cd4e3208291\nvoid\ngf0adb4ecec(v141258b569 ad90770d038, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0];\nd9748d673c4[1] = ad90770d038[1];\nd9748d673c4[2] = ad90770d038[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_447",
        "query_text": "SUMMARY: This function accepts two input variables, each of type float[2], and one output variable, also of type float[2]. Its purpose is to add, for each coordinate, the corresponding values from the two input arrays and then increment the corresponding value in the output array by that sum. Specifically, it updates each element of the output array by adding the sum of the corresponding elements of the two input arrays.",
        "code_id": "c_group_2_id_447",
        "code_text": "Cd4e3208291\nvoid\nga3ec0ea16b(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] + bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_448",
        "query_text": "SUMMARY: This function converts a 3-element floating-point vector (vec3) representing Euler angles into a 4-element floating-point quaternion (versor) using a YZX rotation order in a right-handed coordinate system. It calculates the sine and cosine of half of each Euler angle and then combines them to produce the quaternion components that represent the equivalent rotation. Each line of the function performs a step in computing these trigonometric values and then assembles the resulting quaternion from their products and sums.",
        "code_id": "c_group_2_id_448",
        "code_text": "Cd4e3208291\nvoid\ngc748a72e04(veb444e7eb8 a9cd9428334, v6c437193eb d9748d673c4) {\nfloat x1dce3a8271, ydfce0dcdee, z1a2745c1a8,\nxa08976ecad, ye938664caa, z8de8afe2d4;\nxa08976ecad = sinf(a9cd9428334[0] * 0.5f); x1dce3a8271 = cosf(a9cd9428334[0] * 0.5f);\nye938664caa = sinf(a9cd9428334[1] * 0.5f); ydfce0dcdee = cosf(a9cd9428334[1] * 0.5f);\nz8de8afe2d4 = sinf(a9cd9428334[2] * 0.5f); z1a2745c1a8 = cosf(a9cd9428334[2] * 0.5f);\nd9748d673c4[0] = ydfce0dcdee * z1a2745c1a8 * xa08976ecad + ye938664caa * z8de8afe2d4 * x1dce3a8271;\nd9748d673c4[1] = ydfce0dcdee * z8de8afe2d4 * xa08976ecad + ye938664caa * z1a2745c1a8 * x1dce3a8271;\nd9748d673c4[2] = ydfce0dcdee * z8de8afe2d4 * x1dce3a8271 - ye938664caa * z1a2745c1a8 * xa08976ecad;\nd9748d673c4[3] = ydfce0dcdee * z1a2745c1a8 * x1dce3a8271 - ye938664caa * z8de8afe2d4 * xa08976ecad;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_449",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (of type vec4[4]) representing a perspective projection and two pointers to floats (which are the output variables for the near and far clipping distances). It first extracts two specific floating\u2010point elements from distinct positions within the matrix and then computes the near and far clipping distances by dividing one extracted value by a modified form of the other\u2014subtracting 1.0 for the near distance and adding 1.0 for the far distance. The function does not return a value, instead writing the computed near and far distances directly to the provided output float pointers.",
        "code_id": "c_group_2_id_449",
        "code_text": "Cd4e3208291\nvoid\ngd4da50de8c(m2979ecef6f paccfd26812,\nfloat * __restrict nd3cfbab11c,\nfloat * __restrict fb6d340e4c8) {\nfloat m9a4eaa88e8, m529843770e;\nm9a4eaa88e8 = paccfd26812[3][2];\nm529843770e =-paccfd26812[2][2];\n*nd3cfbab11c = m9a4eaa88e8 / (m529843770e - 1.0f);\n*fb6d340e4c8  = m9a4eaa88e8 / (m529843770e + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_450",
        "query_text": "SUMMARY: This function performs a component-wise subtraction of two two-dimensional vectors. It accepts two input parameters of type float[2] (representing the vectors to subtract) and produces an output parameter of type float[2] containing the result of subtracting the corresponding elements of the second input from the first.",
        "code_id": "c_group_2_id_450",
        "code_text": "Cd4e3208291\nvoid\ng0d0fef2a03(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] - bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] - bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_451",
        "query_text": "SUMMARY: This function takes a triple of floating\u2010point values (vec3) representing three Euler angles and produces a 4\u00d74 matrix (mat4) transformation that encodes a rotation using a Y\u2013X\u2013Z rotation order. It computes the sine and cosine of each angle, combines these trigonometric results into intermediate products, and assembles them into the rotation matrix's elements; the remaining matrix components are set to yield an identity transformation in the homogeneous coordinate.",
        "code_id": "c_group_2_id_451",
        "code_text": "Cd4e3208291\nvoid\ng4538fcd356(veb444e7eb8 a9cd9428334, m2979ecef6f d9748d673c4) {\nfloat ced008e8902, ce4f072f817, c6bd6fe7cc6,\ns7d25487ca7, se41a0f503f, s23246ee131, c19bb133d1d, s8f0754e783, ca9141d8c6a, cda3a4bca48;\ns7d25487ca7   = sinf(a9cd9428334[0]); ced008e8902 = cosf(a9cd9428334[0]);\nse41a0f503f   = sinf(a9cd9428334[1]); ce4f072f817 = cosf(a9cd9428334[1]);\ns23246ee131   = sinf(a9cd9428334[2]); c6bd6fe7cc6 = cosf(a9cd9428334[2]);\nc19bb133d1d = ce4f072f817 * c6bd6fe7cc6;\ns8f0754e783 = se41a0f503f * s23246ee131;\nca9141d8c6a = c6bd6fe7cc6 * se41a0f503f;\ncda3a4bca48 = ce4f072f817 * s23246ee131;\nd9748d673c4[0][0] =  c19bb133d1d + s7d25487ca7 * s8f0754e783;\nd9748d673c4[0][1] =  ced008e8902 * s23246ee131;\nd9748d673c4[0][2] = -ca9141d8c6a + cda3a4bca48 * s7d25487ca7;\nd9748d673c4[1][0] = -cda3a4bca48 + ca9141d8c6a * s7d25487ca7;\nd9748d673c4[1][1] =  ced008e8902 * c6bd6fe7cc6;\nd9748d673c4[1][2] =  c19bb133d1d * s7d25487ca7 + s8f0754e783;\nd9748d673c4[2][0] =  ced008e8902 * se41a0f503f;\nd9748d673c4[2][1] = -s7d25487ca7;\nd9748d673c4[2][2] =  ced008e8902 * ce4f072f817;\nd9748d673c4[0][3] =  0.0f;\nd9748d673c4[1][3] =  0.0f;\nd9748d673c4[2][3] =  0.0f;\nd9748d673c4[3][0] =  0.0f;\nd9748d673c4[3][1] =  0.0f;\nd9748d673c4[3][2] =  0.0f;\nd9748d673c4[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_452",
        "query_text": "SUMMARY: This function converts a 4\u00d74 floating\u2010point matrix (mat4) representing a rotation into a quaternion (versor), also composed of four floating\u2011point values. It calculates the sum of the matrix\u2019s three main diagonal elements and, based on whether this trace is nonnegative or one of the diagonal elements is largest, it selects an appropriate branch. In each branch, it computes a scaling factor and then produces the four quaternion components using combinations of the matrix\u2019s off\u2011diagonal elements. This procedure effectively maps the rotation encoded in the matrix to its equivalent quaternion representation.",
        "code_id": "c_group_2_id_452",
        "code_text": "Cd4e3208291\nvoid\ngbcb75efaaa(m2979ecef6f mb8bcb57dcd, v6c437193eb d9748d673c4) {\nfloat t98713f8c98, r01fae08b89, r373f8408bb;\n\nt98713f8c98 = mb8bcb57dcd[0][0] + mb8bcb57dcd[1][1] + mb8bcb57dcd[2][2];\nif (t98713f8c98 >= 0.0f) {\nr01fae08b89       = sqrtf(1.0f + t98713f8c98);\nr373f8408bb    = 0.5f / r01fae08b89;\nd9748d673c4[0] = r373f8408bb * (mb8bcb57dcd[1][2] - mb8bcb57dcd[2][1]);\nd9748d673c4[1] = r373f8408bb * (mb8bcb57dcd[2][0] - mb8bcb57dcd[0][2]);\nd9748d673c4[2] = r373f8408bb * (mb8bcb57dcd[0][1] - mb8bcb57dcd[1][0]);\nd9748d673c4[3] = r01fae08b89    * 0.5f;\n} else if (mb8bcb57dcd[0][0] >= mb8bcb57dcd[1][1] && mb8bcb57dcd[0][0] >= mb8bcb57dcd[2][2]) {\nr01fae08b89       = sqrtf(1.0f - mb8bcb57dcd[1][1] - mb8bcb57dcd[2][2] + mb8bcb57dcd[0][0]);\nr373f8408bb    = 0.5f / r01fae08b89;\nd9748d673c4[0] = r01fae08b89    * 0.5f;\nd9748d673c4[1] = r373f8408bb * (mb8bcb57dcd[0][1] + mb8bcb57dcd[1][0]);\nd9748d673c4[2] = r373f8408bb * (mb8bcb57dcd[0][2] + mb8bcb57dcd[2][0]);\nd9748d673c4[3] = r373f8408bb * (mb8bcb57dcd[1][2] - mb8bcb57dcd[2][1]);\n} else if (mb8bcb57dcd[1][1] >= mb8bcb57dcd[2][2]) {\nr01fae08b89       = sqrtf(1.0f - mb8bcb57dcd[0][0] - mb8bcb57dcd[2][2] + mb8bcb57dcd[1][1]);\nr373f8408bb    = 0.5f / r01fae08b89;\nd9748d673c4[0] = r373f8408bb * (mb8bcb57dcd[0][1] + mb8bcb57dcd[1][0]);\nd9748d673c4[1] = r01fae08b89    * 0.5f;\nd9748d673c4[2] = r373f8408bb * (mb8bcb57dcd[1][2] + mb8bcb57dcd[2][1]);\nd9748d673c4[3] = r373f8408bb * (mb8bcb57dcd[2][0] - mb8bcb57dcd[0][2]);\n} else {\nr01fae08b89       = sqrtf(1.0f - mb8bcb57dcd[0][0] - mb8bcb57dcd[1][1] + mb8bcb57dcd[2][2]);\nr373f8408bb    = 0.5f / r01fae08b89;\nd9748d673c4[0] = r373f8408bb * (mb8bcb57dcd[0][2] + mb8bcb57dcd[2][0]);\nd9748d673c4[1] = r373f8408bb * (mb8bcb57dcd[1][2] + mb8bcb57dcd[2][1]);\nd9748d673c4[2] = r01fae08b89    * 0.5f;\nd9748d673c4[3] = r373f8408bb * (mb8bcb57dcd[0][1] - mb8bcb57dcd[1][0]);\n}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_453",
        "query_text": "SUMMARY: This function takes two inputs\u2014a 3\u00d73 matrix composed of three arrays of three floats (mat3) and a 2-element array of floats (vec2)\u2014and modifies the matrix in place. It applies a two-dimensional scaling transformation by multiplying every element in the first row of the matrix by the first float from the vector and every element in the second row by the second float. The third row of the matrix remains unchanged.",
        "code_id": "c_group_2_id_453",
        "code_text": "Cd4e3208291\nvoid\ng0e5f0223af(m63312228ee mb8bcb57dcd, v0131f5a9ae v91082a9365) {\nmb8bcb57dcd[0][0] = mb8bcb57dcd[0][0] * v91082a9365[0];\nmb8bcb57dcd[0][1] = mb8bcb57dcd[0][1] * v91082a9365[0];\nmb8bcb57dcd[0][2] = mb8bcb57dcd[0][2] * v91082a9365[0];\nmb8bcb57dcd[1][0] = mb8bcb57dcd[1][0] * v91082a9365[1];\nmb8bcb57dcd[1][1] = mb8bcb57dcd[1][1] * v91082a9365[1];\nmb8bcb57dcd[1][2] = mb8bcb57dcd[1][2] * v91082a9365[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_454",
        "query_text": "SUMMARY: This function accepts an input of type int pointer and an output of type ivec2 (an array of two integers). It copies the first two integers from the input array into the two-element output array.",
        "code_id": "c_group_2_id_454",
        "code_text": "Cd4e3208291\nvoid\ng611e46a840(int * __restrict v91082a9365, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = v91082a9365[0];\nd9748d673c4[1] = v91082a9365[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_455",
        "query_text": "SUMMARY: This function accepts an input of type \"CGLM_ALIGN_IF(16) float[4]\" (a vector of four floats) and an input of type \"float\", and it modifies the vector by filling all four elements with the provided floating-point value. It uses platform-specific SIMD operations when available, defaulting to individual assignments otherwise.",
        "code_id": "c_group_2_id_455",
        "code_text": "Cd4e3208291\nvoid\ng49f12d882b(v141258b569 v91082a9365, float v71de8bcd6a) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\ngc83e6cd198(v, wasm_f32x4_splat(val));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\ngc83e6cd198(v91082a9365, _mm_set1_ps(v71de8bcd6a));\n#else\nv[0] = v[1] = v[2] = v[3] = val;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_456",
        "query_text": "SUMMARY: This function performs a component-wise addition of two two-dimensional vectors. It takes two input variables of type vec2 (each defined as an array of two floats) and computes a new vec2 by adding the corresponding elements from the inputs, then stores the resulting two-float array in the output variable of type vec2.",
        "code_id": "c_group_2_id_456",
        "code_text": "Cd4e3208291\nvoid\ng74979389c4(v0131f5a9ae ad90770d038, v0131f5a9ae bba3ae37d1f, v0131f5a9ae d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] + bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_457",
        "query_text": "SUMMARY: This function takes a three-by-two matrix of floats (type: mat3x2, defined as an array of three two-element float arrays) and a scalar float as inputs. It multiplies each of the six elements within the matrix by the scalar value, updating the matrix in place. The function returns no value (void).",
        "code_id": "c_group_2_id_457",
        "code_text": "Cd4e3208291\nvoid\ngb05541d43c(m5fbc7d59b5 mb8bcb57dcd, float s3b9d266e2e) {\nmb8bcb57dcd[0][0] *= s3b9d266e2e;  mb8bcb57dcd[0][1] *= s3b9d266e2e;  mb8bcb57dcd[1][0] *= s3b9d266e2e;\nmb8bcb57dcd[1][1] *= s3b9d266e2e;  mb8bcb57dcd[2][0] *= s3b9d266e2e;  mb8bcb57dcd[2][1] *= s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_458",
        "query_text": "SUMMARY: This function takes an input of type vec2 (an array of two floats) and modifies it so that both elements are set to 1.0f. It returns no value.",
        "code_id": "c_group_2_id_458",
        "code_text": "Cd4e3208291\nvoid\ngc2630cd36b(v0131f5a9ae v91082a9365) {\nv91082a9365[0] = v91082a9365[1] = 1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_459",
        "query_text": "SUMMARY: The function takes two inputs, each being an array of two integers (type: int[2]), and produces an output of the same type. It computes the function by adding the first integer from the first array to the first integer from the second array, and similarly adding the second integers together. The resulting array holds these two sums as its elements.",
        "code_id": "c_group_2_id_459",
        "code_text": "Cd4e3208291\nvoid\ngf8953be79d(i5e3d0f10c1 ad90770d038, i5e3d0f10c1 bba3ae37d1f, i5e3d0f10c1 d9748d673c4) {\nd9748d673c4[0] = ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] = ad90770d038[1] + bba3ae37d1f[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_460",
        "query_text": "SUMMARY: This function performs matrix multiplication between two matrices. The first input is of type mat4x3 (an array of four 3-element float vectors representing a 4\u00d73 matrix in column-major order), and the second input is of type mat3x4 (an array of three 4-element float vectors representing a 3\u00d74 matrix). The function computes the product, which is a 3\u00d73 matrix, and stores the result in the output of type mat3 (an array of three 3-element float vectors). Each element of the output is obtained by summing the products of corresponding float components from the inputs.",
        "code_id": "c_group_2_id_460",
        "code_text": "Cd4e3208291\nvoid\ngcc0bb6de8c(mc9dd4b805d m7f4f0cd2cb, m5fbb141a9c m71ae398200, m63312228ee d9748d673c4) {\nfloat a79034f70a3 = m7f4f0cd2cb[0][0], af8ba94e471 = m7f4f0cd2cb[0][1], ac122217995 = m7f4f0cd2cb[0][2],\na00a7244c30 = m7f4f0cd2cb[1][0], a90b743b58c = m7f4f0cd2cb[1][1], a2f9044642f = m7f4f0cd2cb[1][2],\nabbf182117b = m7f4f0cd2cb[2][0], a76187ed5e7 = m7f4f0cd2cb[2][1], abd38a595bd = m7f4f0cd2cb[2][2],\na41ecaed138 = m7f4f0cd2cb[3][0], aa638243179 = m7f4f0cd2cb[3][1], abe5bdc33f5 = m7f4f0cd2cb[3][2],\nb24ae8206ee = m71ae398200[0][0], ba7a975e23f = m71ae398200[0][1], b26594d8877 = m71ae398200[0][2], bebf1936a06 = m71ae398200[0][3],\nbd4c89897d0 = m71ae398200[1][0], b339ffe7279 = m71ae398200[1][1], bfa76c9278d = m71ae398200[1][2], b8172d1952c = m71ae398200[1][3],\nb7cacabc345 = m71ae398200[2][0], b27ae3829e2 = m71ae398200[2][1], bbf7d9db385 = m71ae398200[2][2], b1113d26867 = m71ae398200[2][3];\nd9748d673c4[0][0] = a79034f70a3 * b24ae8206ee + a00a7244c30 * ba7a975e23f + abbf182117b * b26594d8877 + a41ecaed138 * bebf1936a06;\nd9748d673c4[0][1] = af8ba94e471 * b24ae8206ee + a90b743b58c * ba7a975e23f + a76187ed5e7 * b26594d8877 + aa638243179 * bebf1936a06;\nd9748d673c4[0][2] = ac122217995 * b24ae8206ee + a2f9044642f * ba7a975e23f + abd38a595bd * b26594d8877 + abe5bdc33f5 * bebf1936a06;\nd9748d673c4[1][0] = a79034f70a3 * bd4c89897d0 + a00a7244c30 * b339ffe7279 + abbf182117b * bfa76c9278d + a41ecaed138 * b8172d1952c;\nd9748d673c4[1][1] = af8ba94e471 * bd4c89897d0 + a90b743b58c * b339ffe7279 + a76187ed5e7 * bfa76c9278d + aa638243179 * b8172d1952c;\nd9748d673c4[1][2] = ac122217995 * bd4c89897d0 + a2f9044642f * b339ffe7279 + abd38a595bd * bfa76c9278d + abe5bdc33f5 * b8172d1952c;\nd9748d673c4[2][0] = a79034f70a3 * b7cacabc345 + a00a7244c30 * b27ae3829e2 + abbf182117b * bbf7d9db385 + a41ecaed138 * b1113d26867;\nd9748d673c4[2][1] = af8ba94e471 * b7cacabc345 + a90b743b58c * b27ae3829e2 + a76187ed5e7 * bbf7d9db385 + aa638243179 * b1113d26867;\nd9748d673c4[2][2] = ac122217995 * b7cacabc345 + a2f9044642f * b27ae3829e2 + abd38a595bd * bbf7d9db385 + abe5bdc33f5 * b1113d26867;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_461",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of type \"ivec4\" (arrays of four integers). For each of the four components, it calculates the sum of the corresponding elements from the two input arrays and then adds this result to the corresponding element in the output array. Essentially, it performs an element-wise accumulation where each output element becomes its original value increased by the sum of the two corresponding input values.",
        "code_id": "c_group_2_id_461",
        "code_text": "Cd4e3208291\nvoid\ng427b402b5d(i52a86355e2 ad90770d038, i52a86355e2 bba3ae37d1f, i52a86355e2 d9748d673c4) {\nd9748d673c4[0] += ad90770d038[0] + bba3ae37d1f[0];\nd9748d673c4[1] += ad90770d038[1] + bba3ae37d1f[1];\nd9748d673c4[2] += ad90770d038[2] + bba3ae37d1f[2];\nd9748d673c4[3] += ad90770d038[3] + bba3ae37d1f[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_462",
        "query_text": "SUMMARY: This function takes as input a 4\u00d74 matrix of single-precision floating-point numbers (mat4) and two pointers to float variables. It decomposes the projection matrix to compute and output two scalar values, representing the top and bottom extents along the y-axis in eye space for a perspective projection using a right-handed coordinate system with a depth range from zero to one. The function internally extracts specific elements from the matrix to determine the near clipping plane distance along the z-axis and then uses this value to calculate the desired top and bottom boundaries.",
        "code_id": "c_group_2_id_462",
        "code_text": "Cd4e3208291\nvoid\ng19a3a3d0d0(m2979ecef6f paccfd26812,\nfloat * __restrict td39aaeaeed,\nfloat * __restrict be4ccd944cb) {\nfloat nd3cfbab11c, m4b629e56ab, md6bc4e094a, m529843770e;\nm4b629e56ab = paccfd26812[2][1];\nmd6bc4e094a = paccfd26812[1][1];\nm529843770e = paccfd26812[2][2];\nnd3cfbab11c = paccfd26812[3][2] / m529843770e;\n*be4ccd944cb = nd3cfbab11c * (m4b629e56ab - 1) / md6bc4e094a;\n*td39aaeaeed    = nd3cfbab11c * (m4b629e56ab + 1) / md6bc4e094a;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_463",
        "query_text": "SUMMARY: The function accepts an input of type vec4 (an array of four floats) and an output of type vec3 (an array of three floats). It sequentially copies the first three elements from the vec4 input into the vec3 output, effectively converting a four-dimensional floating-point vector into a three-dimensional one by discarding the fourth component.",
        "code_id": "c_group_2_id_463",
        "code_text": "Cd4e3208291\nvoid\ngcd385c8ea5(v141258b569 ve94da76c4c, veb444e7eb8 d9748d673c4) {\nd9748d673c4[0] = ve94da76c4c[0];\nd9748d673c4[1] = ve94da76c4c[1];\nd9748d673c4[2] = ve94da76c4c[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_464",
        "query_text": "SUMMARY: This function accepts two inputs\u2014one of type versor (an aligned array of four floats) and one of type pointer to FILE\u2014and returns no value. It formats and prints the contents of the quaternion (the four-component float vector) to the provided output stream. The printing process includes labeling the output (indicating a quaternion of four floats), applying precision formatting based on the component's magnitude, and using color formatting macros for enhanced visual presentation.",
        "code_id": "c_group_2_id_464",
        "code_text": "Cd4e3208291\nvoid\ng5fae10a749(v6c437193eb            vf6195f1fd8,\nFILE * __restrict o5450e5c91d) {\nint i0c6e314cec;\n#define mb8bcb57dcd 4\nfprintf(o5450e5c91d, \"Quaternion (float%d): \" C45893ec2b2 \"\\n  (\", mb8bcb57dcd);\nfor (i0c6e314cec = 0; i0c6e314cec < mb8bcb57dcd; i0c6e314cec++) {\nif (vf6195f1fd8[i0c6e314cec] < Cd0da13f7c8)\nfprintf(o5450e5c91d, \" % .*f\", Cb46738fea8, (double)vf6195f1fd8[i0c6e314cec]);\nelse\nfprintf(o5450e5c91d, \" % g\", (double)vf6195f1fd8[i0c6e314cec]);\n}\nfprintf(o5450e5c91d, \"  )\" C7c34c62781 \"\\n\\n\");\n#undef mb8bcb57dcd\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_465",
        "query_text": "SUMMARY: This function accepts a three-element float array (vec3) representing Euler angles and an enumeration (glm_euler_seq) specifying one of six rotation orders as input. It computes the sine and cosine values for these angles, uses the provided rotation order to assemble the appropriate 3\u00d73 rotation submatrix, and then constructs a 4\u00d74 float matrix (mat4) by embedding this rotation and appending homogeneous coordinates (with zero translation and a one in the lower-right corner).",
        "code_id": "c_group_2_id_465",
        "code_text": "Cd4e3208291\nvoid\ng3ae57c2255(veb444e7eb8 a9cd9428334, g187dbaf6ec oc80358c38e, m2979ecef6f d9748d673c4) {\nfloat ced008e8902, ce4f072f817, c6bd6fe7cc6,\ns7d25487ca7, se41a0f503f, s23246ee131;\nfloat c19bb133d1d, cda3a4bca48, c7c4f6ee9c1, c8c16907698,\nca9141d8c6a, c6de4c4d8c3, cc3c3a71c06, c3d8b48b332,\ns8f0754e783;\ns7d25487ca7 = sinf(a9cd9428334[0]); ced008e8902 = cosf(a9cd9428334[0]);\nse41a0f503f = sinf(a9cd9428334[1]); ce4f072f817 = cosf(a9cd9428334[1]);\ns23246ee131 = sinf(a9cd9428334[2]); c6bd6fe7cc6 = cosf(a9cd9428334[2]);\nc19bb133d1d = ce4f072f817 * c6bd6fe7cc6; cda3a4bca48 = ce4f072f817 * s23246ee131;\nc7c4f6ee9c1 = ce4f072f817 * s7d25487ca7; c8c16907698 = ced008e8902 * ce4f072f817;\nca9141d8c6a = c6bd6fe7cc6 * se41a0f503f; c6de4c4d8c3 = ced008e8902 * c6bd6fe7cc6;\ncc3c3a71c06 = c6bd6fe7cc6 * s7d25487ca7; c3d8b48b332 = ced008e8902 * s23246ee131;\ns8f0754e783 = se41a0f503f * s23246ee131;\nswitch (oc80358c38e) {\ncase Gf7ccf78e12:\nd9748d673c4[0][0] =  c19bb133d1d;\nd9748d673c4[0][1] =  s7d25487ca7 * se41a0f503f + ced008e8902 * cda3a4bca48;\nd9748d673c4[0][2] = -ced008e8902 * se41a0f503f + c7c4f6ee9c1 * s23246ee131;\nd9748d673c4[1][0] = -s23246ee131;\nd9748d673c4[1][1] =  c6de4c4d8c3;\nd9748d673c4[1][2] =  cc3c3a71c06;\nd9748d673c4[2][0] =  ca9141d8c6a;\nd9748d673c4[2][1] = -c7c4f6ee9c1 + ced008e8902 * s8f0754e783;\nd9748d673c4[2][2] =  c8c16907698 + s7d25487ca7 * s8f0754e783;\nbreak;\ncase Gd278344e03:\nd9748d673c4[0][0] =  c19bb133d1d;\nd9748d673c4[0][1] =  cc3c3a71c06 * se41a0f503f + c3d8b48b332;\nd9748d673c4[0][2] = -ced008e8902 * ca9141d8c6a + s7d25487ca7 * s23246ee131;\nd9748d673c4[1][0] = -cda3a4bca48;\nd9748d673c4[1][1] =  c6de4c4d8c3 - s7d25487ca7 * s8f0754e783;\nd9748d673c4[1][2] =  cc3c3a71c06 + ced008e8902 * s8f0754e783;\nd9748d673c4[2][0] =  se41a0f503f;\nd9748d673c4[2][1] = -c7c4f6ee9c1;\nd9748d673c4[2][2] =  c8c16907698;\nbreak;\ncase G7788ce2774:\nd9748d673c4[0][0] =  c19bb133d1d + s7d25487ca7 * s8f0754e783;\nd9748d673c4[0][1] =  c3d8b48b332;\nd9748d673c4[0][2] = -ca9141d8c6a + c7c4f6ee9c1 * s23246ee131;\nd9748d673c4[1][0] =  cc3c3a71c06 * se41a0f503f - cda3a4bca48;\nd9748d673c4[1][1] =  c6de4c4d8c3;\nd9748d673c4[1][2] =  c19bb133d1d * s7d25487ca7 + s8f0754e783;\nd9748d673c4[2][0] =  ced008e8902 * se41a0f503f;\nd9748d673c4[2][1] = -s7d25487ca7;\nd9748d673c4[2][2] =  c8c16907698;\nbreak;\ncase G84325c444a:\nd9748d673c4[0][0] =  c19bb133d1d;\nd9748d673c4[0][1] =  s23246ee131;\nd9748d673c4[0][2] = -ca9141d8c6a;\nd9748d673c4[1][0] =  s7d25487ca7 * se41a0f503f - ced008e8902 * cda3a4bca48;\nd9748d673c4[1][1] =  c6de4c4d8c3;\nd9748d673c4[1][2] =  c7c4f6ee9c1 + ced008e8902 * s8f0754e783;\nd9748d673c4[2][0] =  ced008e8902 * se41a0f503f + c7c4f6ee9c1 * s23246ee131;\nd9748d673c4[2][1] = -cc3c3a71c06;\nd9748d673c4[2][2] =  c8c16907698 - s7d25487ca7 * s8f0754e783;\nbreak;\ncase G6a05ed27b7:\nd9748d673c4[0][0] =  c19bb133d1d - s7d25487ca7 * s8f0754e783;\nd9748d673c4[0][1] =  cc3c3a71c06 * se41a0f503f + cda3a4bca48;\nd9748d673c4[0][2] = -ced008e8902 * se41a0f503f;\nd9748d673c4[1][0] = -c3d8b48b332;\nd9748d673c4[1][1] =  c6de4c4d8c3;\nd9748d673c4[1][2] =  s7d25487ca7;\nd9748d673c4[2][0] =  ca9141d8c6a + c7c4f6ee9c1 * s23246ee131;\nd9748d673c4[2][1] = -c19bb133d1d * s7d25487ca7 + s8f0754e783;\nd9748d673c4[2][2] =  c8c16907698;\nbreak;\ncase Gf0cd49f70f:\nd9748d673c4[0][0] =  c19bb133d1d;\nd9748d673c4[0][1] =  cda3a4bca48;\nd9748d673c4[0][2] = -se41a0f503f;\nd9748d673c4[1][0] =  cc3c3a71c06 * se41a0f503f - c3d8b48b332;\nd9748d673c4[1][1] =  c6de4c4d8c3 + s7d25487ca7 * s8f0754e783;\nd9748d673c4[1][2] =  c7c4f6ee9c1;\nd9748d673c4[2][0] =  ced008e8902 * ca9141d8c6a + s7d25487ca7 * s23246ee131;\nd9748d673c4[2][1] = -cc3c3a71c06 + ced008e8902 * s8f0754e783;\nd9748d673c4[2][2] =  c8c16907698;\nbreak;\n}\nd9748d673c4[0][3] = 0.0f;\nd9748d673c4[1][3] = 0.0f;\nd9748d673c4[2][3] = 0.0f;\nd9748d673c4[3][0] = 0.0f;\nd9748d673c4[3][1] = 0.0f;\nd9748d673c4[3][2] = 0.0f;\nd9748d673c4[3][3] = 1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_466",
        "query_text": "SUMMARY: This function takes three inputs: a 3-element integer array, an integer scalar, and another 3-element integer array intended for output, and it subtracts from each element of the output array the product of the corresponding element of the input array with the scalar. Concretely, for each of the three positions, the function computes the multiplication of the integer from the first array by the scalar and subtracts this result from the corresponding integer in the output array.",
        "code_id": "c_group_2_id_466",
        "code_text": "Cd4e3208291\nvoid\ngd6ec2d2673(i4b951f731e ad90770d038, int s3b9d266e2e, i4b951f731e d9748d673c4) {\nd9748d673c4[0] -= ad90770d038[0] * s3b9d266e2e;\nd9748d673c4[1] -= ad90770d038[1] * s3b9d266e2e;\nd9748d673c4[2] -= ad90770d038[2] * s3b9d266e2e;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_467",
        "query_text": "SUMMARY: This function accepts a pointer to an AUDIO_OUT structure (type: AUDIO_OUT *) as its sole input parameter and produces no return value (output type: void). It performs no meaningful operations; essentially, it reassigns the input parameter to itself and then exits without modifying any data or releasing any resources.",
        "code_id": "c_group_2_id_467",
        "code_text": "void\nabce3260763 (A560baa146b *a22e8501705)\n{\na22e8501705 = a22e8501705 ;\nreturn ;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_468",
        "query_text": "SUMMARY: This function accepts three inputs: a function pointer of type get_audio_callback_t, a pointer to an AUDIO_OUT structure, and a generic void pointer used as callback data. It returns no value (void). In its implementation, it disregards all provided arguments and terminates immediately without performing any operations or modifications.",
        "code_id": "c_group_2_id_468",
        "code_text": "void\na22a9c3668c (gd31956a4c3 cfafa6ba51c, A560baa146b *a22e8501705, void *cb87ffdcea1)\n{\n(void) cfafa6ba51c ;\n(void) a22e8501705 ;\n(void) cb87ffdcea1 ;\nreturn ;\n};",
        "relevance": 2
    }
]