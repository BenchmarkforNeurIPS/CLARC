[
    {
        "query_id": "q_group_2_id_52",
        "query_text": "SUMMARY: The function receives two inputs, each being a pointer to a structure defined as a pair of integers. It modifies the first structure by performing a bitwise AND operation on its individual integer values with the corresponding values from the second structure. The function does not return a value; it updates the first structure in place.",
        "code_id": "c_group_2_id_52",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nand    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nand    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_54",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to an array of unsigned integers (OnigCodePoint) and an integer\u2014and returns an integer. It calculates a specific offset within the array by dividing the integer input by 3 to select one element, then uses the remainder to determine which of the three bytes in that element to extract. It shifts the corresponding unsigned integer value accordingly and masks it to isolate one byte, which is then returned as a standard integer.",
        "code_id": "c_group_2_id_54",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nmov    %eax,%esi\nsar    $0x1f,%esi\nmov    %edx,%ecx\nsub    %esi,%ecx\nmov    %ecx,%edx\nadd    %edx,%edx\nadd    %ecx,%edx\nsub    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    $0x2,%eax\nsub    -0x8(%rbp),%eax\nshl    $0x3,%eax\nmov    -0x4(%rbp),%edx\nmov    %eax,%ecx\nshr    %cl,%edx\nmov    %edx,%eax\nmovzbl %al,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_9",
        "query_text": "SUMMARY: This function accepts one input of type utf8proc_ssize_t (a signed integer type) and returns a constant character pointer. It evaluates the input error code using a switch statement, mapping various predefined error code values to corresponding descriptive error message strings. For each known error condition, it returns a specific constant message detailing the encountered issue; if the error code does not match any predefined case, it returns a default message indicating an unknown error occurred.",
        "code_id": "c_group_2_id_9",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x5,%rax\ncmp    $0x4,%rax\nja     0x68\nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x29\nmov    (%rdx,%rax,1),%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0x35\nadd    %rdx,%rax\nnotrack jmp *%rax\nlea    0x0(%rip),%rax        # 0x42\njmp    0x6f\nlea    0x0(%rip),%rax        # 0x4b\njmp    0x6f\nlea    0x0(%rip),%rax        # 0x54\njmp    0x6f\nlea    0x0(%rip),%rax        # 0x5d\njmp    0x6f\nlea    0x0(%rip),%rax        # 0x66\njmp    0x6f\nlea    0x0(%rip),%rax        # 0x6f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_90",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to an immutable configuration structure (const config_t *) and an integer (int) representing an option flag\u2014and returns an integer (int). It evaluates whether the bitmask in the configuration's options field fully includes the specified option flag, returning a nonzero value if it does and zero otherwise.",
        "code_id": "c_group_2_id_90",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%eax\nand    -0xc(%rbp),%eax\ncmp    %eax,-0xc(%rbp)\nsete   %al\nmovzbl %al,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_56",
        "query_text": "SUMMARY: The function accepts an input parameter of type pointer to a structure (OptAnc) that contains two integer fields. It sets both of these integer fields to zero, effectively resetting the stored values. The function does not return any output (void).",
        "code_id": "c_group_2_id_56",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nmovl   $0x0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_62",
        "query_text": "SUMMARY: The function takes two arrays of unsigned int (OnigCodePoint) and an integer indicating the number of elements to compare. It iterates through the arrays, comparing each corresponding pair of elements. If any pair is not equal, it immediately returns an integer output value of -1; if all compared elements are identical, it returns 0 as the output.",
        "code_id": "c_group_2_id_62",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x57\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rcx\n\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\nje     0x53\nmov    $0xffffffff,%eax\njmp    0x64\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     0x1c\nmov    $0x0,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_11",
        "query_text": "SUMMARY: This function takes two inputs of type mytime (a struct timeval) and returns a double. It calculates the time difference in seconds between the two time points by subtracting the seconds components and then adding the scaled difference of the microseconds components (multiplied by 1.0E-6).",
        "code_id": "c_group_2_id_11",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rsi,%rax\nmov    %rdi,%r8\nmov    %r8,%rsi\nmov    %r9,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x10(%rbp)\nmov    %rdi,-0x8(%rbp)\nmov    %rdx,-0x20(%rbp)\nmov    %rcx,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nsub    %rdx,%rax\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nsub    %rdx,%rax\npxor   %xmm2,%xmm2\ncvtsi2sd %rax,%xmm2\nmovsd  0x0(%rip),%xmm0        # 0x57\n\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_53",
        "query_text": "SUMMARY: This function accepts a single input of type unsigned int (OnigCodePoint) and returns an unsigned int (OnigCodePoint). It checks if the input code point matches one of a few specific characters\u2014namely the beginning of a paired punctuation sequence\u2014and returns the corresponding ending punctuation code point. Specifically, it maps an input representing '<' to the code point for '>', an input representing a single quote to the same single quote, and an input representing '(' to the code point for ')'. If the input does not match any of these specified characters, it returns 0 as the default outcome.",
        "code_id": "c_group_2_id_53",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x3c,-0x4(%rbp)\nje     0x25\ncmpl   $0x3c,-0x4(%rbp)\nja     0x3a\ncmpl   $0x27,-0x4(%rbp)\nje     0x2c\ncmpl   $0x28,-0x4(%rbp)\nje     0x33\njmp    0x3a\nmov    $0x3e,%eax\njmp    0x40\nmov    $0x27,%eax\njmp    0x40\nmov    $0x29,%eax\njmp    0x40\nnop\nmov    $0x0,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_60",
        "query_text": "SUMMARY: This function takes an input of type st_table* and returns no output (void). It iterates over all bins in a hash table, freeing each st_table_entry (of type st_table_entry*) in the linked list stored in each bin. After releasing the memory for these entries, the function frees the array of bins and finally deallocates the st_table structure itself.",
        "code_id": "c_group_2_id_60",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x20,%rsp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    0x4d\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq   \nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rbx\njmp    0x44\nmov    0x18(%rbx),%r12\nmov    %rbx,%rdi\ncall   0x41\nmov    %r12,%rbx\ntest   %rbx,%rbx\njne    0x35\naddl   $0x1,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%eax\ncmp    %eax,-0x14(%rbp)\njl     0x1c\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    %rax,%rdi\ncall   0x69\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x75\nnop\nadd    $0x20,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_55",
        "query_text": "SUMMARY: This function accepts two pointers to an OptAnc structure (which contains two integer fields) as input parameters. It performs a direct copy of all the content from the structure referenced by the second pointer (source) to the structure referenced by the first pointer (destination), and it returns no value (void).",
        "code_id": "c_group_2_id_55",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    (%rdx),%rdx\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_80",
        "query_text": "SUMMARY: The function takes two inputs\u2014a pointer to a configuration structure of type config_t and an integer representing configuration options\u2014and does not return any value (void). It simply assigns the provided integer to the \"options\" field within the configuration structure, thereby setting the configuration options accordingly.",
        "code_id": "c_group_2_id_80",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,0x10(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_10",
        "query_text": "SUMMARY: This function takes an input pointer of type \"pointer to pointer to uint16_t\" and returns a value of type \"int32_t\". Its primary purpose is to decode a Unicode code point from a 16-bit sequence. It reads a 16-bit unit and checks if it represents a high-surrogate; if so, it advances the input pointer to obtain a second 16-bit unit, then combines both units using bitwise operations and arithmetic adjustments to form a complete Unicode code point. If the initial 16-bit unit does not indicate a surrogate pair, it simply returns the unit as the decoded code point.",
        "code_id": "c_group_2_id_10",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0xf800,%eax\ncmp    $0xd800,%eax\njne    0x68\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nlea    0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x4(%rbp),%eax\nshl    $0xa,%eax\nand    $0xffc00,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x3ff,%eax\nor     %edx,%eax\nmov    %eax,-0x4(%rbp)\naddl   $0x10000,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_83",
        "query_text": "SUMMARY: This function is designed to deallocate dynamically allocated memory. Its inputs are a memory pointer (of type void*) and a scanner handle (of type yyscan_t, which is defined as void*). The function does not produce any output (void return type). Internally, it performs a cast on the scanner handle to an internal structure type and then calls the standard free function on the memory pointer (after casting it to a character pointer) to release the allocated memory.",
        "code_id": "c_group_2_id_83",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x28\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_51",
        "query_text": "SUMMARY: This function receives two inputs of type st_data_t (an unsigned long) and returns an integer. It interprets each input as a pointer to a constant character sequence (a null-terminated string) and performs a standard lexicographical comparison between these two strings, returning the result of this comparison.",
        "code_id": "c_group_2_id_51",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x37\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_72",
        "query_text": "SUMMARY: This function, which accepts a constant character pointer (const char*) and a generic pointer type (void*, aliased as yyscan_t) as inputs and returns no value (void), is designed to handle fatal errors. It outputs a provided error message to the standard error stream and then terminates the program using a predefined failure exit code.",
        "code_id": "c_group_2_id_72",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    0x0(%rip),%rax        # 0x23\nmov    -0x18(%rbp),%rdx\nlea    0x0(%rip),%rcx        # 0x2e\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x3e\nmov    $0x2,%edi\ncall   0x48",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_59",
        "query_text": "SUMMARY: This function accepts two integers and a pointer to an array of type MemNumType as inputs. It iterates through a sequence of elements (with the number of iterations specified by the second integer input), checking if any element in the array exactly matches the first integer input. The function returns an integer output: it yields 1 (of type int) if a match is found and 0 (of type int) if no matching element exists.",
        "code_id": "c_group_2_id_59",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %rdx,-0x20(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x41\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x14(%rbp)\njne    0x3d\nmov    $0x1,%eax\njmp    0x4e\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     0x1b\nmov    $0x0,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_95",
        "query_text": "SUMMARY: This function accepts a single input of type mp_err (an enumeration representing various error conditions) and returns a const char* (a string literal). Its functionality is to map the provided mp_err input to a corresponding descriptive error message. It examines the input using a conditional structure and returns a specific string literal for each valid error code, or a default message indicating an invalid error code if the input does not match any predefined enumeration value.",
        "code_id": "c_group_2_id_95",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x6,%eax\ncmp    $0x6,%eax\nja     0x78\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x27\nmov    (%rdx,%rax,1),%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0x33\nadd    %rdx,%rax\nnotrack jmp *%rax\nlea    0x0(%rip),%rax        # 0x40\njmp    0x7f\nlea    0x0(%rip),%rax        # 0x49\njmp    0x7f\nlea    0x0(%rip),%rax        # 0x52\njmp    0x7f\nlea    0x0(%rip),%rax        # 0x5b\njmp    0x7f\nlea    0x0(%rip),%rax        # 0x64\njmp    0x7f\nlea    0x0(%rip),%rax        # 0x6d\njmp    0x7f\nlea    0x0(%rip),%rax        # 0x76\njmp    0x7f\nlea    0x0(%rip),%rax        # 0x7f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_24",
        "query_text": "SUMMARY: The function accepts an input of type fft_object (a pointer to a structure representing an FFT set) and returns no value (void). Its primary functionality is to deallocate the memory associated with the provided FFT set object by calling the standard memory management routine.",
        "code_id": "c_group_2_id_24",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_61",
        "query_text": "SUMMARY: This function accepts a single input of type unsigned long and returns an output of type int. Its behavior is to directly pass the input value through to the output, effectively converting the provided unsigned long value into an int.",
        "code_id": "c_group_2_id_61",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_87",
        "query_text": "SUMMARY: This function accepts two inputs: one is a pointer to a structured configuration object (type config_t *) and the other is a pointer to a destructor function (type void (*)(void *)) that takes a void pointer as its argument and returns no value. Its functionality is to assign the provided destructor function to the destructor attribute of the configuration object. The function itself returns no output (void).",
        "code_id": "c_group_2_id_87",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_99",
        "query_text": "SUMMARY: This function takes an input of type uint64_t and returns an int. It determines whether the provided unsigned integer is exactly a power of two. Specifically, it examines the number by removing successive factors of two (i.e., counting trailing zero bits) and then checks if the remaining value is one. If so, it returns the exponent (the count of divisions), indicating that the input equals 2 raised to that exponent; if not, it returns -1 to signal that the input is not a power of two.",
        "code_id": "c_group_2_id_99",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x1d\naddl   $0x1,-0x4(%rbp)\nshrq   -0x18(%rbp)\nmov    -0x18(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     0x15\ncmpq   $0x1,-0x18(%rbp)\njne    0x35\nmov    -0x4(%rbp),%eax\njmp    0x3a\nmov    $0xffffffff,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_75",
        "query_text": "SUMMARY: This function takes as input a pointer to a configuration setting structure (of type struct config_setting_t) and a generic pointer (of type void *) as parameters, and returns no value (void). Its functionality is to update the configuration setting by assigning the provided generic pointer to the hook field within the configuration setting structure.",
        "code_id": "c_group_2_id_75",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,0x28(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_97",
        "query_text": "SUMMARY: This function takes three parameters: a pointer to a mutable 64-bit unsigned integer array (output), a pointer to a constant 64-bit unsigned integer array (input), and an integer indicating the number of elements (digits) to process. Its purpose is to copy the specified number of 64-bit unsigned integers from the constant array into the mutable array. The operation is performed either by using a memory copy routine or by a simple loop, based on compile-time configuration. The function does not return any value.",
        "code_id": "c_group_2_id_97",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x14(%rbp)\njmp    0x33\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,-0x10(%rbp)\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rcx\nmov    %rcx,-0x8(%rbp)\nmov    %rdx,(%rax)\nmov    -0x14(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ntest   %eax,%eax\nsetg   %al\ntest   %al,%al\njne    0x15\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_76",
        "query_text": "SUMMARY: This function accepts a pointer to a structure (type: struct config_setting_t) and an integer (type: int) as inputs and returns an integer (type: int). It verifies whether the input structure either has no assigned type or is explicitly designated as a boolean type. If the structure is untyped, it assigns the boolean type; if it is already of a different type, the function returns an error code (false). When the boolean type conditions are met, it stores the provided integer value into the union field representing an integer and returns a success code (true).",
        "code_id": "c_group_2_id_76",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovzwl 0x8(%rax),%eax\ntest   %ax,%ax\njne    0x28\nmov    -0x8(%rbp),%rax\nmovw   $0x6,0x8(%rax)\njmp    0x3d\nmov    -0x8(%rbp),%rax\nmovzwl 0x8(%rax),%eax\ncmp    $0x6,%ax\nje     0x3d\nmov    $0x0,%eax\njmp    0x4c\nmov    -0x8(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,0x10(%rax)\nmov    $0x1,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_74",
        "query_text": "SUMMARY: This function accepts a constant pointer to a configuration structure (const config_t *) as input and returns an unsigned short. It functions as a getter by accessing the tab_width field within the provided configuration structure and returning its value.",
        "code_id": "c_group_2_id_74",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzwl 0x14(%rax),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_96",
        "query_text": "SUMMARY: This function accepts an input of type unsigned long and returns a value of the same type. It computes the integer portion of the base-2 logarithm of the input by repeatedly shifting the input to the right (thereby dividing by 2) until the result is zero. For each shift performed, it increments a counter, and finally returns this counter as the output.",
        "code_id": "c_group_2_id_96",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovq   $0x0,-0x8(%rbp)\n\njmp    0x1b\naddq   $0x1,-0x8(%rbp)\nshrq   -0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nsetne  %al\ntest   %al,%al\njne    0x16\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_58",
        "query_text": "SUMMARY: This function takes an unsigned long input (interpreted as a pointer to a constant character sequence) and returns an integer computed as a hash value based on that string\u2019s content. It iterates over the characters of the null\u2010terminated string, updating an accumulator through arithmetic and bitwise operations. Depending on compile-time flags, it applies one of several hashing methods\u2014one that performs left shifts with mask extraction, another that combines summation with bit shifting, and a default that multiplies by a constant before adding each character. The overall behavior is to transform the input string into an integer hash result.",
        "code_id": "c_group_2_id_58",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    $0x0,%ebx\njmp    0x28\nimul   $0x3e5,%ebx,%eax\nlea    (%r12,%rax,1),%ebx\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x18(%rbp)\nmovzbl (%rax),%eax\nmovsbl %al,%r12d\ntest   %r12d,%r12d\nsetne  %al\ntest   %al,%al\njne    0x1e\nmov    %ebx,%eax\nsar    $0x5,%eax\nadd    %ebx,%eax\npop    %rbx\npop    %r12\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_78",
        "query_text": "SUMMARY: This function accepts a pointer to a constant configuration setting structure (const config_setting_t*) as its input and returns an integer (int) as its output. It determines whether the configuration setting represents an aggregate type by examining its type field. The function returns a nonzero integer (true) if the type field indicates that the configuration is either an array, a list, or a group; otherwise, it returns 0 (false).",
        "code_id": "c_group_2_id_78",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzwl 0x8(%rax),%eax\ncmp    $0x7,%ax\nje     0x36\nmov    -0x8(%rbp),%rax\nmovzwl 0x8(%rax),%eax\ncmp    $0x8,%ax\nje     0x36\nmov    -0x8(%rbp),%rax\nmovzwl 0x8(%rax),%eax\ncmp    $0x1,%ax\njne    0x3d\nmov    $0x1,%eax\njmp    0x42\nmov    $0x0,%eax\nmovzbl %al,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_57",
        "query_text": "SUMMARY: The function accepts two inputs of type unsigned long (st_data_t) and returns an int. It performs a simple comparison between these two values and produces an integer result that indicates whether the two inputs are not equal.",
        "code_id": "c_group_2_id_57",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nsetne  %al\nmovzbl %al,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_71",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to a file stream (FILE *) and a constant pointer to a structured value (tt_val_t, which contains an enumerated type indicator and a union holding one of several data types: int, unsigned int, long long, unsigned long long, double, const char *, or const void *). It processes the structured value by examining the associated type enumeration and writes its contained value to the provided file stream in an appropriately formatted manner. The output is directly written to the stream (with no return value) and includes special handling for string types, where control characters are escaped and the entire string is enclosed in quotation marks.",
        "code_id": "c_group_2_id_71",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\ncmp    $0x6,%eax\nja     0x283\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x34\nmov    (%rdx,%rax,1),%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0x40\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%edx\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x58\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x68\njmp    0x2a4\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%edx\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x7f\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x8f\njmp    0x2a4\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0xa7\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xb7\njmp    0x2a4\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0xcf\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xdf\njmp    0x2a4\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0xfc\nmov    %rdx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x10c\njmp    0x2a4\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nmov    $0x22,%edi\ncall   0x122\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\njmp    0x23c\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xa,%al\njne    0x163\nmov    -0x18(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x2,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x156\nmov    %rax,%rdi\ncall   0x15e\njmp    0x237\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xd,%al\njne    0x193\nmov    -0x18(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x2,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x186\nmov    %rax,%rdi\ncall   0x18e\njmp    0x237\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x9,%al\njne    0x1c0\nmov    -0x18(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x2,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x1b6\nmov    %rax,%rdi\ncall   0x1be\njmp    0x237\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xc,%al\njne    0x1ed\nmov    -0x18(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x2,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x1e3\nmov    %rax,%rdi\ncall   0x1eb\njmp    0x237\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x1f,%al\njg     0x21f\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x20d\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x21d\njmp    0x237\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   0x237\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x133\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nmov    $0x22,%edi\ncall   0x25c\njmp    0x2a4\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x271\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x281\njmp    0x2a4\nmov    -0x18(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x3,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x29b\nmov    %rax,%rdi\ncall   0x2a3\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_63",
        "query_text": "SUMMARY: The function accepts an input of type pointer to a structure (OptAnc) containing two integers (\"left\" and \"right\") and a second input of type int. It checks whether the int input is represented as a set bit in the first integer element; if not, it then checks the second integer element. The output is an int that indicates success (1) if the bit is set in either of the integer fields, or failure (0) otherwise.",
        "code_id": "c_group_2_id_63",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nand    -0xc(%rbp),%eax\ntest   %eax,%eax\nje     0x23\nmov    $0x1,%eax\njmp    0x3e\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\nand    -0xc(%rbp),%eax\ntest   %eax,%eax\nje     0x38\nmov    $0x1,%eax\njmp    0x3d\nmov    $0x0,%eax\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_13",
        "query_text": "SUMMARY: This function receives a constant pointer to a character array and a structure of type \"struct floating_decimal_128\" (which contains a 128\u2011bit unsigned integer, a 32\u2011bit signed integer, and a boolean) as inputs, and returns an integer. It examines the unsigned integer component of the structure; if this value is nonzero, the function writes the string \"NaN\" into the character array and returns the length (3). Otherwise, it checks the boolean to determine if a minus sign is needed, prepending it when true, then writes the string \"Infinity\" (8 characters) immediately after any inserted minus sign, returning the combined length as an integer.",
        "code_id": "c_group_2_id_13",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    0x10(%rbp),%rax\nmov    0x18(%rbp),%rdx\nor     %rdx,%rax\ntest   %rax,%rax\nje     0x42\nmov    -0x8(%rbp),%rax\nmov    $0x3,%edx\nlea    0x0(%rip),%rcx        # 0x30\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x3b\nmov    $0x3,%eax\njmp    0x80\nmovzbl 0x24(%rbp),%eax\ntest   %al,%al\nje     0x51\nmov    -0x8(%rbp),%rax\nmovb   $0x2d,(%rax)\nmovzbl 0x24(%rbp),%eax\nmovzbl %al,%edx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    $0x8,%edx\nlea    0x0(%rip),%rcx        # 0x6b\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x76\nmovzbl 0x24(%rbp),%eax\nmovzbl %al,%eax\nadd    $0x8,%eax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_89",
        "query_text": "SUMMARY: The function accepts a C-style string (input type: char pointer) and returns a boolean value (output type: tt_bool_t, which is essentially an int). Its functionality is to traverse the string from the end toward the beginning, replacing any trailing newline-related characters (specifically carriage return or newline) with a null terminator, and then it returns a boolean indicating whether any such termination characters were encountered and removed.",
        "code_id": "c_group_2_id_89",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x8(%rbp),%rax\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\njmp    0x65\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xd,%al\nje     0x52\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xa,%al\njne    0x60\nmovl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%rax\nmovb   $0x0,(%rax)\nsubq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x28(%rbp),%rax\nja     0x3c\nmov    -0x14(%rbp),%eax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_70",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to a structure of type config_t and a pointer of type void*. Its purpose is to assign the provided void pointer to the hook member of the config_t structure. The function does not produce an output value (its return type is void).",
        "code_id": "c_group_2_id_70",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,0x50(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_127",
        "query_text": "SUMMARY: This function accepts a pointer to a structure (of type CC_Rbuf, defined as ring_buffer) and returns a boolean value. Its purpose is to determine whether the ring buffer is empty by checking if the size field within the structure is zero, returning true when empty and false when not.",
        "code_id": "c_group_2_id_127",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\nsete   %al\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_98",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to an array of unsigned 64-bit integers (mp_digit *) and a count as an integer (int) representing the number of elements. Its behavior is to set the specified number of unsigned 64-bit integer elements to zero. The function does not produce any output (void return), and its process involves either using a memory-setting operation to fill the array with 0 values or iterating over the array and assigning 0 to each element based on conditional compilation.",
        "code_id": "c_group_2_id_98",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\njmp    0x24\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,-0x8(%rbp)\nmovq   $0x0,(%rax)\nmov    -0xc(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ntest   %eax,%eax\nsetg   %al\ntest   %al,%al\njne    0x11\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_91",
        "query_text": "SUMMARY: This function accepts a pointer to a structure (strbuf_t) that includes a dynamically allocated string, its length, and its capacity. It retrieves the string (a char pointer) stored within the structure, then resets the structure's contents to a zeroed or cleared state. Finally, it returns the retrieved char pointer.",
        "code_id": "c_group_2_id_91",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    $0x18,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x31\nmov    -0x8(%rbp),%rax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_77",
        "query_text": "SUMMARY: This function takes three inputs: a pointer to a configuration structure (of type config_t *), an integer bit mask (of type int), and an integer flag (of type int). It updates the configuration structure's internal options field by setting the bit(s) specified by the integer bit mask if the integer flag is nonzero, or by clearing those bit(s) if the integer flag is zero. The function does not return any value (void).",
        "code_id": "c_group_2_id_77",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %edx,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\nje     0x2d\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%eax\nor     -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,0x10(%rax)\njmp    0x42\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%edx\nmov    -0xc(%rbp),%eax\nnot    %eax\nand    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,0x10(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_85",
        "query_text": "SUMMARY: This function accepts a single input parameter of type const config_setting_t* and returns an int. It determines whether the provided configuration structure represents a boolean value by checking its type field; if it does, the function returns the integer value stored in the union (specifically in its ival component), and if not, it returns 0.",
        "code_id": "c_group_2_id_85",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzwl 0x8(%rax),%eax\ncmp    $0x6,%ax\njne    0x23\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%eax\njmp    0x28\nmov    $0x0,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_82",
        "query_text": "SUMMARY: The function accepts two inputs\u2014a pointer to a configuration setting structure (of type config_setting_t*) and an unsigned short that represents a format option\u2014and returns an integer (int). It verifies that the configuration setting is of an integer type (either 32-bit or 64-bit) and that the provided format option is valid (either the default or hexadecimal). Upon satisfying both conditions, it updates the configuration setting\u2019s format field with the given value and returns an integer indicating success; if not, it returns an integer indicating failure.",
        "code_id": "c_group_2_id_82",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %ax,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovzwl 0x8(%rax),%eax\ncmp    $0x2,%ax\nje     0x2e\nmov    -0x8(%rbp),%rax\nmovzwl 0x8(%rax),%eax\ncmp    $0x3,%ax\njne    0x3c\ncmpw   $0x0,-0xc(%rbp)\nje     0x43\ncmpw   $0x1,-0xc(%rbp)\nje     0x43\nmov    $0x0,%eax\njmp    0x54\nmov    -0x8(%rbp),%rax\nmovzwl -0xc(%rbp),%edx\nmov    %dx,0xa(%rax)\nmov    $0x1,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_86",
        "query_text": "SUMMARY: This function takes two inputs\u2014the first is a pointer to a structure (of type fuzz_data_t) that includes metadata about content size and an array of 8-bit unsigned integers, and the second is a pointer to a pointer of 8-bit unsigned integers (uint8_t **). The function assigns the memory address of the internal data array from the structure to the provided output pointer and then appends a null terminator at the position indicated by the content size (a 32-bit unsigned integer) within that array. The function is void, so it outputs the changed pointer as an effect via the output parameter.",
        "code_id": "c_group_2_id_86",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x9(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x1(%rax),%eax\nmov    %eax,%eax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_84",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to a structure of type config_t and a pointer to a constant char array (const char *). It deallocates any previously stored string in the include directory field of the provided config_t structure and then assigns a new duplicate of the provided constant char array to that field. The function does not return any value (void).",
        "code_id": "c_group_2_id_84",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x20(%rax),%rax\nmov    %rax,%rdi\ncall   0x24\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x20(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_73",
        "query_text": "SUMMARY: This function accepts a pointer to a configuration structure (config_t *) and an unsigned short value representing float precision. It assigns the provided unsigned short value to the float_precision field within the configuration structure and does not return a value.",
        "code_id": "c_group_2_id_73",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %ax,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovzwl -0xc(%rbp),%edx\nmov    %dx,0x16(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_92",
        "query_text": "SUMMARY: This function receives a pointer to a structure (of type config_t) and returns an unsigned short value. It retrieves the floating-point precision field stored within the given configuration structure.",
        "code_id": "c_group_2_id_92",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzwl 0x16(%rax),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_118",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a pointer to a conversion context structure (of type f_conv_context_t), a pointer to a constant character array (const char*), and a size value (size_t). It verifies that the accessible buffer space in the conversion context is sufficient (when allowing space for a trailing null character) to hold the specified number of characters. If the available space is insufficient, it returns an integer error code (-1). Otherwise, it copies the specified number of characters from the provided character array into the buffer within the conversion context, advances the buffer pointer accordingly, and reduces the remaining available space by that length. It then appends a null terminator to mark the end of the string and returns the number of characters copied as an integer.",
        "code_id": "c_group_2_id_118",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nadd    $0x1,%rax\ncmp    %rax,-0x18(%rbp)\njbe    0x31\nmov    $0xffffffff,%eax\njmp    0x85\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x4b\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nsub    -0x18(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmovb   $0x0,(%rax)\nmov    -0x18(%rbp),%rax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_88",
        "query_text": "SUMMARY: This function takes three inputs\u2014a constant character pointer, another constant character pointer (both representing file paths), and a tt_bool_t (a boolean flag indicating verbosity). It returns a tt_bool_t indicating whether the contents of the two files are identical. The function opens both files in binary mode, reads their contents in 4096-byte chunks, and then compares the bytes sequentially. If a mismatch is detected (or if the files have different lengths), it marks the result as false and, if the verbosity flag is true, prints the location (line and character) where the first difference occurs. Ultimately, after closing the files, it returns TT_TRUE if the files are identical or TT_FALSE if they are not.",
        "code_id": "c_group_2_id_88",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x2068(%rbp)\nmov    %rsi,-0x2070(%rbp)\nmov    %edx,-0x2074(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x1,-0x2060(%rbp)\n\nmovl   $0x0,-0x205c(%rbp)\n\nmovl   $0x0,-0x2058(%rbp)\n\nmovl   $0x1,-0x2054(%rbp)\n\nmov    -0x2068(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x7d\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x88\nmov    %rax,-0x2040(%rbp)\ncmpq   $0x0,-0x2040(%rbp)\n\nsete   %al\ntest   %al,%al\nje     0xc6\nmov    -0x2068(%rbp),%rax\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0xaf\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xbc\nmov    $0x0,%eax\njmp    0x338\nmov    -0x2070(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0xd4\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xdf\nmov    %rax,-0x2038(%rbp)\ncmpq   $0x0,-0x2038(%rbp)\n\nsete   %al\ntest   %al,%al\nje     0x2be\nmov    -0x2040(%rbp),%rax\nmov    %rax,%rdi\ncall   0x108\nmov    -0x2070(%rbp),%rax\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x119\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x126\nmov    $0x0,%eax\njmp    0x338\nmov    -0x2040(%rbp),%rdx\nlea    -0x2010(%rbp),%rax\nmov    %rdx,%rcx\nmov    $0x1000,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   0x153\nmov    %rax,-0x2030(%rbp)\nmov    -0x2038(%rbp),%rdx\nlea    -0x1010(%rbp),%rax\nmov    %rdx,%rcx\nmov    $0x1000,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   0x17d\nmov    %rax,-0x2028(%rbp)\nlea    -0x2010(%rbp),%rax\nmov    %rax,-0x2050(%rbp)\nlea    -0x1010(%rbp),%rax\nmov    %rax,-0x2048(%rbp)\nlea    -0x2010(%rbp),%rdx\nmov    -0x2030(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x2020(%rbp)\nlea    -0x1010(%rbp),%rdx\nmov    -0x2028(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x2018(%rbp)\njmp    0x238\nmov    -0x2050(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x2048(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     0x200\nmovl   $0x0,-0x2054(%rbp)\n\nmovl   $0x1,-0x2058(%rbp)\n\njmp    0x25c\nmov    -0x2050(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xa,%al\njne    0x221\naddl   $0x1,-0x2060(%rbp)\nmovl   $0x0,-0x205c(%rbp)\n\njmp    0x228\naddl   $0x1,-0x205c(%rbp)\naddq   $0x1,-0x2050(%rbp)\n\naddq   $0x1,-0x2048(%rbp)\n\nmov    -0x2050(%rbp),%rax\ncmp    -0x2020(%rbp),%rax\njae    0x25c\nmov    -0x2048(%rbp),%rax\ncmp    -0x2018(%rbp),%rax\njb     0x1d2\nmov    -0x2050(%rbp),%rax\ncmp    -0x2020(%rbp),%rax\njb     0x27c\nmov    -0x2048(%rbp),%rax\ncmp    -0x2018(%rbp),%rax\njae    0x288\nmovl   $0x0,-0x2054(%rbp)\n\njmp    0x2ce\nmov    -0x2040(%rbp),%rax\nmov    %rax,%rdi\ncall   0x297\ntest   %eax,%eax\njne    0x2ae\nmov    -0x2038(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2aa\ntest   %eax,%eax\nje     0x2b5\nmov    $0x1,%eax\njmp    0x2ba\nmov    $0x0,%eax\ntest   %al,%al\njne    0x2cd\ncmpl   $0x0,-0x2058(%rbp)\nje     0x130\njmp    0x2ce\nnop\nmov    -0x2040(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2dd\nmov    -0x2038(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2ec\ncmpl   $0x0,-0x2054(%rbp)\njne    0x332\ncmpl   $0x0,-0x2074(%rbp)\nje     0x332\nmov    -0x205c(%rbp),%esi\nmov    -0x2060(%rbp),%ecx\nmov    -0x2070(%rbp),%rdx\nmov    -0x2068(%rbp),%rax\nmov    %esi,%r8d\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x325\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x332\nmov    -0x2054(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x34c\ncall   0x34c\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_81",
        "query_text": "SUMMARY: This function takes a pointer to a structure (type: tt_testsuite_t *) representing a test suite as input and returns no value (type: void). It sequentially traverses a linked list of test structures (of type tt_test_t) contained within the suite, deallocating memory for each test\u2019s allocated name and the test structure itself. After cleaning up all test entries, it then deallocates memory for the suite\u2019s allocated name and the suite structure.",
        "code_id": "c_group_2_id_81",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\njmp    0x4d\nmov    -0x10(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   0x39\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x45\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    0x1e\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   0x63\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x6f\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_94",
        "query_text": "SUMMARY: This function takes as input a pointer to a structure of type config_t and an unsigned short integer. It modifies the configuration by setting its tab_width field to the input value, ensuring that the value does not exceed 15; if the input exceeds 15, it sets the tab_width to 15. The function has a void output, meaning it does not return any value.",
        "code_id": "c_group_2_id_94",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %ax,-0xc(%rbp)\nmovzwl -0xc(%rbp),%eax\nmov    $0xf,%edx\ncmp    %dx,%ax\ncmovbe %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %dx,0x14(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_69",
        "query_text": "SUMMARY: This function accepts an input of type const config_t* and returns an output of type int. It retrieves and returns the configuration options stored within the provided configuration structure.",
        "code_id": "c_group_2_id_69",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_124",
        "query_text": "SUMMARY: This function accepts an input variable of type f_string_buffer_t* and returns an int. It first validates that the input pointer and the embedded data pointer (of type void* inside a union) are not null. Then, based on the input\u2019s enum type value (of type enum f_string_type), it checks whether the data pointer is properly aligned when necessary. Specifically, for the wide character buffer type (when available), it verifies that the pointer's address is aligned to the size of a wide character; for the standard and UTF8 character buffer types, it simply returns a positive result.",
        "code_id": "c_group_2_id_124",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    0x3f\nlea    0x0(%rip),%rax        # 0x1e\nmov    %rax,%rcx\nmov    $0x20,%edx\nlea    0x0(%rip),%rax        # 0x2d\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    0x73\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rcx\nmov    $0x21,%edx\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdi\ncall   0x73\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%eax\ncmp    $0x2,%eax\nje     0xab\ncmp    $0x2,%eax\njg     0xb2\ntest   %eax,%eax\nje     0x8f\ncmp    $0x1,%eax\nje     0x96\njmp    0xb2\nmov    $0x1,%eax\njmp    0xda\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nand    $0x3,%eax\ntest   %rax,%rax\nsete   %al\nmovzbl %al,%eax\njmp    0xda\nmov    $0x1,%eax\njmp    0xda\nlea    0x0(%rip),%rax        # 0xb9\nmov    %rax,%rcx\nmov    $0x2e,%edx\nlea    0x0(%rip),%rax        # 0xc8\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0xd2\nmov    %rax,%rdi\ncall   0xda\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_93",
        "query_text": "SUMMARY: This function accepts a pointer to a structure representing a list (type config_list_t*) and an integer (type int) indicating an index, and it returns a pointer to a configuration setting (type config_setting_t*). Its primary operation is to remove the configuration setting located at the specified index from the list by shifting the subsequent elements to fill the gap, decrementing the total count of elements, and then returning the removed configuration setting.",
        "code_id": "c_group_2_id_93",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq   \nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq   \nshl    $0x3,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x2c(%rbp),%edx\nsub    %edx,%eax\nsub    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq   \nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x82\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    -0x1(%rax),%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_120",
        "query_text": "SUMMARY: This function takes as input a constant pointer to a structure of type f_string_buffer_t and returns a size_t value. Its main functionality is to retrieve and output the raw capacity information stored within the structure without performing any additional computations.",
        "code_id": "c_group_2_id_120",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_125",
        "query_text": "SUMMARY: The function accepts three inputs\u2014a pointer to a conversion context structure (f_conv_context_t *), and two constant void pointers representing the start and end of a raw byte sequence. It computes the length of this sequence and, after verifying that the available space (inclusive of an extra byte for termination) in the context\u2019s internal character buffer is sufficient, copies the raw byte sequence into that buffer, updates the buffer\u2019s pointer and remaining available space, appends a null terminator at the new end, and returns the number of bytes copied as an integer. If there is insufficient space, it returns -1.",
        "code_id": "c_group_2_id_125",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rax\nadd    $0x1,%rax\ncmp    %rax,-0x8(%rbp)\njbe    0x4d\nmov    $0xffffffff,%eax\njmp    0xa1\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rdx\nmov    -0x30(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x67\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rax\nsub    -0x8(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_116",
        "query_text": "SUMMARY: This function accepts an input of type int32_t representing a Unicode code point and returns an int32_t output representing its lowercase equivalent. It evaluates the input against multiple code point ranges corresponding to uppercase letters and, based on the range, applies specific arithmetic or bitwise transformations to convert the uppercase code point to its lowercase form. For inputs that do not fall within these typical ranges, it handles several exceptional cases using an explicit mapping to produce the appropriate lowercase value.",
        "code_id": "c_group_2_id_116",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x40,-0x4(%rbp)\njle    0x17\ncmpl   $0x5a,-0x4(%rbp)\njle    0x5f\ncmpl   $0xbf,-0x4(%rbp)\njle    0x29\ncmpl   $0xd6,-0x4(%rbp)\njle    0x5f\ncmpl   $0xd7,-0x4(%rbp)\njle    0x3b\ncmpl   $0xde,-0x4(%rbp)\njle    0x5f\ncmpl   $0x390,-0x4(%rbp)\njle    0x4d\ncmpl   $0x3a1,-0x4(%rbp)\njle    0x5f\ncmpl   $0x3a2,-0x4(%rbp)\njle    0x68\ncmpl   $0x3ab,-0x4(%rbp)\njg     0x68\naddl   $0x20,-0x4(%rbp)\njmp    0x44a\ncmpl   $0xff,-0x4(%rbp)\njle    0x7e\ncmpl   $0x12f,-0x4(%rbp)\njle    0x124\ncmpl   $0x131,-0x4(%rbp)\njle    0x94\ncmpl   $0x137,-0x4(%rbp)\njle    0x124\ncmpl   $0x149,-0x4(%rbp)\njle    0xa6\ncmpl   $0x177,-0x4(%rbp)\njle    0x124\ncmpl   $0x181,-0x4(%rbp)\njle    0xb8\ncmpl   $0x185,-0x4(%rbp)\njle    0x124\ncmpl   $0x19f,-0x4(%rbp)\njle    0xca\ncmpl   $0x1a5,-0x4(%rbp)\njle    0x124\ncmpl   $0x1dd,-0x4(%rbp)\njle    0xdc\ncmpl   $0x1ef,-0x4(%rbp)\njle    0x124\ncmpl   $0x1f7,-0x4(%rbp)\njle    0xee\ncmpl   $0x21f,-0x4(%rbp)\njle    0x124\ncmpl   $0x221,-0x4(%rbp)\njle    0x100\ncmpl   $0x233,-0x4(%rbp)\njle    0x124\ncmpl   $0x245,-0x4(%rbp)\njle    0x112\ncmpl   $0x24f,-0x4(%rbp)\njle    0x124\ncmpl   $0x3d7,-0x4(%rbp)\njle    0x12d\ncmpl   $0x3ef,-0x4(%rbp)\njg     0x12d\norl    $0x1,-0x4(%rbp)\njmp    0x44a\ncmpl   $0x138,-0x4(%rbp)\njle    0x13f\ncmpl   $0x148,-0x4(%rbp)\njle    0x187\ncmpl   $0x178,-0x4(%rbp)\njle    0x151\ncmpl   $0x17e,-0x4(%rbp)\njle    0x187\ncmpl   $0x1ae,-0x4(%rbp)\njle    0x163\ncmpl   $0x1b0,-0x4(%rbp)\njle    0x187\ncmpl   $0x1b2,-0x4(%rbp)\njle    0x175\ncmpl   $0x1b6,-0x4(%rbp)\njle    0x187\ncmpl   $0x1cc,-0x4(%rbp)\njle    0x194\ncmpl   $0x1dc,-0x4(%rbp)\njg     0x194\naddl   $0x1,-0x4(%rbp)\nandl   $0xfffffffe,-0x4(%rbp)\njmp    0x44a\ncmpl   $0x3ff,-0x4(%rbp)\njg     0x449\ncmpl   $0x370,-0x4(%rbp)\njge    0x1c5\ncmpl   $0x1f7,-0x4(%rbp)\njg     0x263\ncmpl   $0x178,-0x4(%rbp)\njge    0x22f\njmp    0x449\nmov    -0x4(%rbp),%eax\nsub    $0x370,%eax\ncmp    $0x8f,%eax\nja     0x449\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x1e9\nmov    (%rdx,%rax,1),%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0x1f5\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x4(%rbp),%eax\nsub    $0x220,%eax\ncmp    $0x23,%eax\nja     0x449\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x21d\nmov    (%rdx,%rax,1),%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0x229\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x4(%rbp),%eax\nsub    $0x178,%eax\ncmp    $0x7f,%eax\nja     0x449\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x251\nmov    (%rdx,%rax,1),%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0x25d\nadd    %rdx,%rax\nnotrack jmp *%rax\ncmpl   $0x243,-0x4(%rbp)\njg     0x449\ncmpl   $0x220,-0x4(%rbp)\njge    0x1fb\njmp    0x449\nmovl   $0xff,-0x4(%rbp)\njmp    0x44a\nmovl   $0x180,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1dd,-0x4(%rbp)\njmp    0x44a\nmovl   $0x19a,-0x4(%rbp)\njmp    0x44a\nmovl   $0x19e,-0x4(%rbp)\njmp    0x44a\nmovl   $0x292,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1c6,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1c9,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1cc,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1f3,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1bf,-0x4(%rbp)\njmp    0x44a\nmovl   $0x188,-0x4(%rbp)\njmp    0x44a\nmovl   $0x18c,-0x4(%rbp)\njmp    0x44a\nmovl   $0x192,-0x4(%rbp)\njmp    0x44a\nmovl   $0x199,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1a8,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1ad,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1b0,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1b9,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1bd,-0x4(%rbp)\njmp    0x44a\nmovl   $0x1f5,-0x4(%rbp)\njmp    0x44a\nmovl   $0x23c,-0x4(%rbp)\njmp    0x44a\nmovl   $0x242,-0x4(%rbp)\njmp    0x44a\nmovl   $0x37b,-0x4(%rbp)\njmp    0x44a\nmovl   $0x37c,-0x4(%rbp)\njmp    0x44a\nmovl   $0x37d,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3f3,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3ac,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3ad,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3ae,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3af,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3cc,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3cd,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3ce,-0x4(%rbp)\njmp    0x44a\nmovl   $0x371,-0x4(%rbp)\njmp    0x44a\nmovl   $0x373,-0x4(%rbp)\njmp    0x44a\nmovl   $0x377,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3d1,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3d7,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3f2,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3f8,-0x4(%rbp)\njmp    0x44a\nmovl   $0x3fb,-0x4(%rbp)\njmp    0x44a\nnop\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_121",
        "query_text": "SUMMARY: This function accepts a constant pointer to a f_string_buffer_t structure and returns a size_t value. It verifies the validity of the input pointer and then determines a width capacity based on the contained string type. For a character buffer, it returns the total data size directly; for a wide-character buffer, it returns the data size divided by the size of a wide character; and for a UTF8 buffer, it returns the data size divided by 4. If an unsupported type is encountered, the function triggers a runtime assertion failure.",
        "code_id": "c_group_2_id_121",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    0x3f\nlea    0x0(%rip),%rax        # 0x1e\nmov    %rax,%rcx\nmov    $0x20,%edx\nlea    0x0(%rip),%rax        # 0x2d\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%eax\ncmp    $0x2,%eax\nje     0x73\ncmp    $0x2,%eax\njg     0x81\ntest   %eax,%eax\nje     0x5b\ncmp    $0x1,%eax\nje     0x65\njmp    0x81\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\njmp    0xa9\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nshr    $0x2,%rax\njmp    0xa9\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nshr    $0x2,%rax\njmp    0xa9\nlea    0x0(%rip),%rax        # 0x88\nmov    %rax,%rcx\nmov    $0x2d,%edx\nlea    0x0(%rip),%rax        # 0x97\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0xa1\nmov    %rax,%rdi\ncall   0xa9\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_5",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to an array of unsigned char pointers and another pointer to an array of unsigned char pointers\u2014along with an integer specifying the count of elements to process. It performs an in-place, element-wise exchange of the unsigned char pointer values from the two arrays for the given number of iterations. The function returns no output (void).",
        "code_id": "c_group_2_id_5",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\njmp    0x49\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nlea    0x8(%rax),%rcx\nmov    %rcx,-0x18(%rbp)\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nlea    0x8(%rax),%rcx\nmov    %rcx,-0x20(%rbp)\nmov    %rdx,(%rax)\nmov    -0x24(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x24(%rbp)\ntest   %eax,%eax\nsetg   %al\ntest   %al,%al\njne    0x15\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_122",
        "query_text": "SUMMARY: This function accepts as inputs a pointer to a conversion context structure (f_conv_context_t*), a pointer to a constant wide-character string (const wchar_t*), and a size value (size_t) representing the length of the string. Its output is an integer (int). The function begins by verifying that the available capacity in the context is sufficient to accommodate the input string (plus a terminating null wide-character). If the capacity is insufficient, it returns -1. Otherwise, it calculates the byte length required for the string (as the product of its length and the size of a wide character), copies that many bytes from the input wide-character string to the buffer described in the context, advances the internal buffer pointer by the number of bytes copied, and reduces the available capacity accordingly. Finally, it appends a terminating wide-character null to the buffer and returns the original length.",
        "code_id": "c_group_2_id_122",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rax\nadd    $0x1,%rax\ncmp    %rax,-0x38(%rbp)\njbe    0x40\nmov    $0xffffffff,%eax\njmp    0xa9\nmov    -0x38(%rbp),%rax\nshl    $0x2,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%rdx\nmov    -0x30(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x66\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rax\nsub    -0x10(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x38(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xbd\ncall   0xbd\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_79",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to a structure of type fuzz_data_t and a pointer to a pointer to an 8-bit unsigned integer (uint8_t **). It computes an offset within the data array contained in the structure by adding the structure\u2019s content_size and a single unit to the beginning address of the data array. It then assigns the computed offset address to the output pointer. Additionally, it ensures that the segment of the buffer, as determined by the path_size, is terminated with a null character. The function does not return a value.",
        "code_id": "c_group_2_id_79",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x9(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x1(%rax),%eax\nmov    %eax,%eax\nadd    $0x1,%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x5(%rax),%eax\nmov    %eax,%eax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_119",
        "query_text": "SUMMARY: This function accepts an input of type pointer to f_string_buffer_t and returns an output of type void*. It first verifies that the provided pointer is not NULL and then retrieves and returns the underlying data from the structure's union field.",
        "code_id": "c_group_2_id_119",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    0x3f\nlea    0x0(%rip),%rax        # 0x1e\nmov    %rax,%rcx\nmov    $0x20,%edx\nlea    0x0(%rip),%rax        # 0x2d\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_130",
        "query_text": "SUMMARY: This function takes as input a pointer to a structure (of type CC_RbufConf) and initializes its members. It sets a capacity field to a default value (of type size_t) and assigns three function pointer fields to standard dynamic memory allocation functions (of types that take size_t parameters and return void pointers, or take void pointers respectively). The function returns no value (void).",
        "code_id": "c_group_2_id_130",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovq   $0xa,(%rax)\nmov    -0x8(%rbp),%rax\nmov    0x0(%rip),%rdx        # 0x22\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmov    0x0(%rip),%rdx        # 0x31\nmov    %rdx,0x10(%rax)\nmov    -0x8(%rbp),%rax\nmov    0x0(%rip),%rdx        # 0x40\nmov    %rdx,0x18(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_133",
        "query_text": "SUMMARY: The function accepts two inputs of type \"const void *\" that refer to objects of type \"struct Point\" (with integer fields for coordinates) and returns an \"int\". It compares the two provided Point objects by evaluating whether both of their corresponding coordinate values are equal. If both coordinates in each Point match, the function outputs 0; otherwise, it outputs 1.",
        "code_id": "c_group_2_id_133",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%edx\nmov    -0x8(%rbp),%eax\ncmp    %eax,%edx\njne    0x3a\nmov    -0xc(%rbp),%edx\nmov    -0x4(%rbp),%eax\ncmp    %eax,%edx\nje     0x41\nmov    $0x1,%eax\njmp    0x46\nmov    $0x0,%eax\nmovzbl %al,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_132",
        "query_text": "SUMMARY: The function accepts a pointer to a CC_Rbuf structure (i.e., an object of type struct ring_buffer) as its input and returns nothing (void). It frees the memory resources associated with the ring buffer by first invoking the memory deallocation callback to release the buffer (an array of uint64_t) and then calling the same deallocation function to release the ring buffer structure itself.",
        "code_id": "c_group_2_id_132",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x38(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x20(%rax),%rax\nmov    %rax,%rdi\ncall   *%rdx\nmov    -0x8(%rbp),%rax\nmov    0x38(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   *%rdx\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_129",
        "query_text": "SUMMARY: The function accepts a pointer to a ring-buffer structure (of type CC_Rbuf*) and returns an unsigned integer (of type size_t) representing the current size value stored within the structure.",
        "code_id": "c_group_2_id_129",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_109",
        "query_text": "SUMMARY: This function accepts no parameters (input type: void) and returns a value of type wc_test_ret_t (alias for int). Its primary purpose is to validate AES-256 operations in Cipher Block Chaining (CBC) mode. The function configures encryption (and decryption, when enabled) contexts using a predetermined key and initialization vector. It then encrypts a fixed test message (sourced from established test vectors) and, if decryption is available, decrypts the resulting ciphertext. The outputs from both processes are compared against expected results to verify correctness. Multiple rounds of such tests are performed under different configurations, and error codes are returned immediately if any discrepancies or failures occur. Finally, it releases any allocated resources before returning the result.",
        "code_id": "c_group_2_id_109",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_131",
        "query_text": "SUMMARY: The function accepts two inputs\u2014a pointer to a structure representing a ring buffer (CC_Rbuf) and a 64-bit unsigned integer (uint64_t). It enqueues the provided 64-bit value into the ring buffer by storing the value at the current head position, advancing the head pointer circularly within the buffer's capacity, and, if necessary, incrementing the tail position to maintain the proper data ordering when the buffer is full. Additionally, it updates the current element count of the ring buffer (without exceeding its capacity). The function does not produce any output (void).",
        "code_id": "c_group_2_id_131",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x18(%rax),%rax\ncmp    %rax,%rdx\njne    0x4c\nmov    -0x8(%rbp),%rax\nmov    0x18(%rax),%rax\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    %rdx,%rax\nmov    $0x0,%edx\ndiv    %rcx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x18(%rax)\nmov    -0x8(%rbp),%rax\nmov    0x20(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,(%rdx)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    %rdx,%rax\nmov    $0x0,%edx\ndiv    %rcx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x10(%rax)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\ncmp    %rax,%rdx\njae    0xb7\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_128",
        "query_text": "SUMMARY: This function accepts two inputs: a pointer to a structure (of type CC_Rbuf*) that represents a ring buffer, and an integer that specifies an index. It returns a value of type uint64_t by directly accessing the element located at the provided index within the internal buffer array of the structure.",
        "code_id": "c_group_2_id_128",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x20(%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq   \nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_107",
        "query_text": "SUMMARY: This function updates a linked list of DNS_entry structures by inserting a new DNS_entry structure. It accepts two inputs: a pointer to a pointer to a DNS_entry (serving as the list head) and a pointer to a DNS_entry structure (the element to be added). Depending on compile-time conditions, the function either appends the element at the end of the list (if specific flags are defined) or prepends it to the front. The output is an integer (int) which is returned as 0, indicating the operation's successful completion.",
        "code_id": "c_group_2_id_107",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    $0x0,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_101",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a pointer to an array of unsigned char (byte), a single unsigned char (byte) value, and an integer representing the number of elements to check. It iterates over the array and performs a comparison between each element and the specified unsigned char value using a bitwise XOR operation. The result of each comparison is accumulated using a bitwise OR operation. Finally, the function returns an integer that indicates whether all elements in the array match the specified byte value (0 if they all match; a nonzero value if at least one does not).",
        "code_id": "c_group_2_id_101",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,%eax\nmov    %edx,-0x20(%rbp)\nmov    %al,-0x1c(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    0x41\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nxor    -0x1c(%rbp),%al\nmovzbl %al,%eax\nor     %eax,-0x4(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     0x24\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_104",
        "query_text": "SUMMARY: This function takes four inputs: a pointer to a structure (stats_t) containing double values for connection, receive, and transmit times, and integers for connection count, receive total, and transmit total; two constant character string pointers; and an integer indicating verbosity. It produces no return value (void). Based on the verbosity flag, the function selects one of two formatted string templates and prints a summary report to the standard output. The report includes the aggregate total of transmitted and received bytes, the number of connections, the total receive and transmit times (converted into milliseconds), calculated throughput rates in megabytes per second (derived from the byte totals and their respective times), and the connection time (both overall and as an average per connection).",
        "code_id": "c_group_2_id_104",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\nje     0x2e\nlea    0x0(%rip),%rax        # 0x28\nmov    %rax,-0x8(%rbp)\njmp    0x39\nlea    0x0(%rip),%rax        # 0x35\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x49\n\nmulsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmov    0x18(%rax),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovapd %xmm0,%xmm5\ndivsd  %xmm1,%xmm5\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x74\n\nmovapd %xmm1,%xmm4\nmulsd  %xmm0,%xmm4\nmov    -0x18(%rbp),%rax\nmov    0x20(%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x18(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0xa0\n\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0xac\n\nmovapd %xmm0,%xmm3\ndivsd  %xmm1,%xmm3\nmov    -0x18(%rbp),%rax\nmov    0x1c(%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x18(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0xd8\n\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0xe4\n\nmovapd %xmm0,%xmm2\ndivsd  %xmm1,%xmm2\nmov    -0x18(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0xfd\n\nmovapd %xmm1,%xmm6\nmulsd  %xmm0,%xmm6\nmov    -0x18(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x116\n\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rcx\nmov    -0x18(%rbp),%rax\nmov    0x18(%rax),%r8d\nmov    -0x18(%rbp),%rax\nmov    0x20(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x1c(%rax),%eax\nlea    (%rdx,%rax,1),%edi\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rsi\nmov    -0x8(%rbp),%rax\nmovapd %xmm6,%xmm1\nmovq   %rcx,%xmm0\nmov    %edi,%ecx\nmov    %rax,%rdi\nmov    $0x6,%eax\ncall   0x15c\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_100",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to a structure (of type Ciphers) that aggregates various cryptographic cipher objects, and a void pointer representing a memory heap used for dynamic allocation\u2014and returns no output (void). It conditionally deallocates memory for each distinct cryptographic cipher component stored within the input structure by calling associated freeing routines and custom deallocation functions. After releasing the resources, it sets the corresponding pointers in the structure to NULL, ensuring that no dangling references remain. For some cipher types, it also overwrites sensitive data before deallocation to enhance security.",
        "code_id": "c_group_2_id_100",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_114",
        "query_text": "SUMMARY: This function accepts two inputs of type word32 (unsigned integers) and returns an int. It evaluates whether the provided modulus length meets predefined criteria based on its value and, in conjunction, checks if the accompanying divisor length corresponds to an allowed value. Specifically, for a modulus length equal to 1024, it verifies that the divisor length is 160; for a modulus length equal to 2048, it accepts divisor lengths of either 224 or 256. If a valid pairing is found, the function returns 0; otherwise, it returns -1.",
        "code_id": "c_group_2_id_114",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmovl   $0xffffffff,-0x4(%rbp)\ncmpl   $0x400,-0x14(%rbp)\nje     0x29\ncmpl   $0x800,-0x14(%rbp)\nje     0x3b\njmp    0x5a\ncmpl   $0xa0,-0x18(%rbp)\njne    0x56\nmovl   $0x0,-0x4(%rbp)\njmp    0x56\ncmpl   $0xe0,-0x18(%rbp)\nje     0x4d\ncmpl   $0x100,-0x18(%rbp)\njne    0x59\nmovl   $0x0,-0x4(%rbp)\njmp    0x59\nnop\njmp    0x5a\nnop\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_112",
        "query_text": "SUMMARY: This function accepts three inputs \u2013 an optional pointer to a byte (unsigned char*), an integer representing an initial size, and an integer representing a block size. It calculates the number of padding bytes required to extend the initial size to a multiple of the block size. If the provided byte pointer is not null, it appends padding bytes to the data buffer, with each added byte set to the computed padding value (masked to a single byte). The function returns an integer that represents the new total length after the padding has been applied.",
        "code_id": "c_group_2_id_112",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nsub    $0x1,%eax\nand    -0x1c(%rbp),%eax\nmov    %eax,%edx\nmov    -0x20(%rbp),%eax\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     0x58\nmovl   $0x0,-0x8(%rbp)\njmp    0x50\nmov    -0x1c(%rbp),%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x4(%rbp),%edx\nmov    %dl,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     0x35\nmov    -0x1c(%rbp),%edx\nmov    -0x4(%rbp),%eax\nadd    %edx,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_102",
        "query_text": "SUMMARY: This function accepts a pointer to a structure of type Des3 as its input and returns no output (void). It first checks whether the input pointer is null, and if so, it exits immediately. When asynchronous cryptography support is enabled, it releases any associated asynchronous device context resources from the Des3 structure. Under additional conditional configurations, it clears sensitive key data within this structure by zeroing the corresponding memory areas, and may further verify that the entire structure has been securely wiped of data.",
        "code_id": "c_group_2_id_102",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_113",
        "query_text": "SUMMARY: This function operates on a modifiable character array and a constant character array. It accepts an array segment defined by an unsigned 32-bit integer offset and length, and searches within that segment for a specific substring represented by a constant character array along with its unsigned 32-bit length. If the substring is found, the function assigns its unsigned 32-bit position into a location provided by an output pointer and returns an integer value 0 indicating success; if not, it returns 1 to indicate failure.",
        "code_id": "c_group_2_id_113",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    %rcx,-0x28(%rbp)\nmov    %r8d,-0x2c(%rbp)\nmov    %r9,-0x38(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njb     0x92\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x4(%rbp)\njmp    0x87\nmov    -0x4(%rbp),%edx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    0x83\nmov    -0x2c(%rbp),%edx\nmov    -0x4(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0x6d\ntest   %eax,%eax\njne    0x83\nmov    -0x38(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rax)\nmovl   $0x0,-0x8(%rbp)\njmp    0x92\naddl   $0x1,-0x4(%rbp)\nmov    -0x20(%rbp),%eax\nsub    -0x2c(%rbp),%eax\ncmp    %eax,-0x4(%rbp)\njbe    0x39\nmov    -0x8(%rbp),%eax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_108",
        "query_text": "SUMMARY: The function accepts two parameters\u2014a generic pointer (void*) and an unsigned short integer (word16)\u2014and returns no value (void). Its primary functionality is to signal that a server component is ready to accept TCP connections. In environments where specific configuration macros are defined, it retrieves a signaling structure from the provided argument, initiates a condition check, sets an internal readiness flag and the provided port value within that structure, signals the condition to notify any waiting threads, and then completes the condition handling.",
        "code_id": "c_group_2_id_108",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %ax,-0xc(%rbp)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_110",
        "query_text": "SUMMARY: This function performs file output operations. It accepts a file stream input of type FILE*, a character array of input type const char*, and an unsigned integer of input type word32 that indicates the number of bytes to write. The function attempts to write the specified number of bytes from the given character array to the file stream. If the write operation does not complete successfully (i.e., the number of bytes written does not match the specified unsigned integer), it outputs an error message to the standard error stream and returns an integer of output type int with a value indicating failure; otherwise, it returns an integer indicating success.",
        "code_id": "c_group_2_id_110",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmov    -0x24(%rbp),%edx\nmov    -0x18(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   0x36\nmov    -0x24(%rbp),%edx\ncmp    %rdx,%rax\nsetne  %al\ntest   %al,%al\nje     0x6d\nmov    0x0(%rip),%rax        # 0x4a\nmov    %rax,%rcx\nmov    $0x10,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nmovl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_111",
        "query_text": "SUMMARY: This function accepts an integer (int) as input and returns an unsigned integer (word32) as output. It determines and provides a corresponding minimum size value based on the numeric identifier provided. Using a switch-case mechanism, it maps specific integer values (enabled by certain preprocessor definitions) to predetermined size values, and if an unrecognized identifier is given, it returns zero.",
        "code_id": "c_group_2_id_111",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_106",
        "query_text": "SUMMARY: The function takes an integer (input type: int) and returns an enumerated hash type value (output type: wc_HashType). It first initializes the return value to a special \"none\" state, indicating an error or unmatched type. Under certain build configurations (such as those for FIPS or self-test), it uses a switch statement to map specific integer constants to corresponding enumeration values, ensuring that only particular hash types (like MD5, SHA variants, SHA3, SM3, etc.) are converted. If the input does not match any defined cases, the function retains the default \"none\" value. In other configurations, it checks if the integer is within a valid range and then directly converts it to the corresponding enumerated hash type.",
        "code_id": "c_group_2_id_106",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njle    0x24\ncmpl   $0x11,-0x14(%rbp)\njg     0x24\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_105",
        "query_text": "SUMMARY: This function accepts an input parameter of type int and three output pointers each of type word32 (unsigned int). Based on the integer input, it selects one of several predefined key parameter sets and calculates the sizes (in bytes) of three components\u2014two mandatory components and an optional one when available. For each matching case in a switch statement, it assigns the corresponding size values to temporary word32 variables. If any of the provided output pointers is non-null, the function writes the computed size for that component into the location pointed to by that pointer. Finally, it returns an int value of 0, indicating successful completion.",
        "code_id": "c_group_2_id_105",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\nnop\ncmpq   $0x0,-0x20(%rbp)\nje     0x3d\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\ncmpq   $0x0,-0x28(%rbp)\nje     0x4d\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%edx\nmov    %edx,(%rax)\ncmpq   $0x0,-0x30(%rbp)\nje     0x5d\nmov    -0x30(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rax)\nmov    $0x0,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_115",
        "query_text": "SUMMARY: This function performs a self-test of AES encryption (and, if enabled, decryption) in cipher block chaining (CBC) mode using predetermined test vectors. It has no input parameters (void) and returns a 32\u2010bit integer status code (wc_test_ret_t, defined as int). Internally, it initializes AES context structures (either allocated on the heap or on the stack, depending on compile-time flags), sets up encryption (and decryption) keys along with an initialization vector, processes a fixed message by encrypting it, and verifies that the resulting ciphertext matches an expected value. Where decryption is enabled, it decrypts the ciphertext back to plaintext and confirms that it matches the original message. The function cleans up the AES contexts and returns a status code to indicate success or failure of the test.",
        "code_id": "c_group_2_id_115",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_103",
        "query_text": "SUMMARY: This function accepts five parameters: a pointer to a structure (of type stats_t) that contains numerical statistics (double values representing connection, receive, and transmit time, and integer values for connection count, receive total, and transmit total), three constant character pointers (providing informational text such as a benchmark description, a cipher identifier, and a group name), and an integer flag indicating verbosity. The function processes these inputs by calculating and formatting aggregate performance metrics, such as the total bytes (sum of transmit and receive totals), connection times converted to milliseconds, and throughput rates in megabytes per second (derived from dividing the byte totals by the corresponding timing values and applying conversions). Based on the verbosity flag, the function outputs the formatted benchmark results in either a detailed or a compact format to the standard error stream. The function does not return any value.",
        "code_id": "c_group_2_id_103",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,-0x20(%rbp)\nmov    %r8d,-0x24(%rbp)\ncmpl   $0x0,-0x24(%rbp)\nje     0x167\nmov    -0x8(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x3a\n\nmulsd  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nmov    0x18(%rax),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovapd %xmm0,%xmm5\ndivsd  %xmm1,%xmm5\nmov    -0x8(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x65\n\nmovapd %xmm1,%xmm4\nmulsd  %xmm0,%xmm4\nmov    -0x8(%rbp),%rax\nmov    0x20(%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x8(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x91\n\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x9d\n\nmovapd %xmm0,%xmm3\ndivsd  %xmm1,%xmm3\nmov    -0x8(%rbp),%rax\nmov    0x1c(%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x8(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0xc9\n\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0xd5\n\nmovapd %xmm0,%xmm2\ndivsd  %xmm1,%xmm2\nmov    -0x8(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0xee\n\nmovapd %xmm1,%xmm6\nmulsd  %xmm0,%xmm6\nmov    -0x8(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x107\n\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rsi\nmov    -0x8(%rbp),%rax\nmov    0x18(%rax),%edi\nmov    -0x8(%rbp),%rax\nmov    0x20(%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    0x1c(%rax),%eax\nlea    (%rdx,%rax,1),%r9d\nmov    0x0(%rip),%rax        # 0x130\nmov    -0x20(%rbp),%r8\nmov    -0x18(%rbp),%rcx\nmov    -0x10(%rbp),%rdx\nsub    $0x8,%rsp\npush   %rdi\nmovapd %xmm6,%xmm1\nmovq   %rsi,%xmm0\nlea    0x0(%rip),%rsi        # 0x151\nmov    %rax,%rdi\nmov    $0x6,%eax\ncall   0x15e\nadd    $0x10,%rsp\njmp    0x29f\nmov    -0x8(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x177\n\nmulsd  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nmov    0x18(%rax),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovapd %xmm0,%xmm5\ndivsd  %xmm1,%xmm5\nmov    -0x8(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x1a2\n\nmovapd %xmm1,%xmm4\nmulsd  %xmm0,%xmm4\nmov    -0x8(%rbp),%rax\nmov    0x20(%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x8(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x1ce\n\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x1da\n\nmovapd %xmm0,%xmm3\ndivsd  %xmm1,%xmm3\nmov    -0x8(%rbp),%rax\nmov    0x1c(%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x8(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x206\n\ndivsd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x212\n\nmovapd %xmm0,%xmm2\ndivsd  %xmm1,%xmm2\nmov    -0x8(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x22b\n\nmovapd %xmm1,%xmm6\nmulsd  %xmm0,%xmm6\nmov    -0x8(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x244\n\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rsi\nmov    -0x8(%rbp),%rax\nmov    0x18(%rax),%edi\nmov    -0x8(%rbp),%rax\nmov    0x20(%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    0x1c(%rax),%eax\nlea    (%rdx,%rax,1),%r9d\nmov    0x0(%rip),%rax        # 0x26d\nmov    -0x20(%rbp),%r8\nmov    -0x18(%rbp),%rcx\nmov    -0x10(%rbp),%rdx\nsub    $0x8,%rsp\npush   %rdi\nmovapd %xmm6,%xmm1\nmovq   %rsi,%xmm0\nlea    0x0(%rip),%rsi        # 0x28e\nmov    %rax,%rdi\nmov    $0x6,%eax\ncall   0x29b\nadd    $0x10,%rsp\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_126",
        "query_text": "SUMMARY: This function takes an input of type utf8_int32_t (a 32-bit integer) representing a Unicode code point and returns an integer indicating the display width. It first checks whether the code point is zero and returns 0 in that case. If the code point is less than a specified threshold (0x1100), it returns 1. It then examines whether the code point falls within specific ranges for fullwidth characters\u2014returning 2 if so\u2014and likewise tests a number of ranges commonly associated with wide characters, also returning 2 for matches. If none of these conditions apply, it defaults to returning 1.",
        "code_id": "c_group_2_id_126",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    0x1b\nmov    $0x0,%eax\njmp    0x395\ncmpl   $0x10ff,-0x4(%rbp)\njg     0x2e\nmov    $0x1,%eax\njmp    0x395\ncmpl   $0x3000,-0x4(%rbp)\nje     0x5b\ncmpl   $0xff00,-0x4(%rbp)\njle    0x49\ncmpl   $0xff60,-0x4(%rbp)\njle    0x5b\ncmpl   $0xffdf,-0x4(%rbp)\njle    0x65\ncmpl   $0xffe6,-0x4(%rbp)\njg     0x65\nmov    $0x2,%eax\njmp    0x395\ncmpl   $0x10ff,-0x4(%rbp)\njle    0x7b\ncmpl   $0x115f,-0x4(%rbp)\njle    0x389\ncmpl   $0x11a2,-0x4(%rbp)\njle    0x91\ncmpl   $0x11a7,-0x4(%rbp)\njle    0x389\ncmpl   $0x11f9,-0x4(%rbp)\njle    0xa7\ncmpl   $0x11ff,-0x4(%rbp)\njle    0x389\ncmpl   $0x2328,-0x4(%rbp)\njle    0xbd\ncmpl   $0x232a,-0x4(%rbp)\njle    0x389\ncmpl   $0x2e7f,-0x4(%rbp)\njle    0xd3\ncmpl   $0x2e99,-0x4(%rbp)\njle    0x389\ncmpl   $0x2e9a,-0x4(%rbp)\njle    0xe9\ncmpl   $0x2ef3,-0x4(%rbp)\njle    0x389\ncmpl   $0x2eff,-0x4(%rbp)\njle    0xff\ncmpl   $0x2fd5,-0x4(%rbp)\njle    0x389\ncmpl   $0x2fef,-0x4(%rbp)\njle    0x115\ncmpl   $0x2ffb,-0x4(%rbp)\njle    0x389\ncmpl   $0x3000,-0x4(%rbp)\njle    0x12b\ncmpl   $0x303e,-0x4(%rbp)\njle    0x389\ncmpl   $0x3040,-0x4(%rbp)\njle    0x141\ncmpl   $0x3096,-0x4(%rbp)\njle    0x389\ncmpl   $0x3098,-0x4(%rbp)\njle    0x157\ncmpl   $0x30ff,-0x4(%rbp)\njle    0x389\ncmpl   $0x3104,-0x4(%rbp)\njle    0x16d\ncmpl   $0x312d,-0x4(%rbp)\njle    0x389\ncmpl   $0x3130,-0x4(%rbp)\njle    0x183\ncmpl   $0x318e,-0x4(%rbp)\njle    0x389\ncmpl   $0x318f,-0x4(%rbp)\njle    0x199\ncmpl   $0x31ba,-0x4(%rbp)\njle    0x389\ncmpl   $0x31bf,-0x4(%rbp)\njle    0x1af\ncmpl   $0x31e3,-0x4(%rbp)\njle    0x389\ncmpl   $0x31ef,-0x4(%rbp)\njle    0x1c5\ncmpl   $0x321e,-0x4(%rbp)\njle    0x389\ncmpl   $0x321f,-0x4(%rbp)\njle    0x1db\ncmpl   $0x3247,-0x4(%rbp)\njle    0x389\ncmpl   $0x324f,-0x4(%rbp)\njle    0x1f1\ncmpl   $0x32fe,-0x4(%rbp)\njle    0x389\ncmpl   $0x32ff,-0x4(%rbp)\njle    0x207\ncmpl   $0x4dbf,-0x4(%rbp)\njle    0x389\ncmpl   $0x4dff,-0x4(%rbp)\njle    0x21d\ncmpl   $0xa48c,-0x4(%rbp)\njle    0x389\ncmpl   $0xa48f,-0x4(%rbp)\njle    0x233\ncmpl   $0xa4c6,-0x4(%rbp)\njle    0x389\ncmpl   $0xa95f,-0x4(%rbp)\njle    0x249\ncmpl   $0xa97c,-0x4(%rbp)\njle    0x389\ncmpl   $0xabff,-0x4(%rbp)\njle    0x25f\ncmpl   $0xd7a3,-0x4(%rbp)\njle    0x389\ncmpl   $0xd7af,-0x4(%rbp)\njle    0x275\ncmpl   $0xd7c6,-0x4(%rbp)\njle    0x389\ncmpl   $0xd7ca,-0x4(%rbp)\njle    0x28b\ncmpl   $0xd7fb,-0x4(%rbp)\njle    0x389\ncmpl   $0xf8ff,-0x4(%rbp)\njle    0x2a1\ncmpl   $0xfaff,-0x4(%rbp)\njle    0x389\ncmpl   $0xfe0f,-0x4(%rbp)\njle    0x2b7\ncmpl   $0xfe19,-0x4(%rbp)\njle    0x389\ncmpl   $0xfe2f,-0x4(%rbp)\njle    0x2cd\ncmpl   $0xfe52,-0x4(%rbp)\njle    0x389\ncmpl   $0xfe53,-0x4(%rbp)\njle    0x2e3\ncmpl   $0xfe66,-0x4(%rbp)\njle    0x389\ncmpl   $0xfe67,-0x4(%rbp)\njle    0x2f9\ncmpl   $0xfe6b,-0x4(%rbp)\njle    0x389\ncmpl   $0x1afff,-0x4(%rbp)\njle    0x30b\ncmpl   $0x1b001,-0x4(%rbp)\njle    0x389\ncmpl   $0x1f1ff,-0x4(%rbp)\njle    0x31d\ncmpl   $0x1f202,-0x4(%rbp)\njle    0x389\ncmpl   $0x1f20f,-0x4(%rbp)\njle    0x32f\ncmpl   $0x1f23a,-0x4(%rbp)\njle    0x389\ncmpl   $0x1f23f,-0x4(%rbp)\njle    0x341\ncmpl   $0x1f248,-0x4(%rbp)\njle    0x389\ncmpl   $0x1f24f,-0x4(%rbp)\njle    0x353\ncmpl   $0x1f251,-0x4(%rbp)\njle    0x389\ncmpl   $0x1ffff,-0x4(%rbp)\njle    0x365\ncmpl   $0x2f73f,-0x4(%rbp)\njle    0x389\ncmpl   $0x2b73f,-0x4(%rbp)\njle    0x377\ncmpl   $0x2fffd,-0x4(%rbp)\njle    0x389\ncmpl   $0x2ffff,-0x4(%rbp)\njle    0x390\ncmpl   $0x3fffd,-0x4(%rbp)\njg     0x390\nmov    $0x2,%eax\njmp    0x395\nmov    $0x1,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_117",
        "query_text": "SUMMARY: This function accepts a 32-bit signed integer (utf8_int32_t) representing a Unicode code point and returns another 32-bit signed integer (utf8_int32_t) corresponding to its uppercase equivalent. It determines whether the input is within particular ranges that follow systematic uppercase transformations\u2014either by subtracting a constant value or by altering specific bits\u2014to perform the conversion efficiently. If the input does not fall into these ranges, the function applies an explicit mapping via a switch statement to convert individual code points to their uppercase forms.",
        "code_id": "c_group_2_id_117",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x60,-0x4(%rbp)\njle    0x17\ncmpl   $0x7a,-0x4(%rbp)\njle    0x5f\ncmpl   $0xdf,-0x4(%rbp)\njle    0x29\ncmpl   $0xf6,-0x4(%rbp)\njle    0x5f\ncmpl   $0xf7,-0x4(%rbp)\njle    0x3b\ncmpl   $0xfe,-0x4(%rbp)\njle    0x5f\ncmpl   $0x3b0,-0x4(%rbp)\njle    0x4d\ncmpl   $0x3c1,-0x4(%rbp)\njle    0x5f\ncmpl   $0x3c2,-0x4(%rbp)\njle    0x68\ncmpl   $0x3cb,-0x4(%rbp)\njg     0x68\nsubl   $0x20,-0x4(%rbp)\njmp    0x467\ncmpl   $0xff,-0x4(%rbp)\njle    0x7e\ncmpl   $0x12f,-0x4(%rbp)\njle    0x124\ncmpl   $0x131,-0x4(%rbp)\njle    0x94\ncmpl   $0x137,-0x4(%rbp)\njle    0x124\ncmpl   $0x149,-0x4(%rbp)\njle    0xa6\ncmpl   $0x177,-0x4(%rbp)\njle    0x124\ncmpl   $0x181,-0x4(%rbp)\njle    0xb8\ncmpl   $0x185,-0x4(%rbp)\njle    0x124\ncmpl   $0x19f,-0x4(%rbp)\njle    0xca\ncmpl   $0x1a5,-0x4(%rbp)\njle    0x124\ncmpl   $0x1dd,-0x4(%rbp)\njle    0xdc\ncmpl   $0x1ef,-0x4(%rbp)\njle    0x124\ncmpl   $0x1f7,-0x4(%rbp)\njle    0xee\ncmpl   $0x21f,-0x4(%rbp)\njle    0x124\ncmpl   $0x221,-0x4(%rbp)\njle    0x100\ncmpl   $0x233,-0x4(%rbp)\njle    0x124\ncmpl   $0x245,-0x4(%rbp)\njle    0x112\ncmpl   $0x24f,-0x4(%rbp)\njle    0x124\ncmpl   $0x3d7,-0x4(%rbp)\njle    0x12d\ncmpl   $0x3ef,-0x4(%rbp)\njg     0x12d\nandl   $0xfffffffe,-0x4(%rbp)\njmp    0x467\ncmpl   $0x138,-0x4(%rbp)\njle    0x13f\ncmpl   $0x148,-0x4(%rbp)\njle    0x187\ncmpl   $0x178,-0x4(%rbp)\njle    0x151\ncmpl   $0x17e,-0x4(%rbp)\njle    0x187\ncmpl   $0x1ae,-0x4(%rbp)\njle    0x163\ncmpl   $0x1b0,-0x4(%rbp)\njle    0x187\ncmpl   $0x1b2,-0x4(%rbp)\njle    0x175\ncmpl   $0x1b6,-0x4(%rbp)\njle    0x187\ncmpl   $0x1cc,-0x4(%rbp)\njle    0x194\ncmpl   $0x1dc,-0x4(%rbp)\njg     0x194\nsubl   $0x1,-0x4(%rbp)\norl    $0x1,-0x4(%rbp)\njmp    0x467\ncmpl   $0x3fb,-0x4(%rbp)\njg     0x466\ncmpl   $0x371,-0x4(%rbp)\njge    0x231\ncmpl   $0x292,-0x4(%rbp)\nje     0x2d7\ncmpl   $0x292,-0x4(%rbp)\njg     0x466\ncmpl   $0x242,-0x4(%rbp)\nje     0x3a3\ncmpl   $0x242,-0x4(%rbp)\njg     0x466\ncmpl   $0x23c,-0x4(%rbp)\nje     0x397\ncmpl   $0x23c,-0x4(%rbp)\njg     0x466\ncmpl   $0xff,-0x4(%rbp)\nje     0x29b\ncmpl   $0xff,-0x4(%rbp)\njl     0x466\ncmpl   $0x1f5,-0x4(%rbp)\njg     0x466\ncmpl   $0x180,-0x4(%rbp)\njge    0x267\njmp    0x466\nmov    -0x4(%rbp),%eax\nsub    $0x371,%eax\ncmp    $0x8a,%eax\nja     0x466\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x255\nmov    (%rdx,%rax,1),%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0x261\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x4(%rbp),%eax\nsub    $0x180,%eax\ncmp    $0x75,%eax\nja     0x466\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x289\nmov    (%rdx,%rax,1),%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0x295\nadd    %rdx,%rax\nnotrack jmp *%rax\nmovl   $0x178,-0x4(%rbp)\njmp    0x467\nmovl   $0x243,-0x4(%rbp)\njmp    0x467\nmovl   $0x18e,-0x4(%rbp)\njmp    0x467\nmovl   $0x23d,-0x4(%rbp)\njmp    0x467\nmovl   $0x220,-0x4(%rbp)\njmp    0x467\nmovl   $0x1b7,-0x4(%rbp)\njmp    0x467\nmovl   $0x1c4,-0x4(%rbp)\njmp    0x467\nmovl   $0x1c7,-0x4(%rbp)\njmp    0x467\nmovl   $0x1ca,-0x4(%rbp)\njmp    0x467\nmovl   $0x1f1,-0x4(%rbp)\njmp    0x467\nmovl   $0x1f7,-0x4(%rbp)\njmp    0x467\nmovl   $0x187,-0x4(%rbp)\njmp    0x467\nmovl   $0x18b,-0x4(%rbp)\njmp    0x467\nmovl   $0x191,-0x4(%rbp)\njmp    0x467\nmovl   $0x198,-0x4(%rbp)\njmp    0x467\nmovl   $0x1a7,-0x4(%rbp)\njmp    0x467\nmovl   $0x1ac,-0x4(%rbp)\njmp    0x467\nmovl   $0x1af,-0x4(%rbp)\njmp    0x467\nmovl   $0x1b8,-0x4(%rbp)\njmp    0x467\nmovl   $0x1bc,-0x4(%rbp)\njmp    0x467\nmovl   $0x1f4,-0x4(%rbp)\njmp    0x467\nmovl   $0x23b,-0x4(%rbp)\njmp    0x467\nmovl   $0x241,-0x4(%rbp)\njmp    0x467\nmovl   $0x3fd,-0x4(%rbp)\njmp    0x467\nmovl   $0x3fe,-0x4(%rbp)\njmp    0x467\nmovl   $0x3ff,-0x4(%rbp)\njmp    0x467\nmovl   $0x37f,-0x4(%rbp)\njmp    0x467\nmovl   $0x386,-0x4(%rbp)\njmp    0x467\nmovl   $0x388,-0x4(%rbp)\njmp    0x467\nmovl   $0x389,-0x4(%rbp)\njmp    0x467\nmovl   $0x38a,-0x4(%rbp)\njmp    0x467\nmovl   $0x38c,-0x4(%rbp)\njmp    0x467\nmovl   $0x38e,-0x4(%rbp)\njmp    0x467\nmovl   $0x38f,-0x4(%rbp)\njmp    0x467\nmovl   $0x370,-0x4(%rbp)\njmp    0x467\nmovl   $0x372,-0x4(%rbp)\njmp    0x467\nmovl   $0x376,-0x4(%rbp)\njmp    0x467\nmovl   $0x3f4,-0x4(%rbp)\njmp    0x467\nmovl   $0x3cf,-0x4(%rbp)\njmp    0x467\nmovl   $0x3f9,-0x4(%rbp)\njmp    0x467\nmovl   $0x3f7,-0x4(%rbp)\njmp    0x467\nmovl   $0x3fa,-0x4(%rbp)\njmp    0x467\nnop\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_68",
        "query_text": "SUMMARY: This inline function accepts an input of type configor::token_type (an enumeration) and returns a constant character pointer as output. It maps each enumerated token type to a corresponding string literal, providing a human-readable representation of that token type. If the input does not match any predefined enumeration value, the function returns a default string literal indicating an unknown value.",
        "code_id": "c_group_2_id_68",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0xd,-0x4(%rbp)\nja     0xb7\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x27\nmov    (%rdx,%rax,1),%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0x33\nadd    %rdx,%rax\nnotrack jmp *%rax\nlea    0x0(%rip),%rax        # 0x40\njmp    0xbe\nlea    0x0(%rip),%rax        # 0x49\njmp    0xbe\nlea    0x0(%rip),%rax        # 0x52\njmp    0xbe\nlea    0x0(%rip),%rax        # 0x5b\njmp    0xbe\nlea    0x0(%rip),%rax        # 0x64\njmp    0xbe\nlea    0x0(%rip),%rax        # 0x6d\njmp    0xbe\nlea    0x0(%rip),%rax        # 0x76\njmp    0xbe\nlea    0x0(%rip),%rax        # 0x7f\njmp    0xbe\nlea    0x0(%rip),%rax        # 0x88\njmp    0xbe\nlea    0x0(%rip),%rax        # 0x91\njmp    0xbe\nlea    0x0(%rip),%rax        # 0x9a\njmp    0xbe\nlea    0x0(%rip),%rax        # 0xa3\njmp    0xbe\nlea    0x0(%rip),%rax        # 0xac\njmp    0xbe\nlea    0x0(%rip),%rax        # 0xb5\njmp    0xbe\nlea    0x0(%rip),%rax        # 0xbe\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_7",
        "query_text": "SUMMARY: The function accepts three inputs: a pointer to a structure (of type cacheblock_t), and two size_t values representing the number of elements and an offset depth. For each element in the given array of structures, it sequentially copies up to a fixed number of unsigned characters from an associated memory location (starting at the specified depth) into an internal fixed-size array within the structure. The copying continues until it either reaches the maximum number of bytes or encounters a zero byte; any remaining positions in the array are then filled with zero. The function does not return any value, instead modifying the data in-place.",
        "code_id": "c_group_2_id_7",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovq   $0x0,-0x8(%rbp)\n\njmp    0xc6\nmovl   $0x0,-0xc(%rbp)\njmp    0x6c\nmov    -0x8(%rbp),%rax\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rax\nmov    -0xc(%rbp),%ecx\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nadd    %rdx,%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,%rcx\nshl    $0x4,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rdx,%rcx\nmovzbl (%rax),%edx\nmov    -0xc(%rbp),%eax\nmov    %dl,(%rcx,%rax,1)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x3,-0xc(%rbp)\nja     0xbb\nmov    -0x8(%rbp),%rax\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rax\nmov    -0xc(%rbp),%ecx\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x2a\njmp    0xbb\nmov    -0x8(%rbp),%rax\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmovb   $0x0,(%rdx,%rax,1)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x3,-0xc(%rbp)\njbe    0x9e\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     0x21\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_34",
        "query_text": "SUMMARY: This function accepts an input of type pugi::xml_parse_status and an optional input of type ptrdiff_t (defaulting to 0). It then creates an object of type pugi::xml_parse_result, assigns the provided pugi::xml_parse_status to its status field and the provided ptrdiff_t value to its offset field, and finally returns the constructed pugi::xml_parse_result object.",
        "code_id": "c_group_2_id_34",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x23\nmov    -0x8(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nnop\nmov    -0x8(%rbp),%rax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_8",
        "query_text": "SUMMARY: This function takes as input two constant pointers to unsigned char and a reference to an integer (Lcp) and returns an integer. It performs a lexicographic comparison of the two byte sequences starting from the offset given by the integer reference. The function increments the integer while the corresponding bytes in the sequences match and the byte in the first sequence is nonzero. It then returns the integer difference between the first pair of mismatching bytes.",
        "code_id": "c_group_2_id_8",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\njmp    0x25\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    0x66\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x16\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_6",
        "query_text": "SUMMARY: This function performs an in-place sort on an array of elements of type cacheblock_t. It accepts three inputs: a pointer to the first element in the array of cacheblock_t, an integer representing the number of elements, and a size_t value representing an offset (depth) into each element\u2019s data pointer. For each element starting from the second in the array, the function compares two cacheblock_t elements by walking through their associated unsigned char data beginning at the specified offset until a difference (or a null terminator) is encountered. Based on these comparisons, it shifts elements to arrange the array in ascending order. The function returns no output (void) and directly modifies the input array.",
        "code_id": "c_group_2_id_6",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmov    %rax,-0x28(%rbp)\njmp    0xd6\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x20(%rbp)\njmp    0xb4\nmov    -0x8(%rbp),%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nsub    $0x10,%rax\nmov    0x8(%rax),%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x18(%rbp)\njmp    0x6c\naddq   $0x1,-0x18(%rbp)\naddq   $0x1,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    0x89\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x62\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njbe    0xc4\nmov    -0x20(%rbp),%rax\nsub    $0x10,%rax\nmov    0x8(%rax),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,0x8(%rax)\nsubq   $0x10,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nja     0x3a\njmp    0xc5\nnop\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x8(%rax)\naddq   $0x10,-0x28(%rbp)\nsubl   $0x1,-0x3c(%rbp)\ncmpl   $0x0,-0x3c(%rbp)\nsetg   %al\ntest   %al,%al\njne    0x24\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_15",
        "query_text": "SUMMARY: This function accepts a value of type uint128_t (an unsigned 128\u2010bit integer) and returns a uint32_t (an unsigned 32\u2010bit integer). It evaluates how many consecutive times the input number can be evenly divided by 5 and outputs that count. The function iteratively checks if the current value is divisible by 5; when it is, the value is divided by 5 and a counter is incremented. If at any point the value is not divisible by 5, the function immediately returns the count accumulated so far.",
        "code_id": "c_group_2_id_15",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,%rax\nmov    %rsi,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    0x92\nmov    -0x30(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    $0x5,%edx\nmov    $0x0,%ecx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   0x50\nor     %rdx,%rax\ntest   %rax,%rax\nje     0x5d\nmov    -0x14(%rbp),%eax\njmp    0xa4\nmov    -0x30(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    $0x5,%edx\nmov    $0x0,%ecx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   0x86\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nor     -0x30(%rbp),%rax\ntest   %rax,%rax\njne    0x27\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_18",
        "query_text": "SUMMARY: This function accepts as input a pointer to constant 64\u2010bit unsigned integers representing a 128-bit unsigned integer, a pointer to constant 64\u2010bit unsigned integers representing a 256-bit unsigned integer, and two 32-bit unsigned integers (one used as a bit-shift amount and the other as a correction factor). It computes the product of the 128-bit and 256-bit values (forming an extended precision result), extracts a 256-bit segment of that product by effectively shifting it by the specified number of bits, and incorporates the correction factor with proper carry handling. The final 256-bit result is output by writing four 64-bit unsigned integers to the provided result array.",
        "code_id": "c_group_2_id_18",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x378,%rsp\nmov    %rdi,-0x1f8(%rbp)\nmov    %rsi,-0x200(%rbp)\nmov    %edx,-0x204(%rbp)\nmov    %ecx,-0x208(%rbp)\nmov    %r8,-0x210(%rbp)\ncmpl   $0x0,-0x204(%rbp)\njne    0x6a\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rcx\nmov    $0xb,%edx\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdi\ncall   0x6a\ncmpl   $0xff,-0x204(%rbp)\n\njbe    0x9e\nlea    0x0(%rip),%rax        # 0x7d\nmov    %rax,%rcx\nmov    $0xc,%edx\nlea    0x0(%rip),%rax        # 0x8c\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x96\nmov    %rax,%rdi\ncall   0x9e\nmov    -0x1f8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%r12\nmov    $0x0,%r13d\nmov    -0x200(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%r10\nmov    $0x0,%r11d\nmov    %r13,%rdx\nimul   %r10,%rdx\nmov    %r11,%rax\nimul   %r12,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %r12,%rax\nmul    %r10\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x1f0(%rbp)\nmov    %rdx,-0x1e8(%rbp)\nmov    %rax,-0x1f0(%rbp)\nmov    %rdx,-0x1e8(%rbp)\nmov    -0x1f8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x220(%rbp)\nmovq   $0x0,-0x218(%rbp)\n\nmov    -0x200(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,%r14\nmov    $0x0,%r15d\nmov    -0x220(%rbp),%rbx\nmov    -0x218(%rbp),%rsi\nmov    %rsi,%rdx\nimul   %r14,%rdx\nmov    %rbx,%rax\nimul   %r15,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %rbx,%rax\nmul    %r14\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x1e0(%rbp)\nmov    %rdx,-0x1d8(%rbp)\nmov    %rax,-0x1e0(%rbp)\nmov    %rdx,-0x1d8(%rbp)\nmov    -0x1f8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x230(%rbp)\nmovq   $0x0,-0x228(%rbp)\n\nmov    -0x200(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nmov    %rax,-0x240(%rbp)\nmovq   $0x0,-0x238(%rbp)\n\nmov    -0x230(%rbp),%rbx\nmov    -0x228(%rbp),%rsi\nmov    %rsi,%rdx\nmov    -0x240(%rbp),%r8\nmov    -0x238(%rbp),%r9\nimul   %r8,%rdx\nmov    %r9,%rax\nimul   %rbx,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %rbx,%rax\nmul    %r8\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x1d0(%rbp)\nmov    %rdx,-0x1c8(%rbp)\nmov    %rax,-0x1d0(%rbp)\nmov    %rdx,-0x1c8(%rbp)\nmov    -0x1f8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x250(%rbp)\nmovq   $0x0,-0x248(%rbp)\n\nmov    -0x200(%rbp),%rax\nadd    $0x18,%rax\nmov    (%rax),%rax\nmov    %rax,-0x260(%rbp)\nmovq   $0x0,-0x258(%rbp)\n\nmov    -0x250(%rbp),%rbx\nmov    -0x248(%rbp),%rsi\nmov    %rsi,%rdx\nmov    -0x260(%rbp),%r11\nmov    -0x258(%rbp),%r12\nimul   %r11,%rdx\nmov    %r12,%rax\nimul   %rbx,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %rbx,%rax\nmul    %r11\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x1c0(%rbp)\nmov    %rdx,-0x1b8(%rbp)\nmov    %rax,-0x1c0(%rbp)\nmov    %rdx,-0x1b8(%rbp)\nmov    -0x1f8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,-0x270(%rbp)\nmovq   $0x0,-0x268(%rbp)\n\nmov    -0x200(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x280(%rbp)\nmovq   $0x0,-0x278(%rbp)\n\nmov    -0x270(%rbp),%rbx\nmov    -0x268(%rbp),%rsi\nmov    %rsi,%rdx\nmov    -0x280(%rbp),%r14\nmov    -0x278(%rbp),%r15\nimul   %r14,%rdx\nmov    %r15,%rax\nimul   %rbx,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %rbx,%rax\nmul    %r14\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x1b0(%rbp)\nmov    %rdx,-0x1a8(%rbp)\nmov    %rax,-0x1b0(%rbp)\nmov    %rdx,-0x1a8(%rbp)\nmov    -0x1f8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,-0x290(%rbp)\nmovq   $0x0,-0x288(%rbp)\n\nmov    -0x200(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,-0x2a0(%rbp)\nmovq   $0x0,-0x298(%rbp)\n\nmov    -0x290(%rbp),%rbx\nmov    -0x288(%rbp),%rsi\nmov    %rsi,%rdx\nmov    -0x2a0(%rbp),%r8\nmov    -0x298(%rbp),%r9\nimul   %r8,%rdx\nmov    %r9,%rax\nimul   %rbx,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %rbx,%rax\nmul    %r8\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x1a0(%rbp)\nmov    %rdx,-0x198(%rbp)\nmov    %rax,-0x1a0(%rbp)\nmov    %rdx,-0x198(%rbp)\nmov    -0x1f8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,-0x2b0(%rbp)\nmovq   $0x0,-0x2a8(%rbp)\n\nmov    -0x200(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nmov    %rax,-0x2c0(%rbp)\nmovq   $0x0,-0x2b8(%rbp)\n\nmov    -0x2b0(%rbp),%rbx\nmov    -0x2a8(%rbp),%rsi\nmov    %rsi,%rdx\nmov    -0x2c0(%rbp),%r11\nmov    -0x2b8(%rbp),%r12\nimul   %r11,%rdx\nmov    %r12,%rax\nimul   %rbx,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %rbx,%rax\nmul    %r11\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x190(%rbp)\nmov    %rdx,-0x188(%rbp)\nmov    %rax,-0x190(%rbp)\nmov    %rdx,-0x188(%rbp)\nmov    -0x1f8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,-0x2d0(%rbp)\nmovq   $0x0,-0x2c8(%rbp)\n\nmov    -0x200(%rbp),%rax\nadd    $0x18,%rax\nmov    (%rax),%rax\nmov    %rax,-0x2e0(%rbp)\nmovq   $0x0,-0x2d8(%rbp)\n\nmov    -0x2d0(%rbp),%rbx\nmov    -0x2c8(%rbp),%rsi\nmov    %rsi,%rdx\nmov    -0x2e0(%rbp),%r9\nmov    -0x2d8(%rbp),%r10\nimul   %r9,%rdx\nmov    %r10,%rax\nimul   %rbx,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %rbx,%rax\nmul    %r9\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x180(%rbp)\nmov    %rdx,-0x178(%rbp)\nmov    %rax,-0x180(%rbp)\nmov    %rdx,-0x178(%rbp)\nmov    -0x1f0(%rbp),%rax\nmov    -0x1e8(%rbp),%rdx\nmov    %rax,-0x170(%rbp)\nmov    %rdx,-0x168(%rbp)\nmov    -0x1e0(%rbp),%rcx\nmov    -0x1d8(%rbp),%rbx\nmov    -0x1b0(%rbp),%rax\nmov    -0x1a8(%rbp),%rdx\nadd    %rcx,%rax\nadc    %rbx,%rdx\nmov    %rax,-0x160(%rbp)\nmov    %rdx,-0x158(%rbp)\nmov    $0x1,%ecx\nmov    -0x160(%rbp),%rax\nmov    -0x158(%rbp),%rdx\ncmp    -0x1e0(%rbp),%rax\nmov    %rdx,%rax\nsbb    -0x1d8(%rbp),%rax\njb     0x568\nmov    $0x0,%ecx\nmovzbl %cl,%eax\nmov    %rax,-0x150(%rbp)\nmovq   $0x0,-0x148(%rbp)\n\nmov    -0x1d0(%rbp),%rcx\nmov    -0x1c8(%rbp),%rbx\nmov    -0x1a0(%rbp),%rax\nmov    -0x198(%rbp),%rdx\nadd    %rcx,%rax\nadc    %rbx,%rdx\nmov    %rax,-0x140(%rbp)\nmov    %rdx,-0x138(%rbp)\nmov    $0x1,%ecx\nmov    -0x140(%rbp),%rax\nmov    -0x138(%rbp),%rdx\ncmp    -0x1d0(%rbp),%rax\nmov    %rdx,%rax\nsbb    -0x1c8(%rbp),%rax\njb     0x5d8\nmov    $0x0,%ecx\nmovzbl %cl,%eax\nmov    %rax,-0x130(%rbp)\nmovq   $0x0,-0x128(%rbp)\n\nmov    -0x1c0(%rbp),%rcx\nmov    -0x1b8(%rbp),%rbx\nmov    -0x190(%rbp),%rax\nmov    -0x188(%rbp),%rdx\nadd    %rcx,%rax\nadc    %rbx,%rdx\nmov    %rax,-0x120(%rbp)\nmov    %rdx,-0x118(%rbp)\nmov    $0x1,%ecx\nmov    -0x120(%rbp),%rax\nmov    -0x118(%rbp),%rdx\ncmp    -0x1c0(%rbp),%rax\nmov    %rdx,%rax\nsbb    -0x1b8(%rbp),%rax\njb     0x648\nmov    $0x0,%ecx\nmovzbl %cl,%eax\nmov    %rax,-0x110(%rbp)\nmovq   $0x0,-0x108(%rbp)\n\nmov    -0x160(%rbp),%rax\nmov    -0x158(%rbp),%rdx\nmov    %rax,%rdx\nmov    $0x0,%eax\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    -0x170(%rbp),%rax\nmov    -0x168(%rbp),%rdx\nadd    %rcx,%rax\nadc    %rbx,%rdx\nmov    %rax,-0x100(%rbp)\nmov    %rdx,-0xf8(%rbp)\nmov    $0x1,%ecx\nmov    -0x100(%rbp),%rax\nmov    -0xf8(%rbp),%rdx\ncmp    -0x1f0(%rbp),%rax\nmov    %rdx,%rax\nsbb    -0x1e8(%rbp),%rax\njb     0x6c6\nmov    $0x0,%ecx\nmovzbl %cl,%eax\nmov    %rax,-0xf0(%rbp)\nmovq   $0x0,-0xe8(%rbp)\n\nmov    -0x160(%rbp),%rax\nmov    -0x158(%rbp),%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    -0x140(%rbp),%rax\nmov    -0x138(%rbp),%rdx\nadd    %rax,%rcx\nadc    %rdx,%rbx\nmov    -0x120(%rbp),%rax\nmov    -0x118(%rbp),%rdx\nmov    %rax,%rdx\nmov    $0x0,%eax\nadd    %rcx,%rax\nadc    %rbx,%rdx\nmov    %rax,-0xe0(%rbp)\nmov    %rdx,-0xd8(%rbp)\nmov    $0x1,%ecx\nmov    -0xe0(%rbp),%rax\nmov    -0xd8(%rbp),%rdx\ncmp    -0x140(%rbp),%rax\nmov    %rdx,%rax\nsbb    -0x138(%rbp),%rax\njb     0x75d\nmov    $0x0,%ecx\nmovzbl %cl,%eax\nmov    %rax,-0xd0(%rbp)\nmovq   $0x0,-0xc8(%rbp)\n\nmov    -0x150(%rbp),%rax\nmov    -0x148(%rbp),%rdx\nmov    %rax,%rdx\nmov    $0x0,%eax\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    -0xe0(%rbp),%rax\nmov    -0xd8(%rbp),%rdx\nadd    %rax,%rcx\nadc    %rdx,%rbx\nmov    -0xf0(%rbp),%rax\nmov    -0xe8(%rbp),%rdx\nadd    %rcx,%rax\nadc    %rbx,%rdx\nmov    %rax,-0xc0(%rbp)\nmov    %rdx,-0xb8(%rbp)\nmov    $0x1,%ecx\nmov    -0xc0(%rbp),%rax\nmov    -0xb8(%rbp),%rdx\ncmp    -0xe0(%rbp),%rax\nmov    %rdx,%rax\nsbb    -0xd8(%rbp),%rax\njb     0x7ef\nmov    $0x0,%ecx\nmovzbl %cl,%eax\nmov    %rax,-0xb0(%rbp)\nmovq   $0x0,-0xa8(%rbp)\n\nmov    -0x120(%rbp),%rax\nmov    -0x118(%rbp),%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    -0x180(%rbp),%rax\nmov    -0x178(%rbp),%rdx\nadd    %rax,%rcx\nadc    %rdx,%rbx\nmov    -0x130(%rbp),%rax\nmov    -0x128(%rbp),%rdx\nadd    %rax,%rcx\nadc    %rdx,%rbx\nmov    -0x110(%rbp),%rax\nmov    -0x108(%rbp),%rdx\nmov    %rax,%rdx\nmov    $0x0,%eax\nadd    %rax,%rcx\nadc    %rdx,%rbx\nmov    -0xd0(%rbp),%rax\nmov    -0xc8(%rbp),%rdx\nadd    %rax,%rcx\nadc    %rdx,%rbx\nmov    -0xb0(%rbp),%rax\nmov    -0xa8(%rbp),%rdx\nadd    %rcx,%rax\nadc    %rbx,%rdx\nmov    %rax,-0xa0(%rbp)\nmov    %rdx,-0x98(%rbp)\ncmpl   $0x7f,-0x204(%rbp)\nja     0xa94\nmov    -0x208(%rbp),%eax\nmov    %eax,%eax\nmov    %rax,-0x2f0(%rbp)\nmovq   $0x0,-0x2e8(%rbp)\n\nmov    -0x204(%rbp),%ecx\nmov    -0x100(%rbp),%rax\nmov    -0xf8(%rbp),%rdx\nshrd   %cl,%rdx,%rax\nshr    %cl,%rdx\ntest   $0x40,%cl\nje     0x8e3\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    %rax,%rsi\nmov    %rdx,%rdi\nmov    $0x80,%eax\nsub    -0x204(%rbp),%eax\nmov    %eax,%ecx\nmov    -0xc0(%rbp),%rax\nmov    -0xb8(%rbp),%rdx\nshld   %cl,%rax,%rdx\nshl    %cl,%rax\ntest   $0x40,%cl\nje     0x915\nmov    %rax,%rdx\nxor    %eax,%eax\nmov    %rsi,%rbx\nor     %rax,%rbx\nmov    %rbx,-0x300(%rbp)\nor     %rdx,%rdi\nmov    %rdi,-0x2f8(%rbp)\nmov    -0x2f0(%rbp),%rax\nmov    -0x2e8(%rbp),%rdx\nadd    -0x300(%rbp),%rax\nadc    -0x2f8(%rbp),%rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x204(%rbp),%ecx\nmov    -0xc0(%rbp),%rax\nmov    -0xb8(%rbp),%rdx\nshrd   %cl,%rdx,%rax\nshr    %cl,%rdx\ntest   $0x40,%cl\nje     0x975\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    %rax,%rsi\nmov    %rdx,%rdi\nmov    $0x80,%eax\nsub    -0x204(%rbp),%eax\nmov    %eax,%ecx\nmov    -0xa0(%rbp),%rax\nmov    -0x98(%rbp),%rdx\nshld   %cl,%rax,%rdx\nshl    %cl,%rax\ntest   $0x40,%cl\nje     0x9a7\nmov    %rax,%rdx\nxor    %eax,%eax\nmov    %rsi,%rbx\nor     %rax,%rbx\nmov    %rbx,-0x310(%rbp)\nor     %rdx,%rdi\nmov    %rdi,-0x308(%rbp)\nmov    -0x208(%rbp),%eax\nmov    %eax,%eax\nmov    %rax,-0x320(%rbp)\nmovq   $0x0,-0x318(%rbp)\n\nmov    $0x1,%edx\nmov    -0x48(%rbp),%rax\nmov    -0x320(%rbp),%rbx\nmov    -0x318(%rbp),%rsi\nmov    %rbx,%rdi\ncmp    %rdi,-0x50(%rbp)\nsbb    %rsi,%rax\njb     0xa00\nmov    $0x0,%edx\nmovzbl %dl,%eax\nmov    %rax,-0x330(%rbp)\nmovq   $0x0,-0x328(%rbp)\n\nmov    -0x310(%rbp),%rax\nmov    -0x308(%rbp),%rdx\nadd    -0x330(%rbp),%rax\nadc    -0x328(%rbp),%rdx\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x50(%rbp),%rdx\nmov    -0x210(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x50(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    -0x210(%rbp),%rcx\nadd    $0x8,%rcx\nmov    %rax,(%rcx)\nmov    -0x210(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x40(%rbp),%rax\nmov    %rax,(%rdx)\nmov    -0x40(%rbp),%rax\nmov    -0x38(%rbp),%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    -0x210(%rbp),%rcx\nadd    $0x18,%rcx\nmov    %rax,(%rcx)\njmp    0xd68\ncmpl   $0x80,-0x204(%rbp)\n\njne    0xbb8\nmov    -0x208(%rbp),%eax\nmov    %eax,%eax\nmov    %rax,-0x340(%rbp)\nmovq   $0x0,-0x338(%rbp)\n\nmov    -0xc0(%rbp),%rax\nmov    -0xb8(%rbp),%rdx\nadd    -0x340(%rbp),%rax\nadc    -0x338(%rbp),%rdx\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    -0x208(%rbp),%eax\nmov    %eax,%eax\nmov    %rax,-0x350(%rbp)\nmovq   $0x0,-0x348(%rbp)\n\nmov    $0x1,%edx\nmov    -0x68(%rbp),%rax\nmov    -0x350(%rbp),%rbx\nmov    -0x348(%rbp),%rsi\nmov    %rbx,%rdi\ncmp    %rdi,-0x70(%rbp)\nsbb    %rsi,%rax\njb     0xb24\nmov    $0x0,%edx\nmovzbl %dl,%eax\nmov    %rax,-0x360(%rbp)\nmovq   $0x0,-0x358(%rbp)\n\nmov    -0xa0(%rbp),%rax\nmov    -0x98(%rbp),%rdx\nadd    -0x360(%rbp),%rax\nadc    -0x358(%rbp),%rdx\nmov    %rax,-0x60(%rbp)\nmov    %rdx,-0x58(%rbp)\nmov    -0x70(%rbp),%rdx\nmov    -0x210(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x70(%rbp),%rax\nmov    -0x68(%rbp),%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    -0x210(%rbp),%rcx\nadd    $0x8,%rcx\nmov    %rax,(%rcx)\nmov    -0x210(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rax,(%rdx)\nmov    -0x60(%rbp),%rax\nmov    -0x58(%rbp),%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    -0x210(%rbp),%rcx\nadd    $0x18,%rcx\nmov    %rax,(%rcx)\njmp    0xd68\nmov    -0x208(%rbp),%eax\nmov    %eax,%eax\nmov    %rax,-0x370(%rbp)\nmovq   $0x0,-0x368(%rbp)\n\nmov    -0x204(%rbp),%eax\nlea    -0x80(%rax),%ecx\nmov    -0xc0(%rbp),%rax\nmov    -0xb8(%rbp),%rdx\nshrd   %cl,%rdx,%rax\nshr    %cl,%rdx\ntest   $0x40,%cl\nje     0xbfa\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    %rax,%rsi\nmov    %rdx,%rdi\nmov    $0x100,%eax\nsub    -0x204(%rbp),%eax\nmov    %eax,%ecx\nmov    -0xa0(%rbp),%rax\nmov    -0x98(%rbp),%rdx\nshld   %cl,%rax,%rdx\nshl    %cl,%rax\ntest   $0x40,%cl\nje     0xc2c\nmov    %rax,%rdx\nxor    %eax,%eax\nmov    %rsi,%rbx\nor     %rax,%rbx\nmov    %rbx,-0x380(%rbp)\nor     %rdx,%rdi\nmov    %rdi,-0x378(%rbp)\nmov    -0x370(%rbp),%rax\nmov    -0x368(%rbp),%rdx\nadd    -0x380(%rbp),%rax\nadc    -0x378(%rbp),%rdx\nmov    %rax,-0x90(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    -0x204(%rbp),%eax\nlea    -0x80(%rax),%ecx\nmov    -0xa0(%rbp),%rax\nmov    -0x98(%rbp),%rdx\nshrd   %cl,%rdx,%rax\nshr    %cl,%rdx\ntest   $0x40,%cl\nje     0xc95\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    -0x208(%rbp),%ecx\nmov    %ecx,%ecx\nmov    %rcx,-0x390(%rbp)\nmovq   $0x0,-0x388(%rbp)\n\nmov    $0x1,%esi\nmov    -0x88(%rbp),%rcx\nmov    -0x390(%rbp),%r10\nmov    -0x388(%rbp),%r11\nmov    %r10,%rdi\ncmp    %rdi,-0x90(%rbp)\nsbb    %r11,%rcx\njb     0xcdd\nmov    $0x0,%esi\nmovzbl %sil,%ecx\nmov    %rcx,-0x3a0(%rbp)\nmovq   $0x0,-0x398(%rbp)\n\nadd    -0x3a0(%rbp),%rax\nadc    -0x398(%rbp),%rdx\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    -0x90(%rbp),%rdx\nmov    -0x210(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x90(%rbp),%rax\nmov    -0x88(%rbp),%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    -0x210(%rbp),%rcx\nadd    $0x8,%rcx\nmov    %rax,(%rcx)\nmov    -0x210(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x80(%rbp),%rax\nmov    %rax,(%rdx)\nmov    -0x80(%rbp),%rax\nmov    -0x78(%rbp),%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    -0x210(%rbp),%rcx\nadd    $0x18,%rcx\nmov    %rax,(%rcx)\nnop\nadd    $0x378,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_12",
        "query_text": "SUMMARY: This function takes no input parameters and returns a reference to a static object of type test_utils::detail::testfunc_list_t. The static object is intended to serve as a persistent container (a linked list) for nodes containing function pointers, ensuring that a single instance is available throughout the program's execution.",
        "code_id": "c_group_2_id_12",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x20(%rbp)\n\nmovq   $0x0,-0x18(%rbp)\n\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x44\ncall   0x44\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_3",
        "query_text": "SUMMARY: This function accepts a constant reference to an object of type cxxopts::String (alias for std::string) and returns a value of type std::size_t representing the count of characters in that string.",
        "code_id": "c_group_2_id_3",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_50",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a mutable high-level string (Neyson::String &), a constant character pointer (const char*), and an unsigned integer representing a length (size_t). It processes a sequence of characters from the given pointer, interpreting and removing escape sequences (such as those for quotes, backslashes, control characters, and Unicode code points) and appends the corresponding literal characters to the mutable string. As it iterates over the provided characters, it decodes any escape sequences encountered, converting Unicode escapes to their appropriate multi-byte (UTF\u20118) representations, and ultimately shortens the string to the correct final size. The function returns a boolean value to signal whether the processing succeeded without encountering any invalid or incomplete escape sequences.",
        "code_id": "c_group_2_id_50",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmovq   $0x0,-0x20(%rbp)\n\nmov    -0x48(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x34\nmovb   $0x0,-0x29(%rbp)\nmovq   $0x0,-0x18(%rbp)\n\njmp    0x56a\nmovzbl -0x29(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\nje     0x9b\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5c,%al\njne    0x6b\nmovb   $0x1,-0x29(%rbp)\njmp    0x565\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x94\nmov    %bl,(%rax)\njmp    0x565\nmovb   $0x0,-0x29(%rbp)\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x22,%al\njne    0xd4\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0xcc\nmovb   $0x22,(%rax)\njmp    0x565\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5c,%al\njne    0x109\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x101\nmovb   $0x5c,(%rax)\njmp    0x565\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njne    0x13e\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x136\nmovb   $0x2f,(%rax)\njmp    0x565\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x62,%al\njne    0x173\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x16b\nmovb   $0x8,(%rax)\njmp    0x565\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x66,%al\njne    0x1a8\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x1a0\nmovb   $0xc,(%rax)\njmp    0x565\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x6e,%al\njne    0x1dd\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x1d5\nmovb   $0xa,(%rax)\njmp    0x565\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x72,%al\njne    0x212\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x20a\nmovb   $0xd,(%rax)\njmp    0x565\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x74,%al\njne    0x247\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x23f\nmovb   $0x9,(%rax)\njmp    0x565\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x75,%al\njne    0x55e\nmovl   $0x0,-0x28(%rbp)\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\ncmp    %rax,-0x48(%rbp)\nsetb   %al\ntest   %al,%al\nje     0x286\nmov    $0x0,%eax\njmp    0x5a3\nmovl   $0x0,-0x24(%rbp)\njmp    0x372\nshll   $0x4,-0x28(%rbp)\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    0x2db\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njg     0x2db\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x28(%rbp),%eax\nadd    %edx,%eax\nsub    $0x30,%eax\nmov    %eax,-0x28(%rbp)\njmp    0x369\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x60,%al\njle    0x31d\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x66,%al\njg     0x31d\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x28(%rbp),%eax\nadd    %edx,%eax\nsub    $0x57,%eax\nmov    %eax,-0x28(%rbp)\njmp    0x369\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x40,%al\njle    0x35f\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x46,%al\njg     0x35f\nmov    -0x40(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x28(%rbp),%eax\nadd    %edx,%eax\nsub    $0x37,%eax\nmov    %eax,-0x28(%rbp)\njmp    0x369\nmov    $0x0,%eax\njmp    0x5a3\naddq   $0x1,-0x18(%rbp)\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x3,-0x24(%rbp)\njle    0x292\nsubq   $0x1,-0x18(%rbp)\ncmpl   $0x7f,-0x28(%rbp)\nja     0x3ae\nmov    -0x28(%rbp),%eax\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x3a7\nmov    %bl,(%rax)\njmp    0x565\ncmpl   $0x7ff,-0x28(%rbp)\nja     0x40f\nmov    -0x28(%rbp),%eax\nshr    $0x6,%eax\nand    $0x1f,%eax\nor     $0xffffffc0,%eax\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x3e0\nmov    %bl,(%rax)\nmov    -0x28(%rbp),%eax\nand    $0x3f,%eax\nor     $0xffffff80,%eax\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x408\nmov    %bl,(%rax)\njmp    0x565\ncmpl   $0xffff,-0x28(%rbp)\nja     0x49f\nmov    -0x28(%rbp),%eax\nshr    $0xc,%eax\nand    $0xf,%eax\nor     $0xffffffe0,%eax\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x445\nmov    %bl,(%rax)\nmov    -0x28(%rbp),%eax\nshr    $0x6,%eax\nand    $0x3f,%eax\nor     $0xffffff80,%eax\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x470\nmov    %bl,(%rax)\nmov    -0x28(%rbp),%eax\nand    $0x3f,%eax\nor     $0xffffff80,%eax\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x498\nmov    %bl,(%rax)\njmp    0x565\ncmpl   $0x10ffff,-0x28(%rbp)\nja     0x557\nmov    -0x28(%rbp),%eax\nshr    $0x12,%eax\nand    $0x7,%eax\nor     $0xfffffff0,%eax\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4d5\nmov    %bl,(%rax)\nmov    -0x28(%rbp),%eax\nshr    $0xc,%eax\nand    $0x3f,%eax\nor     $0xffffff80,%eax\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x500\nmov    %bl,(%rax)\nmov    -0x28(%rbp),%eax\nshr    $0x6,%eax\nand    $0x3f,%eax\nor     $0xffffff80,%eax\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x52b\nmov    %bl,(%rax)\nmov    -0x28(%rbp),%eax\nand    $0x3f,%eax\nor     $0xffffff80,%eax\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x553\nmov    %bl,(%rax)\njmp    0x565\nmov    $0x0,%eax\njmp    0x5a3\nmov    $0x0,%eax\njmp    0x5a3\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x48(%rbp),%rax\njb     0x45\nmov    -0x20(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    $0xffffffffffffffff,%rdx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x592\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x59e\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_31",
        "query_text": "SUMMARY: This function processes a null-terminated string of characters (of type pugi::char_t*) using a lookup mapping provided by an array of unsigned characters (of type const unsigned char*). It iterates through the input string, and for each character with a code less than 128 it replaces it with a corresponding value from the lookup table, potentially skipping the character if the table's value indicates so; characters with codes 128 or greater are left unchanged. The transformed data is written back into the original buffer, ensuring the result remains null-terminated, and the function returns a pointer of type pugi::char_t* pointing to the terminating zero.",
        "code_id": "c_group_2_id_31",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    0x7e\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x18(%rbp)\nmovzbl (%rax),%eax\nmov    %al,-0xe(%rbp)\nmovsbl -0xe(%rbp),%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x7f,-0xc(%rbp)\nja     0x6c\nmov    -0xc(%rbp),%edx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xd(%rbp)\nmovzbl -0xd(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %dl,(%rax)\nmovzbl -0xd(%rbp),%eax\nshr    $0x7,%al\nmovzbl %al,%edx\nmov    $0x1,%eax\nsub    %edx,%eax\ncltq   \nadd    %rax,-0x8(%rbp)\njmp    0x7e\nmovzbl -0xe(%rbp),%edx\nmov    -0x8(%rbp),%rax\nlea    0x1(%rax),%rcx\nmov    %rcx,-0x8(%rbp)\nmov    %dl,(%rax)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x1a\nmov    -0x8(%rbp),%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_2",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a mutable reference to a cxxopts::String (alias for std::string), a std::size_t representing a repetition count, and a char. It appends the specified number of repetitions of the given character to the input string and returns a mutable reference to the updated string.",
        "code_id": "c_group_2_id_2",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,%eax\nmov    %al,-0x14(%rbp)\nmovsbl -0x14(%rbp),%edx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x30\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_1",
        "query_text": "SUMMARY: This function accepts a constant reference to a vector of strings (input type: const cxxopts::OptionNames&) and returns a constant reference to a string (output type: const std::string&). It checks whether the provided vector is empty, returning the first element of the vector if available; otherwise, it returns a static, empty string.",
        "code_id": "c_group_2_id_1",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x58,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2c\nlea    -0x41(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x3b\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x46\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0x52\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   0x5e\ntest   %al,%al\nje     0x68\nlea    -0x40(%rbp),%rbx\njmp    0x77\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,%rbx\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x83\nmov    %rbx,%rax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xba\njmp    0xb5\nendbr64 \nmov    %rax,%rbx\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0xaa\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xb5\ncall   0xba\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_40",
        "query_text": "SUMMARY: This function receives an input of type pugi::xml_node_type and returns a value of type bool. It evaluates whether the provided XML node type is either an element node or a declaration node, and returns true in those cases, and false otherwise.",
        "code_id": "c_group_2_id_40",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x2,-0x4(%rbp)\nje     0x17\ncmpl   $0x7,-0x4(%rbp)\njne    0x1e\nmov    $0x1,%eax\njmp    0x23\nmov    $0x0,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_48",
        "query_text": "SUMMARY: This function accepts two inputs of type asmjit::_abi_1_13::TypeId and returns a 32-bit unsigned integer (uint32_t). It converts each input to its unsigned integer representation, left-shifts the first input by 8 bits to occupy the higher-order portion, and then combines it with the second input (occupying the lower-order portion) using a bitwise OR operation.",
        "code_id": "c_group_2_id_48",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%edx\nmov    %esi,%eax\nmov    %dl,-0x4(%rbp)\nmov    %al,-0x8(%rbp)\nmovzbl -0x4(%rbp),%eax\nshl    $0x8,%eax\nmov    %eax,%edx\nmovzbl -0x8(%rbp),%eax\nor     %edx,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_44",
        "query_text": "SUMMARY: This function accepts a constant pointer to a character type (pugi::char_t*) as input and returns a double-precision floating point value. Its primary behavior is to convert a string representing a numerical value into its corresponding double value. Depending on whether a wide character mode is enabled at compile time, it internally uses either the wide-character conversion function (wcstod) or the standard conversion function (strtod) to perform this conversion.",
        "code_id": "c_group_2_id_44",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x21\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_26",
        "query_text": "SUMMARY: This function accepts an input of type pugi::char_t and returns an output of the same type. It determines whether the input represents an ASCII uppercase letter and, if so, produces its corresponding lowercase representation; if the input is not an uppercase letter, it returns the original input unchanged.",
        "code_id": "c_group_2_id_26",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovsbl -0x4(%rbp),%eax\nsub    $0x41,%eax\ncmp    $0x19,%eax\nja     0x22\nmovzbl -0x4(%rbp),%eax\nor     $0x20,%eax\njmp    0x26\nmovzbl -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_17",
        "query_text": "SUMMARY: This function accepts an unsigned 64-bit integer, a pointer to an array of unsigned 64-bit integers, and a signed 32-bit integer, and it returns an unsigned 64-bit integer. It performs two 128-bit multiplications using the 64-bit input and the first two elements of the array. It then extracts the high 64 bits of one product, adds this to the other 128-bit product, and finally performs a right bit-shift by the difference between the provided 32-bit integer and 64. The resulting value, after conversion to an unsigned 64-bit integer, is returned.",
        "code_id": "c_group_2_id_17",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r13\npush   %r12\npush   %rbx\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %edx,-0x54(%rbp)\nmov    -0x48(%rbp),%rax\nmov    %rax,%r12\nmov    $0x0,%r13d\nmov    -0x50(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%r10\nmov    $0x0,%r11d\nmov    %r13,%rdx\nimul   %r10,%rdx\nmov    %r11,%rax\nimul   %r12,%rax\nlea    (%rdx,%rax,1),%rsi\nmov    %r12,%rax\nmul    %r10\nadd    %rdx,%rsi\nmov    %rsi,%rdx\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x48(%rbp),%rax\nmov    %rax,%r8\nmov    $0x0,%r9d\nmov    -0x50(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmov    %r9,%rdx\nimul   %rcx,%rdx\nmov    %rbx,%rax\nimul   %r8,%rax\nlea    (%rdx,%rax,1),%rsi\nmov    %r8,%rax\nmul    %rcx\nlea    (%rsi,%rdx,1),%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x40(%rbp),%rax\nmov    -0x38(%rbp),%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rbx\nadd    %rcx,%rax\nadc    %rbx,%rdx\nmov    -0x54(%rbp),%ecx\nsub    $0x40,%ecx\nshrd   %cl,%rdx,%rax\nshr    %cl,%rdx\ntest   $0x40,%cl\nje     0xe4\nmov    %rdx,%rax\nxor    %edx,%edx\npop    %rbx\npop    %r12\npop    %r13\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_23",
        "query_text": "SUMMARY: This function takes two input variables of type \"const Oracle&\" and returns an output of type bool. It determines the inequality between the two by comparing the int field contained within their OracleVal members and returns true if the values differ, and false if they are equal.",
        "code_id": "c_group_2_id_23",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\ncmp    %eax,%edx\nsetne  %al\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_46",
        "query_text": "SUMMARY: This function receives two constant pointers to the BrokenAPI::Unit structure and returns an integer. It compares the integer field (priority) of both inputs; if they are equal, it compares the C-style string field (name) lexically. The output integer indicates whether the first input is considered greater than, equal to, or less than the second based on these comparisons.",
        "code_id": "c_group_2_id_46",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    0x10(%rax),%eax\ncmp    %eax,%edx\njne    0x43\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x41\njmp    0x62\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    0x10(%rax),%eax\ncmp    %eax,%edx\njle    0x5c\nmov    $0x1,%eax\njmp    0x61\nmov    $0xffffffff,%eax\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_14",
        "query_text": "SUMMARY: This function accepts a single input of type enum class complex_form and returns a value of type const char16_t*. It determines which constant Unicode string to output based on the provided complex form. Specifically, it returns a string representing the algebraic separation if the input denotes an algebraic form, a string representing an angle (using the Unicode angle character) if the input denotes a polar form, and defaults to a standard separator string for any other case.",
        "code_id": "c_group_2_id_14",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\nje     0x19\ncmpl   $0x2,-0x4(%rbp)\nje     0x22\njmp    0x2b\nlea    0x0(%rip),%rax        # 0x20\njmp    0x32\nlea    0x0(%rip),%rax        # 0x29\njmp    0x32\nlea    0x0(%rip),%rax        # 0x32\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_32",
        "query_text": "SUMMARY: This function accepts two inputs of type const pugi::char_t* and one of type size_t, and returns a bool. It compares the first input string and the second input string over the specified count of characters. If any character within this range does not match, it immediately returns false. If all characters in the given range match, it then returns true only if the first string has exactly the given length (indicated by a terminating null character immediately following the compared characters), otherwise it returns false.",
        "code_id": "c_group_2_id_32",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovq   $0x0,-0x8(%rbp)\n\njmp    0x4a\nmov    -0x18(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x20(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     0x45\nmov    $0x0,%eax\njmp    0x67\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x28(%rbp),%rax\njb     0x1e\nmov    -0x18(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nsete   %al\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_4",
        "query_text": "SUMMARY: This function takes four inputs: an array of pointers to unsigned char, an array of Lcp (with Lcp being defined as an alias for int), and two integers representing indices. It exchanges (swaps) the elements at the specified indices in both the unsigned char pointer array and the Lcp array. The function does not return any output.",
        "code_id": "c_group_2_id_4",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x14(%rbp)\nmov    %ecx,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x4d\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rcx\n\nmov    -0x10(%rbp),%rax\nadd    %rcx,%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x80\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_19",
        "query_text": "SUMMARY: This function takes two constant references of type Oracle as inputs and returns a bool. It checks whether the integer values contained in the OracleVal member of each Oracle instance are equal.",
        "code_id": "c_group_2_id_19",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\ncmp    %eax,%edx\nsete   %al\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_16",
        "query_text": "SUMMARY: The function takes a 128\u2010bit unsigned integer (type __uint128_t) as input and returns a 32\u2010bit unsigned integer (type uint32_t) representing the number of decimal digits required to express the input value. It initializes a high constant corresponding to the largest power of 10 for a 128\u2010bit value and iteratively compares and scales this value to determine the appropriate digit count.",
        "code_id": "c_group_2_id_16",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,%rax\nmov    %rsi,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmovabs $0x98a224000000000,%rax\n\nmovabs $0x4b3b4ca85a86c47a,%rdx\n\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x27,-0x34(%rbp)\njmp    0xa2\nmov    -0x50(%rbp),%rax\nmov    -0x48(%rbp),%rdx\ncmp    -0x30(%rbp),%rax\nmov    %rdx,%rax\nsbb    -0x28(%rbp),%rax\njb     0x6d\nmov    -0x34(%rbp),%eax\njmp    0xad\nmov    -0x30(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    $0xa,%edx\nmov    $0x0,%ecx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   0x96\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nsubl   $0x1,-0x34(%rbp)\ncmpl   $0x0,-0x34(%rbp)\njne    0x53\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_47",
        "query_text": "SUMMARY: The function accepts an input of type asmjit::_abi_1_13::CallConvId (an enum class with underlying type uint8_t) and returns a bool. It determines whether the provided calling convention identifier corresponds to one of several established C-style calling conventions (including cdecl, stdcall, fastcall, vectorcall, thiscall, and three regparm variants). Essentially, it checks the input against these specific enumerated values and returns true if a match is found, otherwise it returns false.",
        "code_id": "c_group_2_id_47",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x0,-0x4(%rbp)\nje     0x3d\ncmpb   $0x1,-0x4(%rbp)\nje     0x3d\ncmpb   $0x2,-0x4(%rbp)\nje     0x3d\ncmpb   $0x3,-0x4(%rbp)\nje     0x3d\ncmpb   $0x4,-0x4(%rbp)\nje     0x3d\ncmpb   $0x5,-0x4(%rbp)\nje     0x3d\ncmpb   $0x6,-0x4(%rbp)\nje     0x3d\ncmpb   $0x7,-0x4(%rbp)\njne    0x44\nmov    $0x1,%eax\njmp    0x49\nmov    $0x0,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_123",
        "query_text": "SUMMARY: This function accepts an integer of type utf8_int32_t (an alias for int32_t) and returns a value of type size_t. Its purpose is to determine the number of bytes required to represent a UTF-8 encoded code point. It does so by examining the bit-pattern of the provided code point and deciding whether it fits within 1, 2, 3, or 4 bytes based on predefined bit-mask thresholds.",
        "code_id": "c_group_2_id_123",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0xffffff80,%eax\ntest   %eax,%eax\njne    0x1c\nmov    $0x1,%eax\njmp    0x46\nmov    -0x4(%rbp),%eax\nand    $0xfffff800,%eax\ntest   %eax,%eax\njne    0x2f\nmov    $0x2,%eax\njmp    0x46\nmov    -0x4(%rbp),%eax\nmov    $0x0,%ax\ntest   %eax,%eax\njne    0x41\nmov    $0x3,%eax\njmp    0x46\nmov    $0x4,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_27",
        "query_text": "SUMMARY: This function accepts a constant pointer to a char_t and returns a boolean value. It examines only the first character of the provided string, yielding true if that character is '1', 't', 'T', 'y', or 'Y'; otherwise, it returns false.",
        "code_id": "c_group_2_id_27",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\ncmpb   $0x31,-0x1(%rbp)\nje     0x34\ncmpb   $0x74,-0x1(%rbp)\nje     0x34\ncmpb   $0x54,-0x1(%rbp)\nje     0x34\ncmpb   $0x79,-0x1(%rbp)\nje     0x34\ncmpb   $0x59,-0x1(%rbp)\njne    0x3b\nmov    $0x1,%eax\njmp    0x40\nmov    $0x0,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_29",
        "query_text": "SUMMARY: This function receives as input a pointer to constant pugi::char_t and a size_t representing a data buffer's length, and it returns a size_t that specifies the length of the valid portion of the data. Initially, the function verifies that the provided length meets a minimum threshold; if not, it returns zero. Then, examining up to the last four bytes of the data, it determines whether these trailing bytes are part of a complete multibyte sequence by checking if each byte is not a continuation byte (using bitmasking). If a non-continuation byte is located, the function returns an adjusted length that excludes the incomplete trailing bytes. If all four examined bytes are continuation bytes, it concludes that the entire buffer is valid and returns the original length.",
        "code_id": "c_group_2_id_29",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\ncmpq   $0x4,-0x20(%rbp)\nja     0x1e\nmov    $0x0,%eax\njmp    0x6a\nmovq   $0x1,-0x8(%rbp)\n\njmp    0x5f\nmov    -0x20(%rbp),%rax\nsub    -0x8(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x9(%rbp)\nmovzbl -0x9(%rbp),%eax\nand    $0xc0,%eax\ncmp    $0x80,%eax\nje     0x5a\nmov    -0x20(%rbp),%rax\nsub    -0x8(%rbp),%rax\njmp    0x6a\naddq   $0x1,-0x8(%rbp)\ncmpq   $0x4,-0x8(%rbp)\njbe    0x28\nmov    -0x20(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_25",
        "query_text": "SUMMARY: This function takes two inputs of type pugi::xml_node_type and returns a boolean value. It determines whether a node of the child type can be inserted under a node of the parent type. The function permits insertion only if the parent node is either a document or an element, and if the child node is not a document or a null node. Additionally, when the parent is not a document, it disallows insertion of child nodes that are declarations or document type declarations.",
        "code_id": "c_group_2_id_25",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\nje     0x21\ncmpl   $0x2,-0x4(%rbp)\nje     0x21\nmov    $0x0,%eax\njmp    0x52\ncmpl   $0x1,-0x8(%rbp)\nje     0x2d\ncmpl   $0x0,-0x8(%rbp)\njne    0x34\nmov    $0x0,%eax\njmp    0x52\ncmpl   $0x1,-0x4(%rbp)\nje     0x4d\ncmpl   $0x7,-0x8(%rbp)\nje     0x46\ncmpl   $0x8,-0x8(%rbp)\njne    0x4d\nmov    $0x0,%eax\njmp    0x52\nmov    $0x1,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_38",
        "query_text": "SUMMARY: This function accepts two input parameters, both of type const pugi::char_t* (representing character arrays), and returns an output of type bool. It checks whether the character array referenced by the second pointer exactly matches the beginning segment of the character array referenced by the first pointer, returning true if the entire sequence of the second input is found at the start of the first, and false otherwise.",
        "code_id": "c_group_2_id_38",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\njmp    0x1c\naddq   $0x1,-0x8(%rbp)\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     0x39\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     0x12\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nsete   %al\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_41",
        "query_text": "SUMMARY: This function accepts two inputs of type \"const pugi::char_t*\" and returns an output of type \"bool\". It first verifies that both input pointers are valid, then performs a comparison of the null\u2010terminated character arrays pointed to by these inputs. The function ultimately returns a boolean value indicating whether the two string representations are equal.",
        "code_id": "c_group_2_id_41",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     0x22\ncmpq   $0x0,-0x10(%rbp)\njne    0x4a\nlea    0x0(%rip),%rax        # 0x29\nmov    %rax,%rcx\nmov    $0xd,%edx\nlea    0x0(%rip),%rax        # 0x38\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdi\ncall   0x4a\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x5d\ntest   %eax,%eax\nsete   %al\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_67",
        "query_text": "SUMMARY: This function accepts four parameters: a reference to a value of type std::vector<std::vector<double>>, a constant size_t representing the number of points, a constant size_t representing the dimensionality of each point, and an optional double for the maximum range of generated values (with a default of 10.0). It produces no direct return value (void) but instead populates the referenced vector with the specified number of points, where each point is a vector of doubles containing randomly generated values between 0 and the maximum range.",
        "code_id": "c_group_2_id_67",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovsd  %xmm0,-0x30(%rbp)\nlea    0x0(%rip),%rax        # 0x24\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x2e\nmov    %rax,%rdi\ncall   0x36\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x5d\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x70\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x137\nmov    -0x10(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x90\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0xa2\nmovq   $0x0,-0x8(%rbp)\n\njmp    0x124\ncall   0xb1\nmovslq %eax,%rdx\nimul   $0x10624dd3,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x6,%edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nimul   $0x3e8,%edx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\npxor   %xmm0,%xmm0\ncvtsi2sd %edx,%xmm0\nmulsd  -0x30(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0xe8\n\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x104\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x116\nmovsd  -0x38(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x28(%rbp),%rax\njb     0xac\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     0x7d\nlea    0x0(%rip),%rax        # 0x14c\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x156\nmov    %rax,%rdi\ncall   0x15e\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_42",
        "query_text": "SUMMARY: The function accepts a constant pointer to a character sequence (of type pugi::char_t) and returns a size_t value representing the count of characters in the sequence. It determines the length of a null-terminated string, choosing a wide-character approach (using wcslen) or a standard approach (using strlen) based on the compilation configuration.",
        "code_id": "c_group_2_id_42",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_43",
        "query_text": "SUMMARY: This function accepts an input of type \"pointer to constant char_t\" and returns a result of type \"float\". It converts a textual numeric representation into a floating-point number using standard library conversion routines, choosing between the wide-character or narrow-character conversion method based on compile-time settings.",
        "code_id": "c_group_2_id_43",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x21\ncvtsd2ss %xmm0,%xmm0\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_36",
        "query_text": "SUMMARY: This function accepts two inputs of type const pugi::char_t* (pointers to null-terminated character sequences) and returns a value of the same type. It searches for the first occurrence of the sequence given by the second input within the sequence given by the first input. Depending on a compile-time flag, it utilizes the appropriate standard function (for either wide or narrow characters) to perform the search, and in wide-character mode, it directly returns the first input if the second input represents an empty sequence.",
        "code_id": "c_group_2_id_36",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_66",
        "query_text": "SUMMARY: This function takes two inputs\u2014a non-constant reference to a stream (std::ostream&) and a constant reference to a custom integer type (MyInt). It extracts an integer value from the custom type and inserts that integer into the stream. The function then returns a reference to the same stream (std::ostream&).",
        "code_id": "c_group_2_id_66",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x30\nmov    -0x8(%rbp),%rax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_33",
        "query_text": "SUMMARY: This function takes a generic pointer (void*), a size value (size_t), and an encoding value (xml_encoding) as inputs, and returns a size_t. It conditionally appends a zero terminator to a character buffer encoded either in a wide-character mode or UTF-8, depending on the current compilation context and comparison of the provided encoding with the native character encoding. If termination is required, the function writes a null character at the end of the buffer and returns the new total size (original size plus the size of the terminator). If termination is not needed, it simply returns the original size.",
        "code_id": "c_group_2_id_33",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x14(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njne    0x31\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x10(%rbp),%rax\nadd    $0x1,%rax\njmp    0x35\nmov    -0x10(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_28",
        "query_text": "SUMMARY: This function takes a constant pointer to a character sequence (const pugi::char_t*) and a single character (pugi::char_t) as inputs, then searches the sequence to locate the first occurrence of the specified character. It returns a constant pointer to a character (const pugi::char_t*) indicating the found position, or a null pointer if the character does not appear in the sequence.",
        "code_id": "c_group_2_id_28",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %al,-0xc(%rbp)\nmovsbl -0xc(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x27\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_30",
        "query_text": "SUMMARY: This function takes two input values of type const pugi::char_t* (pointers to characters representing C-style strings) and returns a value of type bool. It first checks whether either of the provided string pointers is null, in which case it verifies that both are null; if not null, it performs a content comparison to determine if the strings are equal, using a wide-character comparison when compiled in wide mode, and a standard narrow-character comparison otherwise.",
        "code_id": "c_group_2_id_30",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     0x22\ncmpq   $0x0,-0x10(%rbp)\njne    0x2f\nmov    -0x8(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nsete   %al\njmp    0x47\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x42\ntest   %eax,%eax\nsete   %al\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_49",
        "query_text": "SUMMARY: The function accepts an input of type asmjit::_abi_1_13::CallConvId (an enumeration based on uint8_t) and returns a boolean value. It evaluates whether the provided calling convention identifier is one of a specific subset (namely, kCDecl, kStdCall, kThisCall, kFastCall, kRegParm1, kRegParm2, or kRegParm3). If the input matches any of these designated values, the function outputs true; otherwise, it outputs false.",
        "code_id": "c_group_2_id_49",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x0,-0x4(%rbp)\nje     0x37\ncmpb   $0x1,-0x4(%rbp)\nje     0x37\ncmpb   $0x4,-0x4(%rbp)\nje     0x37\ncmpb   $0x2,-0x4(%rbp)\nje     0x37\ncmpb   $0x5,-0x4(%rbp)\nje     0x37\ncmpb   $0x6,-0x4(%rbp)\nje     0x37\ncmpb   $0x7,-0x4(%rbp)\njne    0x3e\nmov    $0x1,%eax\njmp    0x43\nmov    $0x0,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_169",
        "query_text": "SUMMARY: This function accepts a perspective projection matrix (of type \"mat4\", an aligned 4\u00d74 array of 4-element float vectors) and a pointer to a float variable. It computes a specific scalar value corresponding to the near clipping distance by dividing the element from the matrix\u2019s fourth row and third column by the difference of the element from the third row and third column with 1.0, then stores the result in the provided float output.",
        "code_id": "c_group_2_id_169",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm1\nmovss  0x0(%rip),%xmm2        # 0x32\n\nsubss  %xmm2,%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_139",
        "query_text": "SUMMARY: This function receives a 3-element array of floats as input and produces a 3-element array of floats as output. It computes the additive inverse of each element in the input array and stores the results in the output array.",
        "code_id": "c_group_2_id_139",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x20\n\nxorps  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  0x0(%rip),%xmm1        # 0x47\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x0(%rip),%xmm1        # 0x6a\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_163",
        "query_text": "SUMMARY: This function accepts a two-element integer array (ivec2, equivalent to int[2]) as its input/output parameter and sets each of its two elements to zero. It does not return any value, effectively producing a two-dimensional integer vector with all elements zero.",
        "code_id": "c_group_2_id_163",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovl   $0x0,(%rax)\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_173",
        "query_text": "SUMMARY: This function accepts an input of type int[4] and an integer scalar, and produces an output of type int[4]. It subtracts the scalar value from each element of the input array and stores the results in the output array.",
        "code_id": "c_group_2_id_173",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nsub    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x8,%rdx\nsub    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0xc,%rdx\nsub    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_177",
        "query_text": "SUMMARY: The function takes two inputs, each being an array of four integers (int[4]), and computes their element-wise differences by subtracting corresponding entries. The resulting array of four integers (int[4]) is then produced as the output.",
        "code_id": "c_group_2_id_177",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_160",
        "query_text": "SUMMARY: This function computes the product of a 2\u00d73 matrix and a 3\u00d72 matrix, both consisting of float elements, and stores the result in a 3\u00d73 matrix also composed of float elements. It achieves this by, for each of the three rows in the 3\u00d72 input matrix, calculating three output values through two-element dot products with the two rows of the 2\u00d73 input matrix. The result is a 3\u00d73 matrix that encapsulates these computed dot products.",
        "code_id": "c_group_2_id_160",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x30(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x40(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x40(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x30(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x48(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x2c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x48(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x28(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x48(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0x30(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x48(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x2c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x20(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x48(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x28(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x48(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x30(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x48(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x2c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x48(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x28(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x48(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_144",
        "query_text": "SUMMARY: The function takes an input of type \"vec2\" (a two-element array of float values) and produces no explicit output but modifies the input in-place by setting both elements to 0.0f, effectively zeroing the 2D vector.",
        "code_id": "c_group_2_id_144",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rax)\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_167",
        "query_text": "SUMMARY: This function accepts a 2\u00d72 matrix (of type mat2) and a 2-dimensional vector (of type vec2) as inputs, and computes their product, yielding a 2-dimensional vector (of type vec2) as the result. On the first line, it calculates the first component of the result by taking the dot product of the first column of the matrix with the input vector, and on the second line, it calculates the second component by taking the dot product of the second column of the matrix with the input vector.",
        "code_id": "c_group_2_id_167",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_151",
        "query_text": "SUMMARY: This function accepts two input arrays of type float[3] representing three-dimensional vectors and an output array of the same type. It computes the element-wise difference between the two input vectors and then adds each resulting value to the corresponding element in the output vector.",
        "code_id": "c_group_2_id_151",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm2\nsubss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nsubss  %xmm2,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm2\nsubss  %xmm2,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_184",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 floating-point matrix (of type mat4) and two pointers to floats (float *), and it computes the near and far clipping plane distances from the provided projection matrix. It does so by extracting two specific elements from the matrix and then performing simple division operations: one value divided by (the other value minus 1) to yield the near clipping distance, and the same value divided by (the other value plus 1) to yield the far clipping distance. The resulting float values are stored via the provided pointers.",
        "code_id": "c_group_2_id_184",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmovss  0x0(%rip),%xmm2        # 0x45\n\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmovss  -0x8(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x6a\n\naddss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_180",
        "query_text": "SUMMARY: This function receives two inputs\u2014a 4x4 matrix of floats (mat4) and a single float\u2014and it operates in place without returning a value (void). It adjusts the matrix by adding the float input to the element located in the fourth row and third column, effectively modifying the translation component along the z-axis of the transformation represented by the matrix.",
        "code_id": "c_group_2_id_180",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\naddss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_155",
        "query_text": "SUMMARY: This function accepts a 2\u00d72 matrix (of type mat2, which is defined as an aligned array of two 2-element float vectors) and returns a float. It computes the sum of the elements from the top-left and bottom-right positions of the matrix, effectively calculating the trace of the matrix.",
        "code_id": "c_group_2_id_155",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_158",
        "query_text": "SUMMARY: This function takes two input parameters and one output parameter, each of type \"int[3]\". It computes the element-wise product of the first two input arrays and adds each resulting product to the corresponding component of the output array.",
        "code_id": "c_group_2_id_158",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %edx,%eax\nlea    (%rcx,%rax,1),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_175",
        "query_text": "SUMMARY: This function accepts a 2-element integer array, an integer scalar, and a second 2-element integer array as inputs. It updates the output array by adding the sum of the corresponding element in the input array and the provided integer to each element in the output array.",
        "code_id": "c_group_2_id_175",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %ecx,%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_185",
        "query_text": "SUMMARY: This function accepts a three-element floating-point array as input and produces another three-element floating-point array as output. For each element, it computes the fractional part by subtracting the floor of the input value from the input value itself. It then ensures that the computed fractional value does not exceed approximately 0.99999994 by clamping it to that upper bound.",
        "code_id": "c_group_2_id_185",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm2\nmovss  %xmm2,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x31\nmovss  -0x24(%rbp),%xmm2\nsubss  %xmm0,%xmm2\nmovd   %xmm2,%eax\nmovss  0x0(%rip),%xmm1        # 0x46\n\nmovd   %eax,%xmm0\ncall   0x4f\nmovd   %xmm0,%eax\nmov    -0x20(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm3\nmovss  %xmm3,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x7d\nmovss  -0x24(%rbp),%xmm3\nsubss  %xmm0,%xmm3\nmovd   %xmm3,%eax\nmov    -0x20(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovss  0x0(%rip),%xmm1        # 0x9a\n\nmovd   %eax,%xmm0\ncall   0xa3\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm4\nmovss  %xmm4,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0xcd\nmovss  -0x24(%rbp),%xmm4\nsubss  %xmm0,%xmm4\nmovd   %xmm4,%eax\nmov    -0x20(%rbp),%rdx\nlea    0x8(%rdx),%rbx\nmovss  0x0(%rip),%xmm1        # 0xea\n\nmovd   %eax,%xmm0\ncall   0xf3\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_145",
        "query_text": "SUMMARY: This function takes two input parameters and one output parameter, all of which are arrays consisting of three integers (ivec3). It performs element-wise division of the first integer array by the second integer array and stores the resulting quotients into the output integer array.",
        "code_id": "c_group_2_id_145",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nmov    (%rdx),%esi\ncltd   \nidiv   %esi\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edi\nmov    -0x18(%rbp),%rcx\nadd    $0x4,%rcx\ncltd   \nidiv   %edi\nmov    %eax,(%rcx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x8,%rdx\nmov    (%rdx),%esi\nmov    -0x18(%rbp),%rcx\nadd    $0x8,%rcx\ncltd   \nidiv   %esi\nmov    %eax,(%rcx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_137",
        "query_text": "SUMMARY: This function transposes a matrix. It accepts an input of type mat4x2 (an array of 4 two-element float arrays representing a 4\u00d72 matrix) and produces an output of type mat2x4 (an array of 2 four-element float arrays representing a 2\u00d74 matrix). The function reorganizes the elements so that the elements of the first column of the input become the elements of the first row of the output, while the elements of the second column become the elements of the second row, thereby interchanging rows and columns.",
        "code_id": "c_group_2_id_137",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_135",
        "query_text": "SUMMARY: This function takes a 3-element floating-point vector (vec3) representing Euler angles and computes a 4-element floating-point vector (versor) representing a quaternion. It calculates the half-angle sine and cosine values for each of the Euler angles\u2014negating the sine for the third angle to account for a left-handed coordinate system\u2014and then combines these trigonometric results to derive the quaternion components.",
        "code_id": "c_group_2_id_135",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmovss  0x0(%rip),%xmm0        # 0xed\n\nmovd   %eax,%xmm2\nxorps  %xmm0,%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x110\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x121\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmulss  -0x14(%rbp),%xmm1\nmulss  -0x10(%rbp),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmulss  -0x18(%rbp),%xmm1\nmulss  -0x10(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_164",
        "query_text": "SUMMARY: This function accepts a single input of type vec4 (an array of 4 single-precision floats) and does not return any value. Its functionality is to reset all elements within the provided vector to zero. It accomplishes this by utilizing platform-specific SIMD operations if available (such as WebAssembly SIMD, SSE, or NEON floating-point instructions) and defaults to assigning zero to each element individually when those optimizations are not available.",
        "code_id": "c_group_2_id_164",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\npxor   %xmm0,%xmm0\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmovaps -0x10(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_174",
        "query_text": "SUMMARY: This function accepts an input of type const float pointer and produces an output of type mat2x4 (i.e., a two-element array where each element is a four-component float vector). It organizes the eight sequential float values from the input into a 2\u00d74 matrix format by assigning the first four float values to the first row of the matrix and the subsequent four float values to the second row.",
        "code_id": "c_group_2_id_174",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x14(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_181",
        "query_text": "SUMMARY: This function takes as input a constant 4-element integer array and an integer scalar, and it updates a destination 4-element integer array. For each element in the destination array, it adds the result of subtracting the scalar from the corresponding element of the input array. The operation is performed element-wise for all four positions of the arrays, and no value is returned.",
        "code_id": "c_group_2_id_181",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_152",
        "query_text": "SUMMARY: This function operates on three parameters of type 2-element float arrays. It subtracts from each element of the output array the sum of the corresponding elements from the two input arrays, effectively updating the output vector by reducing each component by the combined values of the respective components from the inputs.",
        "code_id": "c_group_2_id_152",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm1\naddss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\naddss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_153",
        "query_text": "SUMMARY: This function copies a 4\u00d74 matrix (of type mat4, an array of four 4-element float vectors) from an input to an output. It leverages different hardware-specific SIMD instructions (such as those for WASM SIMD, AVX, SSE/SSE2, or NEON) to efficiently transfer each 4-element vector constituting a row of the 4\u00d74 matrix, ensuring that the output precisely replicates the input. In cases where none of these SIMD capabilities are available, it resorts to a generic copy routine to perform the same task.",
        "code_id": "c_group_2_id_153",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x88(%rbp)\nmov    %rsi,-0x90(%rbp)\nmov    -0x88(%rbp),%rax\nmov    %rax,-0x48(%rbp)\nmov    -0x48(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x90(%rbp),%rax\nmov    %rax,-0x50(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmov    -0x50(%rbp),%rax\nmovaps -0x10(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x88(%rbp),%rax\nadd    $0x10,%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x90(%rbp),%rax\nadd    $0x10,%rax\nmov    %rax,-0x60(%rbp)\nmovaps %xmm0,-0x20(%rbp)\nmov    -0x60(%rbp),%rax\nmovaps -0x20(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x88(%rbp),%rax\nadd    $0x20,%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x90(%rbp),%rax\nadd    $0x20,%rax\nmov    %rax,-0x70(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmov    -0x70(%rbp),%rax\nmovaps -0x30(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x88(%rbp),%rax\nadd    $0x30,%rax\nmov    %rax,-0x78(%rbp)\nmov    -0x78(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x90(%rbp),%rax\nadd    $0x30,%rax\nmov    %rax,-0x80(%rbp)\nmovaps %xmm0,-0x40(%rbp)\nmov    -0x80(%rbp),%rax\nmovaps -0x40(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_141",
        "query_text": "SUMMARY: The function takes two input parameters, each being a fixed-size array of 2 integers, and returns an integer. It computes a scalar value by multiplying the first element of the first input with the second element of the second input, then subtracting the product of the second element of the first input with the first element of the second input. This operation effectively calculates the determinant of a 2\u00d72 matrix formed by the input arrays.",
        "code_id": "c_group_2_id_141",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_150",
        "query_text": "SUMMARY: This function accepts two inputs of type float[2] and produces an output of type float[2]. It computes the element-wise division of the two input arrays, dividing the first element of the first input by the first element of the second input and the second element of the first input by the second element of the second input, and stores the resulting values in the output array.",
        "code_id": "c_group_2_id_150",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_172",
        "query_text": "SUMMARY: This function operates on three-element arrays of integers (ivec3). It takes two such input arrays, each containing three integers, and produces one output array (ivec3) where each position is assigned the greater of the corresponding elements from the two input arrays.",
        "code_id": "c_group_2_id_172",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    0x2c\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\njmp    0x32\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    0x59\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\njmp    0x60\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    0x8b\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\njmp    0x92\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x8,%rdx\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_143",
        "query_text": "SUMMARY: This function performs component-wise multiplication of two 4-dimensional floating-point vectors. It accepts two inputs of type vec4 (an aligned array of four floats) and produces an output of the same type (vec4) by calculating the product of corresponding elements from the inputs. The function utilizes the available SIMD instruction set on the target platform (such as WebAssembly SIMD, SSE, or NEON) to efficiently compute these multiplications, and it defaults to scalar operations when SIMD is not available.",
        "code_id": "c_group_2_id_143",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x58(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmov    -0x40(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x20(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\nmulps  -0x10(%rbp),%xmm0\nmov    -0x68(%rbp),%rax\nmov    %rax,-0x48(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmov    -0x48(%rbp),%rax\nmovaps -0x30(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_166",
        "query_text": "SUMMARY: This function accepts two input parameters of type float[3] and one output parameter of type float[3]. It computes the element\u2010wise sum of the two input float[3] arrays and stores the resulting float[3] array in the output parameter.",
        "code_id": "c_group_2_id_166",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_149",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, each of type float[2]. It performs an element-wise multiply-subtraction operation by multiplying each corresponding pair of elements from the input parameters and subtracting the result from the corresponding element in the output parameter.",
        "code_id": "c_group_2_id_149",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm1\nmulss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmulss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_146",
        "query_text": "SUMMARY: This function takes as inputs an array of three integers (ivec3), an integer scalar (int), and another array of three integers (ivec3) as output. Its functionality is to update each element of the output array by adding the result of subtracting the scalar from the corresponding element of the input array.",
        "code_id": "c_group_2_id_146",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_140",
        "query_text": "SUMMARY: This function takes a constant pointer to a float (input type: const float *) and a 2x2 float matrix (output type: mat2, defined as an array of two vec2 where vec2 is an array of 2 floats) as parameters. It constructs the 2x2 matrix by sequentially copying four float values from the input array into the matrix, placing the first two floats into the first row and the next two floats into the second row.",
        "code_id": "c_group_2_id_140",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_157",
        "query_text": "SUMMARY: This function accepts two inputs of type vec2 (arrays of two floats representing complex numbers with the first element as the real component and the second as the imaginary component) and produces an output of type vec2. It performs complex multiplication by calculating the real part as the product of the real components minus the product of the imaginary components, and the imaginary part as the sum of the cross-products of the real and imaginary components. The final computed real and imaginary parts are stored in the output array.",
        "code_id": "c_group_2_id_157",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmulss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  -0x8(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_182",
        "query_text": "SUMMARY: This function takes a 4\u00d74 floating\u2010point matrix (input type: mat4) and computes a 3-element floating\u2010point vector (output type: vec3) representing Euler angles. It extracts specific values from the matrix and then determines the Euler angles via conditional checks on one of the extracted values to handle different rotation scenarios while addressing potential singularities. The computed angles, corresponding to rotations about three principal axes, are then stored in the output vector.",
        "code_id": "c_group_2_id_182",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x8f\n\ncomiss -0x14(%rbp),%xmm0\njbe    0x15f\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0xa6\n\ncomiss %xmm1,%xmm0\njbe    0x118\nmov    -0x14(%rbp),%eax\nmovd   %eax,%xmm0\ncall   0xb7\nmovd   %xmm0,%eax\nmov    %eax,-0x24(%rbp)\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0xcb\n\nxorps  %xmm1,%xmm0\nmovd   %xmm0,%eax\nmovss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0xe3\nmovd   %xmm0,%eax\nmov    %eax,-0x28(%rbp)\nmovss  -0x18(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0xf7\n\nxorps  %xmm1,%xmm0\nmovd   %xmm0,%eax\nmovss  -0x1c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x10f\nmovd   %xmm0,%eax\nmov    %eax,-0x20(%rbp)\njmp    0x190\nmovss  0x0(%rip),%xmm0        # 0x120\n\nmovss  %xmm0,-0x24(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmov    -0x10(%rbp),%eax\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x139\nmovd   %xmm0,%eax\nmovss  0x0(%rip),%xmm0        # 0x145\n\nmovd   %eax,%xmm2\nxorps  %xmm0,%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm0,-0x28(%rbp)\npxor   %xmm0,%xmm0\nmovss  %xmm0,-0x20(%rbp)\njmp    0x190\nmovss  0x0(%rip),%xmm0        # 0x167\n\nmovss  %xmm0,-0x24(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmov    -0x10(%rbp),%eax\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x180\nmovd   %xmm0,%eax\nmov    %eax,-0x28(%rbp)\npxor   %xmm0,%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x40(%rbp),%rax\nmovss  -0x28(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x4,%rax\nmovss  -0x24(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x8,%rax\nmovss  -0x20(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_171",
        "query_text": "SUMMARY: This function takes as input a two-element integer array, an integer scalar, and a two-element integer array as output. It updates the output array by subtracting, from each of its elements, the result of subtracting the scalar from the corresponding element of the input array.",
        "code_id": "c_group_2_id_171",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_170",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two floats) and a scalar of type float, and it produces an output of type vec2. It computes a new vector by subtracting the scalar from each element of the input vector and stores the result in the output vector.",
        "code_id": "c_group_2_id_170",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nsubss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_156",
        "query_text": "SUMMARY: This function takes an input consisting of an array of three integers, a scalar integer, and an output array of three integers. It updates each element of the output array by subtracting, from its current value, the difference between the corresponding element of the input array and the scalar.",
        "code_id": "c_group_2_id_156",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_154",
        "query_text": "SUMMARY: This function takes two input parameters of type float[3] and computes their element-wise multiplication, producing an output parameter also of type float[3]. Specifically, it multiplies the first elements of the input arrays and stores the result as the first element in the output array, then does the same with the second and third elements respectively.",
        "code_id": "c_group_2_id_154",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_188",
        "query_text": "SUMMARY: The function receives a three-element array of floats serving as a 3-dimensional vector, a float scalar, and an output three-element float array. It computes the result of dividing each component of the input vector by the scalar, and stores these quotient values into the output vector.",
        "code_id": "c_group_2_id_188",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\ndivss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\ndivss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\ndivss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_165",
        "query_text": "SUMMARY: This function accepts an input of type float and an output variable of type vec3 (a 3-element array of float). It assigns the float value to every element in the array, effectively replicating (broadcasting) the input value across all three positions.",
        "code_id": "c_group_2_id_165",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_162",
        "query_text": "SUMMARY: This function receives a 3\u00d73 matrix of floating-point numbers (type mat3) as input and computes a single floating-point value (type float) by summing the elements located on the matrix's main diagonal (the first element of the first row, the second element of the second row, and the third element of the third row).",
        "code_id": "c_group_2_id_162",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\naddss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_138",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of type vec4 (a 4-element aligned array of floats). It performs an element-wise operation where it adds the corresponding values from the two input arrays and subtracts the result from the corresponding values in the output array, updating the output parameter with the computed differences.",
        "code_id": "c_group_2_id_138",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    -0x80(%rbp),%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x78(%rbp),%rax\nmov    %rax,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x20(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\naddps  -0x10(%rbp),%xmm0\nmov    -0x88(%rbp),%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x40(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmovaps -0x40(%rbp),%xmm0\nsubps  -0x30(%rbp),%xmm0\nmov    -0x88(%rbp),%rax\nmov    %rax,-0x70(%rbp)\nmovaps %xmm0,-0x50(%rbp)\nmov    -0x70(%rbp),%rax\nmovaps -0x50(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_136",
        "query_text": "SUMMARY: This function takes as input a three-element array of floats (vec3) that represent Euler angles and computes a four-element array of floats (versor) representing a quaternion. It converts the Euler angle representation into a quaternion form by calculating the sine and cosine of half-angles for rotations about the three axes in an XYZ order under a left-handed coordinate system, thus encapsulating the 3D rotation in a concise quaternion format.",
        "code_id": "c_group_2_id_136",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmovss  0x0(%rip),%xmm0        # 0xed\n\nmovd   %eax,%xmm2\nxorps  %xmm0,%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x110\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x121\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovss  -0x18(%rbp),%xmm1\nmulss  -0xc(%rbp),%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovss  -0x18(%rbp),%xmm1\nmulss  -0x10(%rbp),%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_191",
        "query_text": "SUMMARY: This function accepts three parameters, each of type float[2] (an array of two floats). The first and second inputs represent complex numbers (with the first element as the real part and the second as the imaginary part). The function computes the division of the first complex number by the second complex number, following the standard formula for complex division. It calculates the reciprocal of the squared norm of the second complex number, uses this value to compute the real part (as the sum of the products of corresponding real and imaginary components) and the imaginary part (as the difference of the cross products) of the quotient, and then stores these two components in the output parameter, which is also a float[2] array.",
        "code_id": "c_group_2_id_191",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmovss  0x0(%rip),%xmm0        # 0x50\n\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\nmovss  -0xc(%rbp),%xmm1\nmulss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm2\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmulss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\nmovss  -0xc(%rbp),%xmm1\nmulss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  -0x8(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_176",
        "query_text": "SUMMARY: This function receives an input of type vec4 (an array of four 32-bit floats) and a scalar of type float, and produces an output of type vec4. It scales the input vector by multiplying each of its four components by the scalar value, storing the resulting values into the output vector. Depending on the platform, it may use specialized SIMD operations for enhanced performance.",
        "code_id": "c_group_2_id_176",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x58(%rbp)\nmovss  %xmm0,-0x5c(%rbp)\nmov    %rsi,-0x68(%rbp)\nmovss  -0x5c(%rbp),%xmm0\nmovss  %xmm0,-0x44(%rbp)\nmovss  -0x44(%rbp),%xmm0\nshufps $0x0,%xmm0,%xmm0\nmovaps %xmm0,%xmm1\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x20(%rbp)\nmovaps %xmm1,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\nmulps  -0x10(%rbp),%xmm0\nmov    -0x68(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmov    -0x40(%rbp),%rax\nmovaps -0x30(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_178",
        "query_text": "SUMMARY: This function accepts three inputs, each being a two-element integer array (ivec2). It performs a component-wise addition by summing the corresponding elements of the first two inputs and then accumulates these sums with the corresponding elements of the third input. The modified third input, serving as the output, contains the results of this accumulation.",
        "code_id": "c_group_2_id_178",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nadd    %ecx,%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_189",
        "query_text": "SUMMARY: This function computes the product of a 4\u00d72 matrix and a 4-dimensional vector. It takes as input a matrix represented as an array of four 2-dimensional vectors (type mat4x2, i.e. float[2] arrays), and a 4-dimensional vector (type vec4, i.e. a 4-element float array with specific alignment). The function multiplies each element of the input vector with the corresponding elements in the matrix's columns, sums the products for each row of the matrix, and outputs the resulting 2-dimensional vector (type vec2, a 2-element float array).",
        "code_id": "c_group_2_id_189",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_179",
        "query_text": "SUMMARY: This function performs a component-wise subtraction between two 3-element integer arrays, where each input is of type ivec3 (an array of three integers). It subtracts the corresponding element of the second array from the first array and stores each resulting difference in a third ivec3 output array.",
        "code_id": "c_group_2_id_179",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_168",
        "query_text": "SUMMARY: This function accepts a source input of type const float* and an output of type mat3x4 (a 3-element array where each element is an aligned 4-element array of floats). It sequentially copies 12 float values from the flat source array into the 3x4 matrix, populating each of the three rows with four consecutive float values in order.",
        "code_id": "c_group_2_id_168",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x14(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x28(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x2c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_186",
        "query_text": "SUMMARY: This function accepts a mutable 3\u00d73 matrix of floats (of type mat3) and two integer values specifying row indices. Its purpose is to exchange the two specified rows within the matrix, modifying the input matrix in place without returning any value.",
        "code_id": "c_group_2_id_186",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %edx,-0x30(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x28(%rbp),%rax\nmov    -0x2c(%rbp),%edx\nmovslq %edx,%rdx\nmovss  (%rax,%rdx,4),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nmov    -0x30(%rbp),%edx\nmovslq %edx,%rdx\nmovss  (%rax,%rdx,4),%xmm0\nmov    -0x28(%rbp),%rax\nmov    -0x2c(%rbp),%edx\nmovslq %edx,%rdx\nmovss  %xmm0,(%rax,%rdx,4)\nmov    -0x28(%rbp),%rax\nlea    0xc(%rax),%rcx\nmov    -0x28(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x30(%rbp),%eax\ncltq   \nmovss  (%rcx,%rax,4),%xmm0\nmov    -0x2c(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nmov    -0x28(%rbp),%rax\nlea    0x18(%rax),%rcx\nmov    -0x28(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x30(%rbp),%eax\ncltq   \nmovss  (%rcx,%rax,4),%xmm0\nmov    -0x2c(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nmovss  -0x14(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmov    -0x30(%rbp),%edx\nmovslq %edx,%rdx\nmovss  %xmm0,(%rax,%rdx,4)\nmov    -0x28(%rbp),%rax\nlea    0xc(%rax),%rdx\nmovss  -0x10(%rbp),%xmm0\nmov    -0x30(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nmov    -0x28(%rbp),%rax\nlea    0x18(%rax),%rdx\nmovss  -0xc(%rbp),%xmm0\nmov    -0x30(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x124\ncall   0x124\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_159",
        "query_text": "SUMMARY: This function accepts two input variables and one output variable, each being an array of four integers (ivec4). For each of the four integer positions, it computes the product of the corresponding integers from the two input arrays and then adds that product to the integer at the corresponding position in the output array.",
        "code_id": "c_group_2_id_159",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %edx,%eax\nlea    (%rcx,%rax,1),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_147",
        "query_text": "SUMMARY: This function accepts two inputs: a 3\u00d73 matrix of floats (of type mat3, which is defined as an array of three vec3 arrays where each vec3 is an array of three floats) and a pointer to a FILE stream (of type FILE*). Its purpose is to format and print the matrix to the provided output stream. It first determines the appropriate field widths for each element, then prints the matrix with a header and formatted rows (including colorized output) to ensure proper alignment and visual clarity. The function does not return any value (void).",
        "code_id": "c_group_2_id_147",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x50(%rbp),%rax\nmov    $0x3,%ecx\nmov    $0x3,%edx\nlea    0x0(%rip),%rsi        # 0x38\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x45\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,-0x30(%rbp)\nmovl   $0x0,-0x3c(%rbp)\njmp    0x195\nmovl   $0x0,-0x38(%rbp)\njmp    0x187\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x9f\n\ncomiss %xmm1,%xmm0\njbe    0x104\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovq   %xmm2,%rdx\nlea    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdx        # 0xed\nmov    $0x10,%esi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xff\nmov    %eax,-0x34(%rbp)\njmp    0x15d\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm3,%xmm3\ncvtss2sd %xmm0,%xmm3\nmovq   %xmm3,%rdx\nlea    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0x148\nmov    $0x10,%esi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x15a\nmov    %eax,-0x34(%rbp)\nmov    -0x3c(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%eax\ncmp    %eax,-0x34(%rbp)\njge    0x176\nmov    -0x3c(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%eax\njmp    0x179\nmov    -0x34(%rbp),%eax\nmov    -0x3c(%rbp),%edx\nmovslq %edx,%rdx\nmov    %eax,-0x30(%rbp,%rdx,4)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x2,-0x38(%rbp)\njle    0x70\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x2,-0x3c(%rbp)\njle    0x64\nmovl   $0x0,-0x3c(%rbp)\njmp    0x2fb\nmov    -0x50(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x3,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x1c3\nmov    %rax,%rdi\ncall   0x1cb\nmovl   $0x0,-0x38(%rbp)\njmp    0x2cd\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x206\n\ncomiss %xmm1,%xmm0\njbe    0x26c\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x3c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm4,%xmm4\ncvtss2sd %xmm0,%xmm4\nmovq   %xmm4,%rcx\nmov    -0x38(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%edx\nmov    -0x50(%rbp),%rax\nmovq   %rcx,%xmm0\nmov    $0x5,%ecx\nlea    0x0(%rip),%rsi        # 0x25d\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x26a\njmp    0x2c9\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x3c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm5,%xmm5\ncvtss2sd %xmm0,%xmm5\nmovq   %xmm5,%rcx\nmov    -0x38(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%edx\nmov    -0x50(%rbp),%rax\nmovq   %rcx,%xmm0\nlea    0x0(%rip),%rcx        # 0x2b9\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x2c9\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x2,-0x38(%rbp)\njle    0x1d7\nmov    -0x50(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x4,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x2ef\nmov    %rax,%rdi\ncall   0x2f7\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x2,-0x3c(%rbp)\njle    0x1ab\nmov    -0x50(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x5,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x31d\nmov    %rax,%rdi\ncall   0x325\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x33a\ncall   0x33a\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_142",
        "query_text": "SUMMARY: This function takes three parameters of type vec4 (each being a 4-element aligned array of floats). It computes the element-wise difference between the first two 4-element float arrays and then adds that difference to the elements of the third 4-element float array, effectively updating it so that for each index the new value becomes the original value plus the difference between the corresponding elements of the first and second arrays. Optimized implementations are used when available, but the core behavior is to perform dest[i] = dest[i] + (a[i] - b[i]) for all indices.",
        "code_id": "c_group_2_id_142",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    -0x80(%rbp),%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x78(%rbp),%rax\nmov    %rax,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x20(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\nsubps  -0x10(%rbp),%xmm0\nmov    -0x88(%rbp),%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x40(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmovaps -0x40(%rbp),%xmm0\naddps  -0x30(%rbp),%xmm0\nmov    -0x88(%rbp),%rax\nmov    %rax,-0x70(%rbp)\nmovaps %xmm0,-0x50(%rbp)\nmov    -0x70(%rbp),%rax\nmovaps -0x50(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_161",
        "query_text": "SUMMARY: This function takes a source and a destination, each of type mat3x2 (an array of three vec2, where each vec2 is an array of two floats), and copies the entire 3x2 matrix from the source to the destination by directly assigning each corresponding floating-point element.",
        "code_id": "c_group_2_id_161",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_148",
        "query_text": "SUMMARY: This function accepts an input of type \"mat4\" (a 4x4 matrix of 4-element float vectors) and computes a single output of type \"float\". It operates by summing the three diagonal elements from the first, second, and third rows (i.e., the elements at positions [0][0], [1][1], and [2][2]) of the provided 4x4 matrix, and returns this sum.",
        "code_id": "c_group_2_id_148",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\naddss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_183",
        "query_text": "SUMMARY: This function takes as input a 2-element float array, a float scalar, and another 2-element float array as its output container. It multiplies each element of the first array by the scalar value and then adds the resulting products to the corresponding elements in the output array, updating it in place.",
        "code_id": "c_group_2_id_183",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_192",
        "query_text": "SUMMARY: This function accepts an input variable of type vec4 (a CGLM-aligned array of four floats) and produces an output variable of the same type. It computes, for each floating-point element in the input array, the largest integer value not greater than that element (i.e., the floor operation), and assigns these computed values to the corresponding elements in the output array.",
        "code_id": "c_group_2_id_192",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x24\nmovd   %xmm0,%eax\nmov    -0x20(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovd   %eax,%xmm0\ncall   0x49\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nlea    0x8(%rdx),%rbx\nmovd   %eax,%xmm0\ncall   0x6a\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nlea    0xc(%rdx),%rbx\nmovd   %eax,%xmm0\ncall   0x8b\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_190",
        "query_text": "SUMMARY: This function accepts two input arrays, each consisting of 3 integers, and an output array of 3 integers. For each of the three positions, it evaluates the sum of the respective integers from the two input arrays and then adds this result to the corresponding integer already present in the output array.",
        "code_id": "c_group_2_id_190",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nadd    %ecx,%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_202",
        "query_text": "SUMMARY: This function accepts two inputs of type ivec3 (arrays containing three integers) and computes an output of the same type. It performs an element-wise modulo operation by taking, for each index, the remainder of the division of the corresponding integer from the first input by the integer from the second input, and stores the result in the matching index of the output.",
        "code_id": "c_group_2_id_202",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nmov    (%rdx),%ecx\ncltd   \nidiv   %ecx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%esi\nmov    -0x18(%rbp),%rdx\nlea    0x4(%rdx),%rcx\ncltd   \nidiv   %esi\nmov    %edx,%eax\nmov    %eax,(%rcx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x8,%rdx\nmov    (%rdx),%esi\nmov    -0x18(%rbp),%rdx\nlea    0x8(%rdx),%rcx\ncltd   \nidiv   %esi\nmov    %edx,%eax\nmov    %eax,(%rcx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_187",
        "query_text": "SUMMARY: This function takes as inputs a float value and a 4x4 matrix (of type vec4[4]). The function checks if the first element of the matrix (i.e., the first element of the first row) is zero; if it is, no changes occur. Otherwise, the function updates that element by dividing the second diagonal element of the matrix by the float input. The function returns no output as it modifies the matrix in place.",
        "code_id": "c_group_2_id_187",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\npxor   %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njp     0x2b\npxor   %xmm1,%xmm1\nucomiss %xmm1,%xmm0\nje     0x47\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\njmp    0x48\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_207",
        "query_text": "SUMMARY: This function accepts a three-element array of floats (vec3) as input along with a float value. It assigns the given float value to each element of the array, effectively filling the vector. The function does not return any value.",
        "code_id": "c_group_2_id_207",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_195",
        "query_text": "SUMMARY: This function takes two 3-element arrays of floats (vec3) as inputs and a third 3-element array of floats (vec3) as the output. It computes the element-wise product of the two input arrays and then adds each resulting product to the corresponding element of the output array.",
        "code_id": "c_group_2_id_195",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_197",
        "query_text": "SUMMARY: This function accepts two inputs of type vec4 (which is an array of four floats) and produces an output also of type vec4. It computes the element-wise arithmetic negation of the input vector and stores the resulting values in the output vector. The implementation adapts to available hardware acceleration (such as WebAssembly SIMD, SSE, or NEON) to perform the negation efficiently, with a fallback to scalar operations if necessary.",
        "code_id": "c_group_2_id_197",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x8,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmovl   $0x80000000,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x60(%rbp)\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x5c(%rbp)\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x58(%rbp)\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x54(%rbp)\nmov    -0x60(%rbp),%eax\nmov    -0x5c(%rbp),%edx\nmovd   %edx,%xmm1\nmovd   %eax,%xmm2\npunpckldq %xmm2,%xmm1\nmov    -0x58(%rbp),%eax\nmov    -0x54(%rbp),%edx\nmovd   %edx,%xmm0\nmovd   %eax,%xmm3\npunpckldq %xmm3,%xmm0\npunpcklqdq %xmm1,%xmm0\nnop\nmovaps %xmm0,-0x10(%rbp)\nmovaps -0x10(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nmov    %rax,-0x48(%rbp)\nmov    -0x48(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x30(%rbp)\nmovaps %xmm0,-0x20(%rbp)\nmovaps -0x30(%rbp),%xmm0\nxorps  -0x20(%rbp),%xmm0\nnop\nmov    -0x80(%rbp),%rax\nmov    %rax,-0x50(%rbp)\nmovaps %xmm0,-0x40(%rbp)\nmov    -0x50(%rbp),%rax\nmovaps -0x40(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_194",
        "query_text": "SUMMARY: The function accepts a 3x3 matrix of type float (mat3) and a scalar of type float as inputs, and it does not return any value (void). It modifies the input matrix by applying a 2D translation along the y-axis. Specifically, it updates the elements in the third row of the matrix by incrementing them with the product of a corresponding element from the second row and the scalar input, effectively incorporating a translation component along the y direction into the matrix representation.",
        "code_id": "c_group_2_id_194",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_201",
        "query_text": "SUMMARY: This function computes the determinant of a 2\u00d72 matrix. It accepts as input a matrix of type mat2 (a 2\u00d72 array of floats, with each row represented as a vec2) and returns a float. Internally, it multiplies the top-left element with the bottom-right element and subtracts the product of the bottom-left element with the top-right element to produce the determinant as output.",
        "code_id": "c_group_2_id_201",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm2\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm1\nmulss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_134",
        "query_text": "SUMMARY: This function accepts three inputs: a reference to an output stream (std::ostream&), a pointer to an encoding function (EncodingFn, defined as void(*)(std::ostream&, int)), and an integer representing a Unicode code point (int). It determines whether the integer exceeds or equals 0x10000. If it does, the function computes two surrogate code unit values corresponding to the high and low parts of the UTF-16 representation of the Unicode code point, calls the encoding function to output these two surrogate integers to the provided output stream, and returns a boolean true. If the integer is below 0x10000, it returns false without processing further.",
        "code_id": "c_group_2_id_134",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nsub    $0x10000,%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njns    0x2f\nmov    $0x0,%eax\njmp    0x72\nmov    -0xc(%rbp),%eax\nsar    $0xa,%eax\nor     $0xd8,%ah\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nand    $0x3ff,%eax\nor     $0xdc,%ah\nmov    %eax,-0x4(%rbp)\nmov    -0x20(%rbp),%rcx\nmov    -0x8(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   *%rcx\nmov    -0x20(%rbp),%rcx\nmov    -0x4(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   *%rcx\nmov    $0x1,%eax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_200",
        "query_text": "SUMMARY: This function computes and returns the trace of a 4\u00d74 matrix. It takes as input a parameter of type mat4 (an aligned 4\u00d74 matrix composed of four arrays of four floating-point numbers each) and produces a scalar output of type float. Specifically, the function sums the diagonal elements of the matrix, which are the elements located at the positions (0,0), (1,1), (2,2), and (3,3).",
        "code_id": "c_group_2_id_200",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0xc(%rax),%xmm0\naddss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_209",
        "query_text": "SUMMARY: This function takes two inputs of type int[2] and produces an output of type int[2] by computing the element-wise product of the two input arrays. Specifically, it multiplies the first element of one input with the first element of the other, and similarly for the second element, placing the results in the output array.",
        "code_id": "c_group_2_id_209",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_205",
        "query_text": "SUMMARY: This function accepts two input parameters of type ivec3 (arrays of three integers) and one output parameter of the same type. For each of the three integer elements, it computes the product of the corresponding elements from the input parameters and then subtracts that product from the corresponding element in the output array.",
        "code_id": "c_group_2_id_205",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %ecx,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_193",
        "query_text": "SUMMARY: This function takes as input a matrix of type mat4 (an array of four aligned vec4 elements, where each vec4 is an array of four floats) and produces no direct output (void return). It sets every element of the provided 4\u00d74 matrix to zero. Depending on the hardware capabilities (WebAssembly SIMD, AVX, SSE, NEON), it uses specific SIMD instructions to efficiently fill the matrix with zeros; if none are available, it falls back to a standard method to achieve the same zero-initialization.",
        "code_id": "c_group_2_id_193",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x8,%rsp\nmov    %rdi,-0x78(%rbp)\npxor   %xmm0,%xmm0\nmovaps %xmm0,-0x50(%rbp)\nmov    -0x78(%rbp),%rax\nmov    %rax,-0x58(%rbp)\nmovaps -0x50(%rbp),%xmm0\nmovaps %xmm0,-0x10(%rbp)\nmov    -0x58(%rbp),%rax\nmovaps -0x10(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x78(%rbp),%rax\nadd    $0x10,%rax\nmov    %rax,-0x60(%rbp)\nmovaps -0x50(%rbp),%xmm0\nmovaps %xmm0,-0x20(%rbp)\nmov    -0x60(%rbp),%rax\nmovaps -0x20(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x78(%rbp),%rax\nadd    $0x20,%rax\nmov    %rax,-0x68(%rbp)\nmovaps -0x50(%rbp),%xmm0\nmovaps %xmm0,-0x30(%rbp)\nmov    -0x68(%rbp),%rax\nmovaps -0x30(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x78(%rbp),%rax\nadd    $0x30,%rax\nmov    %rax,-0x70(%rbp)\nmovaps -0x50(%rbp),%xmm0\nmovaps %xmm0,-0x40(%rbp)\nmov    -0x70(%rbp),%rax\nmovaps -0x40(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_214",
        "query_text": "SUMMARY: This function accepts three parameters: the first is an input two-element vector of type int[2], the second is a scalar integer (type int), and the third is an output two-element vector of type int[2]. The function multiplies each element of the input vector by the scalar integer and then adds the resulting product to the corresponding element of the output vector.",
        "code_id": "c_group_2_id_214",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_212",
        "query_text": "SUMMARY: This function accepts an input of a three-element array of integers and a single integer scalar, then outputs a three-element array of integers. It performs element-wise division of the array's integers by the scalar and stores the results in the output array.",
        "code_id": "c_group_2_id_212",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncltd   \nidivl  -0xc(%rbp)\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nlea    0x4(%rdx),%rcx\ncltd   \nidivl  -0xc(%rbp)\nmov    %eax,(%rcx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nlea    0x8(%rdx),%rcx\ncltd   \nidivl  -0xc(%rbp)\nmov    %eax,(%rcx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_203",
        "query_text": "SUMMARY: This function operates on a 4\u00d74 matrix of floats (input type: mat4) and produces two float outputs (output type: float*, representing left and right boundaries). It extracts specific coefficients from the matrix that are related to the perspective projection setup, computes the near-plane depth from these coefficients, and then calculates the horizontal extents (left and right) of the viewing frustum for a right\u2010handed, no-offset configuration.",
        "code_id": "c_group_2_id_203",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm2        # 0x5e\n\nsubss  %xmm2,%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x78\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0x10(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x9b\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0x10(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_199",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of which are arrays of three floats (vec3). It updates the output parameter by subtracting, for each component, the difference between the corresponding elements of the first and second input arrays. Essentially, for each index (0, 1, 2), it performs the operation output[i] = output[i] - (first_input[i] - second_input[i]).",
        "code_id": "c_group_2_id_199",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm2\nsubss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nsubss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm2\nsubss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_217",
        "query_text": "SUMMARY: This function performs an element-wise subtraction between two inputs of type float[3] and stores the result in an output of type float[3]. Specifically, it computes the subtraction for each corresponding index of the input arrays and assigns the result to the corresponding index of the output array.",
        "code_id": "c_group_2_id_217",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_206",
        "query_text": "SUMMARY: This function takes a 3-element floating\u2010point vector (vec3) representing Euler angles and produces a 4\u00d74 floating\u2010point matrix (mat4) that encodes a 3D rotation using a Z\u2013Y\u2013X rotation order. It computes the sine and cosine of each angle and uses intermediate multiplications to construct the rotation submatrix, then sets the remaining parts of the matrix to form a proper homogeneous transformation matrix with zero translation and a unit scale for the homogeneous coordinate.",
        "code_id": "c_group_2_id_206",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x23\nmovd   %xmm0,%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x39\nmovd   %xmm0,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x53\nmovd   %xmm0,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x6d\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x87\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0xa1\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x24(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x1c(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x107\n\nxorps  %xmm1,%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmovss  -0x20(%rbp),%xmm1\nmulss  -0x14(%rbp),%xmm1\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\naddss  -0x8(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x24(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x1c(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nsubss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x0(%rip),%xmm0        # 0x235\n\nmovss  %xmm0,0xc(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_198",
        "query_text": "SUMMARY: This function operates on three variables, each of type integer vector of size 3 (int[3]). It modifies the output vector by subtracting, for each of its three components, the difference between the corresponding components of the first and second integer vectors. In effect, for every component index, the function computes \"output component minus (first vector component minus second vector component)\".",
        "code_id": "c_group_2_id_198",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nsub    %eax,%ecx\nsub    %ecx,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rcx\nadd    $0x4,%rcx\nmov    (%rcx),%ecx\nsub    %ecx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %esi,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rcx\nadd    $0x8,%rcx\nmov    (%rcx),%ecx\nsub    %ecx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %esi,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_204",
        "query_text": "SUMMARY: This function takes as inputs an array of two floats (vec2) and a pointer to a FILE stream. It produces a formatted text representation of the two-element vector by writing to the provided FILE stream. Specifically, it outputs a header indicating the vector's type with color formatting, then prints each float element using either a fixed-precision or general format depending on its value relative to a defined threshold, and finally resets the formatting before finishing. The function does not return any value.",
        "code_id": "c_group_2_id_204",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    $0x2,%edx\nlea    0x0(%rip),%rcx        # 0x24\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x34\nmovl   $0x0,-0x4(%rbp)\njmp    0xfa\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x60\n\ncomiss %xmm1,%xmm0\njbe    0xb1\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovq   %xmm2,%rdx\nmov    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nmov    $0x5,%edx\nlea    0x0(%rip),%rcx        # 0x9f\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xaf\njmp    0xf6\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm3,%xmm3\ncvtss2sd %xmm0,%xmm3\nmovq   %xmm3,%rdx\nmov    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0xe6\nmov    %rdx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xf6\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njle    0x40\nmov    -0x20(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x9,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x11c\nmov    %rax,%rdi\ncall   0x124\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_235",
        "query_text": "SUMMARY: This function takes as input a 3\u00d73 matrix (of type float[3][3]) and a floating-point value representing an angle. It modifies the matrix in place by applying a 2D rotation transformation based on the given angle. Internally, it calculates the sine and cosine of the angle and updates the matrix\u2019s first two rows to represent the rotated coordinates, leaving the remainder of the matrix unchanged. The output is the transformed 3\u00d73 matrix.",
        "code_id": "c_group_2_id_235",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x2c(%rbp),%eax\nmovd   %eax,%xmm0\ncall   0x7f\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x2c(%rbp),%eax\nmovd   %eax,%xmm0\ncall   0x92\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x20(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x18(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x10(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x111\n\nxorps  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x143\n\nxorps  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x176\n\nxorps  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_215",
        "query_text": "SUMMARY: This function takes two inputs of type mat4x2 (an array of 4 vec2 arrays, where each vec2 is defined as an array of 2 floats) and copies the elements from the source input to the destination output. Specifically, it transfers each of the four rows, with their two float components, from the input mat4x2 to the corresponding positions in the output mat4x2.",
        "code_id": "c_group_2_id_215",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_228",
        "query_text": "SUMMARY: This function takes an input of a 3-element array of floats and a scalar float, and produces an output of a 3-element array of floats where each element is the result of multiplying the corresponding element of the input array by the scalar. The function multiplies the first element by the scalar, then the second, and finally the third, storing each result in the output array.",
        "code_id": "c_group_2_id_228",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_196",
        "query_text": "SUMMARY: This function takes a three-element integer array (ivec3), a scalar integer, and another three-element integer array (ivec3) as inputs. It updates the latter by adding, element-wise, the sum of the corresponding element from the first array and the scalar to each element already present in the output array.",
        "code_id": "c_group_2_id_196",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %ecx,%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_216",
        "query_text": "SUMMARY: This function takes as input a two-dimensional matrix of type \"mat2\" (an aligned array of two 2-element \"vec2\" arrays containing floats) and two integers representing row indices. Its functionality is to exchange the data of the two specified rows within the matrix by swapping the corresponding float values in each column, without returning any value (the matrix is modified in place).",
        "code_id": "c_group_2_id_216",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nmovss  (%rax,%rdx,4),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x20(%rbp),%edx\nmovslq %edx,%rdx\nmovss  (%rax,%rdx,4),%xmm0\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nmovss  %xmm0,(%rax,%rdx,4)\nmov    -0x18(%rbp),%rax\nlea    0x8(%rax),%rcx\nmov    -0x18(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x20(%rbp),%eax\ncltq   \nmovss  (%rcx,%rax,4),%xmm0\nmov    -0x1c(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nmov    -0x18(%rbp),%rax\nmov    -0x20(%rbp),%edx\nmovslq %edx,%rdx\nmovss  -0x8(%rbp),%xmm0\nmovss  %xmm0,(%rax,%rdx,4)\nmov    -0x18(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x20(%rbp),%eax\ncltq   \nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rdx,%rax,4)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_220",
        "query_text": "SUMMARY: The function accepts two input arrays of type int[2] and produces an output array of type int[2]. It computes the component-wise minimum between the corresponding elements of the two input arrays and stores the resulting minimum values in the output array.",
        "code_id": "c_group_2_id_220",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    0x2c\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\njmp    0x32\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    0x59\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\njmp    0x60\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_211",
        "query_text": "SUMMARY: This inline function takes a single parameter\u2014a three-element array of floats (type: float[3])\u2014as input and produces no return value (type: void). Its functionality is to initialize each element of the provided array to 0.0f, effectively setting the vector to a zero state.",
        "code_id": "c_group_2_id_211",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_225",
        "query_text": "SUMMARY: This function accepts two input parameters, each of type vec2 (a float array of two elements), and returns a float. It calculates and outputs a scalar value by computing the difference between the product of the first element of the first input and the second element of the second input, and the product of the second element of the first input and the first element of the second input.",
        "code_id": "c_group_2_id_225",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm1\nmulss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_213",
        "query_text": "SUMMARY: This function takes a 4\u00d74 projection matrix (of type mat4, defined as an array of four vec4, where each vec4 is a float[4]) as its primary input. It then decomposes this matrix into its perspective frustum parameters by computing the near and far clipping distances (as floats) and the top, bottom, left, and right extents (also as floats). The outputs are provided via pointers to floats. Essentially, the function interprets the projection matrix for a left-handed, zero-depth configuration and extracts the corresponding frustum boundaries without delving into low-level detail of the underlying transformation mechanics.",
        "code_id": "c_group_2_id_213",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %rcx,-0x50(%rbp)\nmov    %r8,-0x58(%rbp)\nmov    %r9,-0x60(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x77\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\ndivss  -0x18(%rbp),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x18(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xad\n\naddss  %xmm0,%xmm1\nmovss  -0x14(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x10(%rbp),%xmm0\ndivss  -0x24(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x10(%rbp),%xmm0\ndivss  -0x28(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x40(%rbp),%rax\nmovss  -0x10(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x48(%rbp),%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x1c(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x104\n\nsubss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x1c(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x122\n\naddss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x50(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x20(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x140\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x60(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x20(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x15e\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_208",
        "query_text": "SUMMARY: This function processes a matrix of type mat3 (a 3\u00d73 array of float values) by computing its transpose in place. It effectively interchanges the matrix's off-diagonal elements so that the rows become columns and vice versa, updating the original matrix with its transposed form.",
        "code_id": "c_group_2_id_208",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x2c(%rbp),%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x28(%rbp),%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\nmovss  -0x24(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\nmovss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x38(%rbp),%rax\nadd    $0x18,%rax\nmovss  -0x18(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x38(%rbp),%rax\nadd    $0x18,%rax\nmovss  -0x14(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xf8\ncall   0xf8\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_253",
        "query_text": "SUMMARY: This function receives a 3-element integer array (type: int[3]) and a pointer to a file stream (type: FILE*) as inputs, and it outputs information to that stream. It formats and prints the vector elements by first indicating the vector's type and size, then listing each integer element with specified formatting (including color settings), and finally resetting the formatting. The function does not return any value.",
        "code_id": "c_group_2_id_253",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    $0x3,%edx\nlea    0x0(%rip),%rcx        # 0x24\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x34\nmovl   $0x0,-0x4(%rbp)\njmp    0x72\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x5e\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x6e\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x2,-0x4(%rbp)\njle    0x3d\nmov    -0x20(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x9,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x90\nmov    %rax,%rdi\ncall   0x98\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_236",
        "query_text": "SUMMARY: This function takes a two-element integer array (ivec2) and an integer scalar as inputs, and it produces a two-element integer array as output. It adds the scalar value to each element of the input array and stores the results in the output array.",
        "code_id": "c_group_2_id_236",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    -0xc(%rbp),%edx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_250",
        "query_text": "SUMMARY: This function takes an input of type mat3x2 (an array of three 2-element float arrays) and produces an output of type mat2x3 (an array of two 3-element float arrays). It computes the transpose of the matrix by swapping the rows and columns, assigning each element from the input to the corresponding position in the output matrix.",
        "code_id": "c_group_2_id_250",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_221",
        "query_text": "SUMMARY: This function operates on two variables of the type \"mat3\", where \"mat3\" is defined as a 3x3 array of floats. It takes a source 3x3 float matrix and copies each element of the source matrix to a destination 3x3 float matrix, effectively duplicating all nine elements from the input to the output.",
        "code_id": "c_group_2_id_221",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_224",
        "query_text": "SUMMARY: This function operates on an input of type mat4 (a 4x4 array of float values) along with a float scalar. It scales the entire mat4 matrix by multiplying every element within it by the float. The operation modifies the input matrix in place, and the function returns no value.",
        "code_id": "c_group_2_id_224",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0xc(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0xc(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_244",
        "query_text": "SUMMARY: This function takes a two-element integer array and a single integer as inputs, and outputs a two-element integer array. It multiplies each element of the input array by the given scalar integer, then subtracts each resulting product from the corresponding element in the output array.",
        "code_id": "c_group_2_id_244",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_223",
        "query_text": "SUMMARY: This function accepts two arrays of four integers and one integer scalar. It multiplies each element of the first integer array by the scalar and then subtracts the resulting product from the corresponding element of the second integer array, updating the second array with these new values.",
        "code_id": "c_group_2_id_223",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_232",
        "query_text": "SUMMARY: The function accepts two 2-element arrays of integers as input and a 2-element array of integers as output. It subtracts the sum of the corresponding elements of the input arrays from the corresponding elements in the output array. Specifically, it decreases the first element of the output by the sum of the first elements from both inputs and does the same for the second element.",
        "code_id": "c_group_2_id_232",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nadd    %ecx,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_233",
        "query_text": "SUMMARY: This function accepts a 4x4 floating point matrix (mat4) and a floating point value (float) as inputs and produces no direct output (void). It modifies the received matrix by adding the provided float value to the element located at the fourth row and second column, thereby adjusting the y-direction translation component of the matrix.",
        "code_id": "c_group_2_id_233",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\naddss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_226",
        "query_text": "SUMMARY: This function accepts an input of type a three-element array of float values (vec3) and produces an output of the same type. It computes the absolute value of each of the three float components in the input array and assigns these computed values into the corresponding positions of the output array. Line by line, the function applies a floating-point absolute value operation individually to each of the three elements.",
        "code_id": "c_group_2_id_226",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x20\n\nandps  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  0x0(%rip),%xmm1        # 0x47\n\nandps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x0(%rip),%xmm1        # 0x6a\n\nandps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_229",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (type: mat4) and a float (type: float) as input, and it outputs a modified 4\u00d74 matrix. It adjusts the perspective projection parameters by recalculating the near and far plane distances based on specific entries in the input matrix and an additional scalar offset. The function then updates particular entries of the matrix to effectively shift the far plane position further along the depth axis for a right-handed coordinate system with a zero-to-one depth range.",
        "code_id": "c_group_2_id_229",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x10(%rbp),%xmm0\ndivss  -0x14(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x14(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x51\n\naddss  %xmm0,%xmm1\nmovss  -0x10(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  -0x2c(%rbp),%xmm1\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nsubss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x81\n\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x30,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_249",
        "query_text": "SUMMARY: The function takes a scalar (float) and a four-by-four matrix of floats (mat4) as inputs, modifying the matrix to update its horizontal scaling based on the given aspect ratio. It first checks a critical element in the matrix to determine if adjustment is required; if that element is zero, it returns without change. Otherwise, it recalculates that element using another scaling value from the matrix divided by the input scalar, thereby adjusting the perspective projection parameters accordingly.",
        "code_id": "c_group_2_id_249",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\npxor   %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njp     0x2b\npxor   %xmm1,%xmm1\nucomiss %xmm1,%xmm0\nje     0x47\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\njmp    0x48\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_222",
        "query_text": "SUMMARY: This function takes as input a matrix of type mat3x4 (an array of 3 vectors, each containing 4 floats) and outputs a matrix of type mat4x3 (an array of 4 vectors, each containing 3 floats). Its functionality is to compute the transpose of the input 3\u00d74 matrix, effectively converting rows into columns by reassigning each element\u2019s position accordingly.",
        "code_id": "c_group_2_id_222",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x24,%rax\nmovss  0xc(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x24,%rax\nmovss  0xc(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_218",
        "query_text": "SUMMARY: This function converts a set of Euler angles to a quaternion representation using a right-handed coordinate system with a YXZ rotation order. It accepts an input of type vec3 (a three-element array of floats representing the Euler angles) and produces an output of type versor (a four-element array of floats representing the resulting quaternion). The function computes sine and cosine values of half of each angle and then combines these to form the quaternion's components through a series of multiplications and additions.",
        "code_id": "c_group_2_id_218",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xfc\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x10d\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x14e\n\nxorps  %xmm1,%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmovss  -0x10(%rbp),%xmm1\nmulss  -0x18(%rbp),%xmm1\nmulss  -0x4(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_255",
        "query_text": "SUMMARY: This function accepts an input and an output of type mat4 (an array of four vec4 arrays of float values, representing a 4\u00d74 matrix). It duplicates the matrix by copying each float element from the input matrix to its corresponding position in the output matrix. The process is implemented through explicit element-wise assignment for all rows and columns of the 4\u00d74 matrix.",
        "code_id": "c_group_2_id_255",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x30(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x30,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x30(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x30(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  0xc(%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x30(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x30,%rax\nmovss  0xc(%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_231",
        "query_text": "SUMMARY: This function accepts as input a 3-element floating\u2010point vector (vec3) representing Euler angles (assumed in zxy order) and produces as output a 4\u00d74 floating\u2010point matrix (mat4) that represents the corresponding rotation transformation. It computes the sine and cosine values for each angle, evaluates intermediate products based on these trigonometric results, and uses them to assemble the rotation matrix. The output matrix is structured as a homogeneous transformation matrix\u2014with the rotational submatrix in its upper 3\u00d73 portion and the remainder set to form the identity in terms of translation and scaling.",
        "code_id": "c_group_2_id_231",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x23\nmovd   %xmm0,%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x39\nmovd   %xmm0,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x53\nmovd   %xmm0,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x6d\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x87\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0xa1\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x14(%rbp),%xmm1\nmovss  -0xc(%rbp),%xmm0\nsubss  %xmm1,%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  -0x4(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x20(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x118\n\nxorps  %xmm1,%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0x20(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x136\n\nxorps  %xmm1,%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0x14(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x24(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x10(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x1c(%rbp),%xmm1\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x24(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x1a7\n\nxorps  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x24(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x0(%rip),%xmm0        # 0x255\n\nmovss  %xmm0,0xc(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_234",
        "query_text": "SUMMARY: This function converts a set of three Euler angles (input as a vec3, which is an array of three floats) into a quaternion representation (output as a versor, which is an array of four floats) for a left-handed coordinate system using a YZX rotation order. The function begins by computing the half-angle sine and cosine values for each of the three input angles\u2014modifying the third component by inverting the sine to accommodate the left-handed system. It then combines these trigonometric values in a specific manner to calculate the four components of the quaternion, representing the rotation defined by the original Euler angles.",
        "code_id": "c_group_2_id_234",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmovss  0x0(%rip),%xmm0        # 0xed\n\nmovd   %eax,%xmm2\nxorps  %xmm0,%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x110\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x121\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  -0x10(%rbp),%xmm1\nmulss  -0x4(%rbp),%xmm1\nmulss  -0x18(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  -0x10(%rbp),%xmm1\nmulss  -0x8(%rbp),%xmm1\nmulss  -0x18(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_251",
        "query_text": "SUMMARY: This function accepts an input of type float[2] and produces an output of type float[2]. It computes the absolute value for each element of the input array and assigns these results to the corresponding elements of the output array.",
        "code_id": "c_group_2_id_251",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x20\n\nandps  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  0x0(%rip),%xmm1        # 0x47\n\nandps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_210",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of 2 floats) and produces an output of the same type. For each element in the input, the function computes its fractional component by subtracting the integer part (as determined by the floor operation), and then limits the resulting value so that it does not exceed approximately 0.99999994.",
        "code_id": "c_group_2_id_210",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm2\nmovss  %xmm2,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x31\nmovss  -0x24(%rbp),%xmm2\nsubss  %xmm0,%xmm2\nmovd   %xmm2,%eax\nmovss  0x0(%rip),%xmm1        # 0x46\n\nmovd   %eax,%xmm0\ncall   0x4f\nmovd   %xmm0,%eax\nmov    -0x20(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm3\nmovss  %xmm3,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x7d\nmovss  -0x24(%rbp),%xmm3\nsubss  %xmm0,%xmm3\nmovd   %xmm3,%eax\nmov    -0x20(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovss  0x0(%rip),%xmm1        # 0x9a\n\nmovd   %eax,%xmm0\ncall   0xa3\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_237",
        "query_text": "SUMMARY: This function accepts two input variables and one output variable, each being a 3-element array of floats (vec3). It updates every component of the output array by subtracting the combined sum of the corresponding components from the two input arrays. Specifically, for each of the three positions, the function deducts the sum of the respective float values from the input arrays from the float value at the corresponding position in the output array.",
        "code_id": "c_group_2_id_237",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm1\naddss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\naddss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\naddss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_219",
        "query_text": "SUMMARY: This function takes an input of type ivec2 (an array of two integers), a scalar integer, and an output of type ivec2. It computes, for each element of the input array, the difference between that element and the scalar, and then adds the result to the corresponding element of the output array.",
        "code_id": "c_group_2_id_219",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_245",
        "query_text": "SUMMARY: This function decomposes a 4\u00d74 perspective projection matrix (input type: mat4, which is defined as an array of four 4-element float vectors) into its fundamental frustum parameters. It calculates and outputs the distances to the near and far clipping planes, as well as the top, bottom, left, and right boundaries of the viewing volume. The outputs are provided through pointers to floats (output type: float*). The function extracts specific elements from the matrix and uses arithmetic operations to derive these parameters, effectively reversing the projection transformation to yield the frustum dimensions.",
        "code_id": "c_group_2_id_245",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %rcx,-0x50(%rbp)\nmov    %r8,-0x58(%rbp)\nmov    %r9,-0x60(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\ndivss  -0x18(%rbp),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x18(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa2\n\naddss  %xmm0,%xmm1\nmovss  -0x14(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x10(%rbp),%xmm0\ndivss  -0x24(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x10(%rbp),%xmm0\ndivss  -0x28(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x40(%rbp),%rax\nmovss  -0x10(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x48(%rbp),%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x1c(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0xf9\n\nsubss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x1c(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x117\n\naddss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x50(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x20(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x135\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x60(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x20(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x153\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_238",
        "query_text": "SUMMARY: The function receives an input of type const float* (an array of consecutive floating\u2010point numbers) and produces an output of type mat2x3 (a 2-element array where each element is a 3-element float vector). It constructs a 2\u00d73 matrix by assigning the first three floats from the input to populate the first row (3-element vector) of the matrix and the next three floats to the second row.",
        "code_id": "c_group_2_id_238",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x14(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_227",
        "query_text": "SUMMARY: This function takes an input of type mat3 (a 3x3 matrix of floats) and uses it to initialize the top-left 3x3 portion of an output of type mat4 (a 4x4 matrix of floats). Specifically, each element of the 3x3 input matrix is copied into the corresponding position in the 4x4 output matrix from the first row and column up to the third, leaving the rest of the output matrix unaffected.",
        "code_id": "c_group_2_id_227",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_252",
        "query_text": "SUMMARY: This function accepts an input of type mat4 (a 4\u00d74 matrix composed of vec4 elements) and produces an output of type mat3 (a 3\u00d73 matrix composed of vec3 elements). It extracts the top-left 3\u00d73 block from the 4\u00d74 matrix and assigns its elements to the output matrix in a transposed arrangement. Specifically, for each of the first three rows and columns, it maps the element from the column of the input to the row of the output, effectively transposing that 3\u00d73 portion.",
        "code_id": "c_group_2_id_252",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_243",
        "query_text": "SUMMARY: This function takes as input a 4x4 matrix of floats (mat4) representing a perspective projection and a pointer to a float (float*). It computes the near clipping distance by processing specific entries from the given matrix and then stores the resulting float value at the provided memory location.",
        "code_id": "c_group_2_id_243",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm1\nmovss  0x0(%rip),%xmm2        # 0x32\n\nxorps  %xmm2,%xmm1\nmovss  0x0(%rip),%xmm2        # 0x3d\n\nsubss  %xmm2,%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_230",
        "query_text": "SUMMARY: This function converts a set of Euler angles (an input of type vec3, i.e. an array of three floats) into a quaternion (an output of type versor, i.e. an array of four floats) based on a right-handed coordinate system using the ZXY rotation order. It computes the sine and cosine for half of each Euler angle and then combines these intermediate results to produce the four components of the quaternion representing the equivalent rotation.",
        "code_id": "c_group_2_id_230",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xfc\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x10d\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmulss  -0x14(%rbp),%xmm1\nmulss  -0x10(%rbp),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmulss  -0x18(%rbp),%xmm1\nmulss  -0x10(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_241",
        "query_text": "SUMMARY: This function converts a 3\u00d73 rotation matrix (input type: an array of three 3-element float vectors) into a quaternion (output type: a 4-element aligned float vector). It first computes the sum of the three diagonal elements of the matrix and then, based on whether this trace is nonnegative or if one of the specific diagonal elements is dominant, it selects one of several computation paths. Each path calculates a scaling factor from the square root of an expression involving the trace or a diagonal element, and then uses this factor to compute the four components of the quaternion from specific differences and sums of the matrix\u2019s off-diagonal elements.",
        "code_id": "c_group_2_id_241",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0xc(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncomiss %xmm1,%xmm0\njb     0x12d\nmovss  -0xc(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x62\n\naddss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x73\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x82\n\ndivss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm1\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0xc,%rax\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x120\n\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\njmp    0x487\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm1\ncomiss %xmm1,%xmm0\njb     0x269\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm1\ncomiss %xmm1,%xmm0\njb     0x269\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x17e\n\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm2\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\naddss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x1af\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x1be\n\ndivss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x1d5\n\nmulss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\njmp    0x487\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm1\ncomiss %xmm1,%xmm0\njb     0x38c\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x29c\n\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm2\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x2d2\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x2e1\n\ndivss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x326\n\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\njmp    0x487\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x39c\n\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm2\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\naddss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x3d2\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x3e1\n\ndivss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x8,%rax\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x455\n\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_242",
        "query_text": "SUMMARY: This function takes a 3-element float array (vec3) and a 4x4 matrix of float values (mat4) as inputs and returns a float. It calculates a transformed depth value by performing two separate dot products between the input vector and specific columns of the matrix, then divides the result of the first computation by that of the second. Essentially, it projects the input 3D coordinate onto the depth axis within a normalized (0 to 1) space using transformation and perspective division.",
        "code_id": "c_group_2_id_242",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm2\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm2\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0xc(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm2\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x20,%rax\nmovss  0xc(%rax),%xmm2\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x30,%rax\nmovss  0xc(%rax),%xmm0\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_257",
        "query_text": "SUMMARY: This function accepts an input of type mat2x4 (a two-element array where each element is a four-element float vector) and produces an output of type mat4x2 (a four-element array where each element is a two-element float vector). The function computes the transpose of a 2\u00d74 matrix by assigning each element from the corresponding position in the input matrix to its transposed position in the output matrix. Specifically, it maps elements from the rows of the input matrix into the columns of the output matrix, effectively rearranging the data to represent the transposed matrix.",
        "code_id": "c_group_2_id_257",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0xc(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_240",
        "query_text": "SUMMARY: This function accepts as inputs an array consisting of two three-dimensional vectors (each vector is a float[3]), a constant character pointer (serving as an optional tag), and an output stream pointer of type FILE*. Its output is void. The function prints a formatted representation of an axis\u2010aligned bounding box by displaying the two 3D vectors (typically representing the minimum and maximum corners) to the given output stream. It begins by printing a header that includes the provided tag (or a default string if none is provided) with specific color formatting. Then, for each of the two vectors, it prints their three float components using a conditional format based on the magnitude of the value\u2014using a fixed decimal precision for smaller numbers or a general format otherwise. Finally, it concludes by resetting the color format.",
        "code_id": "c_group_2_id_240",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\ncmpq   $0x0,-0x20(%rbp)\nje     0x25\nmov    -0x20(%rbp),%rax\njmp    0x2c\nlea    0x0(%rip),%rax        # 0x2c\nmov    -0x28(%rbp),%rcx\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x3a\nmov    %rax,%rsi\nmov    %rcx,%rdi\nmov    $0x0,%eax\ncall   0x4a\nmovl   $0x0,-0x8(%rbp)\njmp    0x197\nmov    -0x28(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x3,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rdi\ncall   0x76\nmovl   $0x0,-0x4(%rbp)\njmp    0x169\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xb1\n\ncomiss %xmm1,%xmm0\njbe    0x111\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovq   %xmm2,%rdx\nmov    -0x28(%rbp),%rax\nmovq   %rdx,%xmm0\nmov    $0x5,%edx\nlea    0x0(%rip),%rcx        # 0xff\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x10f\njmp    0x165\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm3,%xmm3\ncvtss2sd %xmm0,%xmm3\nmovq   %xmm3,%rdx\nmov    -0x28(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0x155\nmov    %rdx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x165\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x2,-0x4(%rbp)\njle    0x82\nmov    -0x28(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x4,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x18b\nmov    %rax,%rdi\ncall   0x193\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x1,-0x8(%rbp)\njle    0x56\nmov    -0x28(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x5,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x1b9\nmov    %rax,%rdi\ncall   0x1c1\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_248",
        "query_text": "SUMMARY: The function accepts two input vectors and one output vector, each defined as a 2-element array of floats (vec2). It updates the output vector by subtracting, from each element, the difference between the corresponding elements of the first and second input vectors. Specifically, for each index, the function decreases the current value in the output vector by the result of subtracting the second input\u2019s element from the first input\u2019s element.",
        "code_id": "c_group_2_id_248",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm2\nsubss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nsubss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_259",
        "query_text": "SUMMARY: This function accepts a 3-element floating-point vector (type vec3) representing Euler angles and produces a 4\u00d74 floating-point matrix (type mat4) that encodes a rotation transformation. It computes the sine and cosine of the three angles, calculates specific product combinations of these trigonometric values, and then populates the upper-left 3\u00d73 submatrix with values defining the rotation in 3D space following a Y\u2013Z\u2013X sequence. The remaining matrix elements are set to form an identity in the homogeneous coordinate, ensuring the resulting matrix is suitable for use as a transformation matrix in 3D graphics.",
        "code_id": "c_group_2_id_259",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x23\nmovd   %xmm0,%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x39\nmovd   %xmm0,%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x53\nmovd   %xmm0,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x6d\nmovd   %xmm0,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x87\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0xa1\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nmovss  -0x18(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x111\n\nxorps  %xmm1,%xmm0\nmulss  -0x20(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x10(%rbp),%xmm0\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\naddss  -0x8(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\naddss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x19f\n\nxorps  %xmm1,%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0x28(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x10(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0xc(%rbp),%xmm0\nsubss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x0(%rip),%xmm0        # 0x248\n\nmovss  %xmm0,0xc(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_239",
        "query_text": "SUMMARY: This function takes an input of type vec2 (an array of 2 floats representing a complex number with a real and an imaginary part) and produces an output of the same type. It computes the conjugate of the complex number represented by the input, maintaining the real component unchanged while negating the imaginary component. Specifically, it assigns the first element of the input to the first element of the output and assigns the negative of the second element of the input to the second element of the output.",
        "code_id": "c_group_2_id_239",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  0x0(%rip),%xmm1        # 0x3c\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_247",
        "query_text": "SUMMARY: This function takes an input of type int[2] and produces an output of type int[2]. It computes the absolute value of each element in the input array and assigns these computed absolute values to the corresponding elements in the output array. Specifically, it applies the absolute value operation individually to the first and second elements of the input.",
        "code_id": "c_group_2_id_247",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x4,%rdx\nmov    %eax,%ecx\nneg    %ecx\ncmovns %ecx,%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_258",
        "query_text": "SUMMARY: The function accepts an input variable of type vec4 (an aligned array of 4 floats) and outputs a variable of the same type. It computes the square root of each of the four floating-point numbers in the input, storing the results in the corresponding positions of the output. The implementation automatically selects an optimized vectorized computation path based on the available hardware (using SIMD instructions for WebAssembly or SSE when available), and falls back to a scalar computation using the standard square root function if those are not present.",
        "code_id": "c_group_2_id_258",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x10(%rbp)\nsqrtps -0x10(%rbp),%xmm0\nnop\nmov    -0x40(%rbp),%rax\nmov    %rax,-0x30(%rbp)\nmovaps %xmm0,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovaps -0x20(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_256",
        "query_text": "SUMMARY: This function accepts a 3\u00d73 matrix (type: mat3) and a 2-element vector (type: vec2) as inputs, and produces a 3\u00d73 matrix (type: mat3) as output. Its behavior involves scaling the first row of the input matrix by the first element of the 2-element vector and scaling the second row by the second element of the vector, while the third row remains unaltered, effectively applying a two-dimensional non-uniform scaling transformation to the matrix.",
        "code_id": "c_group_2_id_256",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_263",
        "query_text": "SUMMARY: This function takes an input variable of type vec4 (an array of 4 floats with potential 16-byte alignment) and copies its contents to an output variable of the same type. The function conditionally uses architecture-specific SIMD instructions when available (such as those from WebAssembly, SSE, or NEON) to perform an efficient copy; otherwise, it falls back to copying each of the four float components individually.",
        "code_id": "c_group_2_id_263",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmovaps -0x10(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_262",
        "query_text": "SUMMARY: This function takes an input of type \"const float *\" and an output of type \"mat4x2\" (an array of four \"vec2\" elements, where each \"vec2\" is an array of two floats). It sequentially assigns the eight consecutive float values from the input array into the four rows of the output matrix, mapping each pair of floats to the two elements of each row.",
        "code_id": "c_group_2_id_262",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x14(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_266",
        "query_text": "SUMMARY: This function accepts a scalar input of type float and an output matrix of type mat4 (a 4\u00d74 array of floats). It adjusts the perspective projection values within the provided matrix by modifying one of its elements: if the matrix's top-left element is nonzero, it is replaced with the value derived from dividing another specific matrix element (from the second row, second column) by the input float, thereby recalibrating the projection based on the aspect ratio.",
        "code_id": "c_group_2_id_266",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\npxor   %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njp     0x2b\npxor   %xmm1,%xmm1\nucomiss %xmm1,%xmm0\nje     0x47\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\njmp    0x48\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_246",
        "query_text": "SUMMARY: This function accepts two inputs of type ivec2 (arrays of two integers) and computes a single integer output. It calculates the dot product by multiplying the first element of the first input with the first element of the second input and then adding the product of the second elements from both inputs.",
        "code_id": "c_group_2_id_246",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   %edx,%eax\nadd    %ecx,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_254",
        "query_text": "SUMMARY: This function takes an input of type mat2x3 (which is defined as an array of 2 vectors, each being an array of 3 floats) and produces an output of the same type by copying the entire content of the input to the output. It sequentially copies each element from the first vector (3 floats) and then from the second vector (3 floats), ensuring that every float in the 2x3 matrix is duplicated in the destination.",
        "code_id": "c_group_2_id_254",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_269",
        "query_text": "SUMMARY: This function receives as input a 3x3 transformation matrix (a matrix consisting of three 3-element float arrays) and a 2D translation vector (an array of two floats). It updates the matrix in place by modifying its bottom row. Specifically, for each element in the bottom row, it adds a weighted sum of the corresponding top-row entries\u2014where the weights are the translation vector\u2019s float components\u2014to the existing bottom row value. The function does not return a value.",
        "code_id": "c_group_2_id_269",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_273",
        "query_text": "SUMMARY: This function takes a 3-element floating\u2010point array (vec3) representing Euler angles and computes a 4\u00d74 floating\u2010point matrix (mat4) that represents a rotation transformation. It first calculates the sine and cosine for each of the three angles and then uses their combinations to form the components of the rotation matrix according to an XZY rotation order. Finally, it ensures that the matrix is in homogeneous form by setting the appropriate elements for translation and scaling (with the bottom row having [0, 0, 0, 1]).",
        "code_id": "c_group_2_id_273",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x23\nmovd   %xmm0,%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x39\nmovd   %xmm0,%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x53\nmovd   %xmm0,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x6d\nmovd   %xmm0,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x87\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0xa1\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\naddss  -0x10(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nsubss  -0x8(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x18(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x13b\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nsubss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\naddss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x0(%rip),%xmm0        # 0x22f\n\nmovss  %xmm0,0xc(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_268",
        "query_text": "SUMMARY: This function accepts two inputs of type integer array of size 3 (representing 3-dimensional integer vectors) and computes, for each of the three positions, the smaller of the corresponding integers. The resulting set of three minimum integers is then stored in an output variable, which is also a 3-element integer array.",
        "code_id": "c_group_2_id_268",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    0x2c\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\njmp    0x32\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    0x59\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\njmp    0x60\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    0x8b\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\njmp    0x92\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x8,%rdx\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_267",
        "query_text": "SUMMARY: This function performs a component-wise subtraction between two two-element integer arrays (type: int[2]), storing the result in a third integer array (type: int[2]). It subtracts the first element of the second array from the first element of the first array and similarly subtracts the second element of the second array from the second element of the first array.",
        "code_id": "c_group_2_id_267",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_264",
        "query_text": "SUMMARY: This function operates on three variables, each being an array of four integers. It takes two input arrays of integers, compares corresponding elements from both arrays, and populates an output array (also of four integers) with the smaller value from each pair.",
        "code_id": "c_group_2_id_264",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    0x2c\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\njmp    0x32\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    0x59\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\njmp    0x60\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    0x8b\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\njmp    0x92\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x8,%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    0xbd\nmov    -0x8(%rbp),%rax\nmov    0xc(%rax),%eax\njmp    0xc4\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0xc,%rdx\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_261",
        "query_text": "SUMMARY: The function accepts an input of type vec3 (a 3-element array of floats) and produces an output of the same type, vec3. It computes the square root of each element in the input array and stores the results in the corresponding elements of the output array.",
        "code_id": "c_group_2_id_261",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x24\nmovd   %xmm0,%eax\nmov    -0x20(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovd   %eax,%xmm0\ncall   0x49\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nlea    0x8(%rdx),%rbx\nmovd   %eax,%xmm0\ncall   0x6a\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_260",
        "query_text": "SUMMARY: This function operates on three arrays of two integers each. It performs an element-wise multiplication of the first two integer arrays and then subtracts each resulting product from the corresponding element in the output integer array.",
        "code_id": "c_group_2_id_260",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %ecx,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_304",
        "query_text": "SUMMARY: This function takes as inputs a 3-element array of floats (vec3) and a float scalar, and produces as output another 3-element array of floats (vec3). It operates by adding the float scalar to each element of the input 3-element float array individually, storing each computed sum into the corresponding index of the output array.",
        "code_id": "c_group_2_id_304",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\naddss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\naddss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_284",
        "query_text": "SUMMARY: This function accepts two 4-element arrays of integers (type: ivec4) and returns an integer (type: int). It computes the squared Euclidean distance between the two 4-dimensional integer vectors by subtracting corresponding components, squaring each difference, and summing the squared values.",
        "code_id": "c_group_2_id_284",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%rax\nmov    (%rax),%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nadd    $0x8,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nadd    $0xc,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x10(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,%edx\nmov    -0xc(%rbp),%eax\nimul   %eax,%eax\nadd    %eax,%edx\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\nadd    %eax,%edx\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\nadd    %edx,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_307",
        "query_text": "SUMMARY: This function accepts a 3x4 matrix (an array of three 4-element float vectors, with 16-byte alignment) and a scalar value of type float. It scales the matrix by multiplying each of the 12 individual float elements by the scalar, and it performs the operation in place, returning no value (void).",
        "code_id": "c_group_2_id_307",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0xc(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_290",
        "query_text": "SUMMARY: This function accepts three inputs of type vec4 (each being an array of four floats) and updates a fourth vector (also of type vec4) by adding the corresponding components of the first two inputs to those of the output variable. In essence, it performs an element-wise addition where each output component becomes the sum of its previous value plus the corresponding components from the two input vectors. The computation is carried out using platform-specific SIMD instructions when available, resorting to a straightforward element-wise computation otherwise.",
        "code_id": "c_group_2_id_290",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    -0x80(%rbp),%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x78(%rbp),%rax\nmov    %rax,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x20(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\naddps  -0x10(%rbp),%xmm0\nmov    -0x88(%rbp),%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x40(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmovaps -0x40(%rbp),%xmm0\naddps  -0x30(%rbp),%xmm0\nmov    -0x88(%rbp),%rax\nmov    %rax,-0x70(%rbp)\nmovaps %xmm0,-0x50(%rbp)\nmov    -0x70(%rbp),%rax\nmovaps -0x50(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_265",
        "query_text": "SUMMARY: This function takes a 3-element array of floats (representing Euler angles) as input and computes a 4-element array of floats (representing a quaternion) as output. Specifically, it calculates the sine and cosine of half of each Euler angle, with the third angle\u2019s sine negated to accommodate a left-handed coordinate system. It then combines these half-angle trigonometric values using fixed multiplications and additions to form a quaternion that corresponds to an XZY rotation order.",
        "code_id": "c_group_2_id_265",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmovss  0x0(%rip),%xmm0        # 0xed\n\nmovd   %eax,%xmm2\nxorps  %xmm0,%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x110\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x121\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x135\n\nxorps  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovss  -0x18(%rbp),%xmm1\nmulss  -0x8(%rbp),%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_272",
        "query_text": "SUMMARY: This function accepts a 3-element float array (vec3) representing Euler angles (in radians) and produces a 4\u00d74 float matrix (mat4) that encodes the corresponding rotation transformation. It computes the sine and cosine of each Euler angle, combines these trigonometric results into intermediate values, and assigns them to specific elements in the matrix to construct a homogeneous rotation matrix based on rotations about the X, Y, and Z axes.",
        "code_id": "c_group_2_id_272",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x23\nmovd   %xmm0,%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x39\nmovd   %xmm0,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x53\nmovd   %xmm0,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x6d\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x87\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0xa1\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x24(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x1c(%rbp),%xmm1\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x118\n\nxorps  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x1c(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0x18(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x147\n\nxorps  %xmm1,%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0x14(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x24(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x8(%rbp),%xmm0\nsubss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\naddss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x18(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x1b8\n\nxorps  %xmm1,%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0x24(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x0(%rip),%xmm0        # 0x255\n\nmovss  %xmm0,0xc(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_281",
        "query_text": "SUMMARY: This function accepts two input parameters of type integer array with 2 elements each and a destination output parameter of the same type. It computes the product of the first element from each of the input arrays and adds the result to the first element of the destination array, then does the same for the second element.",
        "code_id": "c_group_2_id_281",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %edx,%eax\nlea    (%rcx,%rax,1),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_297",
        "query_text": "SUMMARY: This function accepts a parameter of type mat2 (a 2x2 matrix represented as an array of two vec2, where each vec2 is an array of two floats) and transposes it in place. It operates by swapping the two off-diagonal elements of the input matrix, leaving the diagonal elements unchanged, and produces no return value (void).",
        "code_id": "c_group_2_id_297",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_271",
        "query_text": "SUMMARY: This function multiplies two matrices to produce a 2\u00d72 matrix. It takes as inputs a matrix of type mat4x2 (an array of four 2-element float vectors, representing a 2\u00d74 matrix in column-major format) and a matrix of type mat2x4 (an array of two 4-element float vectors, representing a 4\u00d72 matrix in column-major format). The function computes each element of the output matrix (of type mat2, which is an array of two 2-element float vectors, representing a 2\u00d72 matrix) by calculating the dot products between corresponding rows (derived from the columns of the first input) and columns (derived from the columns of the second input).",
        "code_id": "c_group_2_id_271",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %rdx,-0x58(%rbp)\nmov    -0x48(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x40(%rbp)\nmov    -0x48(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x3c(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x38(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x34(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x30(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x50(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x50(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x50(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x50(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x50(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x50(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x50(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x50(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x40(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x30(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x34(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x2c(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x40(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x38(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x30(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x34(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x2c(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_308",
        "query_text": "SUMMARY: This function performs a linear transformation by multiplying a 2\u00d73 matrix (an array of two 3-element float arrays) with a 2-element vector (a float array of length 2) to produce a 3-element vector (a float array of length 3). It extracts the two float values from the input vector, then computes each of the three output float values by forming a weighted sum of corresponding elements from the two rows of the matrix, and finally stores these computed sums in the output vector.",
        "code_id": "c_group_2_id_308",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_280",
        "query_text": "SUMMARY: This function receives three parameters: an input array of 4 integers (ivec4), an integer scalar, and an output array of 4 integers (ivec4). It multiplies each element of the input array by the scalar and then adds the resulting product to the corresponding element of the output array, executing these operations component-wise.",
        "code_id": "c_group_2_id_280",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_274",
        "query_text": "SUMMARY: This function accepts an input of a 4\u00d74 matrix of floats (mat4) representing a right-handed perspective projection and computes six frustum parameters, outputting them as float values via pointer arguments. Specifically, it calculates the near and far plane distances as well as the top, bottom, left, and right boundaries of the view frustum based on the elements of the input matrix, and then stores these computed values in the provided float pointers.",
        "code_id": "c_group_2_id_274",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %rcx,-0x50(%rbp)\nmov    %r8,-0x58(%rbp)\nmov    %r9,-0x60(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x18(%rbp),%xmm0\nmovss  0x0(%rip),%xmm2        # 0x93\n\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmovss  -0x14(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x18(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xb5\n\naddss  %xmm0,%xmm1\nmovss  -0x14(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x10(%rbp),%xmm0\ndivss  -0x24(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x10(%rbp),%xmm0\ndivss  -0x28(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x40(%rbp),%rax\nmovss  -0x10(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x48(%rbp),%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x1c(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x10c\n\nsubss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x1c(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x12a\n\naddss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x50(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x20(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x148\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x60(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x20(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x166\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_312",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 single-precision floating-point matrix (representing a perspective projection transformation) and two pointers to float variables as inputs. It calculates the near clipping plane distance from the matrix and then computes the horizontal bounds on the near plane of the projection, storing these computed boundary values into the provided float outputs.",
        "code_id": "c_group_2_id_312",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0xc(%rax),%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x62\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0xc(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x85\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0xc(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_303",
        "query_text": "SUMMARY: The function accepts an input parameter of type int[4] and two additional integer parameters representing a minimum and a maximum value. It reviews each element of the int[4] array and modifies it in place so that every element is confined within the specified range: if an element is lower than the minimum value, it is set to the minimum; if it exceeds the maximum value, it is set to the maximum. The output is the modified int[4] array where all elements satisfy the constraint min \u2264 element \u2264 max.",
        "code_id": "c_group_2_id_303",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %edx,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    0x28\nmov    -0x8(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\njmp    0x3c\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    0x3c\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    0x5a\nmov    -0x8(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\njmp    0x76\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    0x76\nmov    -0x8(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    0x94\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\njmp    0xb0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    0xb0\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    0xce\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\njmp    0xea\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    0xea\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_285",
        "query_text": "SUMMARY: This function accepts two inputs, each being an array of three integers (ivec3), multiplies their corresponding elements, sums these products, and returns the resulting sum as an integer.",
        "code_id": "c_group_2_id_285",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   %edx,%eax\nadd    %eax,%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   %edx,%eax\nadd    %ecx,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_275",
        "query_text": "SUMMARY: This function accepts a 2\u00d72 matrix of 2-element floating\u2010point arrays (a 2\u00d72 float matrix with potential 16\u2011byte alignment) and a pointer to a FILE stream as its inputs, and it produces no output (void return type). Its purpose is to print the matrix in a formatted and human-readable way. Initially, it writes a header stating the type and dimensions of the matrix, then it calculates the appropriate column widths for each matrix element based on a chosen precision and a threshold that decides between fixed-point and general formatting. Finally, it prints each row of the matrix with the elements right\u2010aligned using the determined widths, ensuring the output is neatly formatted within decorative boundary characters, and resets any applied formatting at the end.",
        "code_id": "c_group_2_id_275",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x50(%rbp),%rax\nmov    $0x2,%ecx\nmov    $0x2,%edx\nlea    0x0(%rip),%rsi        # 0x38\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x45\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,-0x30(%rbp)\nmovl   $0x0,-0x3c(%rbp)\njmp    0x174\nmovl   $0x0,-0x38(%rbp)\njmp    0x166\nmov    -0x3c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x90\n\ncomiss %xmm1,%xmm0\njbe    0xec\nmov    -0x3c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovq   %xmm2,%rdx\nlea    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdx        # 0xd5\nmov    $0x10,%esi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xe7\nmov    %eax,-0x34(%rbp)\njmp    0x13c\nmov    -0x3c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm3,%xmm3\ncvtss2sd %xmm0,%xmm3\nmovq   %xmm3,%rdx\nlea    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0x127\nmov    $0x10,%esi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x139\nmov    %eax,-0x34(%rbp)\nmov    -0x3c(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%eax\ncmp    %eax,-0x34(%rbp)\njge    0x155\nmov    -0x3c(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%eax\njmp    0x158\nmov    -0x34(%rbp),%eax\nmov    -0x3c(%rbp),%edx\nmovslq %edx,%rdx\nmov    %eax,-0x30(%rbp,%rdx,4)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x1,-0x38(%rbp)\njle    0x6a\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x1,-0x3c(%rbp)\njle    0x5e\nmovl   $0x0,-0x3c(%rbp)\njmp    0x2bf\nmov    -0x50(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x3,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x1a2\nmov    %rax,%rdi\ncall   0x1aa\nmovl   $0x0,-0x38(%rbp)\njmp    0x291\nmov    -0x3c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x1dc\n\ncomiss %xmm1,%xmm0\njbe    0x239\nmov    -0x38(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x3c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm4,%xmm4\ncvtss2sd %xmm0,%xmm4\nmovq   %xmm4,%rcx\nmov    -0x38(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%edx\nmov    -0x50(%rbp),%rax\nmovq   %rcx,%xmm0\nmov    $0x5,%ecx\nlea    0x0(%rip),%rsi        # 0x22a\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x237\njmp    0x28d\nmov    -0x38(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x3c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm5,%xmm5\ncvtss2sd %xmm0,%xmm5\nmovq   %xmm5,%rcx\nmov    -0x38(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%edx\nmov    -0x50(%rbp),%rax\nmovq   %rcx,%xmm0\nlea    0x0(%rip),%rcx        # 0x27d\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x28d\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x1,-0x38(%rbp)\njle    0x1b6\nmov    -0x50(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x4,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x2b3\nmov    %rax,%rdi\ncall   0x2bb\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x1,-0x3c(%rbp)\njle    0x18a\nmov    -0x50(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x5,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x2e1\nmov    %rax,%rdi\ncall   0x2e9\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x2fe\ncall   0x2fe\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_282",
        "query_text": "SUMMARY: This function accepts two input parameters of type vec3 (an array of 3 floats) and produces no direct return value. It copies the three floating-point numbers from the source array (input type: vec3) into the destination array (output type: vec3) by individually assigning each corresponding element, effectively duplicating the entire 3-component vector.",
        "code_id": "c_group_2_id_282",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_276",
        "query_text": "SUMMARY: This function takes as input a 4-element float array (type vec4) and a single float scalar, and produces an output 4-element float array (type vec4). Its behavior is to add the scalar to each component of the input array and store the resulting values in the output array. The implementation optimizes this addition using platform-specific SIMD operations when available, but the core functionality remains adding the scalar value to every element of the input vector.",
        "code_id": "c_group_2_id_276",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x58(%rbp)\nmovss  %xmm0,-0x5c(%rbp)\nmov    %rsi,-0x68(%rbp)\nmovss  -0x5c(%rbp),%xmm0\nmovss  %xmm0,-0x44(%rbp)\nmovss  -0x44(%rbp),%xmm0\nshufps $0x0,%xmm0,%xmm0\nmovaps %xmm0,%xmm1\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x20(%rbp)\nmovaps %xmm1,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\naddps  -0x10(%rbp),%xmm0\nmov    -0x68(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmov    -0x40(%rbp),%rax\nmovaps -0x30(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_295",
        "query_text": "SUMMARY: This function takes as inputs a 2x4 matrix (implemented as an array of 2 vectors, where each vector is an aligned array of 4 floats) and a scalar float value. It scales the matrix in place by multiplying each of its elements by the provided scalar, and it returns no value (void).",
        "code_id": "c_group_2_id_295",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_319",
        "query_text": "SUMMARY: This function accepts an input of type mat3 (a 3\u00d73 float matrix) and produces an output of the same type. It calculates the transpose of the provided 3\u00d73 matrix by reassigning elements such that the element at the ith row and jth column in the input is placed at the jth row and ith column in the output. Each assignment explicitly swaps the indices, ensuring that the matrix's rows and columns are interchanged.",
        "code_id": "c_group_2_id_319",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_309",
        "query_text": "SUMMARY: This routine performs component-wise addition on two input arrays of four 32-bit floating-point values (defined as vec4) and stores the result into an output array of the same type. The implementation conditionally leverages platform-specific SIMD instructions\u2014using WebAssembly SIMD, SSE/SSE2, or NEON\u2014in order to efficiently load, add, and store the 4-element vectors. In the absence of such hardware features, it manually adds each corresponding element from the input arrays.",
        "code_id": "c_group_2_id_309",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x58(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmov    -0x40(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x20(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\naddps  -0x10(%rbp),%xmm0\nmov    -0x68(%rbp),%rax\nmov    %rax,-0x48(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmov    -0x48(%rbp),%rax\nmovaps -0x30(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_291",
        "query_text": "SUMMARY: This function takes as input a two-dimensional matrix (of type \"mat2\", which is a two-element array of 2-element float vectors) along with two integer indices. It operates by exchanging the entire contents of the two columns specified by the integer inputs. The matrix, which serves as the output (modified in place), has its specified columns swapped, and no new data is returned.",
        "code_id": "c_group_2_id_291",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  -0x8(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_294",
        "query_text": "SUMMARY: This function accepts an input of type float[3] (a 3-dimensional vector) and a float scalar, then produces an output of type float[3] by subtracting the scalar from each element of the input vector individually.",
        "code_id": "c_group_2_id_294",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nsubss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsubss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_315",
        "query_text": "SUMMARY: This function accepts two parameters, both of type vec4 (an array of 4 floats). It copies the contents from the first vec4 (input) into the second vec4 (output), ensuring that the destination receives an exact replica of the input vector. The implementation employs optimized methods for certain platform-specific conditions but ultimately achieves a straightforward element-by-element copy of the four floating-point values.",
        "code_id": "c_group_2_id_315",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_277",
        "query_text": "SUMMARY: The function accepts an input of type \"mat4\" (a 4x4 matrix composed of four float[4] vectors) and an output pointer of type \"float*\". It extracts a specific element from the projection matrix and uses it, along with another matrix element, to calculate the value representing the far clipping plane distance, which is then stored via the provided float pointer.",
        "code_id": "c_group_2_id_277",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm2\nmovss  0x0(%rip),%xmm1        # 0x32\n\naddss  %xmm2,%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_293",
        "query_text": "SUMMARY: This function takes a constant pointer to a float (const float *) as input and produces an output of type mat4x3 (an array of 4 vectors, each being an array of 3 floats). It sequentially assigns groups of three floats from the input array to each of the four vectors in the output, effectively constructing a 4x3 matrix from a flat array of 12 floats.",
        "code_id": "c_group_2_id_293",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x14(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x24,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x28(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x24,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x2c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x24,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_299",
        "query_text": "SUMMARY: This function takes a vector of type float[4] (an aligned array of four 32-bit floating-point numbers) as its input and outputs no value (void return). Its functionality is to set every element of the input vector to the constant value 1.0. It uses platform-specific SIMD instructions (such as those available for WASM, SSE, or NEON) when available for optimized performance, otherwise it sets the elements individually.",
        "code_id": "c_group_2_id_299",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x14\n\nmovss  %xmm0,-0x1c(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nshufps $0x0,%xmm0,%xmm0\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmovaps -0x10(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_289",
        "query_text": "SUMMARY: The function accepts a two-element integer array (ivec2) and two integers representing a lower and an upper bound. It operates in place by adjusting the values of the array so that each element lies within the inclusive range defined by these minimum and maximum bounds, returning the modified array as the output.",
        "code_id": "c_group_2_id_289",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %edx,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    0x28\nmov    -0x8(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\njmp    0x3c\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    0x3c\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    0x5a\nmov    -0x8(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\njmp    0x76\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    0x76\nmov    -0x8(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_298",
        "query_text": "SUMMARY: The function receives an input of type ivec3 (an array of three integers) and a scalar integer, subtracts the scalar from each element of the input ivec3, and stores the results in an output variable of type ivec3 (an array of three integers). The function processes the subtraction element-wise for all three components of the input integer vector.",
        "code_id": "c_group_2_id_298",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nsub    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x8,%rdx\nsub    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_287",
        "query_text": "SUMMARY: This function receives two inputs, each being an array of three integers (type int[3]), and computes a component-wise multiplication of these arrays. The result, which is also an array of three integers (type int[3]), is produced by multiplying the corresponding elements of the input arrays.",
        "code_id": "c_group_2_id_287",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x8,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_279",
        "query_text": "SUMMARY: This function accepts two input arrays of three floats each and modifies a third array of three floats. For each of the three components, it sums the corresponding float from each of the two input arrays and then adds this sum to the corresponding component in the output array. The function operates in-place on the output array without returning a value.",
        "code_id": "c_group_2_id_279",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\naddss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\naddss  %xmm2,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\naddss  %xmm2,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_270",
        "query_text": "SUMMARY: This function takes two inputs\u2014a 4-element array of floating-point numbers (vec4) and a standard I/O stream pointer of type FILE*\u2014and produces no output value (void). It formats and prints the elements of the 4-element vector to the provided output stream. Specifically, it writes a header indicating that the content is a vector of four floats, then iterates over the four elements, printing each with formatting that adapts based on the magnitude of the number, and finally appends formatting to reset any applied text colors.",
        "code_id": "c_group_2_id_270",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    $0x4,%edx\nlea    0x0(%rip),%rcx        # 0x24\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x34\nmovl   $0x0,-0x4(%rbp)\njmp    0xfa\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x60\n\ncomiss %xmm1,%xmm0\njbe    0xb1\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovq   %xmm2,%rdx\nmov    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nmov    $0x5,%edx\nlea    0x0(%rip),%rcx        # 0x9f\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xaf\njmp    0xf6\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm3,%xmm3\ncvtss2sd %xmm0,%xmm3\nmovq   %xmm3,%rdx\nmov    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0xe6\nmov    %rdx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xf6\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x3,-0x4(%rbp)\njle    0x40\nmov    -0x20(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x9,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x11c\nmov    %rax,%rdi\ncall   0x124\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_305",
        "query_text": "SUMMARY: This function takes a two-element array of single-precision floating-point numbers (vec2) as input and produces a two-element array of single-precision floating-point numbers (vec2) as output. It computes the square root of each element from the input array and assigns the results to the corresponding elements of the output array.",
        "code_id": "c_group_2_id_305",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x24\nmovd   %xmm0,%eax\nmov    -0x20(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovd   %eax,%xmm0\ncall   0x49\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_310",
        "query_text": "SUMMARY: This inline function initializes a quaternion represented by a 4-element float array. It takes as inputs one output parameter (a modifiable array of four floats) and four individual floats. The function assigns the four input float values to the elements of the float array sequentially, updating it in place.",
        "code_id": "c_group_2_id_310",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmovss  %xmm1,-0x10(%rbp)\nmovss  %xmm2,-0x14(%rbp)\nmovss  %xmm3,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  -0x10(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  -0x14(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  -0x18(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_301",
        "query_text": "SUMMARY: This function accepts two inputs: one is a three-element array of floats (type vec3) and the other is a pointer to a FILE stream (type FILE *). It produces no return value (void). Its purpose is to output a formatted representation of the three floating-point values to the provided stream. The function prints a header indicating the vector type and then iterates through the array, printing each float with conditional formatting based on its value relative to a preset threshold. It also incorporates color formatting directives to enhance the visual output on compatible terminals.",
        "code_id": "c_group_2_id_301",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    $0x3,%edx\nlea    0x0(%rip),%rcx        # 0x24\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x34\nmovl   $0x0,-0x4(%rbp)\njmp    0xfa\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x60\n\ncomiss %xmm1,%xmm0\njbe    0xb1\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovq   %xmm2,%rdx\nmov    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nmov    $0x5,%edx\nlea    0x0(%rip),%rcx        # 0x9f\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xaf\njmp    0xf6\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm3,%xmm3\ncvtss2sd %xmm0,%xmm3\nmovq   %xmm3,%rdx\nmov    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0xe6\nmov    %rdx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xf6\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x2,-0x4(%rbp)\njle    0x40\nmov    -0x20(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x9,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x11c\nmov    %rax,%rdi\ncall   0x124\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_288",
        "query_text": "SUMMARY: This function accepts two parameters, both of which are arrays of three integers (type: ivec3). It replicates the entire content of the first array into the second array by copying each of the three elements individually.",
        "code_id": "c_group_2_id_288",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_292",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a one-dimensional array containing two integers and a single integer scalar\u2014and produces an output as a one-dimensional array containing two integers. The function divides each element of the input array by the scalar value and assigns the resulting quotient to the respective element in the output array, performing an element-wise scalar division.",
        "code_id": "c_group_2_id_292",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncltd   \nidivl  -0xc(%rbp)\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nlea    0x4(%rdx),%rcx\ncltd   \nidivl  -0xc(%rbp)\nmov    %eax,(%rcx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_296",
        "query_text": "SUMMARY: This function takes two inputs and one output, each being an array of 4 integers (ivec4). For each of the four positions, the function compares the corresponding integers from the two input arrays and places the larger value into the same index of the output array.",
        "code_id": "c_group_2_id_296",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    0x2c\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\njmp    0x32\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    0x59\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\njmp    0x60\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    0x8b\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\njmp    0x92\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x8,%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    0xbd\nmov    -0x8(%rbp),%rax\nmov    0xc(%rax),%eax\njmp    0xc4\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0xc,%rdx\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_316",
        "query_text": "SUMMARY: This function accepts a single floating-point value (type: float) and a destination array of four floats (type: vec4, which is a 16-byte aligned float[4]). Its primary functionality is to assign the given float value to every element of the output array, effectively broadcasting the value. Depending on the platform, it may use specialized SIMD instructions (WebAssembly SIMD or SSE/SSE2) to perform the broadcast efficiently; otherwise, it individually assigns the value to each position in the array.",
        "code_id": "c_group_2_id_316",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x24(%rbp)\nmov    %rdi,-0x30(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nshufps $0x0,%xmm0,%xmm0\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmovaps -0x10(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_302",
        "query_text": "SUMMARY: This function takes an input of type vec2 (a two-element array of floats) and copies its contents to an output also of type vec2, thereby duplicating the two floating-point values from the source to the destination.",
        "code_id": "c_group_2_id_302",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_286",
        "query_text": "SUMMARY: This function takes a 3x3 matrix of floats (mat3), a floating-point rotation angle (float), and produces a 3x3 matrix of floats (mat3) as its output. It applies a two-dimensional rotation by the specified angle to the first two rows of the input matrix while keeping the third row unchanged, effectively transforming the input matrix with the given rotation.",
        "code_id": "c_group_2_id_286",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmovss  %xmm0,-0x2c(%rbp)\nmov    %rsi,-0x38(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x2c(%rbp),%eax\nmovd   %eax,%xmm0\ncall   0x83\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x2c(%rbp),%eax\nmovd   %eax,%xmm0\ncall   0x96\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x20(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x18(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x10(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x115\n\nxorps  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x147\n\nxorps  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x17a\n\nxorps  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x28(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x38(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x28(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x38(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x28(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x38(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_327",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (mat4) and two pointers to floats (float*) as inputs. It decomposes the provided perspective projection matrix, extracting parameters associated with the vertical extents along the y-axis in a left-handed coordinate system. Essentially, the function calculates a near clipping distance and then computes two float values representing the top and bottom bounds of the view frustum. The computed values are stored in the output float pointers.",
        "code_id": "c_group_2_id_327",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x4d\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm2        # 0x6f\n\nsubss  %xmm2,%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x10(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x89\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0xc(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x10(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xac\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0xc(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_283",
        "query_text": "SUMMARY: This function takes as inputs a matrix of type mat3 (a 3\u00d73 array of floats) and a scalar of type float. Its purpose is to scale the matrix by the given scalar factor. Line by line, each element of the 3\u00d73 matrix is multiplied by the scalar, modifying the matrix in place. There is no explicit output since the transformation occurs directly on the provided matrix.",
        "code_id": "c_group_2_id_283",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_278",
        "query_text": "SUMMARY: This function converts a set of Euler angles into a quaternion using a right-handed coordinate system. It accepts as input a three-element floating\u2011point array (vec3) representing the Euler angles and produces as output a four-element floating\u2011point array (versor) representing the quaternion. The function computes the sine and cosine of half each Euler angle and then combines these intermediate values to form the quaternion components.",
        "code_id": "c_group_2_id_278",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xfc\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x10d\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmulss  -0x10(%rbp),%xmm1\nmulss  -0x14(%rbp),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x14(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x17c\n\nxorps  %xmm1,%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x14(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_328",
        "query_text": "SUMMARY: This function converts a three-component float array (vec3) representing Euler rotation angles into a corresponding four-component float array (versor) representing a quaternion based on a ZYX rotation order for a left-handed coordinate system. It computes half-angle sine and cosine values for each of the three angles, combines these intermediate values with appropriate sign adjustments, and then calculates each component of the quaternion, which encodes the final rotation.",
        "code_id": "c_group_2_id_328",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmovss  0x0(%rip),%xmm0        # 0xed\n\nmovd   %eax,%xmm2\nxorps  %xmm0,%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x110\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x121\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmulss  -0x10(%rbp),%xmm1\nmulss  -0x14(%rbp),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x14(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x190\n\nxorps  %xmm1,%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x14(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_306",
        "query_text": "SUMMARY: This function accepts an input of type \"integer array of length 3\" and a scalar of type \"integer\", and it outputs a modified integer array of length 3. Specifically, for each element in the three-element output array, it subtracts the sum of the corresponding element from the input array and the scalar. Line by line, each element in the output is updated by deducting (element from the input array + scalar) from its current value.",
        "code_id": "c_group_2_id_306",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %ecx,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_317",
        "query_text": "SUMMARY: This function takes as input a 4\u00d74 floating-point matrix (of type mat4) representing a specific perspective projection and a pointer to a float (output type). It computes the near clipping plane distance by extracting particular elements from the matrix and assigns the resulting float to the provided output pointer. Specifically, it derives the output by dividing the element from the fourth row and third column by the negation of the element from the third row and third column.",
        "code_id": "c_group_2_id_317",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x25\n\nxorps  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_311",
        "query_text": "SUMMARY: This function takes a 4\u00d74 matrix of floats (mat4) as input along with a pointer to a float variable as output. It computes a quotient by dividing the float value in the fourth row and third column of the matrix by the result of subtracting the element in the third row and third column from 1.0. The computed value is then stored in the provided float pointer, effectively extracting the far clipping plane distance from the perspective projection matrix under a left-handed coordinate system with no depth range transformation.",
        "code_id": "c_group_2_id_311",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm2\nmovss  0x0(%rip),%xmm1        # 0x32\n\nsubss  %xmm2,%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_325",
        "query_text": "SUMMARY: This function accepts an input of type pointer to float and an output of type vec2 (an array of 2 floats). It copies the first two float values from the input pointer into the output vec2, effectively transferring a 2-dimensional vector from one representation to another.",
        "code_id": "c_group_2_id_325",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_300",
        "query_text": "SUMMARY: This function receives a two-dimensional array of floats with dimensions 3\u00d73 (mat3) and returns a float. It calculates the determinant of the provided 3\u00d73 matrix by accessing each element in the matrix and applying the standard determinant formula for a 3\u00d73 matrix. Specifically, it computes the determinant by performing arithmetic operations involving the multiplication and subtraction of products of selected elements from the matrix, and then returns the resulting value.",
        "code_id": "c_group_2_id_300",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmulss  -0x10(%rbp),%xmm1\nsubss  %xmm1,%xmm0\nmulss  -0x24(%rbp),%xmm0\nmovss  -0x20(%rbp),%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm2\nmulss  -0x8(%rbp),%xmm2\nsubss  %xmm2,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovaps %xmm0,%xmm2\nsubss  %xmm1,%xmm2\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovss  -0x1c(%rbp),%xmm1\nmulss  -0x14(%rbp),%xmm1\nsubss  %xmm1,%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm2,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_313",
        "query_text": "SUMMARY: This function accepts one input of type mat4 (a 4\u00d74 floating-point matrix) and returns a float. It extracts two elements from the matrix\u2014specifically the component at index [1][1] and the component at index [0][0]\u2014and returns their quotient, effectively computing the aspect ratio represented in the perspective projection matrix.",
        "code_id": "c_group_2_id_313",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\ndivss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_323",
        "query_text": "SUMMARY: This function accepts a two-element floating-point array (vec2) and a floating-point scalar as inputs. It multiplies each element of the input array by the scalar, then stores the resulting two-element floating-point array (vec2) as output.",
        "code_id": "c_group_2_id_323",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_320",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of type int[4]. It updates the output parameter by adding, component-wise, the difference between the corresponding elements of the first two input parameters. In other words, for each of the four components, it subtracts the second input's element from the first input's element and then adds that result to the corresponding element in the output.",
        "code_id": "c_group_2_id_320",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nsub    %eax,%edx\nadd    %ecx,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nlea    (%rcx,%rsi,1),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x8,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nlea    (%rcx,%rsi,1),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0xc,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nlea    (%rcx,%rsi,1),%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_330",
        "query_text": "SUMMARY: This function multiplies two matrices and produces a new matrix as a result. It takes an input of type mat3x4 (an array of 3 vec4, representing a 3\u2010column by 4\u2011row matrix in column-major order) and an input of type mat4x3 (an array of 4 vec3, representing a 4\u2011column by 3\u2011row matrix in column-major order), and it computes their product to store in an output of type mat4 (an array of 4 vec4, representing a 4\u2011column by 4\u2011row matrix). The function works by extracting the individual floating\u2013point components of the first and second matrices and then computing each element of the resulting matrix as the dot product between the corresponding column from the first matrix and the appropriate row from the second matrix.",
        "code_id": "c_group_2_id_330",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x68(%rbp)\nmov    %rsi,-0x70(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    -0x68(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x60(%rbp)\nmov    -0x68(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x5c(%rbp)\nmov    -0x68(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x58(%rbp)\nmov    -0x68(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x54(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x50(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x4c(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x48(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x44(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x40(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x3c(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x38(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x20,%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x34(%rbp)\nmov    -0x70(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x30(%rbp)\nmov    -0x70(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x70(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x24,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x24,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x24,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x60(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x30(%rbp),%xmm1\nmovss  -0x50(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x40(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x78(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x5c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x30(%rbp),%xmm1\nmovss  -0x4c(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x78(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x58(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x30(%rbp),%xmm1\nmovss  -0x48(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x78(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0x54(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x30(%rbp),%xmm1\nmovss  -0x44(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x34(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x78(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmovss  -0x60(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x24(%rbp),%xmm1\nmovss  -0x50(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x40(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x10,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x5c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x24(%rbp),%xmm1\nmovss  -0x4c(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x10,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x58(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x24(%rbp),%xmm1\nmovss  -0x48(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x10,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x54(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x24(%rbp),%xmm1\nmovss  -0x44(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x34(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x10,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0xc(%rax)\nmovss  -0x60(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x50(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x40(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x5c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x4c(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x58(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x48(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x54(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x44(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x34(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0xc(%rax)\nmovss  -0x60(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmovss  -0x50(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x40(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x30,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x5c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmovss  -0x4c(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x30,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x58(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmovss  -0x48(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x30,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x54(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmovss  -0x44(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x34(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x30,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_314",
        "query_text": "SUMMARY: This function takes as inputs a 2\u00d74 matrix (represented as an array of 2 arrays, each containing 4 floats) and a 2-dimensional vector (an array of 2 floats). It computes a 4-dimensional vector (an array of 4 floats) as output by performing a component-wise linear combination of the two rows of the matrix using the two scalar elements from the vector. Each element of the resulting vector is calculated by multiplying the corresponding element from the first row of the matrix by the first scalar and adding it to the product of the corresponding element from the second row with the second scalar.",
        "code_id": "c_group_2_id_314",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_329",
        "query_text": "SUMMARY: This function takes two inputs of type int[4] and produces an output of the same type. It transfers the contents of the first int[4] array into the second int[4] array by copying each of the four integer elements in order.",
        "code_id": "c_group_2_id_329",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_324",
        "query_text": "SUMMARY: This function takes a 4x4 matrix of floats (representing a perspective projection in a left-handed coordinate system with a zero-to-one depth range) and a float value as inputs. It adjusts the projection matrix by shifting its far clipping plane by the given delta value. The function recalculates key elements related to the near and far clipping distances and updates the corresponding matrix entries to reflect the new far plane position, while maintaining the proper perspective transformation. The output is the modified 4x4 matrix (the changes are applied in-place), and the function returns no value.",
        "code_id": "c_group_2_id_324",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x26\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x10(%rbp),%xmm0\ndivss  -0x14(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x14(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x5c\n\naddss  %xmm0,%xmm1\nmovss  -0x10(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  -0x2c(%rbp),%xmm1\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nsubss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x8c\n\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0xa2\n\nxorps  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x30,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_335",
        "query_text": "SUMMARY: This function operates on three input variables: a three-element float array (representing a vector), a single float (scalar), and another three-element float array (representing a destination vector to be modified). For each of the three elements, the function multiplies the corresponding element of the first array by the scalar, then subtracts that product from the corresponding element of the destination array.",
        "code_id": "c_group_2_id_335",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmulss  -0xc(%rbp),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_345",
        "query_text": "SUMMARY: This function takes two inputs of type int[4] and produces an output of type int[4]. It computes element-wise multiplication by multiplying each corresponding integer in the input arrays and stores the resulting products in the output array.",
        "code_id": "c_group_2_id_345",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x8,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0xc,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_326",
        "query_text": "SUMMARY: This function accepts an input variable of type \"vec2\" (an array of two floats) and computes the floor value for each element. The resulting values are then stored in an output variable of type \"vec2\" (also an array of two floats). Essentially, it rounds each of the two input float components down to the nearest integer value and writes the result to the corresponding position in the output array.",
        "code_id": "c_group_2_id_326",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x24\nmovd   %xmm0,%eax\nmov    -0x20(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovd   %eax,%xmm0\ncall   0x49\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_321",
        "query_text": "SUMMARY: This function accepts two parameters of type \"int[2]\"\u2014a source vector and a destination vector. It copies the two integer elements from the source vector into the destination vector, ensuring that the output vector contains the same pair of integer values as the input vector.",
        "code_id": "c_group_2_id_321",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_332",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (of type mat4, which is an array of four aligned 4-element float vectors) and two pointers to floats. It extracts specific elements from the matrix, calculates a near clipping distance from one of the matrix\u2019s entries, and then computes two horizontal frustum bounds (left and right) based on that near distance and other matrix elements. The results are stored in the floats pointed to by the two pointer arguments.",
        "code_id": "c_group_2_id_332",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x47\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm2        # 0x69\n\nsubss  %xmm2,%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x83\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0x10(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa6\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0x10(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_343",
        "query_text": "SUMMARY: The function accepts two inputs\u2014a 3-element array of type int (int[3]) and an integer scalar (int)\u2014and produces an output that is a 3-element array of type int (int[3]). It multiplies each element of the input array by the scalar value and assigns the resulting values to the corresponding elements of the output array.",
        "code_id": "c_group_2_id_343",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nimul   -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x8,%rdx\nimul   -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_322",
        "query_text": "SUMMARY: This function multiplies a 3\u00d72 matrix (an array consisting of 3 elements, each being an array of 2 floats) with a 3-dimensional vector (an array of 3 floats) to produce a 2-dimensional vector (an array of 2 floats). It first extracts the three float components from the input vector, then computes each component of the resulting vector as a linear combination of the extracted components weighted by corresponding elements from the matrix. The first output float is calculated by summing the products of the first element of each matrix sub-array with the respective vector components, while the second output float is generated using the second elements from the matrix sub-arrays.",
        "code_id": "c_group_2_id_322",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_341",
        "query_text": "SUMMARY: This function accepts three parameters of type vec2 (a two-element float array). It computes the element-wise difference between the first and second vec2 inputs, and then adds each resulting component to the corresponding component of the output vec2. Essentially, it updates the output by accumulating the differences between the two input vectors.",
        "code_id": "c_group_2_id_341",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm2\nsubss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nsubss  %xmm2,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_318",
        "query_text": "SUMMARY: This function takes as inputs a 2\u00d74 matrix (of type mat2x4, represented as an array of 2 vec4\u2019s) and a 4\u00d72 matrix (of type mat4x2, represented as an array of 4 vec2\u2019s) and computes their product, storing the result in a 4\u00d74 matrix (of type mat4, represented as an array of 4 vec4\u2019s). In essence, it forms each column of the 4\u00d74 output by taking a linear combination of the two columns of the 2\u00d74 input, with the weights being the corresponding elements from a column (or row, depending on conceptual layout) of the 4\u00d72 input.",
        "code_id": "c_group_2_id_318",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %rdx,-0x58(%rbp)\nmov    -0x48(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x40(%rbp)\nmov    -0x48(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x3c(%rbp)\nmov    -0x48(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x38(%rbp)\nmov    -0x48(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x34(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x30(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x50(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x50(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x50(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x50(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x50(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x50(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x50(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x50(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x40(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x30(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x2c(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x38(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0x34(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmovss  -0x40(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x30(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x2c(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x38(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x34(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0xc(%rax)\nmovss  -0x40(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x30(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x2c(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x38(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x28(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x34(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0xc(%rax)\nmovss  -0x40(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x30(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x30,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x2c(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x30,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x38(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x30,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x34(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x30,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_336",
        "query_text": "SUMMARY: This function accepts two input variables and one output variable, each of which is a three-element array of integers (ivec3). It computes the element-wise difference between the first and second input arrays, then adds each resulting difference to the corresponding element of the output array.",
        "code_id": "c_group_2_id_336",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nsub    %eax,%edx\nadd    %ecx,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nlea    (%rcx,%rsi,1),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x8,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nlea    (%rcx,%rsi,1),%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_349",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (of type mat4, which is an array of four aligned vec4 arrays of floats) and a pointer to a float (of type float*). It computes the far clipping plane distance from a perspective projection matrix configured for a left-handed coordinate system with a depth range from zero to one. Specifically, it performs a calculation using selected elements from the input matrix and stores the computed far-plane distance in the output float variable.",
        "code_id": "c_group_2_id_349",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm2\nmovss  0x0(%rip),%xmm1        # 0x32\n\nsubss  %xmm2,%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_331",
        "query_text": "SUMMARY: This function accepts an output variable of type mat3 (which is a 3\u00d73 array of floats) and an input variable of type float representing an angle. Its purpose is to construct a 3\u00d73 transformation matrix that encapsulates a two-dimensional rotation in homogeneous coordinates. The function computes the sine and cosine of the given angle and organizes these values within the matrix to represent the standard 2D rotational transformation. No value is returned.",
        "code_id": "c_group_2_id_331",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmovd   %eax,%xmm0\ncall   0x21\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nmovd   %eax,%xmm0\ncall   0x34\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  -0x8(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x18(%rbp),%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x78\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x0(%rip),%xmm0        # 0xd3\n\nmovss  %xmm0,0x8(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_344",
        "query_text": "SUMMARY: This function takes an input consisting of an array of four integers and a single integer scalar, and produces an output array of four integers. For each element in the input array, it adds the scalar to the element and stores the result in the corresponding element of the output array.",
        "code_id": "c_group_2_id_344",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    -0xc(%rbp),%edx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    -0xc(%rbp),%edx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    -0xc(%rbp),%edx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_338",
        "query_text": "SUMMARY: This function operates on three variables of type ivec2 (which are int[2]). It subtracts the difference between the corresponding elements of the first two input variables from each element of the output variable. Specifically, for each coordinate index, it updates the output by subtracting the result of the difference (first input minus second input).",
        "code_id": "c_group_2_id_338",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nsub    %eax,%ecx\nsub    %ecx,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rcx\nadd    $0x4,%rcx\nmov    (%rcx),%ecx\nsub    %ecx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %esi,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_364",
        "query_text": "SUMMARY: This function takes as input a 4-element array of integers (ivec4) and modifies it in-place by setting all four elements to the integer value zero, without returning any value.",
        "code_id": "c_group_2_id_364",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovl   $0x0,(%rax)\nmov    -0x8(%rbp),%rdx\nadd    $0x8,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rdx),%edx\nmov    %edx,(%rax)\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_366",
        "query_text": "SUMMARY: This function accepts an input of type vec4 (a 4-element array of 32-bit floats) and computes, for each element, its fractional part by subtracting the floor of the element\u2019s value. It then clamps each fractional result so that it does not exceed approximately 0.99999994, and stores the resulting 4-element array in an output variable of the same type.",
        "code_id": "c_group_2_id_366",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm2\nmovss  %xmm2,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x31\nmovss  -0x24(%rbp),%xmm2\nsubss  %xmm0,%xmm2\nmovd   %xmm2,%eax\nmovss  0x0(%rip),%xmm1        # 0x46\n\nmovd   %eax,%xmm0\ncall   0x4f\nmovd   %xmm0,%eax\nmov    -0x20(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm3\nmovss  %xmm3,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x7d\nmovss  -0x24(%rbp),%xmm3\nsubss  %xmm0,%xmm3\nmovd   %xmm3,%eax\nmov    -0x20(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovss  0x0(%rip),%xmm1        # 0x9a\n\nmovd   %eax,%xmm0\ncall   0xa3\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm4\nmovss  %xmm4,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0xcd\nmovss  -0x24(%rbp),%xmm4\nsubss  %xmm0,%xmm4\nmovd   %xmm4,%eax\nmov    -0x20(%rbp),%rdx\nlea    0x8(%rdx),%rbx\nmovss  0x0(%rip),%xmm1        # 0xea\n\nmovd   %eax,%xmm0\ncall   0xf3\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm5\nmovss  %xmm5,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x11d\nmovss  -0x24(%rbp),%xmm5\nsubss  %xmm0,%xmm5\nmovd   %xmm5,%eax\nmov    -0x20(%rbp),%rdx\nlea    0xc(%rdx),%rbx\nmovss  0x0(%rip),%xmm1        # 0x13a\n\nmovd   %eax,%xmm0\ncall   0x143\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_354",
        "query_text": "SUMMARY: This function receives a 2\u00d72 matrix (mat2, which is defined as an array of two float[2] vectors with potential 16\u2010byte alignment) as an in/out parameter and a float scalar as an input. It scales the matrix by multiplying each element in the matrix by the scalar value, updating the matrix directly.",
        "code_id": "c_group_2_id_354",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x58(%rbp)\nmovss  %xmm0,-0x5c(%rbp)\nmovss  -0x5c(%rbp),%xmm0\nmovss  %xmm0,-0x44(%rbp)\nmovss  -0x44(%rbp),%xmm0\nshufps $0x0,%xmm0,%xmm0\nmovaps %xmm0,%xmm1\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmovups (%rax),%xmm0\nmovaps %xmm0,-0x20(%rbp)\nmovaps %xmm1,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\nmulps  -0x10(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmov    -0x40(%rbp),%rax\nmovaps -0x30(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_333",
        "query_text": "SUMMARY: This function multiplies each element of an input 2-dimensional integer vector (ivec2) by an integer scalar and stores the resulting values in an output 2-dimensional integer vector (ivec2). Specifically, the first element of the input vector is multiplied by the scalar and assigned to the first element of the output vector, and the second element is similarly processed for the second output element.",
        "code_id": "c_group_2_id_333",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nimul   -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_353",
        "query_text": "SUMMARY: This function takes an input of type \"pointer to constant float\" (representing an array of at least four floats) and an output of type \"vec4\" (an aligned array of four floats). It copies each of the four individual float values from the input array to the corresponding position in the output array, effectively building a 4-dimensional vector from the provided source data.",
        "code_id": "c_group_2_id_353",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_340",
        "query_text": "SUMMARY: This function accepts an input matrix of type mat2x3 (an array consisting of 2 vectors, each containing 3 floats) and produces an output matrix of type mat3x2 (an array consisting of 3 vectors, each containing 2 floats) that is the transpose of the input. The function rearranges the elements by swapping the row and column indices, so that each element in the output matrix is taken from the corresponding transposed position of the input matrix.",
        "code_id": "c_group_2_id_340",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_347",
        "query_text": "SUMMARY: This function receives a 4x4 matrix (type: mat4) and a single precision floating-point number (type: float) as inputs, and it produces no output (return type: void). Its behavior is to modify the input matrix by incrementally adjusting the element located at the fourth row and first column by adding the provided floating-point value.",
        "code_id": "c_group_2_id_347",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\naddss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_339",
        "query_text": "SUMMARY: This function takes an input of type int[4] and produces an output of type int[3]. It sequentially copies the first three integers from the input array into the output array, effectively transferring the initial three elements while ignoring the fourth element.",
        "code_id": "c_group_2_id_339",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_357",
        "query_text": "SUMMARY: This function accepts a 4x4 matrix (of type mat4, which is an aligned array of four vec4, where each vec4 is an aligned array of four floats) and two integer indices. It exchanges the rows of the matrix corresponding to those two indices, effectively swapping their positions in the 4x4 matrix. The function directly modifies the input matrix and does not return any value.",
        "code_id": "c_group_2_id_357",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %edx,-0x30(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x28(%rbp),%rax\nmov    -0x2c(%rbp),%edx\nmovslq %edx,%rdx\nmovss  (%rax,%rdx,4),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x28(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x28(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nlea    0x30(%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    -0x30(%rbp),%edx\nmovslq %edx,%rdx\nmovss  (%rax,%rdx,4),%xmm0\nmov    -0x28(%rbp),%rax\nmov    -0x2c(%rbp),%edx\nmovslq %edx,%rdx\nmovss  %xmm0,(%rax,%rdx,4)\nmov    -0x28(%rbp),%rax\nlea    0x10(%rax),%rcx\nmov    -0x28(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x30(%rbp),%eax\ncltq   \nmovss  (%rcx,%rax,4),%xmm0\nmov    -0x2c(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nmov    -0x28(%rbp),%rax\nlea    0x20(%rax),%rcx\nmov    -0x28(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x30(%rbp),%eax\ncltq   \nmovss  (%rcx,%rax,4),%xmm0\nmov    -0x2c(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nmov    -0x28(%rbp),%rax\nlea    0x30(%rax),%rcx\nmov    -0x28(%rbp),%rax\nlea    0x30(%rax),%rdx\nmov    -0x30(%rbp),%eax\ncltq   \nmovss  (%rcx,%rax,4),%xmm0\nmov    -0x2c(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nmovss  -0x20(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmov    -0x30(%rbp),%edx\nmovslq %edx,%rdx\nmovss  %xmm0,(%rax,%rdx,4)\nmov    -0x28(%rbp),%rax\nlea    0x10(%rax),%rdx\nmovss  -0x1c(%rbp),%xmm0\nmov    -0x30(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nmov    -0x28(%rbp),%rax\nlea    0x20(%rax),%rdx\nmovss  -0x18(%rbp),%xmm0\nmov    -0x30(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nmov    -0x28(%rbp),%rax\nlea    0x30(%rax),%rdx\nmovss  -0x14(%rbp),%xmm0\nmov    -0x30(%rbp),%eax\ncltq   \nmovss  %xmm0,(%rdx,%rax,4)\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x176\ncall   0x176\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_350",
        "query_text": "SUMMARY: This function accepts an input of type float[3] and returns a float. Its purpose is to determine the smallest value among the three elements in the input array by comparing each element and selecting the minimum, then returning that value as output.",
        "code_id": "c_group_2_id_350",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  -0x4(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njbe    0x3d\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  -0x4(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njbe    0x61\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_368",
        "query_text": "SUMMARY: This inline function accepts an input of type integer array with three elements (ivec3) and returns no output (void). The function's behavior is to set each of the three integer elements in the array to zero, effectively initializing or resetting the array's contents.",
        "code_id": "c_group_2_id_368",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmovl   $0x0,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rdx),%edx\nmov    %edx,(%rax)\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_374",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 floating-point matrix (an array of four 4-element float vectors) and two pointers to floats as inputs. It computes two scalar floating-point outputs representing near and far clipping distances by extracting specific elements from the input matrix and applying division operations using those elements. Specifically, it derives the near clipping distance by dividing one matrix element by another, and the far clipping distance by dividing the same element by an incremented version of the other. The resulting values are stored in the provided float pointers.",
        "code_id": "c_group_2_id_374",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x57\n\naddss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_334",
        "query_text": "SUMMARY: This function takes an input of type vec3 (an array of three floats) and returns a float as output. It examines the three components of the input vector to determine which one has the greatest value, ultimately returning that highest float value. The function initially considers the first element as the maximum, then sequentially compares the second and third elements to update the maximum when a larger value is found, and finally outputs the largest value.",
        "code_id": "c_group_2_id_334",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\ncomiss -0x4(%rbp),%xmm0\njbe    0x39\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\ncomiss -0x4(%rbp),%xmm0\njbe    0x59\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_386",
        "query_text": "SUMMARY: This function accepts a 3-element vector of floats (vec3) representing Euler angles and computes a corresponding quaternion (versor, a 4-element aligned float array) that applies the rotation defined by a Y-X-Z ordering in a left-handed coordinate system. It calculates half-angle sine and cosine components for each Euler angle (with the sine of the third angle negated to account for the coordinate system), then combines these values to produce the four components of the resulting quaternion.",
        "code_id": "c_group_2_id_386",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmovss  0x0(%rip),%xmm0        # 0xed\n\nmovd   %eax,%xmm2\nxorps  %xmm0,%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x110\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x121\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x162\n\nxorps  %xmm1,%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmovss  -0x10(%rbp),%xmm1\nmulss  -0x18(%rbp),%xmm1\nmulss  -0x4(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_355",
        "query_text": "SUMMARY: The function performs multiplication between a 3x2 matrix (an array of three 2-element float arrays) and a 2x3 matrix (an array of two 3-element float arrays), producing a 2x2 matrix (an array of two 2-element float arrays) as the output. In essence, it computes each element of the resulting matrix by evaluating the dot products between appropriate rows of the first matrix and columns of the second matrix.",
        "code_id": "c_group_2_id_355",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x30(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x40(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x40(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x40(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x30(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x48(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x2c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x48(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x30(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x48(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x2c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x48(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_351",
        "query_text": "SUMMARY: The function accepts a constant two-element integer array (ivec2) and a pointer to a FILE (output stream). It produces no return value. Its primary role is to write a formatted representation of the two-element integer vector to the provided output stream. Specifically, it outputs a label indicating an integer vector with two elements, then prints each integer in the array within parentheses with preset spacing and color formatting, concluding with a reset of the formatting and additional newlines.",
        "code_id": "c_group_2_id_351",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    $0x2,%edx\nlea    0x0(%rip),%rcx        # 0x24\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x34\nmovl   $0x0,-0x4(%rbp)\njmp    0x72\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x5e\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x6e\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njle    0x3d\nmov    -0x20(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x9,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x90\nmov    %rax,%rdi\ncall   0x98\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_361",
        "query_text": "SUMMARY: This function computes the inverse of a 2x2 matrix. It accepts an input of type mat2 (an array of two vec2, with each vec2 being a 2-element array of float) representing the matrix to be inverted, and produces an output of the same type (mat2) that contains the inverse matrix. The function extracts the four individual float elements from the input matrix, calculates the reciprocal of its determinant, and then computes each element of the inverse matrix using the standard inversion formula for 2x2 matrices.",
        "code_id": "c_group_2_id_361",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmovss  -0x10(%rbp),%xmm1\nmovaps %xmm1,%xmm2\nmulss  -0xc(%rbp),%xmm2\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmovss  0x0(%rip),%xmm0        # 0x74\n\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x10(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x9c\n\nxorps  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0xba\n\nxorps  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_358",
        "query_text": "SUMMARY: This function accepts three arrays of three floating-point numbers (vec3) as inputs. It processes an in-place update on the third array by subtracting, for each corresponding index, the product of the elements from the first and second arrays. In essence, each element of the output array is reduced by the product of the corresponding elements of the two input arrays.",
        "code_id": "c_group_2_id_358",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm1\nmulss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmulss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmulss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_360",
        "query_text": "SUMMARY: This function accepts an input of type const float* and an output of type vec3 (an array of three floats). It sequentially copies three float values from the input to the output array by assigning the first float to the first element, the second float to the second element, and the third float to the third element.",
        "code_id": "c_group_2_id_360",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_337",
        "query_text": "SUMMARY: This function takes two inputs\u2014a three-element array of floats (vec3) and a float scalar\u2014and produces an output that is also a three-element array of floats (vec3). It computes the floating-point remainder of each element in the input array when divided by the scalar, storing the three corresponding results in the output array.",
        "code_id": "c_group_2_id_337",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmovss  %xmm0,-0x1c(%rbp)\nmov    %rsi,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovss  -0x1c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x31\nmovd   %xmm0,%eax\nmov    -0x28(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x28(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovss  -0x1c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x5e\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x28(%rbp),%rdx\nlea    0x8(%rdx),%rbx\nmovss  -0x1c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x87\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_346",
        "query_text": "SUMMARY: This function takes three arrays of three integers each (int[3]). It subtracts, element by element, the sum of the corresponding elements of the first two integer arrays from the corresponding element of the third array, updating the output array with the result.",
        "code_id": "c_group_2_id_346",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nadd    %ecx,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_369",
        "query_text": "SUMMARY: This function accepts a 3\u00d74 matrix (type mat3x4: an array of three 4-element float vectors) and a 3D vector (type vec3: an array of three floats) as inputs and produces a 4D vector (type vec4: an array of four floats) as output. It extracts the three scalar components of the 3D vector and, for each of the four output components, computes the sum of the products of these scalars with the corresponding elements from the 3\u00d74 matrix. Essentially, it performs a multiplication of the 3\u00d74 matrix with the 3D vector to generate a transformed 4D vector.",
        "code_id": "c_group_2_id_369",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0xc(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_359",
        "query_text": "SUMMARY: This function accepts two inputs, each being an array of four integers (ivec4), and computes their element-wise addition. It produces an output that is also an array of four integers (ivec4), where each position is the sum of the corresponding elements from the two input arrays.",
        "code_id": "c_group_2_id_359",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_383",
        "query_text": "SUMMARY: This function takes an integer vector of three elements (ivec3) and two integer values representing a minimum and a maximum. It ensures that each element of the vector is adjusted to lie within the inclusive range defined by these minimum and maximum values. If any element is less than the minimum, it is set to the minimum; if it is greater than the maximum, it is set to the maximum. The function performs these modifications in place and does not return a value.",
        "code_id": "c_group_2_id_383",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %edx,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    0x28\nmov    -0x8(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\njmp    0x3c\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    0x3c\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    0x5a\nmov    -0x8(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\njmp    0x76\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    0x76\nmov    -0x8(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    0x94\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\njmp    0xb0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    0xb0\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_388",
        "query_text": "SUMMARY: This function accepts a scalar of type float and computes a four-element vector (vec4, an array of 4 floats). It calculates the cube, square, and the first power of the input value and then sets a constant value, resulting in an output vector whose elements correspond respectively to the cubic term, quadratic term, linear term, and the constant 1.0.",
        "code_id": "c_group_2_id_388",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmov    %rdi,-0x20(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x8,%rax\nmovss  -0x14(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x0(%rip),%xmm0        # 0x63\n\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_375",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two floats) and produces an output of the same type (an array of two floats) by computing the element-wise arithmetic negation of the input values. Specifically, it negates each of the two float elements from the input array and stores the results into the corresponding positions in the output array.",
        "code_id": "c_group_2_id_375",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x20\n\nxorps  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  0x0(%rip),%xmm1        # 0x47\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_365",
        "query_text": "SUMMARY: This function accepts a two-element array of integers (ivec2) and an integer scalar as its inputs. It performs element-wise subtraction by deducting the scalar from each component of the two-element integer array, and then stores the resulting values into an output two-element array of integers.",
        "code_id": "c_group_2_id_365",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nsub    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_370",
        "query_text": "SUMMARY: This function takes as input an integer array of two elements and an integer scalar, and it modifies an output integer array of two elements by subtracting from each of its elements the sum of the corresponding element in the input integer array and the scalar.",
        "code_id": "c_group_2_id_370",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %ecx,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_378",
        "query_text": "SUMMARY: This function accepts two inputs, each being an array of two integers (ivec2), representing 2D integer vectors. It calculates the squared differences between the corresponding components of these two arrays and returns the sum of these squared values as an integer.",
        "code_id": "c_group_2_id_378",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%rax\nmov    (%rax),%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\nadd    %edx,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_356",
        "query_text": "SUMMARY: This function scales a 4x2 matrix in place. It takes as input a 4x2 matrix (an array of four arrays of 2 floats each) and a scalar of type float. The function multiplies each element of the input matrix by the scalar, effectively applying a uniform scaling transformation to the matrix, and produces no explicit output (void return type).",
        "code_id": "c_group_2_id_356",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_367",
        "query_text": "SUMMARY: This function accepts as inputs a 4\u00d74 floating\u2010point matrix (mat4) representing a right-handed no-clip perspective projection and a single floating-point scalar (float) that specifies an adjustment to the far clipping plane. It computes the current near and far clipping distances using specific elements from the matrix, adjusts the far distance by the provided scalar, and then recalculates and updates the corresponding entries in the matrix. The output is the modified projection matrix (mat4) reflecting the new far clipping plane position.",
        "code_id": "c_group_2_id_367",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm2        # 0x42\n\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmovss  -0x10(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x14(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x64\n\naddss  %xmm0,%xmm1\nmovss  -0x10(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  -0x2c(%rbp),%xmm1\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nsubss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x94\n\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\naddss  -0xc(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x30,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_348",
        "query_text": "SUMMARY: This function accepts an input of type mat2x3 (a two-by-three array of floats) and a scalar of type float, and produces no return value (void). Its primary operation is to uniformly scale each element of the two-by-three matrix by the provided floating-point scalar, updating the matrix in place.",
        "code_id": "c_group_2_id_348",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_376",
        "query_text": "SUMMARY: This function takes two inputs\u2014a 3-element integer array and a scalar integer\u2014and produces an output in the form of a 4-element integer array. It populates the first three elements of the output with the values from the input 3-element array and assigns the scalar integer to the fourth element of the output.",
        "code_id": "c_group_2_id_376",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_352",
        "query_text": "SUMMARY: This function takes a vector of 4 integers as one input, an integer scalar as another input, and a second vector of 4 integers as the output. It performs an element-wise operation whereby each element of the output vector is incremented by the sum of the corresponding element from the input vector and the scalar integer.",
        "code_id": "c_group_2_id_352",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %ecx,%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_363",
        "query_text": "SUMMARY: This function accepts three arguments, each being an array of two single-precision floating-point values (vec2). It multiplies the corresponding components of the two input arrays and then adds each product to the respective component of the destination array, updating it in place.",
        "code_id": "c_group_2_id_363",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_377",
        "query_text": "SUMMARY: This function accepts as inputs a 4\u00d74 float matrix (of type vec4[4]) and a pointer to a FILE stream (of type FILE*). It does not return any value. Its functionality is to print a formatted textual representation of the 4\u00d74 matrix to the given FILE stream. The function begins by outputting a header that indicates the dimensions of the matrix, then measures the formatted width of each element (using either fixed decimal precision or general formatting based on a preset threshold) to determine appropriate column widths. Using these computed column widths, it generates and prints each row of the matrix within a bordered layout and applies designated color formatting, finally resetting the color output once printing completes.",
        "code_id": "c_group_2_id_377",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x50(%rbp),%rax\nmov    $0x4,%ecx\nmov    $0x4,%edx\nlea    0x0(%rip),%rsi        # 0x38\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x45\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,-0x30(%rbp)\nmovl   $0x0,-0x3c(%rbp)\njmp    0x17d\nmovl   $0x0,-0x38(%rbp)\njmp    0x16f\nmov    -0x3c(%rbp),%eax\ncltq   \nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x9b\n\ncomiss %xmm1,%xmm0\njbe    0xf6\nmov    -0x3c(%rbp),%eax\ncltq   \nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovq   %xmm2,%rdx\nlea    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdx        # 0xdf\nmov    $0x10,%esi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xf1\nmov    %eax,-0x34(%rbp)\njmp    0x145\nmov    -0x3c(%rbp),%eax\ncltq   \nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm3,%xmm3\ncvtss2sd %xmm0,%xmm3\nmovq   %xmm3,%rdx\nlea    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0x130\nmov    $0x10,%esi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x142\nmov    %eax,-0x34(%rbp)\nmov    -0x3c(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%eax\ncmp    %eax,-0x34(%rbp)\njge    0x15e\nmov    -0x3c(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%eax\njmp    0x161\nmov    -0x34(%rbp),%eax\nmov    -0x3c(%rbp),%edx\nmovslq %edx,%rdx\nmov    %eax,-0x30(%rbp,%rdx,4)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x3,-0x38(%rbp)\njle    0x76\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x3,-0x3c(%rbp)\njle    0x6a\nmovl   $0x0,-0x3c(%rbp)\njmp    0x2c5\nmov    -0x50(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x3,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x1ab\nmov    %rax,%rdi\ncall   0x1b3\nmovl   $0x0,-0x38(%rbp)\njmp    0x297\nmov    -0x3c(%rbp),%eax\ncltq   \nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x1e4\n\ncomiss %xmm1,%xmm0\njbe    0x240\nmov    -0x38(%rbp),%eax\ncltq   \nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x3c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm4,%xmm4\ncvtss2sd %xmm0,%xmm4\nmovq   %xmm4,%rcx\nmov    -0x38(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%edx\nmov    -0x50(%rbp),%rax\nmovq   %rcx,%xmm0\nmov    $0x5,%ecx\nlea    0x0(%rip),%rsi        # 0x231\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x23e\njmp    0x293\nmov    -0x38(%rbp),%eax\ncltq   \nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x3c(%rbp),%eax\ncltq   \nmovss  (%rdx,%rax,4),%xmm0\npxor   %xmm5,%xmm5\ncvtss2sd %xmm0,%xmm5\nmovq   %xmm5,%rcx\nmov    -0x38(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%edx\nmov    -0x50(%rbp),%rax\nmovq   %rcx,%xmm0\nlea    0x0(%rip),%rcx        # 0x283\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x293\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x3,-0x38(%rbp)\njle    0x1bf\nmov    -0x50(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x4,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x2b9\nmov    %rax,%rdi\ncall   0x2c1\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x3,-0x3c(%rbp)\njle    0x193\nmov    -0x50(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x5,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x2e7\nmov    %rax,%rdi\ncall   0x2ef\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x304\ncall   0x304\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_342",
        "query_text": "SUMMARY: This function receives an aligned 4\u00d74 matrix (of type mat4, where each row is a 4-element aligned float vector) and two pointers to float, which serve as outputs. Its purpose is to decompose the provided perspective projection matrix (configured for a right-handed coordinate system with a zero-to-one depth range) by extracting certain matrix components to calculate the horizontal extents of the view frustum at the near clipping plane. In detail, it computes the distance to the near clipping plane from an element of the matrix and then uses this distance together with other matrix elements to derive the left and right boundaries of the frustum. The resulting left and right boundary values are written to the locations indicated by the input float pointers.",
        "code_id": "c_group_2_id_342",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\ndivss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x68\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0x10(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x8b\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0x10(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_373",
        "query_text": "SUMMARY: This function accepts a 3x3 matrix (of type mat3, which is defined as an array of three vec3 arrays of floats) and a float scalar. It applies an in-place 2D translation along the horizontal axis to the matrix by updating its translation components. Specifically, it modifies the last row of the matrix by adding the product of the corresponding elements from the first row (representing the x-axis scale factors) and the float value to the existing values. The function does not return a value; instead, it directly alters the matrix.",
        "code_id": "c_group_2_id_373",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_394",
        "query_text": "SUMMARY: This function takes an input parameter of type \"array of 4 integers\" (ivec4) and performs an in-place modification where each element of the array is set to the integer value 1. There is no return value, as the function directly modifies the input.",
        "code_id": "c_group_2_id_394",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovl   $0x1,(%rax)\nmov    -0x8(%rbp),%rdx\nadd    $0x8,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rdx),%edx\nmov    %edx,(%rax)\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_389",
        "query_text": "SUMMARY: This function accepts an input parameter of type ivec2 (an array of 2 integers) and assigns the value 1 to both of its elements. It operates directly on the provided array and does not return any value.",
        "code_id": "c_group_2_id_389",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovl   $0x1,(%rax)\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_384",
        "query_text": "SUMMARY: This function operates on three input parameters, each of type vec4 (an aligned array of 4 floating-point values). It computes an element-wise subtraction between the first and second vec4 values and then subtracts the resulting difference from the third vec4 value, updating it in place with the outcome. The operation essentially performs, for each of the 4 elements, a calculation akin to: output element = original output element minus (first element minus second element), using the most appropriate vectorized instructions available for the current platform.",
        "code_id": "c_group_2_id_384",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    -0x80(%rbp),%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x78(%rbp),%rax\nmov    %rax,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x20(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\nsubps  -0x10(%rbp),%xmm0\nmov    -0x88(%rbp),%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x40(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmovaps -0x40(%rbp),%xmm0\nsubps  -0x30(%rbp),%xmm0\nmov    -0x88(%rbp),%rax\nmov    %rax,-0x70(%rbp)\nmovaps %xmm0,-0x50(%rbp)\nmov    -0x70(%rbp),%rax\nmovaps -0x50(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_362",
        "query_text": "SUMMARY: This function takes two inputs of type \"int[3]\" (3-element integer arrays) and computes an output of type int. It calculates each corresponding difference between the elements of the inputs, squares these differences, and returns the sum, which represents the squared Euclidean distance.",
        "code_id": "c_group_2_id_362",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%rax\nmov    (%rax),%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nadd    $0x8,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\nadd    %eax,%edx\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\nadd    %edx,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_380",
        "query_text": "SUMMARY: This function operates on three variables of type ivec2 (arrays of two integers). It computes the element-wise remainder of the integers from the first input against the corresponding integers from the second input and stores the results in the output variable of type ivec2.",
        "code_id": "c_group_2_id_380",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nmov    (%rdx),%ecx\ncltd   \nidiv   %ecx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%esi\nmov    -0x18(%rbp),%rdx\nlea    0x4(%rdx),%rcx\ncltd   \nidiv   %esi\nmov    %edx,%eax\nmov    %eax,(%rcx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_379",
        "query_text": "SUMMARY: This function accepts two input variables, each of type ivec2 (an array of 2 integers), and an output variable of the same type. It calculates the integer division of each corresponding element from the two input arrays and stores each result in the output array.",
        "code_id": "c_group_2_id_379",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nmov    (%rdx),%esi\ncltd   \nidiv   %esi\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edi\nmov    -0x18(%rbp),%rcx\nadd    $0x4,%rcx\ncltd   \nidiv   %edi\nmov    %eax,(%rcx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_391",
        "query_text": "SUMMARY: This function accepts two input parameters: one of type int[4] (a four-element integer array) and one of type FILE* (a pointer to a file stream). It outputs no value. Its behavior is to format and print the provided 4-element integer array to the given file stream, including a header indicating the vector\u2019s size and a list of its elements, with additional formatting (such as color markers) applied to the output.",
        "code_id": "c_group_2_id_391",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    $0x4,%edx\nlea    0x0(%rip),%rcx        # 0x24\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x34\nmovl   $0x0,-0x4(%rbp)\njmp    0x72\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x5e\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x6e\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x3,-0x4(%rbp)\njle    0x3d\nmov    -0x20(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x9,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x90\nmov    %rax,%rdi\ncall   0x98\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_385",
        "query_text": "SUMMARY: This function processes an input of type int[4] and an integer scalar. It multiplies each of the four integer elements from the input by the scalar and stores the results in an output of type int[4].",
        "code_id": "c_group_2_id_385",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nimul   -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x8,%rdx\nimul   -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0xc,%rdx\nimul   -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_396",
        "query_text": "SUMMARY: This function takes a 3-element floating-point vector (vec3) and a 4\u00d74 floating-point matrix (mat4) as inputs, and returns a floating-point value. It computes two intermediate scalar values by linearly combining the vector's components with specific columns of the matrix. The first scalar represents the transformed depth (from the matrix\u2019s third column and translation component), while the second represents a homogeneous coordinate (using the matrix\u2019s fourth column and translation component). The function then performs a perspective division of these two scalars and scales/shifts the result to yield a normalized depth value in a 0 to 1 range.",
        "code_id": "c_group_2_id_396",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm2\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm2\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0xc(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm2\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x20,%rax\nmovss  0xc(%rax),%xmm2\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x20(%rbp),%rax\nadd    $0x30,%rax\nmovss  0xc(%rax),%xmm0\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\ndivss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xff\n\nmulss  %xmm0,%xmm1\nmovss  0x0(%rip),%xmm0        # 0x10b\n\naddss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_381",
        "query_text": "SUMMARY: This function operates on three variables of type ivec2 (i.e., arrays of two integers). It computes the element-wise difference between the first and second input vectors and then adds each difference to the corresponding element of the output vector. Specifically, for the first element, it adds the difference (first input's element minus second input's element) to the first element of the output vector, and similarly for the second element.",
        "code_id": "c_group_2_id_381",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nsub    %eax,%edx\nadd    %ecx,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nlea    (%rcx,%rsi,1),%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_371",
        "query_text": "SUMMARY: This function takes an input 4\u00d74 matrix (of type mat4, which is an array of four 16-byte aligned float[4] vectors) and produces its transposed version as an output 4\u00d74 matrix (also of type mat4). It loads the rows of the input matrix into SIMD registers, transposes the 4\u00d74 data using SSE2 operations, and then stores the resulting vectors into the output matrix.",
        "code_id": "c_group_2_id_371",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x198,%rsp\nmov    %rdi,-0x208(%rbp)\nmov    %rsi,-0x210(%rbp)\nmov    -0x208(%rbp),%rax\nmov    %rax,-0x1c8(%rbp)\nmov    -0x1c8(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x1c0(%rbp)\nmov    -0x208(%rbp),%rax\nadd    $0x10,%rax\nmov    %rax,-0x1d0(%rbp)\nmov    -0x1d0(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x1b0(%rbp)\nmov    -0x208(%rbp),%rax\nadd    $0x20,%rax\nmov    %rax,-0x1d8(%rbp)\nmov    -0x1d8(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x1a0(%rbp)\nmov    -0x208(%rbp),%rax\nadd    $0x30,%rax\nmov    %rax,-0x1e0(%rbp)\nmov    -0x1e0(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x190(%rbp)\nmovaps -0x1c0(%rbp),%xmm0\nmovaps %xmm0,-0x20(%rbp)\nmovaps -0x1b0(%rbp),%xmm0\nmovaps %xmm0,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\nunpcklps -0x10(%rbp),%xmm0\nnop\nmovaps %xmm0,-0x180(%rbp)\nmovaps -0x1a0(%rbp),%xmm0\nmovaps %xmm0,-0x40(%rbp)\nmovaps -0x190(%rbp),%xmm0\nmovaps %xmm0,-0x30(%rbp)\nmovaps -0x40(%rbp),%xmm0\nunpcklps -0x30(%rbp),%xmm0\nnop\nmovaps %xmm0,-0x170(%rbp)\nmovaps -0x1c0(%rbp),%xmm0\nmovaps %xmm0,-0x60(%rbp)\nmovaps -0x1b0(%rbp),%xmm0\nmovaps %xmm0,-0x50(%rbp)\nmovaps -0x60(%rbp),%xmm0\nunpckhps -0x50(%rbp),%xmm0\nnop\nmovaps %xmm0,-0x160(%rbp)\nmovaps -0x1a0(%rbp),%xmm0\nmovaps %xmm0,-0x80(%rbp)\nmovaps -0x190(%rbp),%xmm0\nmovaps %xmm0,-0x70(%rbp)\nmovaps -0x80(%rbp),%xmm0\nunpckhps -0x70(%rbp),%xmm0\nnop\nmovaps %xmm0,-0x150(%rbp)\nmovaps -0x180(%rbp),%xmm0\nmovaps %xmm0,-0xa0(%rbp)\nmovaps -0x170(%rbp),%xmm0\nmovaps %xmm0,-0x90(%rbp)\nmovaps -0xa0(%rbp),%xmm0\nmovhps -0x90(%rbp),%xmm0\nnop\nmovaps %xmm0,-0x1c0(%rbp)\nmovaps -0x170(%rbp),%xmm0\nmovaps %xmm0,-0xc0(%rbp)\nmovaps -0x180(%rbp),%xmm0\nmovaps %xmm0,-0xb0(%rbp)\nmovaps -0xc0(%rbp),%xmm0\nmovlps -0xa8(%rbp),%xmm0\nnop\nmovaps %xmm0,-0x1b0(%rbp)\nmovaps -0x160(%rbp),%xmm0\nmovaps %xmm0,-0xe0(%rbp)\nmovaps -0x150(%rbp),%xmm0\nmovaps %xmm0,-0xd0(%rbp)\nmovaps -0xe0(%rbp),%xmm0\nmovhps -0xd0(%rbp),%xmm0\nnop\nmovaps %xmm0,-0x1a0(%rbp)\nmovaps -0x150(%rbp),%xmm0\nmovaps %xmm0,-0x100(%rbp)\nmovaps -0x160(%rbp),%xmm0\nmovaps %xmm0,-0xf0(%rbp)\nmovaps -0x100(%rbp),%xmm0\nmovlps -0xe8(%rbp),%xmm0\nnop\nmovaps %xmm0,-0x190(%rbp)\nmov    -0x210(%rbp),%rax\nmov    %rax,-0x1e8(%rbp)\nmovaps -0x1c0(%rbp),%xmm0\nmovaps %xmm0,-0x110(%rbp)\nmov    -0x1e8(%rbp),%rax\nmovaps -0x110(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x210(%rbp),%rax\nadd    $0x10,%rax\nmov    %rax,-0x1f0(%rbp)\nmovaps -0x1b0(%rbp),%xmm0\nmovaps %xmm0,-0x120(%rbp)\nmov    -0x1f0(%rbp),%rax\nmovaps -0x120(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x210(%rbp),%rax\nadd    $0x20,%rax\nmov    %rax,-0x1f8(%rbp)\nmovaps -0x1a0(%rbp),%xmm0\nmovaps %xmm0,-0x130(%rbp)\nmov    -0x1f8(%rbp),%rax\nmovaps -0x130(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x210(%rbp),%rax\nadd    $0x30,%rax\nmov    %rax,-0x200(%rbp)\nmovaps -0x190(%rbp),%xmm0\nmovaps %xmm0,-0x140(%rbp)\nmov    -0x200(%rbp),%rax\nmovaps -0x140(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_392",
        "query_text": "SUMMARY: This function accepts a floating-point value and a 4\u00d74 matrix of floats (where the matrix is represented as an array of four aligned 4-element vectors) and outputs no value (performing in-place modification). It verifies if the top-left element of the matrix is nonzero; if so, it updates that element by dividing another matrix element (the one representing the vertical scale) by the given float. Essentially, it adjusts the projection matrix\u2019s horizontal scaling based on an aspect ratio.",
        "code_id": "c_group_2_id_392",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\npxor   %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njp     0x2b\npxor   %xmm1,%xmm1\nucomiss %xmm1,%xmm0\nje     0x47\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\njmp    0x48\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_407",
        "query_text": "SUMMARY: This function converts a set of Euler angles, provided as an array of 3 floats (vec3), into a quaternion represented as an array of 4 floats (versor) using right-handed conventions. Initially, it computes the sine and cosine of half of each Euler angle. Then, it combines these trigonometric values to calculate the four components of the quaternion, encapsulating the rotation defined by the Euler angles.",
        "code_id": "c_group_2_id_407",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xfc\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x10d\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovss  -0x18(%rbp),%xmm1\nmulss  -0xc(%rbp),%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovss  -0x18(%rbp),%xmm1\nmulss  -0x10(%rbp),%xmm1\nmulss  -0x8(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_372",
        "query_text": "SUMMARY: This function takes as input a 4\u00d74 floating\u2010point matrix (of type mat4) representing a left-handed perspective projection and a single floating-point scalar (of type float). It recalculates and updates two specific elements of the matrix to effectively adjust the far clipping distance of the projection. To do so, the function derives the current near and far distances from the matrix\u2019s existing coefficients, adds an offset to the computed far distance, and then updates the matrix accordingly to maintain the correct projection transformation. The matrix is modified in place as the output.",
        "code_id": "c_group_2_id_372",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x26\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm2        # 0x4d\n\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmovss  -0x10(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x14(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x6f\n\naddss  %xmm0,%xmm1\nmovss  -0x10(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  -0x2c(%rbp),%xmm1\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nsubss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x9f\n\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\naddss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0xba\n\nxorps  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x20,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x30,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_387",
        "query_text": "SUMMARY: This function takes a 4\u00d73 matrix (of type mat4x3, i.e., an array of four 3-element single-precision floating-point vectors) and a scalar (of type float) as inputs. It scales every element of the provided matrix by multiplying each float value by the scalar, modifying the matrix in place. The function does not return any value.",
        "code_id": "c_group_2_id_387",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x24,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x24,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x24,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x24,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x24,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x24,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_405",
        "query_text": "SUMMARY: This function accepts an input of type mat4 (a 4x4 matrix of floats with 16-byte alignment) and a pointer to a float as output. It computes the near clipping plane distance for a right-handed perspective projection with a zero to one depth range. Specifically, it calculates the near distance by dividing a specific element from the fourth row by an element from the third row of the input matrix, and then stores the result via the provided float pointer.",
        "code_id": "c_group_2_id_405",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_382",
        "query_text": "SUMMARY: This function operates on a 4-element integer array (ivec4) and an integer scalar as inputs, and it produces an output in a 4-element integer array (ivec4). For each corresponding element, it subtracts the result of subtracting the scalar from the input vector element, then updates the output array element with this computed difference.",
        "code_id": "c_group_2_id_382",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_416",
        "query_text": "SUMMARY: This function takes two arrays of three floats (vec3) as arguments. It processes the input by applying the floor mathematical operation (which rounds each float down to the nearest integer value) to every element of the first array, and writes the resulting three values into the corresponding positions of the second array. The function does not return a value.",
        "code_id": "c_group_2_id_416",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x24\nmovd   %xmm0,%eax\nmov    -0x20(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovd   %eax,%xmm0\ncall   0x49\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nlea    0x8(%rdx),%rbx\nmovd   %eax,%xmm0\ncall   0x6a\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_390",
        "query_text": "SUMMARY: This function accepts an input of type vec3 (an array of three floats) and returns an output of type float. It computes the sum of the three float values contained in the input array by adding them together and then returns the resulting float.",
        "code_id": "c_group_2_id_390",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_423",
        "query_text": "SUMMARY: This function takes a 4\u00d74 matrix (an array of four 4-element float vectors, type mat4) as input and returns a float. It computes a perspective field-of-view angle in radians by accessing a specific element from the matrix (the one at the second row and second column), calculating the reciprocal of that element, applying the arctan function to this reciprocal, and finally multiplying the result by two.",
        "code_id": "c_group_2_id_423",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x25\n\ndivss  %xmm1,%xmm0\nmovd   %xmm0,%eax\nmovd   %eax,%xmm0\ncall   0x36\naddss  %xmm0,%xmm0\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_415",
        "query_text": "SUMMARY: This function accepts a 4x4 matrix of floats (mat4) and two pointers to floats as inputs and outputs. Its purpose is to decompose a perspective projection matrix, extracting the vertical extents (top and bottom values) based on the given projection parameters. Internally, it reads specific elements from the matrix to compute an effective near clip distance and then uses this near value along with other matrix elements to derive the top and bottom extents. These computed float values are written to the provided memory locations for further use.",
        "code_id": "c_group_2_id_415",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0xc(%rax),%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x68\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0x8(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x8b\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0x8(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_402",
        "query_text": "SUMMARY: This function takes a 3-element float array, a float, and another 3-element float array as inputs. It multiplies each element of the first 3-element array by the float and then adds the resulting product to the corresponding element of the second 3-element array, updating it in place as the output.",
        "code_id": "c_group_2_id_402",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_406",
        "query_text": "SUMMARY: This function takes as input a 4-element array of floats (vec4) and a single float value, and it produces an output 4-element array of floats (vec4). It computes the floating-point remainder (using fmodf) of each component of the input array with respect to the provided float, storing the result in the corresponding component of the output array.",
        "code_id": "c_group_2_id_406",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmovss  %xmm0,-0x1c(%rbp)\nmov    %rsi,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovss  -0x1c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x31\nmovd   %xmm0,%eax\nmov    -0x28(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x28(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovss  -0x1c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x5e\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x28(%rbp),%rdx\nlea    0x8(%rdx),%rbx\nmovss  -0x1c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x87\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x28(%rbp),%rdx\nlea    0xc(%rdx),%rbx\nmovss  -0x1c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0xb0\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_404",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two float values) and a float scalar, computes the floating-point remainder (using the fmod operation) of each element in the input array with the scalar, and outputs a vec2 (an array of two float values) containing these remainders.",
        "code_id": "c_group_2_id_404",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmovss  %xmm0,-0x1c(%rbp)\nmov    %rsi,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmovss  -0x1c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x31\nmovd   %xmm0,%eax\nmov    -0x28(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x28(%rbp),%rdx\nlea    0x4(%rdx),%rbx\nmovss  -0x1c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmovd   %eax,%xmm0\ncall   0x5e\nmovd   %xmm0,%eax\nmov    %eax,(%rbx)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_401",
        "query_text": "SUMMARY: This function accepts two input variables, each of type ivec4 (a 4-element integer array), along with an output variable of the same type. For each of the four integer elements, it computes the product of the corresponding elements from the two input arrays and subtracts that product from the corresponding element in the output array. In other words, it performs an element-wise multiply\u2013subtract operation on the output array.",
        "code_id": "c_group_2_id_401",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %ecx,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nimul   %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_395",
        "query_text": "SUMMARY: This function takes two input parameters, each being an array of 2 floats, and returns a single float. It computes the dot product of the two 2-dimensional float vectors by performing element-wise multiplication and summing the results.",
        "code_id": "c_group_2_id_395",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_398",
        "query_text": "SUMMARY: This function takes an input vector (an aligned array of four floats), a scalar value (a float), and an output vector (an aligned array of four floats). It subtracts the scalar from each element of the input vector and stores the resulting values in the output vector. The implementation uses architecture-specific vectorized operations for platforms supporting WebAssembly SIMD, SSE, or NEON, and falls back to element-wise subtraction if those optimizations are not available.",
        "code_id": "c_group_2_id_398",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x58(%rbp)\nmovss  %xmm0,-0x5c(%rbp)\nmov    %rsi,-0x68(%rbp)\nmovss  -0x5c(%rbp),%xmm0\nmovss  %xmm0,-0x44(%rbp)\nmovss  -0x44(%rbp),%xmm0\nshufps $0x0,%xmm0,%xmm0\nmovaps %xmm0,%xmm1\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x20(%rbp)\nmovaps %xmm1,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\nsubps  -0x10(%rbp),%xmm0\nmov    -0x68(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmov    -0x40(%rbp),%rax\nmovaps -0x30(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_412",
        "query_text": "SUMMARY: This function accepts a constant pointer to a float (type: const float *) that points to a sequence of nine float values and produces a 3x3 matrix (type: mat3, an array of three vec3 arrays). It sequentially copies the nine float values into the matrix by mapping the first three values to the first vector, the next three to the second vector, and the final three to the third vector.",
        "code_id": "c_group_2_id_412",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x14(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_400",
        "query_text": "SUMMARY: This function accepts two input parameters, each being an array of three integers (int[3]), and calculates a component-wise sum of these arrays. The resulting array of three integers (int[3]) holds the sum of the corresponding elements from the two input arrays, with each position in the output computed by adding the respective integers from the inputs.",
        "code_id": "c_group_2_id_400",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_414",
        "query_text": "SUMMARY: This function receives an array of two integers (ivec2) and a single integer (int) as inputs, then assigns the integer value to both elements of the array. It performs this operation by directly updating the first and second elements of the array, effectively filling the two-element vector with the same integer value. There is no explicit return value, as the output is provided by modifying the input array in place.",
        "code_id": "c_group_2_id_414",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_399",
        "query_text": "SUMMARY: This function accepts a constant pointer to a float (input type: const float*) and populates a 3 by 2 matrix (output type: mat3x2, defined as an array of 3 float arrays of length 2) with values. It sequentially assigns the first two floats from the input to the first row of the matrix, the next two floats to the second row, and the final two floats to the third row.",
        "code_id": "c_group_2_id_399",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x14(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_411",
        "query_text": "SUMMARY: This function accepts a 4x4 matrix (an array of four aligned 4-element float vectors) and a pointer to a float output. It computes the far clipping plane distance for a right-handed perspective projection without a near plane by performing arithmetic on specific elements of the input matrix, then writes the computed value to the float pointed to by the second argument.",
        "code_id": "c_group_2_id_411",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm2\nmovss  0x0(%rip),%xmm1        # 0x32\n\naddss  %xmm2,%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_410",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two floats) and a scalar of type float. It computes the quotient of each element in the vec2 by the float scalar and returns the results in an output vec2 (an array of two floats).",
        "code_id": "c_group_2_id_410",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\ndivss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\ndivss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_420",
        "query_text": "SUMMARY: This function multiplies a 4x3 matrix (defined as an array of 4 vectors, where each vector is an array of 3 floats) by a 4-dimensional vector (aligned array of 4 floats) to compute a resulting 3-dimensional vector (array of 3 floats). It operates by individually extracting the four float components of the 4-dimensional input and then calculating each component of the 3-dimensional result as the sum of products of corresponding entries from the matrix and vector.",
        "code_id": "c_group_2_id_420",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x24,%rax\nmovss  (%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x24,%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x24,%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_393",
        "query_text": "SUMMARY: The function accepts three variables of type ivec4 (which are arrays of four integers). It modifies the output array by subtracting, for each of its four elements, the sum of the corresponding elements from the two input arrays.",
        "code_id": "c_group_2_id_393",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nadd    %ecx,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_422",
        "query_text": "SUMMARY: This function accepts two input variables of type float[2] and computes a new float[2] by performing component-wise multiplication. Specifically, it multiplies the first element of the first input with the first element of the second input and the second element of the first input with the second element of the second input, storing the results in the output variable of type float[2].",
        "code_id": "c_group_2_id_422",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_413",
        "query_text": "SUMMARY: This function receives a 4\u00d74 matrix (of type mat4, which is an array of four 4-element float vectors) and a floating-point scalar value. It multiplies every element of the matrix by the scalar, performing the operation in a vectorized manner using SSE2 instructions. The scaled matrix is updated in place and returned as type mat4.",
        "code_id": "c_group_2_id_413",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb8,%rsp\nmov    %rdi,-0x128(%rbp)\nmovss  %xmm0,-0x12c(%rbp)\n\nmovss  -0x12c(%rbp),%xmm0\n\nmovss  %xmm0,-0x114(%rbp)\n\nmovss  -0x114(%rbp),%xmm0\n\nshufps $0x0,%xmm0,%xmm0\nmovaps %xmm0,-0xd0(%rbp)\nmov    -0x128(%rbp),%rax\nmov    %rax,-0xd8(%rbp)\nmov    -0xd8(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x20(%rbp)\nmovaps -0xd0(%rbp),%xmm0\nmovaps %xmm0,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\nmulps  -0x10(%rbp),%xmm0\nmov    -0x128(%rbp),%rax\nmov    %rax,-0xe0(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmov    -0xe0(%rbp),%rax\nmovaps -0x30(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x128(%rbp),%rax\nadd    $0x10,%rax\nmov    %rax,-0xe8(%rbp)\nmov    -0xe8(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x50(%rbp)\nmovaps -0xd0(%rbp),%xmm0\nmovaps %xmm0,-0x40(%rbp)\nmovaps -0x50(%rbp),%xmm0\nmulps  -0x40(%rbp),%xmm0\nmov    -0x128(%rbp),%rax\nadd    $0x10,%rax\nmov    %rax,-0xf0(%rbp)\nmovaps %xmm0,-0x60(%rbp)\nmov    -0xf0(%rbp),%rax\nmovaps -0x60(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x128(%rbp),%rax\nadd    $0x20,%rax\nmov    %rax,-0xf8(%rbp)\nmov    -0xf8(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x80(%rbp)\nmovaps -0xd0(%rbp),%xmm0\nmovaps %xmm0,-0x70(%rbp)\nmovaps -0x80(%rbp),%xmm0\nmulps  -0x70(%rbp),%xmm0\nmov    -0x128(%rbp),%rax\nadd    $0x20,%rax\nmov    %rax,-0x100(%rbp)\nmovaps %xmm0,-0x90(%rbp)\nmov    -0x100(%rbp),%rax\nmovaps -0x90(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nmov    -0x128(%rbp),%rax\nadd    $0x30,%rax\nmov    %rax,-0x108(%rbp)\nmov    -0x108(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0xb0(%rbp)\nmovaps -0xd0(%rbp),%xmm0\nmovaps %xmm0,-0xa0(%rbp)\nmovaps -0xb0(%rbp),%xmm0\nmulps  -0xa0(%rbp),%xmm0\nmov    -0x128(%rbp),%rax\nadd    $0x30,%rax\nmov    %rax,-0x110(%rbp)\nmovaps %xmm0,-0xc0(%rbp)\nmov    -0x110(%rbp),%rax\nmovaps -0xc0(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_427",
        "query_text": "SUMMARY: This inline function takes two inputs: a 3-component float array and a float number, and it produces a 4-component float array as output. The function assigns the elements of the input 3-component float array to the first three positions of the output array, and then it assigns the float number to the fourth position of the output array.",
        "code_id": "c_group_2_id_427",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x18(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_425",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 single\u2010precision floating-point matrix and two pointers to single-precision floats as inputs and computes two scalar values representing vertical boundaries. It extracts specific elements from the matrix corresponding to vertical scaling and translation parameters, computes a near-plane distance using another matrix element, and then calculates the upper and lower vertical limits based on these extracted values. The resulting computed single-precision floats are output via the provided pointer parameters.",
        "code_id": "c_group_2_id_425",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm2        # 0x64\n\nsubss  %xmm2,%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x10(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x7e\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0xc(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x10(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa1\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0xc(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_417",
        "query_text": "SUMMARY: This function accepts an input of type int[3] and an int value. It assigns the provided int to every element of the int[3] array, resulting in all entries containing the same integer. The function does not return any value (void).",
        "code_id": "c_group_2_id_417",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rdx),%edx\nmov    %edx,(%rax)\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_421",
        "query_text": "SUMMARY: This function performs a copy operation from one 4\u00d73 matrix to another. It takes an input of type mat4x3 (an array of 4 vectors, where each vector consists of 3 floats) and outputs a mat4x3 by copying each element individually from the input to the destination matrix. Line by line, the function assigns each float from the corresponding positions in the source matrix to the destination matrix, effectively replicating the entire matrix.",
        "code_id": "c_group_2_id_421",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x24,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x24,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x24,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_403",
        "query_text": "SUMMARY: This function operates on two-dimensional floating-point arrays (vec2) and a floating-point scalar. It subtracts, for each element, the product of the corresponding element of the first two-dimensional array and the scalar from the respective element of the second two-dimensional array, thereby updating the second array in place.",
        "code_id": "c_group_2_id_403",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmulss  -0xc(%rbp),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_429",
        "query_text": "SUMMARY: This function computes the element-wise subtraction of two four-element floating-point vectors (each defined as a 16-byte aligned float array) and stores the resulting vector in a provided output. It accepts two input arrays of type vec4 (which are essentially float[4] arrays) and produces a vec4 as output, utilizing platform-specific SIMD operations when available, or performing manual subtraction for each component otherwise.",
        "code_id": "c_group_2_id_429",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x58(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmovaps (%rax),%xmm0\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmov    -0x40(%rbp),%rax\nmovaps (%rax),%xmm1\nmovaps %xmm1,-0x20(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmovaps -0x20(%rbp),%xmm0\nsubps  -0x10(%rbp),%xmm0\nmov    -0x68(%rbp),%rax\nmov    %rax,-0x48(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmov    -0x48(%rbp),%rax\nmovaps -0x30(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_397",
        "query_text": "SUMMARY: This function accepts one parameter of type int[3] (an array of three integers) and sets each element of the array to the integer value 1, modifying the array in place without returning any value.",
        "code_id": "c_group_2_id_397",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmovl   $0x1,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rdx),%edx\nmov    %edx,(%rax)\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_418",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (represented as an array of four aligned 4-element floating-point vectors) as its input along with two output pointers to floating-point numbers. It computes two values by extracting specific elements from the matrix, processing them through simple arithmetic, and then assigns the results to the two output floats, which represent the near and far clipping plane distances derived from the perspective projection parameters.",
        "code_id": "c_group_2_id_418",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x3b\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x62\n\naddss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_434",
        "query_text": "SUMMARY: The function takes as input a projection matrix (of type vec4 mat4) and several pointers to floating\u2010point variables (of type float*), and it decomposes the matrix to extract the parameters of a left-handed perspective projection. Specifically, it calculates the near and far clipping distances and determines the boundaries (top, bottom, left, right) of the projection frustum by extracting specific elements from the matrix and using them in arithmetic expressions. The computed values are then stored via the provided output pointers.",
        "code_id": "c_group_2_id_434",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %rcx,-0x50(%rbp)\nmov    %r8,-0x58(%rbp)\nmov    %r9,-0x60(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x77\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x18(%rbp),%xmm0\nmovss  0x0(%rip),%xmm2        # 0x9e\n\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmovss  -0x14(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x18(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xc0\n\naddss  %xmm0,%xmm1\nmovss  -0x14(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x10(%rbp),%xmm0\ndivss  -0x24(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x10(%rbp),%xmm0\ndivss  -0x28(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x40(%rbp),%rax\nmovss  -0x10(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x48(%rbp),%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x1c(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x117\n\nsubss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x1c(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x135\n\naddss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmov    -0x50(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x20(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x153\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x60(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x20(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x171\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_467",
        "query_text": "SUMMARY: This function accepts a pointer to an AUDIO_OUT structure (type: AUDIO_OUT *) as its sole input parameter and produces no return value (output type: void). It performs no meaningful operations; essentially, it reassigns the input parameter to itself and then exits without modifying any data or releasing any resources.",
        "code_id": "c_group_2_id_467",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_419",
        "query_text": "SUMMARY: This function takes a single precision floating-point value as input along with a four-by-four matrix (an array of four vec4, where each vec4 is an array of four floats). It first checks whether the (0,0) element of the matrix is zero, and if so, it exits without modification. Otherwise, it recalculates that (0,0) element by dividing the (1,1) element of the matrix by the input floating-point value. The modified matrix serves as the function's output.",
        "code_id": "c_group_2_id_419",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\npxor   %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njp     0x2b\npxor   %xmm1,%xmm1\nucomiss %xmm1,%xmm0\nje     0x47\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\njmp    0x48\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_439",
        "query_text": "SUMMARY: This function takes two input variables of type int[2] (representing two-element integer vectors) and produces an output variable of the same type. It evaluates each corresponding element of the two input vectors and assigns the greater of each pair to the respective position in the output vector.",
        "code_id": "c_group_2_id_439",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    0x2c\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\njmp    0x32\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    0x59\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\njmp    0x60\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_424",
        "query_text": "SUMMARY: This function accepts a 4-element floating-point vector (type: vec4, which is an array of 4 floats) and returns a single floating-point value (type: float). The function retrieves and returns the fourth element from the input vector.",
        "code_id": "c_group_2_id_424",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  0xc(%rax),%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_409",
        "query_text": "SUMMARY: This function performs an element-wise addition by adding a scalar (float) to each component of a two-dimensional vector (float array of two elements). It takes two inputs\u2014a two-element floating-point vector and a scalar of type float\u2014and produces an output of the same two-element float array type where each element is the sum of the corresponding input element and the scalar value.",
        "code_id": "c_group_2_id_409",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\naddss  -0xc(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_430",
        "query_text": "SUMMARY: This function takes a 3-element integer array and an integer as inputs, and produces a 3-element integer array as output. It adds the integer input to each element of the input array and stores the resulting values in the output array.",
        "code_id": "c_group_2_id_430",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    -0xc(%rbp),%edx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    -0xc(%rbp),%edx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_468",
        "query_text": "SUMMARY: This function accepts three inputs: a function pointer of type get_audio_callback_t, a pointer to an AUDIO_OUT structure, and a generic void pointer used as callback data. It returns no value (void). In its implementation, it disregards all provided arguments and terminates immediately without performing any operations or modifications.",
        "code_id": "c_group_2_id_468",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_408",
        "query_text": "SUMMARY: This function takes two inputs\u2014a matrix of type mat3 (which is a 3\u00d73 array of floats) and a scalar of type float\u2014and modifies the matrix in place. It multiplies every element in the first and second rows of the matrix by the scalar value (performing a uniform scaling in the 2D sense), while leaving the third row unchanged. The function does not return any value (void output).",
        "code_id": "c_group_2_id_408",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_433",
        "query_text": "SUMMARY: This function takes a float[3] array as its input and returns no output. The function's behavior is to set each of the three float elements in the array to the value 1.0f.",
        "code_id": "c_group_2_id_433",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x8(%rax),%rdx\nmovss  0x0(%rip),%xmm0        # 0x1c\n\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_435",
        "query_text": "SUMMARY: This function takes a four-element array of integers (int[4]) as input and computes the absolute value of each element, storing the results in a separate four-element array of integers (int[4]).",
        "code_id": "c_group_2_id_435",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x4,%rdx\nmov    %eax,%ecx\nneg    %ecx\ncmovns %ecx,%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x8,%rdx\nmov    %eax,%ecx\nneg    %ecx\ncmovns %ecx,%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0xc,%rdx\nmov    %eax,%ecx\nneg    %ecx\ncmovns %ecx,%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_431",
        "query_text": "SUMMARY: This function accepts an input of type float[2] (a two-dimensional vector) and a float value, then it updates the vector in place so that both of its elements match the provided float value. It does not return any value.",
        "code_id": "c_group_2_id_431",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_442",
        "query_text": "SUMMARY: This function takes three parameters of type int[4]. It computes, for each corresponding element, the subtraction of the difference between the first and second input values from the value in the third parameter. In other words, it updates each element of the output int[4] by subtracting the result of the difference between the two input int[4] elements.",
        "code_id": "c_group_2_id_442",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nsub    %eax,%ecx\nsub    %ecx,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rcx\nadd    $0x4,%rcx\nmov    (%rcx),%ecx\nsub    %ecx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %esi,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rcx\nadd    $0x8,%rcx\nmov    (%rcx),%ecx\nsub    %ecx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %esi,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rcx\nadd    $0xc,%rcx\nmov    (%rcx),%ecx\nsub    %ecx,%eax\nmov    %eax,%esi\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nsub    %esi,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_438",
        "query_text": "SUMMARY: This function computes the transpose of a 2\u00d72 matrix of 32\u2010bit floats. It takes as input a matrix of type \"2-element array of 2-element float vectors\" (each vector being 16\u2010byte aligned) and produces as output another matrix of the same type, with its elements rearranged to achieve the transpose. The implementation uses SSE2 operations to load the four floating\u2010point values from the input, shuffle them appropriately, and then store the result into the output matrix.",
        "code_id": "c_group_2_id_438",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovaps (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmovaps (%rax),%xmm0\nshufps $0xd8,%xmm1,%xmm0\nmov    -0x40(%rbp),%rax\nmov    %rax,-0x28(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmovaps -0x10(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_436",
        "query_text": "SUMMARY: This function takes a 4x4 floating-point matrix (mat4) as input and produces a 3x3 floating-point matrix (mat3) as output. It extracts the upper-left 3x3 submatrix by copying the first three elements of the first three rows from the 4x4 matrix into the 3x3 matrix.",
        "code_id": "c_group_2_id_436",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_432",
        "query_text": "SUMMARY: The function takes two input parameters\u2014a 3-element integer array (ivec3) and an integer scalar\u2014along with an output parameter, which is also a 3-element integer array (ivec3). It multiplies each element of the input array by the scalar and then adds the resulting product to the corresponding element of the output array.",
        "code_id": "c_group_2_id_432",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_426",
        "query_text": "SUMMARY: This function converts a rotation specified by Euler angles to a quaternion. It accepts a three-element float array (vec3) representing Euler angles in radians and produces a four-element float array (versor) representing the corresponding quaternion rotation in a right-handed coordinate system. The function computes the sine and cosine of half of each Euler angle and then combines these intermediary values to generate the quaternion components.",
        "code_id": "c_group_2_id_426",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xfc\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x10d\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x121\n\nxorps  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmovss  -0x18(%rbp),%xmm1\nmulss  -0x8(%rbp),%xmm1\nmulss  -0xc(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0xc(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_446",
        "query_text": "SUMMARY: This function accepts an input variable of type vec4 (an aligned four-element float array) and an output variable of type vec3 (a three-element float array). Its functionality is to copy the first three float elements from the input to the output, effectively trimming the fourth element.",
        "code_id": "c_group_2_id_446",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_445",
        "query_text": "SUMMARY: This function receives an input array of three integers (type int[3]) and computes the absolute value of each element. It then stores these absolute values element-by-element into an output array of three integers (type int[3]).",
        "code_id": "c_group_2_id_445",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x4,%rdx\nmov    %eax,%ecx\nneg    %ecx\ncmovns %ecx,%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x10(%rbp),%rdx\nadd    $0x8,%rdx\nmov    %eax,%ecx\nneg    %ecx\ncmovns %ecx,%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_440",
        "query_text": "SUMMARY: This function takes a constant pointer to a sequence of float values (input type: const float*) and transforms it into a 4\u00d74 matrix (output type: an array of 4 float[4] vectors) by mapping 16 sequential floats into a structured matrix layout. More specifically, it reorganizes the input flat array by distributing its values into two groups, with the first eight values populating the first two columns and the remaining eight values populating the last two columns of the destination matrix.",
        "code_id": "c_group_2_id_440",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x14(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x30(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x30,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x34(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x30,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x28(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x38(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x30,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x2c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x3c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x30,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_443",
        "query_text": "SUMMARY: This inline function accepts two input parameters, each being a 3-element array of floats (float[3]), and computes their dot product by multiplying corresponding elements and summing the results. It returns a single float value representing this computed dot product.",
        "code_id": "c_group_2_id_443",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm0,%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_441",
        "query_text": "SUMMARY: This function accepts two input parameters of type float[3] and produces an output of the same type. It performs an element-wise division by computing the quotient of the corresponding elements from the first and second input arrays, storing these results sequentially in the output array.",
        "code_id": "c_group_2_id_441",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_428",
        "query_text": "SUMMARY: This function computes the transpose of a matrix. It takes an input of type mat4x3 (an array of four vectors, each containing three float elements, representing a 4\u00d73 matrix) and produces an output of type mat3x4 (an array of three vectors, each containing four float elements, representing a 3\u00d74 matrix). The function rearranges the elements so that the element originally at the position (row, column) in the input matrix is placed at the position (column, row) in the output matrix.",
        "code_id": "c_group_2_id_428",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x24,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,0xc(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rdx),%xmm0\nmovss  %xmm0,0xc(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_453",
        "query_text": "SUMMARY: This function takes two inputs\u2014a 3\u00d73 matrix composed of three arrays of three floats (mat3) and a 2-element array of floats (vec2)\u2014and modifies the matrix in place. It applies a two-dimensional scaling transformation by multiplying every element in the first row of the matrix by the first float from the vector and every element in the second row by the second float. The third row of the matrix remains unchanged.",
        "code_id": "c_group_2_id_453",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_450",
        "query_text": "SUMMARY: This function performs a component-wise subtraction of two two-dimensional vectors. It accepts two input parameters of type float[2] (representing the vectors to subtract) and produces an output parameter of type float[2] containing the result of subtracting the corresponding elements of the second input from the first.",
        "code_id": "c_group_2_id_450",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_451",
        "query_text": "SUMMARY: This function takes a triple of floating\u2010point values (vec3) representing three Euler angles and produces a 4\u00d74 matrix (mat4) transformation that encodes a rotation using a Y\u2013X\u2013Z rotation order. It computes the sine and cosine of each angle, combines these trigonometric results into intermediate products, and assembles them into the rotation matrix's elements; the remaining matrix components are set to yield an identity transformation in the homogeneous coordinate.",
        "code_id": "c_group_2_id_451",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x23\nmovd   %xmm0,%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x39\nmovd   %xmm0,%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x53\nmovd   %xmm0,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x6d\nmovd   %xmm0,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x87\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0xa1\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x20(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x28(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  -0x10(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\nsubss  -0x8(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0x8(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nsubss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\naddss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x28(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x19f\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x10,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x0(%rip),%xmm0        # 0x22f\n\nmovss  %xmm0,0xc(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_449",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (of type vec4[4]) representing a perspective projection and two pointers to floats (which are the output variables for the near and far clipping distances). It first extracts two specific floating\u2010point elements from distinct positions within the matrix and then computes the near and far clipping distances by dividing one extracted value by a modified form of the other\u2014subtracting 1.0 for the near distance and adding 1.0 for the far distance. The function does not return a value, instead writing the computed near and far distances directly to the provided output float pointers.",
        "code_id": "c_group_2_id_449",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x3b\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmovss  0x0(%rip),%xmm2        # 0x50\n\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmovss  -0x8(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x75\n\naddss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_444",
        "query_text": "SUMMARY: This function accepts two input parameters\u2014an integer vector of four elements (ivec4) and an integer scalar\u2014and one output parameter, an integer vector of four elements (ivec4). For each index from 0 to 3, it subtracts the sum of the corresponding element from the input vector and the scalar from the corresponding element in the output vector, updating the output vector with the result.",
        "code_id": "c_group_2_id_444",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %ecx,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0xc(%rbp),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_460",
        "query_text": "SUMMARY: This function performs matrix multiplication between two matrices. The first input is of type mat4x3 (an array of four 3-element float vectors representing a 4\u00d73 matrix in column-major order), and the second input is of type mat3x4 (an array of three 4-element float vectors representing a 3\u00d74 matrix). The function computes the product, which is a 3\u00d73 matrix, and stores the result in the output of type mat3 (an array of three 3-element float vectors). Each element of the output is obtained by summing the products of corresponding float components from the inputs.",
        "code_id": "c_group_2_id_460",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x68(%rbp)\nmov    %rsi,-0x70(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    -0x68(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x60(%rbp)\nmov    -0x68(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x5c(%rbp)\nmov    -0x68(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x58(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0xc,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x54(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x50(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0xc,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x4c(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x18,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x48(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x44(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x18,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x40(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x24,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x3c(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x24,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x38(%rbp)\nmov    -0x68(%rbp),%rax\nadd    $0x24,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x34(%rbp)\nmov    -0x70(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x30(%rbp)\nmov    -0x70(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x70(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmov    -0x70(%rbp),%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x10,%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x70(%rbp),%rax\nadd    $0x20,%rax\nmovss  0xc(%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x60(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x30(%rbp),%xmm1\nmovss  -0x54(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x48(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x24(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x78(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x5c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x30(%rbp),%xmm1\nmovss  -0x50(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x44(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x24(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x78(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x58(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x30(%rbp),%xmm1\nmovss  -0x4c(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x40(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x34(%rbp),%xmm0\nmulss  -0x24(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x78(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0x60(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x54(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x48(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x5c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x50(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x44(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x58(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x20(%rbp),%xmm1\nmovss  -0x4c(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x40(%rbp),%xmm0\nmulss  -0x18(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x34(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0xc,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x60(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x54(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x48(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x5c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x50(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x44(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x58(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x4c(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x40(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x34(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x78(%rbp),%rax\nadd    $0x18,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_455",
        "query_text": "SUMMARY: This function accepts an input of type \"CGLM_ALIGN_IF(16) float[4]\" (a vector of four floats) and an input of type \"float\", and it modifies the vector by filling all four elements with the provided floating-point value. It uses platform-specific SIMD operations when available, defaulting to individual assignments otherwise.",
        "code_id": "c_group_2_id_455",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovss  %xmm0,-0x2c(%rbp)\nmovss  -0x2c(%rbp),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmovss  -0x1c(%rbp),%xmm0\nshufps $0x0,%xmm0,%xmm0\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmovaps %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmovaps -0x10(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_452",
        "query_text": "SUMMARY: This function converts a 4\u00d74 floating\u2010point matrix (mat4) representing a rotation into a quaternion (versor), also composed of four floating\u2011point values. It calculates the sum of the matrix\u2019s three main diagonal elements and, based on whether this trace is nonnegative or one of the diagonal elements is largest, it selects an appropriate branch. In each branch, it computes a scaling factor and then produces the four quaternion components using combinations of the matrix\u2019s off\u2011diagonal elements. This procedure effectively maps the rotation encoded in the matrix to its equivalent quaternion representation.",
        "code_id": "c_group_2_id_452",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm0,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0xc(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncomiss %xmm1,%xmm0\njb     0x12d\nmovss  -0xc(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x62\n\naddss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x73\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x82\n\ndivss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm1\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0xc,%rax\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x120\n\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\njmp    0x487\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm1\ncomiss %xmm1,%xmm0\njb     0x269\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm1\ncomiss %xmm1,%xmm0\njb     0x269\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x17e\n\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm2\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\naddss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x1af\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x1be\n\ndivss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x1d5\n\nmulss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\njmp    0x487\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm1\ncomiss %xmm1,%xmm0\njb     0x38c\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x29c\n\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm2\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x2d2\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x2e1\n\ndivss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x326\n\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\njmp    0x487\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x39c\n\nsubss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm2\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\naddss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x3d2\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x3e1\n\ndivss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x8,%rax\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x455\n\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nadd    $0xc,%rax\nmulss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_437",
        "query_text": "SUMMARY: This function processes an input 4-element array of floats and writes to an output 4-element array of floats by computing the sign value for each component. For each float in the input, the corresponding output is determined to be \u20131.0 if the input is negative, 1.0 if positive, and 0.0 if the input is zero. The implementation uses optimized vectorized operations with SSE when available, and falls back to individual element processing otherwise.",
        "code_id": "c_group_2_id_437",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0xa8,%rsp\nmov    %rdi,-0x118(%rbp)\nmov    %rsi,-0x120(%rbp)\nmov    -0x118(%rbp),%rax\nmov    %rax,-0x108(%rbp)\nmov    -0x108(%rbp),%rax\nmovaps (%rax),%xmm0\nmovaps %xmm0,-0x100(%rbp)\nmovaps 0x0(%rip),%xmm0        # 0x43\nmovaps %xmm0,-0xf0(%rbp)\nmovaps -0xf0(%rbp),%xmm0\nmovaps -0xf0(%rbp),%xmm1\nshufps $0xaa,%xmm1,%xmm0\nmovaps %xmm0,-0xe0(%rbp)\nmovaps -0xf0(%rbp),%xmm0\nmovaps -0xf0(%rbp),%xmm1\nshufps $0x55,%xmm1,%xmm0\nmovaps -0x100(%rbp),%xmm1\nmovaps %xmm1,-0x20(%rbp)\nmovaps -0xe0(%rbp),%xmm1\nmovaps %xmm1,-0x10(%rbp)\nmovaps -0x10(%rbp),%xmm1\ncmpltps -0x20(%rbp),%xmm1\nnop\nmovaps %xmm1,-0x40(%rbp)\nmovaps %xmm0,-0x30(%rbp)\nmovaps -0x40(%rbp),%xmm0\nandps  -0x30(%rbp),%xmm0\nnop\nmovaps %xmm0,-0xd0(%rbp)\nmovaps -0xf0(%rbp),%xmm0\nmovaps -0xf0(%rbp),%xmm1\nshufps $0x0,%xmm1,%xmm0\nmovaps -0x100(%rbp),%xmm1\nmovaps %xmm1,-0x60(%rbp)\nmovaps -0xe0(%rbp),%xmm1\nmovaps %xmm1,-0x50(%rbp)\nmovaps -0x60(%rbp),%xmm1\ncmpltps -0x50(%rbp),%xmm1\nnop\nmovaps %xmm1,-0x80(%rbp)\nmovaps %xmm0,-0x70(%rbp)\nmovaps -0x80(%rbp),%xmm0\nandps  -0x70(%rbp),%xmm0\nnop\nmovaps %xmm0,-0xc0(%rbp)\nmovaps -0xd0(%rbp),%xmm0\nmovaps %xmm0,-0xa0(%rbp)\nmovaps -0xc0(%rbp),%xmm0\nmovaps %xmm0,-0x90(%rbp)\nmovaps -0xa0(%rbp),%xmm0\norps   -0x90(%rbp),%xmm0\nnop\nmov    -0x120(%rbp),%rax\nmov    %rax,-0x110(%rbp)\nmovaps %xmm0,-0xb0(%rbp)\nmov    -0x110(%rbp),%rax\nmovaps -0xb0(%rbp),%xmm0\nmovaps %xmm0,(%rax)\nnop\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_447",
        "query_text": "SUMMARY: This function accepts two input variables, each of type float[2], and one output variable, also of type float[2]. Its purpose is to add, for each coordinate, the corresponding values from the two input arrays and then increment the corresponding value in the output array by that sum. Specifically, it updates each element of the output array by adding the sum of the corresponding elements of the two input arrays.",
        "code_id": "c_group_2_id_447",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\naddss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm2\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\naddss  %xmm2,%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_448",
        "query_text": "SUMMARY: This function converts a 3-element floating-point vector (vec3) representing Euler angles into a 4-element floating-point quaternion (versor) using a YZX rotation order in a right-handed coordinate system. It calculates the sine and cosine of half of each Euler angle and then combines them to produce the quaternion components that represent the equivalent rotation. Each line of the function performs a step in computing these trigonometric values and then assembles the resulting quaternion from their products and sums.",
        "code_id": "c_group_2_id_448",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x24\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x35\nmovd   %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4c\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x5d\nmovd   %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x89\nmovd   %xmm0,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xa4\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xb5\nmovd   %xmm0,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xd0\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0xe1\nmovd   %xmm0,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xfc\n\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   0x10d\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x18(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  -0x10(%rbp),%xmm1\nmulss  -0x4(%rbp),%xmm1\nmulss  -0x18(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0x8,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\nmovss  -0x10(%rbp),%xmm1\nmulss  -0x8(%rbp),%xmm1\nmulss  -0x18(%rbp),%xmm1\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_458",
        "query_text": "SUMMARY: This function takes an input of type vec2 (an array of two floats) and modifies it so that both elements are set to 1.0f. It returns no value.",
        "code_id": "c_group_2_id_458",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  0x0(%rip),%xmm0        # 0x1c\n\nmovss  %xmm0,(%rax)\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_457",
        "query_text": "SUMMARY: This function takes a three-by-two matrix of floats (type: mat3x2, defined as an array of three two-element float arrays) and a scalar float as inputs. It multiplies each of the six elements within the matrix by the scalar value, updating the matrix in place. The function returns no value (void).",
        "code_id": "c_group_2_id_457",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nadd    $0x10,%rax\nmulss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_465",
        "query_text": "SUMMARY: This function accepts a three-element float array (vec3) representing Euler angles and an enumeration (glm_euler_seq) specifying one of six rotation orders as input. It computes the sine and cosine values for these angles, uses the provided rotation order to assemble the appropriate 3\u00d73 rotation submatrix, and then constructs a 4\u00d74 float matrix (mat4) by embedding this rotation and appending homogeneous coordinates (with zero translation and a one in the lower-right corner).",
        "code_id": "c_group_2_id_465",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %esi,-0x4c(%rbp)\nmov    %rdx,-0x58(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x26\nmovd   %xmm0,%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x3c\nmovd   %xmm0,%eax\nmov    %eax,-0x38(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x56\nmovd   %xmm0,%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x70\nmovd   %xmm0,%eax\nmov    %eax,-0x30(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0x8a\nmovd   %xmm0,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmovd   %eax,%xmm0\ncall   0xa4\nmovd   %xmm0,%eax\nmov    %eax,-0x28(%rbp)\nmovss  -0x30(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\nmovss  %xmm0,-0x24(%rbp)\nmovss  -0x30(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmovss  -0x30(%rbp),%xmm0\nmulss  -0x3c(%rbp),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x30(%rbp),%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x34(%rbp),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x28(%rbp),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x28(%rbp),%xmm0\nmulss  -0x3c(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x34(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x4c(%rbp),%eax\nsub    $0x6,%eax\ncmp    $0x1e,%eax\nja     0x6c8\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x152\nmov    (%rdx,%rax,1),%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0x15e\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x58(%rbp),%rax\nmovss  -0x24(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x34(%rbp),%xmm1\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x20(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x38(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x1a2\n\nxorps  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x34(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x2c(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x1d9\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x10(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x14(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nsubss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\naddss  -0x18(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\njmp    0x6c8\nmov    -0x58(%rbp),%rax\nmovss  -0x24(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x34(%rbp),%xmm0\naddss  -0x8(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x38(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x284\n\nxorps  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x14(%rbp),%xmm1\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x20(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x2bb\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x10(%rbp),%xmm0\nsubss  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\naddss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x34(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x1c(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x327\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x18(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\njmp    0x6c8\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\naddss  -0x24(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nmovss  -0x8(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\nsubss  -0x14(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x34(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nsubss  -0x20(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x10(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x3c(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\naddss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x34(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x3c(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x3f7\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x18(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\njmp    0x6c8\nmov    -0x58(%rbp),%rax\nmovss  -0x24(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nmovss  -0x2c(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x43e\n\nxorps  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x34(%rbp),%xmm0\nmovss  -0x38(%rbp),%xmm1\nmulss  -0x20(%rbp),%xmm1\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nsubss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x10(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\naddss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x38(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x34(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x4d8\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x18(%rbp),%xmm0\nsubss  %xmm1,%xmm0\nmovss  %xmm0,0x8(%rax)\njmp    0x6c8\nmovss  -0x3c(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  -0x24(%rbp),%xmm0\nsubss  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x34(%rbp),%xmm0\naddss  -0x20(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovss  -0x38(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x54b\n\nxorps  %xmm1,%xmm0\nmulss  -0x34(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x8(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x571\n\nxorps  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x10(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x3c(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x1c(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\naddss  -0x14(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x24(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x5c4\n\nxorps  %xmm1,%xmm0\nmulss  -0x3c(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\naddss  -0x4(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x18(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\njmp    0x6c8\nmov    -0x58(%rbp),%rax\nmovss  -0x24(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nmovss  -0x20(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmovss  -0x34(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x61d\n\nxorps  %xmm1,%xmm0\nmov    -0x58(%rbp),%rax\nmovss  %xmm0,0x8(%rax)\nmovss  -0xc(%rbp),%xmm0\nmulss  -0x34(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nsubss  -0x8(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\naddss  -0x10(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\nmovss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nmovss  -0x38(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x14(%rbp),%xmm1\nmovss  -0x3c(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nmovss  -0x38(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nsubss  -0xc(%rbp),%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\nmovss  -0x18(%rbp),%xmm0\nmovss  %xmm0,0x8(%rax)\nnop\nmov    -0x58(%rbp),%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x10,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x20,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0xc(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x4(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x30,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,0x8(%rax)\nmov    -0x58(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x0(%rip),%xmm0        # 0x739\n\nmovss  %xmm0,0xc(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_462",
        "query_text": "SUMMARY: This function takes as input a 4\u00d74 matrix of single-precision floating-point numbers (mat4) and two pointers to float variables. It decomposes the projection matrix to compute and output two scalar values, representing the top and bottom extents along the y-axis in eye space for a perspective projection using a right-handed coordinate system with a depth range from zero to one. The function internally extracts specific elements from the matrix to determine the near clipping plane distance along the z-axis and then uses this value to calculate the desired top and bottom boundaries.",
        "code_id": "c_group_2_id_462",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rax\nmovss  0x8(%rax),%xmm0\ndivss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x10(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x6e\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0xc(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x10(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x91\n\naddss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\ndivss  -0xc(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_454",
        "query_text": "SUMMARY: This function accepts an input of type int pointer and an output of type ivec2 (an array of two integers). It copies the first two integers from the input array into the two-element output array.",
        "code_id": "c_group_2_id_454",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_463",
        "query_text": "SUMMARY: The function accepts an input of type vec4 (an array of four floats) and an output of type vec3 (an array of three floats). It sequentially copies the first three elements from the vec4 input into the vec3 output, effectively converting a four-dimensional floating-point vector into a three-dimensional one by discarding the fourth component.",
        "code_id": "c_group_2_id_463",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x10(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovss  0x8(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_466",
        "query_text": "SUMMARY: This function takes three inputs: a 3-element integer array, an integer scalar, and another 3-element integer array intended for output, and it subtracts from each element of the output array the product of the corresponding element of the input array with the scalar. Concretely, for each of the three positions, the function computes the multiplication of the integer from the first array by the scalar and subtracts this result from the corresponding integer in the output array.",
        "code_id": "c_group_2_id_466",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_456",
        "query_text": "SUMMARY: This function performs a component-wise addition of two two-dimensional vectors. It takes two input variables of type vec2 (each defined as an array of two floats) and computes a new vec2 by adding the corresponding elements from the inputs, then stores the resulting two-float array in the output variable of type vec2.",
        "code_id": "c_group_2_id_456",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nmovss  (%rax),%xmm0\naddss  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\naddss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_461",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of type \"ivec4\" (arrays of four integers). For each of the four components, it calculates the sum of the corresponding elements from the two input arrays and then adds this result to the corresponding element in the output array. Essentially, it performs an element-wise accumulation where each output element becomes its original value increased by the sum of the two corresponding input values.",
        "code_id": "c_group_2_id_461",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nadd    %ecx,%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nadd    %eax,%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_459",
        "query_text": "SUMMARY: The function takes two inputs, each being an array of two integers (type: int[2]), and produces an output of the same type. It computes the function by adding the first integer from the first array to the first integer from the second array, and similarly adding the second integers together. The resulting array holds these two sums as its elements.",
        "code_id": "c_group_2_id_459",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_464",
        "query_text": "SUMMARY: This function accepts two inputs\u2014one of type versor (an aligned array of four floats) and one of type pointer to FILE\u2014and returns no value. It formats and prints the contents of the quaternion (the four-component float vector) to the provided output stream. The printing process includes labeling the output (indicating a quaternion of four floats), applying precision formatting based on the component's magnitude, and using color formatting macros for enhanced visual presentation.",
        "code_id": "c_group_2_id_464",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    $0x4,%edx\nlea    0x0(%rip),%rcx        # 0x24\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x34\nmovl   $0x0,-0x4(%rbp)\njmp    0xfa\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x60\n\ncomiss %xmm1,%xmm0\njbe    0xb1\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovq   %xmm2,%rdx\nmov    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nmov    $0x5,%edx\nlea    0x0(%rip),%rcx        # 0x9f\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xaf\njmp    0xf6\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm3,%xmm3\ncvtss2sd %xmm0,%xmm3\nmovq   %xmm3,%rdx\nmov    -0x20(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0xe6\nmov    %rdx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0xf6\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x3,-0x4(%rbp)\njle    0x40\nmov    -0x20(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x9,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x11c\nmov    %rax,%rdi\ncall   0x124\nnop\nleave  \nret    ",
        "relevance": 2
    }
]