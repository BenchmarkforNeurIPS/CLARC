[
    {
        "query_id": "q_group_2_id_0",
        "query_text": "SUMMARY: This function takes an input of type std::size_t and returns a value of type char. Its functionality is to access and retrieve the character at the given index from an internal array of characters, while ensuring that the index is within the valid range of the stored sequence.",
        "code_id": "c_group_2_id_0",
        "code_text": "#include \"helper_header.h\"\n;\n;\nnamespace Catch {\nusing size_type = std::size_t;\n};\nclass StringRef {\n    public:\n        using size_type = std::size_t;\n        using const_iterator = const char*;\n\n    private:\n        static constexpr char const* const s_empty = \"\";\n\n        char const* m_start = s_empty;\n        size_type m_size = 0;\n\n    public: // construction\n        constexpr StringRef() noexcept = default;\n\n        StringRef( char const* rawChars ) noexcept;\n\n        constexpr StringRef( char const* rawChars, size_type size ) noexcept\n        :   m_start( rawChars ),\n            m_size( size )\n        {}\n\n        StringRef( std::string const& stdString ) noexcept\n        :   m_start( stdString.c_str() ),\n            m_size( stdString.size() )\n        {}\n\n        explicit operator std::string() const {\n            return std::string(m_start, m_size);\n        }\n\n    public: // operators\n        auto operator == ( StringRef const& other ) const noexcept -> bool;\n        auto operator != (StringRef const& other) const noexcept -> bool {\n            return !(*this == other);\n        }\n\n        auto operator[] ( size_type index ) const noexcept -> char {\n            assert(index < m_size);\n            return m_start[index];\n        }\n\n    public: // named queries\n        constexpr auto empty() const noexcept -> bool {\n            return m_size == 0;\n        }\n        constexpr auto size() const noexcept -> size_type {\n            return m_size;\n        }\n\n        // Returns the current start pointer. If the StringRef is not\n        // null-terminated, throws std::domain_exception\n        auto c_str() const -> char const*;\n\n    public: // substrings and searches\n        // Returns a substring of [start, start + length).\n        // If start + length > size(), then the substring is [start, size()).\n        // If start > size(), then the substring is empty.\n        auto substr( size_type start, size_type length ) const noexcept -> StringRef;\n\n        // Returns the current start pointer. May not be null-terminated.\n        auto data() const noexcept -> char const*;\n\n        constexpr auto isNullTerminated() const noexcept -> bool {\n            return m_start[m_size] == '\\0';\n        }\n\n    public: // iterators\n        constexpr const_iterator begin() const { return m_start; }\n        constexpr const_iterator end() const { return m_start + m_size; }\n    };\nnamespace Catch {\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_1",
        "query_text": "SUMMARY: This function accepts a constant reference to a vector of strings (input type: const cxxopts::OptionNames&) and returns a constant reference to a string (output type: const std::string&). It checks whether the provided vector is empty, returning the first element of the vector if available; otherwise, it returns a static, empty string.",
        "code_id": "c_group_2_id_1",
        "code_text": "inline\nconst std::string&\nfirst_or_empty(const OptionNames& long_names)\n{\n  static const std::string empty{\"\"};\n  return long_names.empty() ? empty : long_names.front();\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_2",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a mutable reference to a cxxopts::String (alias for std::string), a std::size_t representing a repetition count, and a char. It appends the specified number of repetitions of the given character to the input string and returns a mutable reference to the updated string.",
        "code_id": "c_group_2_id_2",
        "code_text": "inline\nString&\nstringAppend(String& s, std::size_t n, char c)\n{\n  return s.append(n, c);\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_3",
        "query_text": "SUMMARY: This function accepts a constant reference to an object of type cxxopts::String (alias for std::string) and returns a value of type std::size_t representing the count of characters in that string.",
        "code_id": "c_group_2_id_3",
        "code_text": "inline\nstd::size_t\nstringLength(const String& s)\n{\n  return s.length();\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_4",
        "query_text": "SUMMARY: This function takes four inputs: an array of pointers to unsigned char, an array of Lcp (with Lcp being defined as an alias for int), and two integers representing indices. It exchanges (swaps) the elements at the specified indices in both the unsigned char pointer array and the Lcp array. The function does not return any output.",
        "code_id": "c_group_2_id_4",
        "code_text": "inline void exch( unsigned char  *strings[], Lcp lcps[], int I, int J) { \n  std::swap(strings[I],strings[J]);\n  std::swap(lcps[I],lcps[J]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_5",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to an array of unsigned char pointers and another pointer to an array of unsigned char pointers\u2014along with an integer specifying the count of elements to process. It performs an in-place, element-wise exchange of the unsigned char pointer values from the two arrays for the given number of iterations. The function returns no output (void).",
        "code_id": "c_group_2_id_5",
        "code_text": "static void vecswap2(string *a, string *b, int n)\n{   while (n-- > 0) {\n        string t = *a;\n        *a++ = *b;\n        *b++ = t;\n    }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_6",
        "query_text": "SUMMARY: This function performs an in-place sort on an array of elements of type cacheblock_t. It accepts three inputs: a pointer to the first element in the array of cacheblock_t, an integer representing the number of elements, and a size_t value representing an offset (depth) into each element\u2019s data pointer. For each element starting from the second in the array, the function compares two cacheblock_t elements by walking through their associated unsigned char data beginning at the specified offset until a difference (or a null terminator) is encountered. Based on these comparisons, it shifts elements to arrange the array in ascending order. The function returns no output (void) and directly modifies the input array.",
        "code_id": "c_group_2_id_6",
        "code_text": "static inline void\ninssort_cache(cacheblock_t* cache, int n, size_t depth)\n{\n\tcacheblock_t *pi, *pj;\n\tunsigned char *s, *t;\n\tfor (pi = cache + 1; --n > 0; ++pi) {\n\t\tunsigned char* tmp = pi->ptr;\n\t\tfor (pj = pi; pj > cache; --pj) {\n\t\t\tt = tmp + depth;\n\t\t\tfor (s=(pj-1)->ptr+depth; *s==*t && *s!=0; ++s, ++t)\n\t\t\t\t;\n\t\t\tif (*s <= *t)\n\t\t\t\tbreak;\n\t\t\tpj->ptr = (pj-1)->ptr;\n\t\t}\n\t\tpj->ptr = tmp;\n\t}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_7",
        "query_text": "SUMMARY: The function accepts three inputs: a pointer to a structure (of type cacheblock_t), and two size_t values representing the number of elements and an offset depth. For each element in the given array of structures, it sequentially copies up to a fixed number of unsigned characters from an associated memory location (starting at the specified depth) into an internal fixed-size array within the structure. The copying continues until it either reaches the maximum number of bytes or encounters a zero byte; any remaining positions in the array are then filled with zero. The function does not return any value, instead modifying the data in-place.",
        "code_id": "c_group_2_id_7",
        "code_text": "static void\nfill_cache(cacheblock_t* cache, size_t N, size_t depth)\n{\n\tfor (size_t i=0; i < N; ++i) {\n\t\tunsigned int j=0;\n\t\twhile (j < CACHED_BYTES && cache[i].ptr[depth+j]) {\n\t\t\tcache[i].bytes[j] = cache[i].ptr[depth+j];\n\t\t\t++j;\n\t\t}\n\t\twhile (j < CACHED_BYTES) {\n\t\t\tcache[i].bytes[j] = 0;\n\t\t\t++j;\n\t\t}\n\t}\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_8",
        "query_text": "SUMMARY: This function takes as input two constant pointers to unsigned char and a reference to an integer (Lcp) and returns an integer. It performs a lexicographic comparison of the two byte sequences starting from the offset given by the integer reference. The function increments the integer while the corresponding bytes in the sequences match and the byte in the first sequence is nonzero. It then returns the integer difference between the first pair of mismatching bytes.",
        "code_id": "c_group_2_id_8",
        "code_text": "inline int lcpstrcmp( unsigned char const * const p, unsigned char const * const q, Lcp &i) {\n  for( ; !(q[i] - p[i]) && p[i]; i++ )\n    ;\n  return q[i]-p[i];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_9",
        "query_text": "SUMMARY: This function accepts one input of type utf8proc_ssize_t (a signed integer type) and returns a constant character pointer. It evaluates the input error code using a switch statement, mapping various predefined error code values to corresponding descriptive error message strings. For each known error condition, it returns a specific constant message detailing the encountered issue; if the error code does not match any predefined case, it returns a default message indicating an unknown error occurred.",
        "code_id": "c_group_2_id_9",
        "code_text": "UTF8PROC_DLLEXPORT const char *utf8proc_errmsg(utf8proc_ssize_t errcode) {\n  switch (errcode) {\n    case UTF8PROC_ERROR_NOMEM:\n    return \"Memory for processing UTF-8 data could not be allocated.\";\n    case UTF8PROC_ERROR_OVERFLOW:\n    return \"UTF-8 string is too long to be processed.\";\n    case UTF8PROC_ERROR_INVALIDUTF8:\n    return \"Invalid UTF-8 string\";\n    case UTF8PROC_ERROR_NOTASSIGNED:\n    return \"Unassigned Unicode code point found in UTF-8 string.\";\n    case UTF8PROC_ERROR_INVALIDOPTS:\n    return \"Invalid options for UTF-8 processing chosen.\";\n    default:\n    return \"An unknown error occurred while processing UTF-8 data.\";\n  }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_10",
        "query_text": "SUMMARY: This function takes an input pointer of type \"pointer to pointer to uint16_t\" and returns a value of type \"int32_t\". Its primary purpose is to decode a Unicode code point from a 16-bit sequence. It reads a 16-bit unit and checks if it represents a high-surrogate; if so, it advances the input pointer to obtain a second 16-bit unit, then combines both units using bitwise operations and arithmetic adjustments to form a complete Unicode code point. If the initial 16-bit unit does not indicate a surrogate pair, it simply returns the unit as the decoded code point.",
        "code_id": "c_group_2_id_10",
        "code_text": "static utf8proc_int32_t seqindex_decode_entry(const utf8proc_uint16_t **entry)\n{\n  utf8proc_int32_t entry_cp = **entry;\n  if ((entry_cp & 0xF800) == 0xD800) {\n    *entry = *entry + 1;\n    entry_cp = ((entry_cp & 0x03FF) << 10) | (**entry & 0x03FF);\n    entry_cp += 0x10000;\n  }\n  return entry_cp;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_11",
        "query_text": "SUMMARY: This function takes two inputs of type mytime (a struct timeval) and returns a double. It calculates the time difference in seconds between the two time points by subtracting the seconds components and then adding the scaled difference of the microseconds components (multiplied by 1.0E-6).",
        "code_id": "c_group_2_id_11",
        "code_text": "double elapsed(mytime t1, mytime t0)\n{\n     return (double)(t1.tv_sec - t0.tv_sec) +\n          (double)(t1.tv_usec - t0.tv_usec) * 1.0E-6;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_12",
        "query_text": "SUMMARY: This function takes no input parameters and returns a reference to a static object of type test_utils::detail::testfunc_list_t. The static object is intended to serve as a persistent container (a linked list) for nodes containing function pointers, ensuring that a single instance is available throughout the program's execution.",
        "code_id": "c_group_2_id_12",
        "code_text": "inline testfunc_list_t& testfunc_list() noexcept {\n    static testfunc_list_t lst;\n    return lst;\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_13",
        "query_text": "SUMMARY: This function receives a constant pointer to a character array and a structure of type \"struct floating_decimal_128\" (which contains a 128\u2011bit unsigned integer, a 32\u2011bit signed integer, and a boolean) as inputs, and returns an integer. It examines the unsigned integer component of the structure; if this value is nonzero, the function writes the string \"NaN\" into the character array and returns the length (3). Otherwise, it checks the boolean to determine if a minus sign is needed, prepending it when true, then writes the string \"Infinity\" (8 characters) immediately after any inserted minus sign, returning the combined length as an integer.",
        "code_id": "c_group_2_id_13",
        "code_text": "static inline int copy_special_str(char * const result, const struct floating_decimal_128 fd) {\n  if (fd.mantissa) {\n    memcpy(result, \"NaN\", 3);\n    return 3;\n  }\n  if (fd.sign) {\n    result[0] = '-';\n  }\n  memcpy(result + fd.sign, \"Infinity\", 8);\n  return fd.sign + 8;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_14",
        "query_text": "SUMMARY: This function accepts a single input of type enum class complex_form and returns a value of type const char16_t*. It determines which constant Unicode string to output based on the provided complex form. Specifically, it returns a string representing the algebraic separation if the input denotes an algebraic form, a string representing an angle (using the Unicode angle character) if the input denotes a polar form, and defaults to a standard separator string for any other case.",
        "code_id": "c_group_2_id_14",
        "code_text": "static const char16_t* middle_string(complex_form form)\n    {\n        switch(form) {\n            case complex_form::algebric: return u\" + i*\";\n            case complex_form::polar: return u\"\\u2220 \"; // the angle character \u2220\n            default: return u\", \";\n        }\n    }\n\n;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_15",
        "query_text": "SUMMARY: This function accepts a value of type uint128_t (an unsigned 128\u2010bit integer) and returns a uint32_t (an unsigned 32\u2010bit integer). It evaluates how many consecutive times the input number can be evenly divided by 5 and outputs that count. The function iteratively checks if the current value is divisible by 5; when it is, the value is divided by 5 and a counter is incremented. If at any point the value is not divisible by 5, the function immediately returns the count accumulated so far.",
        "code_id": "c_group_2_id_15",
        "code_text": "static inline uint32_t pow5Factor(uint128_t value) {\n  for (uint32_t count = 0; value > 0; ++count) {\n    if (value % 5 != 0) {\n      return count;\n    }\n    value /= 5;\n  }\n  return 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_16",
        "query_text": "SUMMARY: The function takes a 128\u2010bit unsigned integer (type __uint128_t) as input and returns a 32\u2010bit unsigned integer (type uint32_t) representing the number of decimal digits required to express the input value. It initializes a high constant corresponding to the largest power of 10 for a 128\u2010bit value and iteratively compares and scales this value to determine the appropriate digit count.",
        "code_id": "c_group_2_id_16",
        "code_text": "static inline uint32_t decimalLength(const uint128_t v) {\n  static uint128_t LARGEST_POW10 = (((uint128_t) 5421010862427522170ull) << 64) | 687399551400673280ull;\n  uint128_t p10 = LARGEST_POW10;\n  for (uint32_t i = 39; i > 0; i--) {\n    if (v >= p10) {\n      return i;\n    }\n    p10 /= 10;\n  }\n  return 1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_17",
        "query_text": "SUMMARY: This function accepts an unsigned 64-bit integer, a pointer to an array of unsigned 64-bit integers, and a signed 32-bit integer, and it returns an unsigned 64-bit integer. It performs two 128-bit multiplications using the 64-bit input and the first two elements of the array. It then extracts the high 64 bits of one product, adds this to the other 128-bit product, and finally performs a right bit-shift by the difference between the provided 32-bit integer and 64. The resulting value, after conversion to an unsigned 64-bit integer, is returned.",
        "code_id": "c_group_2_id_17",
        "code_text": "static inline uint64_t mulShift64(const uint64_t m, const uint64_t* const mul, const int32_t j) {\n  const uint128_t b0 = ((uint128_t) m) * mul[0];\n  const uint128_t b2 = ((uint128_t) m) * mul[1];\n  return (uint64_t) (((b0 >> 64) + b2) >> (j - 64));\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_18",
        "query_text": "SUMMARY: This function accepts as input a pointer to constant 64\u2010bit unsigned integers representing a 128-bit unsigned integer, a pointer to constant 64\u2010bit unsigned integers representing a 256-bit unsigned integer, and two 32-bit unsigned integers (one used as a bit-shift amount and the other as a correction factor). It computes the product of the 128-bit and 256-bit values (forming an extended precision result), extracts a 256-bit segment of that product by effectively shifting it by the specified number of bits, and incorporates the correction factor with proper carry handling. The final 256-bit result is output by writing four 64-bit unsigned integers to the provided result array.",
        "code_id": "c_group_2_id_18",
        "code_text": "static inline void mul_128_256_shift(\n    const uint64_t* const a, const uint64_t* const b, const uint32_t shift, const uint32_t corr, uint64_t* const result) {\n  assert(shift > 0);\n  assert(shift < 256);\n  const uint128_t b00 = ((uint128_t) a[0]) * b[0]; // 0\n  const uint128_t b01 = ((uint128_t) a[0]) * b[1]; // 64\n  const uint128_t b02 = ((uint128_t) a[0]) * b[2]; // 128\n  const uint128_t b03 = ((uint128_t) a[0]) * b[3]; // 196\n  const uint128_t b10 = ((uint128_t) a[1]) * b[0]; // 64\n  const uint128_t b11 = ((uint128_t) a[1]) * b[1]; // 128\n  const uint128_t b12 = ((uint128_t) a[1]) * b[2]; // 196\n  const uint128_t b13 = ((uint128_t) a[1]) * b[3]; // 256\n\n  const uint128_t s0 = b00;       // 0   x\n  const uint128_t s1 = b01 + b10; // 64  x\n  const uint128_t c1 = s1 < b01;  // 196 x\n  const uint128_t s2 = b02 + b11; // 128 x\n  const uint128_t c2 = s2 < b02;  // 256 x\n  const uint128_t s3 = b03 + b12; // 196 x\n  const uint128_t c3 = s3 < b03;  // 324 x\n\n  const uint128_t p0 = s0 + (s1 << 64);                                // 0\n  const uint128_t d0 = p0 < b00;                                       // 128\n  const uint128_t q1 = s2 + (s1 >> 64) + (s3 << 64);                   // 128\n  const uint128_t d1 = q1 < s2;                                        // 256\n  const uint128_t p1 = q1 + (c1 << 64) + d0;                           // 128\n  const uint128_t d2 = p1 < q1;                                        // 256\n  const uint128_t p2 = b13 + (s3 >> 64) + c2 + (c3 << 64) + d1 + d2;   // 256\n\n  if (shift < 128) {\n    const uint128_t r0 = corr + ((p0 >> shift) | (p1 << (128 - shift)));\n    const uint128_t r1 = ((p1 >> shift) | (p2 << (128 - shift))) + (r0 < corr);\n    result[0] = (uint64_t) r0;\n    result[1] = (uint64_t) (r0 >> 64);\n    result[2] = (uint64_t) r1;\n    result[3] = (uint64_t) (r1 >> 64);\n  } else if (shift == 128) {\n    const uint128_t r0 = corr + p1;\n    const uint128_t r1 = p2 + (r0 < corr);\n    result[0] = (uint64_t) r0;\n    result[1] = (uint64_t) (r0 >> 64);\n    result[2] = (uint64_t) r1;\n    result[3] = (uint64_t) (r1 >> 64);\n  } else {\n    const uint128_t r0 = corr + ((p1 >> (shift - 128)) | (p2 << (256 - shift)));\n    const uint128_t r1 = (p2 >> (shift - 128)) + (r0 < corr);\n    result[0] = (uint64_t) r0;\n    result[1] = (uint64_t) (r0 >> 64);\n    result[2] = (uint64_t) r1;\n    result[3] = (uint64_t) (r1 >> 64);\n  }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_19",
        "query_text": "SUMMARY: This function takes two constant references of type Oracle as inputs and returns a bool. It checks whether the integer values contained in the OracleVal member of each Oracle instance are equal.",
        "code_id": "c_group_2_id_19",
        "code_text": "bool operator==( Oracle const& a, Oracle const& b ) { return a.val.i == b.val.i; };",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_20",
        "query_text": "SUMMARY: This function accepts two inputs of type BadRelops (each containing an integer field) and returns a boolean value. It evaluates a comparison between the integer values of the two inputs, outputting true if the integer in the first input is less than the integer in the second input, and false otherwise.",
        "code_id": "c_group_2_id_20",
        "code_text": "constexpr bool operator<(BadRelops a, BadRelops b) { return a.i < b.i; };",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_21",
        "query_text": "SUMMARY: This function takes two inputs of type BadRelops (each encapsulating an integer) and returns a boolean output. It evaluates whether the integer contained in the first input is less than the integer contained in the second input, thereby inverting the conventional greater-than comparison logic.",
        "code_id": "c_group_2_id_21",
        "code_text": "constexpr bool operator>(BadRelops a, BadRelops b) { return a.i < b.i; };",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_22",
        "query_text": "SUMMARY: This function implements a move assignment operation for an object of type VoidNothrowBoth. It takes as input an rvalue reference of type VoidNothrowBoth&& and, without returning any value (void output), performs a no-throw move assignment. The function is designed to guarantee that no exceptions are thrown during its execution.",
        "code_id": "c_group_2_id_22",
        "code_text": "#include \"helper_header.h\"\nnamespace std {\nnamespace experimental {\nstruct VoidNothrowBoth\n{\n  VoidNothrowBoth(VoidNothrowBoth&&) noexcept(true) {};\n  void operator=(VoidNothrowBoth&&) noexcept(true) {}; // note void return type\n};\n};\n};\nstruct VoidNothrowBoth\n{\n  VoidNothrowBoth(VoidNothrowBoth&&) noexcept(true) {};\n  void operator=(VoidNothrowBoth&&) noexcept(true) {}; // note void return type\n};\nnamespace std {\nnamespace experimental {\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_23",
        "query_text": "SUMMARY: This function takes two input variables of type \"const Oracle&\" and returns an output of type bool. It determines the inequality between the two by comparing the int field contained within their OracleVal members and returns true if the values differ, and false if they are equal.",
        "code_id": "c_group_2_id_23",
        "code_text": "bool operator!=( Oracle const& a, Oracle const& b ) { return a.val.i != b.val.i; };",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_24",
        "query_text": "SUMMARY: The function accepts an input of type fft_object (a pointer to a structure representing an FFT set) and returns no value (void). Its primary functionality is to deallocate the memory associated with the provided FFT set object by calling the standard memory management routine.",
        "code_id": "c_group_2_id_24",
        "code_text": "void free_fft(fft_object object) {\n\tfree(object);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_25",
        "query_text": "SUMMARY: This function takes two inputs of type pugi::xml_node_type and returns a boolean value. It determines whether a node of the child type can be inserted under a node of the parent type. The function permits insertion only if the parent node is either a document or an element, and if the child node is not a document or a null node. Additionally, when the parent is not a document, it disallows insertion of child nodes that are declarations or document type declarations.",
        "code_id": "c_group_2_id_25",
        "code_text": "bool allow_insert_child(xml_node_type parent, xml_node_type child)\n\t{\n\t\tif (parent != node_document && parent != node_element) return false;\n\t\tif (child == node_document || child == node_null) return false;\n\t\tif (parent != node_document && (child == node_declaration || child == node_doctype)) return false;\n\n\t\treturn true;\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_26",
        "query_text": "SUMMARY: This function accepts an input of type pugi::char_t and returns an output of the same type. It determines whether the input represents an ASCII uppercase letter and, if so, produces its corresponding lowercase representation; if the input is not an uppercase letter, it returns the original input unchanged.",
        "code_id": "c_group_2_id_26",
        "code_text": "char_t tolower_ascii(char_t ch)\n\t{\n\t\treturn static_cast<unsigned int>(ch - 'A') < 26 ? static_cast<char_t>(ch | ' ') : ch;\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_27",
        "query_text": "SUMMARY: This function accepts a constant pointer to a char_t and returns a boolean value. It examines only the first character of the provided string, yielding true if that character is '1', 't', 'T', 'y', or 'Y'; otherwise, it returns false.",
        "code_id": "c_group_2_id_27",
        "code_text": "bool get_value_bool(const char_t* value)\n\t{\n\t\t// only look at first char\n\t\tchar_t first = *value;\n\n\t\t// 1*, t* (true), T* (True), y* (yes), Y* (YES)\n\t\treturn (first == '1' || first == 't' || first == 'T' || first == 'y' || first == 'Y');\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_28",
        "query_text": "SUMMARY: This function takes a constant pointer to a character sequence (const pugi::char_t*) and a single character (pugi::char_t) as inputs, then searches the sequence to locate the first occurrence of the specified character. It returns a constant pointer to a character (const pugi::char_t*) indicating the found position, or a null pointer if the character does not appear in the sequence.",
        "code_id": "c_group_2_id_28",
        "code_text": "const char_t* find_char(const char_t* s, char_t c)\n\t{\n\t#ifdef PUGIXML_WCHAR_MODE\n\t\treturn wcschr(s, c);\n\t#else\n\t\treturn strchr(s, c);\n\t#endif\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_29",
        "query_text": "SUMMARY: This function receives as input a pointer to constant pugi::char_t and a size_t representing a data buffer's length, and it returns a size_t that specifies the length of the valid portion of the data. Initially, the function verifies that the provided length meets a minimum threshold; if not, it returns zero. Then, examining up to the last four bytes of the data, it determines whether these trailing bytes are part of a complete multibyte sequence by checking if each byte is not a continuation byte (using bitmasking). If a non-continuation byte is located, the function returns an adjusted length that excludes the incomplete trailing bytes. If all four examined bytes are continuation bytes, it concludes that the entire buffer is valid and returns the original length.",
        "code_id": "c_group_2_id_29",
        "code_text": "size_t get_valid_length(const char_t* data, size_t length)\n\t{\n\t\tif (length < 5) return 0;\n\n\t\tfor (size_t i = 1; i <= 4; ++i)\n\t\t{\n\t\t\tuint8_t ch = static_cast<uint8_t>(data[length - i]);\n\n\t\t\t// either a standalone character or a leading one\n\t\t\tif ((ch & 0xc0) != 0x80) return length - i;\n\t\t}\n\n\t\t// there are four non-leading characters at the end, sequence tail is broken so might as well process the whole chunk\n\t\treturn length;\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_30",
        "query_text": "SUMMARY: This function takes two input values of type const pugi::char_t* (pointers to characters representing C-style strings) and returns a value of type bool. It first checks whether either of the provided string pointers is null, in which case it verifies that both are null; if not null, it performs a content comparison to determine if the strings are equal, using a wide-character comparison when compiled in wide mode, and a standard narrow-character comparison otherwise.",
        "code_id": "c_group_2_id_30",
        "code_text": "bool test_string_equal(const pugi::char_t* lhs, const pugi::char_t* rhs)\n{\n\treturn (!lhs || !rhs) ? lhs == rhs :\n\t#ifdef PUGIXML_WCHAR_MODE\n\t\twcscmp(lhs, rhs) == 0;\n\t#else\n\t\tstrcmp(lhs, rhs) == 0;\n\t#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_31",
        "query_text": "SUMMARY: This function processes a null-terminated string of characters (of type pugi::char_t*) using a lookup mapping provided by an array of unsigned characters (of type const unsigned char*). It iterates through the input string, and for each character with a code less than 128 it replaces it with a corresponding value from the lookup table, potentially skipping the character if the table's value indicates so; characters with codes 128 or greater are left unchanged. The transformed data is written back into the original buffer, ensuring the result remains null-terminated, and the function returns a pointer of type pugi::char_t* pointing to the terminating zero.",
        "code_id": "c_group_2_id_31",
        "code_text": "char_t* translate_table(char_t* buffer, const unsigned char* table)\n\t{\n\t\tchar_t* write = buffer;\n\n\t\twhile (*buffer)\n\t\t{\n\t\t\tchar_t ch = *buffer++;\n\t\t\tunsigned int index = static_cast<unsigned int>(ch);\n\n\t\t\tif (index < 128)\n\t\t\t{\n\t\t\t\tunsigned char code = table[index];\n\n\t\t\t\t// code=128 means \"skip character\" (table size is 128 so 128 can be a special value)\n\t\t\t\t// this code skips these characters without extra branches\n\t\t\t\t*write = static_cast<char_t>(code);\n\t\t\t\twrite += 1 - (code >> 7);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*write++ = ch;\n\t\t\t}\n\t\t}\n\n\t\t// zero-terminate\n\t\t*write = 0;\n\n\t\treturn write;\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_32",
        "query_text": "SUMMARY: This function accepts two inputs of type const pugi::char_t* and one of type size_t, and returns a bool. It compares the first input string and the second input string over the specified count of characters. If any character within this range does not match, it immediately returns false. If all characters in the given range match, it then returns true only if the first string has exactly the given length (indicated by a terminating null character immediately following the compared characters), otherwise it returns false.",
        "code_id": "c_group_2_id_32",
        "code_text": "bool strequalrange(const char_t* lhs, const char_t* rhs, size_t count)\n\t{\n\t\tfor (size_t i = 0; i < count; ++i)\n\t\t\tif (lhs[i] != rhs[i])\n\t\t\t\treturn false;\n\n\t\treturn lhs[count] == 0;\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_33",
        "query_text": "SUMMARY: This function takes a generic pointer (void*), a size value (size_t), and an encoding value (xml_encoding) as inputs, and returns a size_t. It conditionally appends a zero terminator to a character buffer encoded either in a wide-character mode or UTF-8, depending on the current compilation context and comparison of the provided encoding with the native character encoding. If termination is required, the function writes a null character at the end of the buffer and returns the new total size (original size plus the size of the terminator). If termination is not needed, it simply returns the original size.",
        "code_id": "c_group_2_id_33",
        "code_text": "size_t zero_terminate_buffer(void* buffer, size_t size, xml_encoding encoding)\n\t{\n\t\t// We only need to zero-terminate if encoding conversion does not do it for us\n\t#ifdef PUGIXML_WCHAR_MODE\n\t\txml_encoding wchar_encoding = get_wchar_encoding();\n\n\t\tif (encoding == wchar_encoding || need_endian_swap_utf(encoding, wchar_encoding))\n\t\t{\n\t\t\tsize_t length = size / sizeof(char_t);\n\n\t\t\tstatic_cast<char_t*>(buffer)[length] = 0;\n\t\t\treturn (length + 1) * sizeof(char_t);\n\t\t}\n\t#else\n\t\tif (encoding == encoding_utf8)\n\t\t{\n\t\t\tstatic_cast<char*>(buffer)[size] = 0;\n\t\t\treturn size + 1;\n\t\t}\n\t#endif\n\n\t\treturn size;\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_34",
        "query_text": "SUMMARY: This function accepts an input of type pugi::xml_parse_status and an optional input of type ptrdiff_t (defaulting to 0). It then creates an object of type pugi::xml_parse_result, assigns the provided pugi::xml_parse_status to its status field and the provided ptrdiff_t value to its offset field, and finally returns the constructed pugi::xml_parse_result object.",
        "code_id": "c_group_2_id_34",
        "code_text": "inline xml_parse_result make_parse_result(xml_parse_status status, ptrdiff_t offset = 0)\n\t{\n\t\txml_parse_result result;\n\t\tresult.status = status;\n\t\tresult.offset = offset;\n\n\t\treturn result;\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_35",
        "query_text": "SUMMARY: This function accepts an input of type uint8_t* and a uint32_t. It ignores the 32-bit unsigned integer, writes a fixed placeholder character ('?') into the byte pointed to by the uint8_t* input, and then returns a uint8_t* pointing to the next memory location.",
        "code_id": "c_group_2_id_35",
        "code_text": "#include \"helper_header.h\"\nnamespace pugi {\nnamespace impl {\ntypedef uint8_t* value_type;\n};\n};\n;\nstruct latin1_writer\n\t{\n\t\ttypedef uint8_t* value_type;\n\n\t\tstatic value_type high(value_type result, uint32_t ch)\n\t\t{\n\t\t\t(void)ch;\n\n\t\t\t*result = '?';\n\n\t\t\treturn result + 1;\n\t\t}\n\n\t};\nnamespace pugi {\nnamespace impl {\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_36",
        "query_text": "SUMMARY: This function accepts two inputs of type const pugi::char_t* (pointers to null-terminated character sequences) and returns a value of the same type. It searches for the first occurrence of the sequence given by the second input within the sequence given by the first input. Depending on a compile-time flag, it utilizes the appropriate standard function (for either wide or narrow characters) to perform the search, and in wide-character mode, it directly returns the first input if the second input represents an empty sequence.",
        "code_id": "c_group_2_id_36",
        "code_text": "const char_t* find_substring(const char_t* s, const char_t* p)\n\t{\n\t#ifdef PUGIXML_WCHAR_MODE\n\t\t// MSVC6 wcsstr bug workaround (if s is empty it always returns 0)\n\t\treturn (*p == 0) ? s : wcsstr(s, p);\n\t#else\n\t\treturn strstr(s, p);\n\t#endif\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_37",
        "query_text": "SUMMARY: This function takes two inputs: one is a pointer to an unsigned 8-bit integer (uint8_t*) representing a destination buffer, and the other is an unsigned 32-bit integer (uint32_t) representing a character value. It writes a single byte to the destination: if the input integer is greater than 255, it writes the byte value corresponding to the character '?' (a replacement character); otherwise, it converts the input integer to an 8-bit unsigned value and writes it. The function returns an updated pointer (uint8_t*) that points to the next byte position after the written byte.",
        "code_id": "c_group_2_id_37",
        "code_text": "#include \"helper_header.h\"\nnamespace pugi {\nnamespace impl {\ntypedef uint8_t* value_type;\n};\n};\n;\nstruct latin1_writer\n\t{\n\t\ttypedef uint8_t* value_type;\n\n\t\tstatic value_type low(value_type result, uint32_t ch)\n\t\t{\n\t\t\t*result = static_cast<uint8_t>(ch > 255 ? '?' : ch);\n\n\t\t\treturn result + 1;\n\t\t}\n\n\t};\nnamespace pugi {\nnamespace impl {\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_38",
        "query_text": "SUMMARY: This function accepts two input parameters, both of type const pugi::char_t* (representing character arrays), and returns an output of type bool. It checks whether the character array referenced by the second pointer exactly matches the beginning segment of the character array referenced by the first pointer, returning true if the entire sequence of the second input is found at the start of the first, and false otherwise.",
        "code_id": "c_group_2_id_38",
        "code_text": "bool starts_with(const char_t* string, const char_t* pattern)\n\t{\n\t\twhile (*pattern && *string == *pattern)\n\t\t{\n\t\t\tstring++;\n\t\t\tpattern++;\n\t\t}\n\n\t\treturn *pattern == 0;\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_39",
        "query_text": "SUMMARY: This function accepts an output parameter of type uint32_t* and an input parameter of type uint32_t. It stores the 32-bit unsigned integer value at the memory location indicated by the pointer and then returns a new pointer of type uint32_t* that points to the next element in the sequence.",
        "code_id": "c_group_2_id_39",
        "code_text": "#include \"helper_header.h\"\nnamespace pugi {\nnamespace impl {\ntypedef uint8_t* value_type;\n};\n};\n;\nstruct utf32_writer\n\t{\n\t\ttypedef uint32_t* value_type;\n\n\t\tstatic value_type low(value_type result, uint32_t ch)\n\t\t{\n\t\t\t*result = ch;\n\n\t\t\treturn result + 1;\n\t\t}\n\n\t\tstatic value_type high(value_type result, uint32_t ch)\n\t\t{\n\t\t\t*result = ch;\n\n\t\t\treturn result + 1;\n\t\t}\n\n\t\tstatic value_type any(value_type result, uint32_t ch)\n\t\t{\n\t\t\t*result = ch;\n\n\t\t\treturn result + 1;\n\t\t}\n\t};\nnamespace pugi {\nnamespace impl {\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_40",
        "query_text": "SUMMARY: This function receives an input of type pugi::xml_node_type and returns a value of type bool. It evaluates whether the provided XML node type is either an element node or a declaration node, and returns true in those cases, and false otherwise.",
        "code_id": "c_group_2_id_40",
        "code_text": "bool allow_insert_attribute(xml_node_type parent)\n\t{\n\t\treturn parent == node_element || parent == node_declaration;\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_41",
        "query_text": "SUMMARY: This function accepts two inputs of type \"const pugi::char_t*\" and returns an output of type \"bool\". It first verifies that both input pointers are valid, then performs a comparison of the null\u2010terminated character arrays pointed to by these inputs. The function ultimately returns a boolean value indicating whether the two string representations are equal.",
        "code_id": "c_group_2_id_41",
        "code_text": "bool strequal(const char_t* src, const char_t* dst)\n\t{\n\t\tassert(src && dst);\n\n\t#ifdef PUGIXML_WCHAR_MODE\n\t\treturn wcscmp(src, dst) == 0;\n\t#else\n\t\treturn strcmp(src, dst) == 0;\n\t#endif\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_42",
        "query_text": "SUMMARY: The function accepts a constant pointer to a character sequence (of type pugi::char_t) and returns a size_t value representing the count of characters in the sequence. It determines the length of a null-terminated string, choosing a wide-character approach (using wcslen) or a standard approach (using strlen) based on the compilation configuration.",
        "code_id": "c_group_2_id_42",
        "code_text": "static size_t strlength(const pugi::char_t* s)\n{\n#ifdef PUGIXML_WCHAR_MODE\n\treturn wcslen(s);\n#else\n\treturn strlen(s);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_43",
        "query_text": "SUMMARY: This function accepts an input of type \"pointer to constant char_t\" and returns a result of type \"float\". It converts a textual numeric representation into a floating-point number using standard library conversion routines, choosing between the wide-character or narrow-character conversion method based on compile-time settings.",
        "code_id": "c_group_2_id_43",
        "code_text": "float get_value_float(const char_t* value)\n\t{\n\t#ifdef PUGIXML_WCHAR_MODE\n\t\treturn static_cast<float>(wcstod(value, NULL));\n\t#else\n\t\treturn static_cast<float>(strtod(value, NULL));\n\t#endif\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_44",
        "query_text": "SUMMARY: This function accepts a constant pointer to a character type (pugi::char_t*) as input and returns a double-precision floating point value. Its primary behavior is to convert a string representing a numerical value into its corresponding double value. Depending on whether a wide character mode is enabled at compile time, it internally uses either the wide-character conversion function (wcstod) or the standard conversion function (strtod) to perform this conversion.",
        "code_id": "c_group_2_id_44",
        "code_text": "double get_value_double(const char_t* value)\n\t{\n\t#ifdef PUGIXML_WCHAR_MODE\n\t\treturn wcstod(value, NULL);\n\t#else\n\t\treturn strtod(value, NULL);\n\t#endif\n\t};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_45",
        "query_text": "SUMMARY: This is an inline, constant member function that takes no explicit input parameters (its effective input is the constant instance of a global management structure) and returns a pointer to a file stream (output type: FILE*). Its functionality is to check whether an internal file stream pointer (of type FILE*) is set; if it is, the function returns that pointer, otherwise it returns the standard output stream pointer (stdout). The function is marked as noexcept, establishing that it does not throw exceptions.",
        "code_id": "c_group_2_id_45",
        "code_text": "#include \"helper_header.h\"\nnamespace BrokenAPI {\nstruct Unit;\n};\nnamespace BrokenAPI {\ntypedef void (*Entry)(void);\n};\nnamespace BrokenAPI {\nstruct Unit {\n  Entry entry;\n  const char* name;\n  int priority;\n  unsigned flags;\n  Unit* next;\n};\n};\n;\n;\n;\nstruct BrokenGlobal {\n  // Application arguments.\n  int _argc;\n  const char** _argv;\n\n  // Output file.\n  FILE* _file;\n\n  // Unit tests.\n  BrokenAPI::Unit* _unitList;\n  BrokenAPI::Unit* _unitRunning;\n\n  bool hasArg(const char* a) const noexcept {\n    for (int i = 1; i < _argc; i++)\n      if (strcmp(_argv[i], a) == 0)\n        return true;\n    return false;\n  }\n\n  inline FILE* file() const noexcept { return _file ? _file : stdout; }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_46",
        "query_text": "SUMMARY: This function receives two constant pointers to the BrokenAPI::Unit structure and returns an integer. It compares the integer field (priority) of both inputs; if they are equal, it compares the C-style string field (name) lexically. The output integer indicates whether the first input is considered greater than, equal to, or less than the second based on these comparisons.",
        "code_id": "c_group_2_id_46",
        "code_text": "static int BrokenAPI_compareUnits(const BrokenAPI::Unit* a, const BrokenAPI::Unit* b) noexcept {\n  if (a->priority == b->priority)\n    return strcmp(a->name, b->name);\n  else\n    return a->priority > b->priority ? 1 : -1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_47",
        "query_text": "SUMMARY: The function accepts an input of type asmjit::_abi_1_13::CallConvId (an enum class with underlying type uint8_t) and returns a bool. It determines whether the provided calling convention identifier corresponds to one of several established C-style calling conventions (including cdecl, stdcall, fastcall, vectorcall, thiscall, and three regparm variants). Essentially, it checks the input against these specific enumerated values and returns true if a match is found, otherwise it returns false.",
        "code_id": "c_group_2_id_47",
        "code_text": "static inline bool shouldTreatAsCDecl(CallConvId ccId) noexcept {\n  return ccId == CallConvId::kCDecl ||\n         ccId == CallConvId::kStdCall ||\n         ccId == CallConvId::kFastCall ||\n         ccId == CallConvId::kVectorCall ||\n         ccId == CallConvId::kThisCall ||\n         ccId == CallConvId::kRegParm1 ||\n         ccId == CallConvId::kRegParm2 ||\n         ccId == CallConvId::kRegParm3;\n};\n};\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_48",
        "query_text": "SUMMARY: This function accepts two inputs of type asmjit::_abi_1_13::TypeId and returns a 32-bit unsigned integer (uint32_t). It converts each input to its unsigned integer representation, left-shifts the first input by 8 bits to occupy the higher-order portion, and then combines it with the second input (occupying the lower-order portion) using a bitwise OR operation.",
        "code_id": "c_group_2_id_48",
        "code_text": "static inline uint32_t makeCastOp(TypeId dst, TypeId src) noexcept {\n  return (uint32_t(dst) << 8) | uint32_t(src);\n};\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_49",
        "query_text": "SUMMARY: The function accepts an input of type asmjit::_abi_1_13::CallConvId (an enumeration based on uint8_t) and returns a boolean value. It evaluates whether the provided calling convention identifier is one of a specific subset (namely, kCDecl, kStdCall, kThisCall, kFastCall, kRegParm1, kRegParm2, or kRegParm3). If the input matches any of these designated values, the function outputs true; otherwise, it outputs false.",
        "code_id": "c_group_2_id_49",
        "code_text": "static inline bool shouldTreatAsCDeclIn64BitMode(CallConvId ccId) noexcept {\n  return ccId == CallConvId::kCDecl ||\n         ccId == CallConvId::kStdCall ||\n         ccId == CallConvId::kThisCall ||\n         ccId == CallConvId::kFastCall ||\n         ccId == CallConvId::kRegParm1 ||\n         ccId == CallConvId::kRegParm2 ||\n         ccId == CallConvId::kRegParm3;\n};\n};\n};\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_50",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a mutable high-level string (Neyson::String &), a constant character pointer (const char*), and an unsigned integer representing a length (size_t). It processes a sequence of characters from the given pointer, interpreting and removing escape sequences (such as those for quotes, backslashes, control characters, and Unicode code points) and appends the corresponding literal characters to the mutable string. As it iterates over the provided characters, it decodes any escape sequences encountered, converting Unicode escapes to their appropriate multi-byte (UTF\u20118) representations, and ultimately shortens the string to the correct final size. The function returns a boolean value to signal whether the processing succeeded without encountering any invalid or incomplete escape sequences.",
        "code_id": "c_group_2_id_50",
        "code_text": "bool fixString(String &string, const char *ptr, size_t len)\n{\n    size_t j = 0;\n    string.resize(len);\n    bool escape = false;\n\n    for (size_t i = 0; i < len; ++i)\n        if (!escape)\n        {\n            if (ptr[i] == '\\\\')\n                escape = true;\n            else\n                string[j++] = ptr[i];\n        }\n        else\n        {\n            escape = false;\n            if (ptr[i] == '\\\"')\n                string[j++] = '\\\"';\n            else if (ptr[i] == '\\\\')\n                string[j++] = '\\\\';\n            else if (ptr[i] == '/')\n                string[j++] = '/';\n            else if (ptr[i] == 'b')\n                string[j++] = '\\b';\n            else if (ptr[i] == 'f')\n                string[j++] = '\\f';\n            else if (ptr[i] == 'n')\n                string[j++] = '\\n';\n            else if (ptr[i] == 'r')\n                string[j++] = '\\r';\n            else if (ptr[i] == 't')\n                string[j++] = '\\t';\n            else if (ptr[i] == 'u')\n            {\n                uint32_t code = 0;\n                if (++i + 4 > len) return false;\n                for (int j = 0; j < 4; ++i, ++j)\n                {\n                    code <<= 4;\n                    if (ptr[i] >= '0' && ptr[i] <= '9')\n                        code += ptr[i] - '0';\n                    else if (ptr[i] >= 'a' && ptr[i] <= 'f')\n                        code += ptr[i] - 'a' + 10;\n                    else if (ptr[i] >= 'A' && ptr[i] <= 'F')\n                        code += ptr[i] - 'A' + 10;\n                    else\n                        return false;\n                }\n                --i;\n\n                if (code <= 0x7F)\n                    string[j++] = char(code);\n                else if (code <= 0x07FF)\n                {\n                    string[j++] = char(((code >> 6) & 0x1F) | 0xC0);\n                    string[j++] = char((code & 0x3F) | 0x80);\n                }\n                else if (code <= 0xFFFF)\n                {\n                    string[j++] = char(((code >> 12) & 0x0F) | 0xE0);\n                    string[j++] = char(((code >> 6) & 0x3F) | 0x80);\n                    string[j++] = char((code & 0x3F) | 0x80);\n                }\n                else if (code <= 0x10FFFF)\n                {\n                    string[j++] = char(((code >> 18) & 0x07) | 0xF0);\n                    string[j++] = char(((code >> 12) & 0x3F) | 0x80);\n                    string[j++] = char(((code >> 6) & 0x3F) | 0x80);\n                    string[j++] = char((code & 0x3F) | 0x80);\n                }\n                else\n                    return false;\n            }\n            else\n                return false;\n        }\n\n    string.erase(j);\n    string.shrink_to_fit();\n    return 0;\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_51",
        "query_text": "SUMMARY: This function receives two inputs of type st_data_t (an unsigned long) and returns an integer. It interprets each input as a pointer to a constant character sequence (a null-terminated string) and performs a standard lexicographical comparison between these two strings, returning the result of this comparison.",
        "code_id": "c_group_2_id_51",
        "code_text": "static int\nstr_cmp(st_data_t a1, st_data_t a2)\n{\n  const char* s1 = (const char* )a1;\n  const char* s2 = (const char* )a2;\n  return strcmp(s1, s2);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_52",
        "query_text": "SUMMARY: The function receives two inputs, each being a pointer to a structure defined as a pair of integers. It modifies the first structure by performing a bitwise AND operation on its individual integer values with the corresponding values from the second structure. The function does not return a value; it updates the first structure in place.",
        "code_id": "c_group_2_id_52",
        "code_text": "static void\nalt_merge_opt_anc_info(OptAnc* to, OptAnc* add)\n{\n  to->left  &= add->left;\n  to->right &= add->right;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_53",
        "query_text": "SUMMARY: This function accepts a single input of type unsigned int (OnigCodePoint) and returns an unsigned int (OnigCodePoint). It checks if the input code point matches one of a few specific characters\u2014namely the beginning of a paired punctuation sequence\u2014and returns the corresponding ending punctuation code point. Specifically, it maps an input representing '<' to the code point for '>', an input representing a single quote to the same single quote, and an input representing '(' to the code point for ')'. If the input does not match any of these specified characters, it returns 0 as the default outcome.",
        "code_id": "c_group_2_id_53",
        "code_text": "static OnigCodePoint\nget_name_end_code_point(OnigCodePoint start)\n{\n  switch (start) {\n  case '<':  return (OnigCodePoint )'>';  break;\n  case '\\'': return (OnigCodePoint )'\\''; break;\n  case '(':  return (OnigCodePoint )')';  break;\n  default:\n    break;\n  }\n\n  return (OnigCodePoint )0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_54",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to an array of unsigned integers (OnigCodePoint) and an integer\u2014and returns an integer. It calculates a specific offset within the array by dividing the integer input by 3 to select one element, then uses the remainder to determine which of the three bytes in that element to extract. It shifts the corresponding unsigned integer value accordingly and masks it to isolate one byte, which is then returned as a standard integer.",
        "code_id": "c_group_2_id_54",
        "code_text": "extern int\nonig_codes_byte_at(OnigCodePoint codes[], int at)\n{\n  int index;\n  int b;\n  OnigCodePoint code;\n\n  index = at / 3;\n  b     = at % 3;\n  code = codes[index];\n\n  return ((code >> ((2 - b) * 8)) & 0xff);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_55",
        "query_text": "SUMMARY: This function accepts two pointers to an OptAnc structure (which contains two integer fields) as input parameters. It performs a direct copy of all the content from the structure referenced by the second pointer (source) to the structure referenced by the first pointer (destination), and it returns no value (void).",
        "code_id": "c_group_2_id_55",
        "code_text": "static void\ncopy_opt_anc_info(OptAnc* to, OptAnc* from)\n{\n  *to = *from;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_56",
        "query_text": "SUMMARY: The function accepts an input parameter of type pointer to a structure (OptAnc) that contains two integer fields. It sets both of these integer fields to zero, effectively resetting the stored values. The function does not return any output (void).",
        "code_id": "c_group_2_id_56",
        "code_text": "static void\nclear_opt_anc_info(OptAnc* a)\n{\n  a->left  = 0;\n  a->right = 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_57",
        "query_text": "SUMMARY: The function accepts two inputs of type unsigned long (st_data_t) and returns an int. It performs a simple comparison between these two values and produces an integer result that indicates whether the two inputs are not equal.",
        "code_id": "c_group_2_id_57",
        "code_text": "static int\nnumcmp(st_data_t x, st_data_t y)\n{\n  return x != y;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_58",
        "query_text": "SUMMARY: This function takes an unsigned long input (interpreted as a pointer to a constant character sequence) and returns an integer computed as a hash value based on that string\u2019s content. It iterates over the characters of the null\u2010terminated string, updating an accumulator through arithmetic and bitwise operations. Depending on compile-time flags, it applies one of several hashing methods\u2014one that performs left shifts with mask extraction, another that combines summation with bit shifting, and a default that multiplies by a constant before adding each character. The overall behavior is to transform the input string into an integer hash result.",
        "code_id": "c_group_2_id_58",
        "code_text": "static int\nstr_hash(st_data_t astring)\n{\n  const char* string = (const char* )astring;\n  register int c;\n\n#ifdef HASH_ELFHASH\n  register unsigned int h = 0, g;\n\n  while ((c = *string++) != '\\0') {\n    h = ( h << 4 ) + c;\n    if ( g = h & 0xF0000000 )\n\t    h ^= g >> 24;\n    h &= ~g;\n  }\n  return h;\n#elif HASH_PERL\n  register int val = 0;\n\n  while ((c = *string++) != '\\0') {\n    val += c;\n    val += (val << 10);\n    val ^= (val >> 6);\n  }\n  val += (val << 3);\n  val ^= (val >> 11);\n\n  return val + (val << 15);\n#else\n  register int val = 0;\n\n  while ((c = *string++) != '\\0') {\n    val = val*997 + c;\n  }\n\n  return val + (val>>5);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_59",
        "query_text": "SUMMARY: This function accepts two integers and a pointer to an array of type MemNumType as inputs. It iterates through a sequence of elements (with the number of iterations specified by the second integer input), checking if any element in the array exactly matches the first integer input. The function returns an integer output: it yields 1 (of type int) if a match is found and 0 (of type int) if no matching element exists.",
        "code_id": "c_group_2_id_59",
        "code_text": "static int mem_is_in_memp(int mem, int num, MemNumType* memp)\n{\n  int i;\n\n  for (i = 0; i < num; i++) {\n    if (mem == (int )memp[i]) return 1;\n  }\n  return 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_60",
        "query_text": "SUMMARY: This function takes an input of type st_table* and returns no output (void). It iterates over all bins in a hash table, freeing each st_table_entry (of type st_table_entry*) in the linked list stored in each bin. After releasing the memory for these entries, the function frees the array of bins and finally deallocates the st_table structure itself.",
        "code_id": "c_group_2_id_60",
        "code_text": "extern void\nst_free_table(st_table* table)\n{\n  register st_table_entry *ptr, *next;\n  int i;\n\n  for(i = 0; i < table->num_bins; i++) {\n    ptr = table->bins[i];\n    while (ptr != 0) {\n\t    next = ptr->next;\n\t    free(ptr);\n\t    ptr = next;\n    }\n  }\n  free(table->bins);\n  free(table);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_61",
        "query_text": "SUMMARY: This function accepts a single input of type unsigned long and returns an output of type int. Its behavior is to directly pass the input value through to the output, effectively converting the provided unsigned long value into an int.",
        "code_id": "c_group_2_id_61",
        "code_text": "static int\nnumhash(st_data_t n)\n{\n  return n;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_62",
        "query_text": "SUMMARY: The function takes two arrays of unsigned int (OnigCodePoint) and an integer indicating the number of elements to compare. It iterates through the arrays, comparing each corresponding pair of elements. If any pair is not equal, it immediately returns an integer output value of -1; if all compared elements are identical, it returns 0 as the output.",
        "code_id": "c_group_2_id_62",
        "code_text": "extern int\nonig_codes_cmp(OnigCodePoint a[], OnigCodePoint b[], int n)\n{\n  int i;\n\n  for (i = 0; i < n; i++) {\n    if (a[i] != b[i])\n      return -1;\n  }\n\n  return 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_63",
        "query_text": "SUMMARY: The function accepts an input of type pointer to a structure (OptAnc) containing two integers (\"left\" and \"right\") and a second input of type int. It checks whether the int input is represented as a set bit in the first integer element; if not, it then checks the second integer element. The output is an int that indicates success (1) if the bit is set in either of the integer fields, or failure (0) otherwise.",
        "code_id": "c_group_2_id_63",
        "code_text": "static int\nis_set_opt_anc_info(OptAnc* to, int anc)\n{\n  if ((to->left & anc) != 0) return 1;\n\n  return ((to->right & anc) != 0 ? 1 : 0);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_64",
        "query_text": "SUMMARY: This function takes two objects of type most_hostile_types::with_order_by_representation::Rep as input and returns a boolean value. Its functionality is to always yield true, regardless of the input values.",
        "code_id": "c_group_2_id_64",
        "code_text": "bool operator==(Rep, Rep) { return true; };\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_65",
        "query_text": "SUMMARY: This function accepts two inputs of type most_hostile_types::with_order_by_representation::Rep (each containing an integer member) and returns a boolean value. Its behavior is to consistently yield false, regardless of the internal values of the provided inputs.",
        "code_id": "c_group_2_id_65",
        "code_text": "bool operator<(Rep, Rep) { return false; };\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_66",
        "query_text": "SUMMARY: This function takes two inputs\u2014a non-constant reference to a stream (std::ostream&) and a constant reference to a custom integer type (MyInt). It extracts an integer value from the custom type and inserts that integer into the stream. The function then returns a reference to the same stream (std::ostream&).",
        "code_id": "c_group_2_id_66",
        "code_text": "std::ostream& operator<<(std::ostream& os, const MyInt& obj) {\n    os << obj.value();\n    return os;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_67",
        "query_text": "SUMMARY: This function accepts four parameters: a reference to a value of type std::vector<std::vector<double>>, a constant size_t representing the number of points, a constant size_t representing the dimensionality of each point, and an optional double for the maximum range of generated values (with a default of 10.0). It produces no direct return value (void) but instead populates the referenced vector with the specified number of points, where each point is a vector of doubles containing randomly generated values between 0 and the maximum range.",
        "code_id": "c_group_2_id_67",
        "code_text": "void generateRandomPointCloud(\n    my_vector_of_vectors_t& samples, const size_t N, const size_t dim,\n    const double max_range = 10.0)\n{\n    std::cout << \"Generating \" << N << \" random points...\";\n    samples.resize(N);\n    for (size_t i = 0; i < N; i++)\n    {\n        samples[i].resize(dim);\n        for (size_t d = 0; d < dim; d++)\n            samples[i][d] = max_range * (rand() % 1000) / (1000.0);\n    }\n    std::cout << \"done\\n\";\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_68",
        "query_text": "SUMMARY: This inline function accepts an input of type configor::token_type (an enumeration) and returns a constant character pointer as output. It maps each enumerated token type to a corresponding string literal, providing a human-readable representation of that token type. If the input does not match any predefined enumeration value, the function returns a default string literal indicating an unknown value.",
        "code_id": "c_group_2_id_68",
        "code_text": "inline const char* to_string(token_type token)\n{\n    switch (token)\n    {\n    case token_type::uninitialized:\n        return \"uninitialized\";\n    case token_type::literal_true:\n        return \"literal_true\";\n    case token_type::literal_false:\n        return \"literal_false\";\n    case token_type::literal_null:\n        return \"literal_null\";\n    case token_type::value_string:\n        return \"value_string\";\n    case token_type::value_integer:\n        return \"value_integer\";\n    case token_type::value_float:\n        return \"value_float\";\n    case token_type::begin_array:\n        return \"begin_array\";\n    case token_type::end_array:\n        return \"end_array\";\n    case token_type::begin_object:\n        return \"begin_object\";\n    case token_type::end_object:\n        return \"end_object\";\n    case token_type::name_separator:\n        return \"name_separator\";\n    case token_type::value_separator:\n        return \"value_separator\";\n    case token_type::end_of_input:\n        return \"end_of_input\";\n    }\n    return \"unknown\";\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_69",
        "query_text": "SUMMARY: This function accepts an input of type const config_t* and returns an output of type int. It retrieves and returns the configuration options stored within the provided configuration structure.",
        "code_id": "c_group_2_id_69",
        "code_text": "int config_get_options(const config_t *config)\n{\n  return(config->options);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_70",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to a structure of type config_t and a pointer of type void*. Its purpose is to assign the provided void pointer to the hook member of the config_t structure. The function does not produce an output value (its return type is void).",
        "code_id": "c_group_2_id_70",
        "code_text": "void config_set_hook(config_t *config, void *hook)\n{\n  config->hook = hook;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_71",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to a file stream (FILE *) and a constant pointer to a structured value (tt_val_t, which contains an enumerated type indicator and a union holding one of several data types: int, unsigned int, long long, unsigned long long, double, const char *, or const void *). It processes the structured value by examining the associated type enumeration and writes its contained value to the provided file stream in an appropriately formatted manner. The output is directly written to the stream (with no return value) and includes special handling for string types, where control characters are escaped and the entire string is enclosed in quotation marks.",
        "code_id": "c_group_2_id_71",
        "code_text": "void tt_output_val(FILE *stream, const tt_val_t *val)\n{\n  switch(val->type)\n  {\n    case TT_VAL_INT:\n      fprintf(stream, \"%d\", val->value.int_val);\n      break;\n\n    case TT_VAL_UINT:\n      fprintf(stream, \"%u\", val->value.uint_val);\n      break;\n\n    case TT_VAL_INT64:\n      fprintf(stream, \"%lld\", val->value.int64_val);\n      break;\n\n    case TT_VAL_UINT64:\n      fprintf(stream, \"%llu\", val->value.uint64_val);\n      break;\n\n    case TT_VAL_DOUBLE:\n      fprintf(stream, \"%f\", val->value.double_val);\n      break;\n\n    case TT_VAL_STR:\n    {\n      const char *p;\n\n      fputc('\\\"', stream);\n      for(p = val->value.str_val; *p; ++p)\n      {\n        if(*p == '\\n')\n          fputs(\"\\\\n\", stream);\n        else if(*p == '\\r')\n          fputs(\"\\\\r\", stream);\n        else if(*p == '\\t')\n          fputs(\"\\\\t\", stream);\n        else if(*p == '\\f')\n          fputs(\"\\\\f\", stream);\n        else if(*p < ' ')\n          fprintf(stream, \"\\\\0x%02X\", *p);\n        else\n          fputc(*p, stream);\n      }\n      fputc('\\\"', stream);\n      break;\n    }\n\n    case TT_VAL_PTR:\n      fprintf(stream, \"%p\", val->value.ptr_val);\n      break;\n\n    default:\n      fputs(\"???\", stream);\n      break;\n  }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_72",
        "query_text": "SUMMARY: This function, which accepts a constant character pointer (const char*) and a generic pointer type (void*, aliased as yyscan_t) as inputs and returns no value (void), is designed to handle fatal errors. It outputs a provided error message to the standard error stream and then terminates the program using a predefined failure exit code.",
        "code_id": "c_group_2_id_72",
        "code_text": "static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\tfprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_73",
        "query_text": "SUMMARY: This function accepts a pointer to a configuration structure (config_t *) and an unsigned short value representing float precision. It assigns the provided unsigned short value to the float_precision field within the configuration structure and does not return a value.",
        "code_id": "c_group_2_id_73",
        "code_text": "void config_set_float_precision(config_t *config, unsigned short digits)\n{\n  config->float_precision = digits;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_74",
        "query_text": "SUMMARY: This function accepts a constant pointer to a configuration structure (const config_t *) as input and returns an unsigned short. It functions as a getter by accessing the tab_width field within the provided configuration structure and returning its value.",
        "code_id": "c_group_2_id_74",
        "code_text": "unsigned short config_get_tab_width(const config_t *config)\n{\n  return config->tab_width;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_75",
        "query_text": "SUMMARY: This function takes as input a pointer to a configuration setting structure (of type struct config_setting_t) and a generic pointer (of type void *) as parameters, and returns no value (void). Its functionality is to update the configuration setting by assigning the provided generic pointer to the hook field within the configuration setting structure.",
        "code_id": "c_group_2_id_75",
        "code_text": "void config_setting_set_hook(config_setting_t *setting, void *hook)\n{\n  setting->hook = hook;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_76",
        "query_text": "SUMMARY: This function accepts a pointer to a structure (type: struct config_setting_t) and an integer (type: int) as inputs and returns an integer (type: int). It verifies whether the input structure either has no assigned type or is explicitly designated as a boolean type. If the structure is untyped, it assigns the boolean type; if it is already of a different type, the function returns an error code (false). When the boolean type conditions are met, it stores the provided integer value into the union field representing an integer and returns a success code (true).",
        "code_id": "c_group_2_id_76",
        "code_text": "int config_setting_set_bool(config_setting_t *setting, int value)\n{\n  if(setting->type == CONFIG_TYPE_NONE)\n    setting->type = CONFIG_TYPE_BOOL;\n  else if(setting->type != CONFIG_TYPE_BOOL)\n    return(CONFIG_FALSE);\n\n  setting->value.ival = value;\n  return(CONFIG_TRUE);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_77",
        "query_text": "SUMMARY: This function takes three inputs: a pointer to a configuration structure (of type config_t *), an integer bit mask (of type int), and an integer flag (of type int). It updates the configuration structure's internal options field by setting the bit(s) specified by the integer bit mask if the integer flag is nonzero, or by clearing those bit(s) if the integer flag is zero. The function does not return any value (void).",
        "code_id": "c_group_2_id_77",
        "code_text": "void config_set_option(config_t *config, int option, int flag)\n{\n  if(flag)\n    config->options |= option;\n  else\n    config->options &= ~option;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_78",
        "query_text": "SUMMARY: This function accepts a pointer to a constant configuration setting structure (const config_setting_t*) as its input and returns an integer (int) as its output. It determines whether the configuration setting represents an aggregate type by examining its type field. The function returns a nonzero integer (true) if the type field indicates that the configuration is either an array, a list, or a group; otherwise, it returns 0 (false).",
        "code_id": "c_group_2_id_78",
        "code_text": "int config_setting_is_aggregate(const config_setting_t *setting)\n{\n  return((setting->type == CONFIG_TYPE_ARRAY)\n         || (setting->type == CONFIG_TYPE_LIST)\n         || (setting->type == CONFIG_TYPE_GROUP));\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_79",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a pointer to a structure of type fuzz_data_t and a pointer to a pointer to an 8-bit unsigned integer (uint8_t **). It computes an offset within the data array contained in the structure by adding the structure\u2019s content_size and a single unit to the beginning address of the data array. It then assigns the computed offset address to the output pointer. Additionally, it ensures that the segment of the buffer, as determined by the path_size, is terminated with a null character. The function does not return a value.",
        "code_id": "c_group_2_id_79",
        "code_text": "void fuzz_data_path(fuzz_data_t *fuzz_data, uint8_t **buff)\n{\n  *buff = fuzz_data->data + fuzz_data->content_size + 1;\n\n  // Ensure the buffer is null terminated\n  (*buff)[fuzz_data->path_size] = '\\0';\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_80",
        "query_text": "SUMMARY: The function takes two inputs\u2014a pointer to a configuration structure of type config_t and an integer representing configuration options\u2014and does not return any value (void). It simply assigns the provided integer to the \"options\" field within the configuration structure, thereby setting the configuration options accordingly.",
        "code_id": "c_group_2_id_80",
        "code_text": "void config_set_options(config_t *config, int options)\n{\n  config->options = options;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_81",
        "query_text": "SUMMARY: This function takes a pointer to a structure (type: tt_testsuite_t *) representing a test suite as input and returns no value (type: void). It sequentially traverses a linked list of test structures (of type tt_test_t) contained within the suite, deallocating memory for each test\u2019s allocated name and the test structure itself. After cleaning up all test entries, it then deallocates memory for the suite\u2019s allocated name and the suite structure.",
        "code_id": "c_group_2_id_81",
        "code_text": "void tt_suite_destroy(tt_testsuite_t *suite)\n{\n  tt_test_t *test = suite->first_test;\n\n  while(test)\n  {\n    tt_test_t *tmp = test->next;\n    free((void *)test->name);\n    free(test);\n    test = tmp;\n  }\n\n  free((void *)suite->name);\n  free(suite);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_82",
        "query_text": "SUMMARY: The function accepts two inputs\u2014a pointer to a configuration setting structure (of type config_setting_t*) and an unsigned short that represents a format option\u2014and returns an integer (int). It verifies that the configuration setting is of an integer type (either 32-bit or 64-bit) and that the provided format option is valid (either the default or hexadecimal). Upon satisfying both conditions, it updates the configuration setting\u2019s format field with the given value and returns an integer indicating success; if not, it returns an integer indicating failure.",
        "code_id": "c_group_2_id_82",
        "code_text": "int config_setting_set_format(config_setting_t *setting, unsigned short format)\n{\n  if(((setting->type != CONFIG_TYPE_INT)\n      && (setting->type != CONFIG_TYPE_INT64))\n     || ((format != CONFIG_FORMAT_DEFAULT) && (format != CONFIG_FORMAT_HEX)))\n    return(CONFIG_FALSE);\n\n  setting->format = format;\n\n  return(CONFIG_TRUE);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_83",
        "query_text": "SUMMARY: This function is designed to deallocate dynamically allocated memory. Its inputs are a memory pointer (of type void*) and a scanner handle (of type yyscan_t, which is defined as void*). The function does not produce any output (void return type). Internally, it performs a cast on the scanner handle to an internal structure type and then calls the standard free function on the memory pointer (after casting it to a character pointer) to release the allocated memory.",
        "code_id": "c_group_2_id_83",
        "code_text": "void yyfree (void * ptr , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_84",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to a structure of type config_t and a pointer to a constant char array (const char *). It deallocates any previously stored string in the include directory field of the provided config_t structure and then assigns a new duplicate of the provided constant char array to that field. The function does not return any value (void).",
        "code_id": "c_group_2_id_84",
        "code_text": "void config_set_include_dir(config_t *config, const char *include_dir)\n{\n  __delete(config->include_dir);\n  config->include_dir = strdup(include_dir);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_85",
        "query_text": "SUMMARY: This function accepts a single input parameter of type const config_setting_t* and returns an int. It determines whether the provided configuration structure represents a boolean value by checking its type field; if it does, the function returns the integer value stored in the union (specifically in its ival component), and if not, it returns 0.",
        "code_id": "c_group_2_id_85",
        "code_text": "int config_setting_get_bool(const config_setting_t *setting)\n{\n  return((setting->type == CONFIG_TYPE_BOOL) ? setting->value.ival : 0);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_86",
        "query_text": "SUMMARY: This function takes two inputs\u2014the first is a pointer to a structure (of type fuzz_data_t) that includes metadata about content size and an array of 8-bit unsigned integers, and the second is a pointer to a pointer of 8-bit unsigned integers (uint8_t **). The function assigns the memory address of the internal data array from the structure to the provided output pointer and then appends a null terminator at the position indicated by the content size (a 32-bit unsigned integer) within that array. The function is void, so it outputs the changed pointer as an effect via the output parameter.",
        "code_id": "c_group_2_id_86",
        "code_text": "void fuzz_data_content(fuzz_data_t *fuzz_data, uint8_t **buff)\n{\n  *buff = fuzz_data->data;\n\n  // Ensure the buffer is null terminated\n  (*buff)[fuzz_data->content_size] = '\\0';\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_87",
        "query_text": "SUMMARY: This function accepts two inputs: one is a pointer to a structured configuration object (type config_t *) and the other is a pointer to a destructor function (type void (*)(void *)) that takes a void pointer as its argument and returns no value. Its functionality is to assign the provided destructor function to the destructor attribute of the configuration object. The function itself returns no output (void).",
        "code_id": "c_group_2_id_87",
        "code_text": "void config_set_destructor(config_t *config, void (*destructor)(void *))\n{\n  config->destructor = destructor;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_88",
        "query_text": "SUMMARY: This function takes three inputs\u2014a constant character pointer, another constant character pointer (both representing file paths), and a tt_bool_t (a boolean flag indicating verbosity). It returns a tt_bool_t indicating whether the contents of the two files are identical. The function opens both files in binary mode, reads their contents in 4096-byte chunks, and then compares the bytes sequentially. If a mismatch is detected (or if the files have different lengths), it marks the result as false and, if the verbosity flag is true, prints the location (line and character) where the first difference occurs. Ultimately, after closing the files, it returns TT_TRUE if the files are identical or TT_FALSE if they are not.",
        "code_id": "c_group_2_id_88",
        "code_text": "static tt_bool_t __tt_compare_files(const char *file1, const char *file2,\n                                    tt_bool_t verbose)\n{\n  FILE *fp1, *fp2;\n  char buf1[4096], buf2[4096];\n  int line = 1;\n  int character = 0;\n  size_t r1, r2;\n  tt_bool_t done = TT_FALSE, matched = TT_TRUE;\n\n  if(!(fp1 = fopen(file1, \"rb\")))\n  {\n    printf(\"cannot open file: %s\\n\", file1);\n    return(TT_FALSE);\n  }\n\n  if(!(fp2 = fopen(file2, \"rb\")))\n  {\n    fclose(fp1);\n    printf(\"cannot open file: %s\\n\", file2);\n    return(TT_FALSE);\n  }\n\n  while(!done)\n  {\n    char *p, *q, *pe, *qe;\n\n    r1 = fread(buf1, 1, sizeof(buf1), fp1);\n    r2 = fread(buf2, 1, sizeof(buf2), fp2);\n\n    p = buf1;\n    q = buf2;\n    pe = buf1 + r1;\n    qe = buf2 + r2;\n\n    while(p < pe && q < qe)\n    {\n      if(*p != *q)\n      {\n        matched = TT_FALSE;\n        done = TT_TRUE;\n        break;\n      }\n\n      if(*p == '\\n')\n      {\n        ++line;\n        character = 0;\n      }\n      else\n        ++character;\n\n      ++p;\n      ++q;\n    }\n\n    if(p < pe || q < qe)\n    {\n      matched = TT_FALSE;\n      break;\n    }\n\n    if(feof(fp1) || feof(fp2))\n      break;\n  }\n\n  fclose(fp1);\n  fclose(fp2);\n\n  if(!matched && verbose)\n    printf(\"files \\\"%s\\\" and \\\"%s\\\" differ starting at line %d, char %d\\n\",\n           file1, file2, line, character);\n\n  return(matched);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_89",
        "query_text": "SUMMARY: The function accepts a C-style string (input type: char pointer) and returns a boolean value (output type: tt_bool_t, which is essentially an int). Its functionality is to traverse the string from the end toward the beginning, replacing any trailing newline-related characters (specifically carriage return or newline) with a null terminator, and then it returns a boolean indicating whether any such termination characters were encountered and removed.",
        "code_id": "c_group_2_id_89",
        "code_text": "static tt_bool_t __tt_chop(char *s)\n{\n  size_t len = strlen(s);\n  char *p;\n  tt_bool_t eol = TT_FALSE;\n\n  for(p = s + len - 1; p > s; --p) {\n    if ((*p == '\\r') || (*p == '\\n')) {\n      eol = TT_TRUE;\n      *p = 0;\n    }\n  }\n\n  return(eol);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_90",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to an immutable configuration structure (const config_t *) and an integer (int) representing an option flag\u2014and returns an integer (int). It evaluates whether the bitmask in the configuration's options field fully includes the specified option flag, returning a nonzero value if it does and zero otherwise.",
        "code_id": "c_group_2_id_90",
        "code_text": "int config_get_option(const config_t *config, int option)\n{\n  return((config->options & option) == option);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_91",
        "query_text": "SUMMARY: This function accepts a pointer to a structure (strbuf_t) that includes a dynamically allocated string, its length, and its capacity. It retrieves the string (a char pointer) stored within the structure, then resets the structure's contents to a zeroed or cleared state. Finally, it returns the retrieved char pointer.",
        "code_id": "c_group_2_id_91",
        "code_text": "char *libconfig_strbuf_release(strbuf_t *buf)\n{\n  char *r = buf->string;\n  __zero(buf);\n  return(r);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_92",
        "query_text": "SUMMARY: This function receives a pointer to a structure (of type config_t) and returns an unsigned short value. It retrieves the floating-point precision field stored within the given configuration structure.",
        "code_id": "c_group_2_id_92",
        "code_text": "unsigned short config_get_float_precision(const config_t *config)\n{\n  return config->float_precision;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_93",
        "query_text": "SUMMARY: This function accepts a pointer to a structure representing a list (type config_list_t*) and an integer (type int) indicating an index, and it returns a pointer to a configuration setting (type config_setting_t*). Its primary operation is to remove the configuration setting located at the specified index from the list by shifting the subsequent elements to fill the gap, decrementing the total count of elements, and then returning the removed configuration setting.",
        "code_id": "c_group_2_id_93",
        "code_text": "static config_setting_t *__config_list_remove(config_list_t *list, int idx)\n{\n  config_setting_t *removed = *(list->elements + idx);\n  int offset = (idx * sizeof(config_setting_t *));\n  int len = list->length - 1 - idx;\n  char *base = (char *)list->elements + offset;\n\n  memmove(base, base + sizeof(config_setting_t *),\n          len * sizeof(config_setting_t *));\n\n  list->length--;\n\n  /* possibly realloc smaller? */\n\n  return(removed);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_94",
        "query_text": "SUMMARY: This function takes as input a pointer to a structure of type config_t and an unsigned short integer. It modifies the configuration by setting its tab_width field to the input value, ensuring that the value does not exceed 15; if the input exceeds 15, it sets the tab_width to 15. The function has a void output, meaning it does not return any value.",
        "code_id": "c_group_2_id_94",
        "code_text": "void config_set_tab_width(config_t *config, unsigned short width)\n{\n  /* As per documentation: valid range is 0 - 15. */\n  config->tab_width = (width <= 15) ? width : 15;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_95",
        "query_text": "SUMMARY: This function accepts a single input of type mp_err (an enumeration representing various error conditions) and returns a const char* (a string literal). Its functionality is to map the provided mp_err input to a corresponding descriptive error message. It examines the input using a conditional structure and returns a specific string literal for each valid error code, or a default message indicating an invalid error code if the input does not match any predefined enumeration value.",
        "code_id": "c_group_2_id_95",
        "code_text": "const char *mp_error_to_string(mp_err code)\n{\n   switch (code) {\n   case MP_OKAY:\n      return \"Successful\";\n   case MP_ERR:\n      return \"Unknown error\";\n   case MP_MEM:\n      return \"Out of heap\";\n   case MP_VAL:\n      return \"Value out of range\";\n   case MP_ITER:\n      return \"Max. iterations reached\";\n   case MP_BUF:\n      return \"Buffer overflow\";\n   case MP_OVF:\n      return \"Integer overflow\";\n   default:\n      return \"Invalid error code\";\n   }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_96",
        "query_text": "SUMMARY: This function accepts an input of type unsigned long and returns a value of the same type. It computes the integer portion of the base-2 logarithm of the input by repeatedly shifting the input to the right (thereby dividing by 2) until the result is zero. For each shift performed, it increments a counter, and finally returns this counter as the output.",
        "code_id": "c_group_2_id_96",
        "code_text": "static mp_word s_mp_flog2_mp_word_d(mp_word value)\n{\n   mp_word r = 0u;\n   while ((value >>= 1) != 0u) {\n      r++;\n   }\n   return r;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_97",
        "query_text": "SUMMARY: This function takes three parameters: a pointer to a mutable 64-bit unsigned integer array (output), a pointer to a constant 64-bit unsigned integer array (input), and an integer indicating the number of elements (digits) to process. Its purpose is to copy the specified number of 64-bit unsigned integers from the constant array into the mutable array. The operation is performed either by using a memory copy routine or by a simple loop, based on compile-time configuration. The function does not return any value.",
        "code_id": "c_group_2_id_97",
        "code_text": "void s_mp_copy_digs(mp_digit *d, const mp_digit *s, int digits)\n{\n#ifdef MP_USE_MEMOPS\n   if (digits > 0) {\n      memcpy(d, s, (size_t)digits * sizeof(mp_digit));\n   }\n#else\n   while (digits-- > 0) {\n      *d++ = *s++;\n   }\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_98",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to an array of unsigned 64-bit integers (mp_digit *) and a count as an integer (int) representing the number of elements. Its behavior is to set the specified number of unsigned 64-bit integer elements to zero. The function does not produce any output (void return), and its process involves either using a memory-setting operation to fill the array with 0 values or iterating over the array and assigning 0 to each element based on conditional compilation.",
        "code_id": "c_group_2_id_98",
        "code_text": "void s_mp_zero_digs(mp_digit *d, int digits)\n{\n#ifdef MP_USE_MEMOPS\n   if (digits > 0) {\n      memset(d, 0, (size_t)digits * sizeof(mp_digit));\n   }\n#else\n   while (digits-- > 0) {\n      *d++ = 0;\n   }\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_99",
        "query_text": "SUMMARY: This function takes an input of type uint64_t and returns an int. It determines whether the provided unsigned integer is exactly a power of two. Specifically, it examines the number by removing successive factors of two (i.e., counting trailing zero bits) and then checks if the remaining value is one. If so, it returns the exponent (the count of divisions), indicating that the input equals 2 raised to that exponent; if not, it returns -1 to signal that the input is not a power of two.",
        "code_id": "c_group_2_id_99",
        "code_text": "int      s_mp_ispow2d(mp_digit d)\n{\n  int   pow = 0;\n\n  while((d & 1) == 0) {\n    ++pow; d >>= 1;\n  }\n\n  if(d == 1)\n    return pow;\n\n  return -1;\n\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_100",
        "query_text": "SUMMARY: This function takes two inputs\u2014a pointer to a structure (of type Ciphers) that aggregates various cryptographic cipher objects, and a void pointer representing a memory heap used for dynamic allocation\u2014and returns no output (void). It conditionally deallocates memory for each distinct cryptographic cipher component stored within the input structure by calling associated freeing routines and custom deallocation functions. After releasing the resources, it sets the corresponding pointers in the structure to NULL, ensuring that no dangling references remain. For some cipher types, it also overwrites sensitive data before deallocation to enhance security.",
        "code_id": "c_group_2_id_100",
        "code_text": "static void FreeCiphersSide(Ciphers *cipher, void* heap)\n{\n#ifdef BUILD_ARC4\n    wc_Arc4Free(cipher->arc4);\n    XFREE(cipher->arc4, heap, DYNAMIC_TYPE_CIPHER);\n    cipher->arc4 = NULL;\n#endif\n#ifdef BUILD_DES3\n    wc_Des3Free(cipher->des3);\n    XFREE(cipher->des3, heap, DYNAMIC_TYPE_CIPHER);\n    cipher->des3 = NULL;\n#endif\n#if defined(BUILD_AES) || defined(BUILD_AESGCM) || defined(HAVE_ARIA)\n    /* See: InitKeys() in keys.c on addition of BUILD_AESGCM check (enc->aes,\n     * dec->aes) */\n    wc_AesFree(cipher->aes);\n    XFREE(cipher->aes, heap, DYNAMIC_TYPE_CIPHER);\n    cipher->aes = NULL;\n#endif\n#if defined(WOLFSSL_SM4_GCM) || defined(WOLFSSL_SM4_CCM)\n    wc_Sm4Free(cipher->sm4);\n    XFREE(cipher->sm4, heap, DYNAMIC_TYPE_CIPHER);\n    cipher->sm4 = NULL;\n#endif\n#if (defined(BUILD_AESGCM) || defined(BUILD_AESCCM) || defined(HAVE_ARIA)) && \\\n    !defined(WOLFSSL_NO_TLS12)\n    XFREE(cipher->additional, heap, DYNAMIC_TYPE_CIPHER);\n    cipher->additional = NULL;\n#endif\n#ifdef CIPHER_NONCE\n    XFREE(cipher->nonce, heap, DYNAMIC_TYPE_CIPHER);\n    cipher->nonce = NULL;\n#endif\n#ifdef HAVE_ARIA\n    wc_AriaFreeCrypt(cipher->aria);\n    XFREE(cipher->aria, heap, DYNAMIC_TYPE_CIPHER);\n    cipher->aria = NULL;\n#endif\n#ifdef HAVE_CAMELLIA\n    XFREE(cipher->cam, heap, DYNAMIC_TYPE_CIPHER);\n    cipher->cam = NULL;\n#endif\n#ifdef HAVE_CHACHA\n    if (cipher->chacha)\n        ForceZero(cipher->chacha, sizeof(ChaCha));\n    XFREE(cipher->chacha, heap, DYNAMIC_TYPE_CIPHER);\n    cipher->chacha = NULL;\n#endif\n#if defined(WOLFSSL_TLS13) && defined(HAVE_NULL_CIPHER)\n    wc_HmacFree(cipher->hmac);\n    XFREE(cipher->hmac, heap, DYNAMIC_TYPE_CIPHER);\n    cipher->hmac = NULL;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_101",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a pointer to an array of unsigned char (byte), a single unsigned char (byte) value, and an integer representing the number of elements to check. It iterates over the array and performs a comparison between each element and the specified unsigned char value using a bitwise XOR operation. The result of each comparison is accumulated using a bitwise OR operation. Finally, the function returns an integer that indicates whether all elements in the array match the specified byte value (0 if they all match; a nonzero value if at least one does not).",
        "code_id": "c_group_2_id_101",
        "code_text": "static int PadCheck(const byte* a, byte pad, int length)\n{\n    int i;\n    int compareSum = 0;\n\n    for (i = 0; i < length; i++) {\n        compareSum |= a[i] ^ pad;\n    }\n\n    return compareSum;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_102",
        "query_text": "SUMMARY: This function accepts a pointer to a structure of type Des3 as its input and returns no output (void). It first checks whether the input pointer is null, and if so, it exits immediately. When asynchronous cryptography support is enabled, it releases any associated asynchronous device context resources from the Des3 structure. Under additional conditional configurations, it clears sensitive key data within this structure by zeroing the corresponding memory areas, and may further verify that the entire structure has been securely wiped of data.",
        "code_id": "c_group_2_id_102",
        "code_text": "void wc_Des3Free(Des3* des3)\n{\n    if (des3 == NULL)\n        return;\n\n#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_3DES)\n    wolfAsync_DevCtxFree(&des3->asyncDev, WOLFSSL_ASYNC_MARKER_3DES);\n#endif /* WOLFSSL_ASYNC_CRYPT */\n#if defined(WOLF_CRYPTO_CB) || \\\n        (defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_3DES))\n    ForceZero(des3->devKey, sizeof(des3->devKey));\n#endif\n#ifdef WOLFSSL_CHECK_MEM_ZERO\n    wc_MemZero_Check(des3, sizeof(Des3));\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_103",
        "query_text": "SUMMARY: This function accepts five parameters: a pointer to a structure (of type stats_t) that contains numerical statistics (double values representing connection, receive, and transmit time, and integer values for connection count, receive total, and transmit total), three constant character pointers (providing informational text such as a benchmark description, a cipher identifier, and a group name), and an integer flag indicating verbosity. The function processes these inputs by calculating and formatting aggregate performance metrics, such as the total bytes (sum of transmit and receive totals), connection times converted to milliseconds, and throughput rates in megabytes per second (derived from dividing the byte totals by the corresponding timing values and applying conversions). Based on the verbosity flag, the function outputs the formatted benchmark results in either a detailed or a compact format to the standard error stream. The function does not return any value.",
        "code_id": "c_group_2_id_103",
        "code_text": "static void print_stats(stats_t* wcStat, const char* desc, const char* cipher, const char *group, int verbose)\n{\n    if (verbose) {\n        fprintf(stderr,\n                \"wolfSSL %s Benchmark on %s with group %s:\\n\"\n                \"\\tTotal       : %9d bytes\\n\"\n                \"\\tNum Conns   : %9d\\n\"\n                \"\\tRx Total    : %9.3f ms\\n\"\n                \"\\tTx Total    : %9.3f ms\\n\"\n                \"\\tRx          : %9.3f MB/s\\n\"\n                \"\\tTx          : %9.3f MB/s\\n\"\n                \"\\tConnect     : %9.3f ms\\n\"\n                \"\\tConnect Avg : %9.3f ms\\n\",\n                desc,\n                cipher,\n                group,\n                wcStat->txTotal + wcStat->rxTotal,\n                wcStat->connCount,\n                wcStat->rxTime * 1000,\n                wcStat->txTime * 1000,\n                wcStat->rxTotal / wcStat->rxTime / 1024 / 1024,\n                wcStat->txTotal / wcStat->txTime / 1024 / 1024,\n                wcStat->connTime * 1000,\n                wcStat->connTime * 1000 / wcStat->connCount);\n    }\n    else {\n        fprintf(stderr,\n                \"%-6s  %-33s  %-25s  %11d  %9d  %9.3f  %9.3f  %9.3f  \"\n                \"%9.3f  %17.3f  %15.3f\\n\",\n                desc,\n                cipher,\n                group,\n                wcStat->txTotal + wcStat->rxTotal,\n                wcStat->connCount,\n                wcStat->rxTime * 1000,\n                wcStat->txTime * 1000,\n                wcStat->rxTotal / wcStat->rxTime / 1024 / 1024,\n                wcStat->txTotal / wcStat->txTime / 1024 / 1024,\n                wcStat->connTime * 1000,\n                wcStat->connTime * 1000 / wcStat->connCount);\n    }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_104",
        "query_text": "SUMMARY: This function takes four inputs: a pointer to a structure (stats_t) containing double values for connection, receive, and transmit times, and integers for connection count, receive total, and transmit total; two constant character string pointers; and an integer indicating verbosity. It produces no return value (void). Based on the verbosity flag, the function selects one of two formatted string templates and prints a summary report to the standard output. The report includes the aggregate total of transmitted and received bytes, the number of connections, the total receive and transmit times (converted into milliseconds), calculated throughput rates in megabytes per second (derived from the byte totals and their respective times), and the connection time (both overall and as an average per connection).",
        "code_id": "c_group_2_id_104",
        "code_text": "static void PrintTlsStats(stats_t* wcStat, const char* desc, const char* cipher, int verbose)\n{\n    const char* formatStr;\n\n    if (verbose) {\n        formatStr = \"wolfSSL %s Benchmark on %s:\\n\"\n               \"\\tTotal       : %9d bytes\\n\"\n               \"\\tNum Conns   : %9d\\n\"\n               \"\\tRx Total    : %9.3f ms\\n\"\n               \"\\tTx Total    : %9.3f ms\\n\"\n               \"\\tRx          : %9.3f MB/s\\n\"\n               \"\\tTx          : %9.3f MB/s\\n\"\n               \"\\tConnect     : %9.3f ms\\n\"\n               \"\\tConnect Avg : %9.3f ms\\n\";\n    }\n    else {\n        formatStr = \"%-6s  %-33s  %11d  %9d  %9.3f  %9.3f  %9.3f  %9.3f  %17.3f  %15.3f\\n\";\n    }\n\n    printf(formatStr,\n           desc,\n           cipher,\n           wcStat->txTotal + wcStat->rxTotal,\n           wcStat->connCount,\n           wcStat->rxTime * 1000,\n           wcStat->txTime * 1000,\n           wcStat->rxTotal / wcStat->rxTime / 1024 / 1024,\n           wcStat->txTotal / wcStat->txTime / 1024 / 1024,\n           wcStat->connTime * 1000,\n           wcStat->connTime * 1000 / wcStat->connCount);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_105",
        "query_text": "SUMMARY: This function accepts an input parameter of type int and three output pointers each of type word32 (unsigned int). Based on the integer input, it selects one of several predefined key parameter sets and calculates the sizes (in bytes) of three components\u2014two mandatory components and an optional one when available. For each matching case in a switch statement, it assigns the corresponding size values to temporary word32 variables. If any of the provided output pointers is non-null, the function writes the computed size for that component into the location pointed to by that pointer. Finally, it returns an int value of 0, indicating successful completion.",
        "code_id": "c_group_2_id_105",
        "code_text": "int wc_DhGetNamedKeyParamSize(int name, word32* p, word32* g, word32* q)\n{\n    word32 pSz = 0, gSz = 0, qSz = 0;\n\n    switch (name) {\n        #ifdef HAVE_FFDHE_2048\n        case WC_FFDHE_2048:\n            pSz = sizeof(dh_ffdhe2048_p);\n            gSz = sizeof(dh_ffdhe2048_g);\n            #ifdef HAVE_FFDHE_Q\n            qSz = sizeof(dh_ffdhe2048_q);\n            #endif /* HAVE_FFDHE_Q */\n            break;\n        #endif /* HAVE_FFDHE_2048 */\n        #ifdef HAVE_FFDHE_3072\n        case WC_FFDHE_3072:\n            pSz = sizeof(dh_ffdhe3072_p);\n            gSz = sizeof(dh_ffdhe3072_g);\n            #ifdef HAVE_FFDHE_Q\n            qSz = sizeof(dh_ffdhe3072_q);\n            #endif /* HAVE_FFDHE_Q */\n            break;\n        #endif /* HAVE_FFDHE_3072 */\n        #ifdef HAVE_FFDHE_4096\n        case WC_FFDHE_4096:\n            pSz = sizeof(dh_ffdhe4096_p);\n            gSz = sizeof(dh_ffdhe4096_g);\n            #ifdef HAVE_FFDHE_Q\n            qSz = sizeof(dh_ffdhe4096_q);\n            #endif /* HAVE_FFDHE_Q */\n            break;\n        #endif /* HAVE_FFDHE_4096 */\n        #ifdef HAVE_FFDHE_6144\n        case WC_FFDHE_6144:\n            pSz = sizeof(dh_ffdhe6144_p);\n            gSz = sizeof(dh_ffdhe6144_g);\n            #ifdef HAVE_FFDHE_Q\n            qSz = sizeof(dh_ffdhe6144_q);\n            #endif /* HAVE_FFDHE_Q */\n            break;\n        #endif /* HAVE_FFDHE_6144 */\n        #ifdef HAVE_FFDHE_8192\n        case WC_FFDHE_8192:\n            pSz = sizeof(dh_ffdhe8192_p);\n            gSz = sizeof(dh_ffdhe8192_g);\n            #ifdef HAVE_FFDHE_Q\n            qSz = sizeof(dh_ffdhe8192_q);\n            #endif /* HAVE_FFDHE_Q */\n            break;\n        #endif /* HAVE_FFDHE_8192 */\n        default:\n            break;\n    }\n\n    if (p != NULL) *p = pSz;\n    if (g != NULL) *g = gSz;\n    if (q != NULL) *q = qSz;\n\n    return 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_106",
        "query_text": "SUMMARY: The function takes an integer (input type: int) and returns an enumerated hash type value (output type: wc_HashType). It first initializes the return value to a special \"none\" state, indicating an error or unmatched type. Under certain build configurations (such as those for FIPS or self-test), it uses a switch statement to map specific integer constants to corresponding enumeration values, ensuring that only particular hash types (like MD5, SHA variants, SHA3, SM3, etc.) are converted. If the input does not match any defined cases, the function retains the default \"none\" value. In other configurations, it checks if the integer is within a valid range and then directly converts it to the corresponding enumerated hash type.",
        "code_id": "c_group_2_id_106",
        "code_text": "enum wc_HashType wc_HashTypeConvert(int hashType)\n{\n    /* Default to hash type none as error */\n    enum wc_HashType eHashType = WC_HASH_TYPE_NONE;\n#if defined(HAVE_FIPS) || defined(HAVE_SELFTEST)\n    /* original FIPSv1  and CAVP selftest require a mapping for unique hash\n       type to wc_HashType */\n    switch (hashType) {\n    #ifndef NO_MD5\n        case WC_MD5:\n            eHashType = WC_HASH_TYPE_MD5;\n            break;\n    #endif /* !NO_MD5 */\n    #ifndef NO_SHA\n        case WC_SHA:\n            eHashType = WC_HASH_TYPE_SHA;\n            break;\n    #endif /* !NO_SHA */\n\n    #ifdef WOLFSSL_SHA224\n        case WC_SHA224:\n            eHashType = WC_HASH_TYPE_SHA224;\n            break;\n    #endif /* WOLFSSL_SHA224 */\n\n    #ifndef NO_SHA256\n        case WC_SHA256:\n            eHashType = WC_HASH_TYPE_SHA256;\n            break;\n    #endif /* !NO_SHA256 */\n\n    #ifdef WOLFSSL_SHA384\n        case WC_SHA384:\n            eHashType = WC_HASH_TYPE_SHA384;\n            break;\n    #endif /* WOLFSSL_SHA384 */\n    #ifdef WOLFSSL_SHA512\n        case WC_SHA512:\n            eHashType = WC_HASH_TYPE_SHA512;\n            break;\n\n    #endif /* WOLFSSL_SHA512 */\n    #ifdef WOLFSSL_SHA3\n        case WC_SHA3_224:\n            eHashType = WC_HASH_TYPE_SHA3_224;\n            break;\n        case WC_SHA3_256:\n            eHashType = WC_HASH_TYPE_SHA3_256;\n            break;\n        case WC_SHA3_384:\n            eHashType = WC_HASH_TYPE_SHA3_384;\n            break;\n        case WC_SHA3_512:\n            eHashType = WC_HASH_TYPE_SHA3_512;\n            break;\n    #endif /* WOLFSSL_SHA3 */\n    #ifdef WOLFSSL_SM3\n        case WC_SM3:\n            eHashType = WC_HASH_TYPE_SM3;\n            break;\n    #endif\n        default:\n            eHashType = WC_HASH_TYPE_NONE;\n            break;\n    }\n#else\n    /* current master uses same unique types as wc_HashType */\n    if (hashType > 0 && hashType <= WC_HASH_TYPE_MAX) {\n        eHashType = (enum wc_HashType)hashType;\n    }\n#endif\n    return eHashType;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_107",
        "query_text": "SUMMARY: This function updates a linked list of DNS_entry structures by inserting a new DNS_entry structure. It accepts two inputs: a pointer to a pointer to a DNS_entry (serving as the list head) and a pointer to a DNS_entry structure (the element to be added). Depending on compile-time conditions, the function either appends the element at the end of the list (if specific flags are defined) or prepends it to the front. The output is an integer (int) which is returned as 0, indicating the operation's successful completion.",
        "code_id": "c_group_2_id_107",
        "code_text": "static int AddDNSEntryToList(DNS_entry** lst, DNS_entry* entry)\n{\n#if defined(OPENSSL_EXTRA) && !defined(WOLFSSL_ALT_NAMES_NO_REV)\n    entry->next = NULL;\n    if (*lst == NULL) {\n        /* First on list */\n        *lst = entry;\n    }\n    else {\n        DNS_entry* temp = *lst;\n\n        /* Find end */\n        for (; (temp->next != NULL); temp = temp->next);\n\n        /* Add to end */\n        temp->next = entry;\n    }\n#else\n    /* Prepend entry to linked list. */\n    entry->next = *lst;\n    *lst = entry;\n#endif\n\n    return 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_108",
        "query_text": "SUMMARY: The function accepts two parameters\u2014a generic pointer (void*) and an unsigned short integer (word16)\u2014and returns no value (void). Its primary functionality is to signal that a server component is ready to accept TCP connections. In environments where specific configuration macros are defined, it retrieves a signaling structure from the provided argument, initiates a condition check, sets an internal readiness flag and the provided port value within that structure, signals the condition to notify any waiting threads, and then completes the condition handling.",
        "code_id": "c_group_2_id_108",
        "code_text": "static void SignalReady(void* args, word16 port)\n{\n#if defined(NO_MAIN_DRIVER) && defined(WOLFSSL_COND)\n    /* signal ready to tcp_accept */\n    func_args* server_args = (func_args*)args;\n    tcp_ready* ready = server_args->signal;\n    THREAD_CHECK_RET(wolfSSL_CondStart(&ready->cond));\n    ready->ready = 1;\n    ready->port = port;\n    THREAD_CHECK_RET(wolfSSL_CondSignal(&ready->cond));\n    THREAD_CHECK_RET(wolfSSL_CondEnd(&ready->cond));\n#endif /* NO_MAIN_DRIVER && WOLFSSL_COND */\n    (void)args;\n    (void)port;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_109",
        "query_text": "SUMMARY: This function accepts no parameters (input type: void) and returns a value of type wc_test_ret_t (alias for int). Its primary purpose is to validate AES-256 operations in Cipher Block Chaining (CBC) mode. The function configures encryption (and decryption, when enabled) contexts using a predetermined key and initialization vector. It then encrypts a fixed test message (sourced from established test vectors) and, if decryption is available, decrypts the resulting ciphertext. The outputs from both processes are compared against expected results to verify correctness. Multiple rounds of such tests are performed under different configurations, and error codes are returned immediately if any discrepancies or failures occur. Finally, it releases any allocated resources before returning the result.",
        "code_id": "c_group_2_id_109",
        "code_text": "wc_test_ret_t aes256_test(void)\n{\n#ifdef HAVE_AES_CBC\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\n    Aes *enc = NULL;\n#else\n    Aes enc[1];\n#endif\n    byte cipher[WC_AES_BLOCK_SIZE];\n#ifdef HAVE_AES_DECRYPT\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\n    Aes *dec = NULL;\n#else\n    Aes dec[1];\n#endif\n    byte plain[WC_AES_BLOCK_SIZE];\n#endif\n#endif /* HAVE_AES_CBC */\n    wc_test_ret_t ret = 0;\n\n#ifdef HAVE_AES_CBC\n    /* Test vectors from NIST Special Publication 800-38A, 2001 Edition,\n     * Appendix F.2.5  */\n    WOLFSSL_SMALL_STACK_STATIC const byte msg[] = {\n        0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,\n        0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a\n    };\n\n    WOLFSSL_SMALL_STACK_STATIC const byte verify[] =\n    {\n        0xf5,0x8c,0x4c,0x04,0xd6,0xe5,0xf1,0xba,\n        0x77,0x9e,0xab,0xfb,0x5f,0x7b,0xfb,0xd6\n    };\n#ifdef HAVE_RENESAS_SYNC\n    byte *key =\n                (byte*)guser_PKCbInfo.wrapped_key_aes256;\n    int keySz = (256/8);\n#else\n    WOLFSSL_SMALL_STACK_STATIC const byte key[] = {\n        0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,\n        0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,\n        0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,\n        0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4\n    };\n    int keySz = (int)sizeof(key);\n#endif\n    WOLFSSL_SMALL_STACK_STATIC const byte iv[]  = {\n        0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,\n        0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F\n    };\n    WOLFSSL_ENTER(\"aes256_test\");\n\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\n    enc = wc_AesNew(HEAP_HINT, devId, &ret);\n    if (enc == NULL)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    #ifdef HAVE_AES_DECRYPT\n    dec = wc_AesNew(HEAP_HINT, devId, &ret);\n    if (dec == NULL)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    #endif\n#else\n    XMEMSET(enc, 0, sizeof(Aes));\n    #ifdef HAVE_AES_DECRYPT\n    XMEMSET(dec, 0, sizeof(Aes));\n    #endif\n    ret = wc_AesInit(enc, HEAP_HINT, devId);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    #ifdef HAVE_AES_DECRYPT\n    ret = wc_AesInit(dec, HEAP_HINT, devId);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    #endif\n#endif /* WOLFSSL_SMALL_STACK && !WOLFSSL_NO_MALLOC */\n\n    ret = wc_AesSetKey(enc, key, (word32)keySz, iv, AES_ENCRYPTION);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\n    ret = wc_AesSetKey(dec, key, (word32)keySz, iv, AES_DECRYPTION);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\n\n    XMEMSET(cipher, 0, WC_AES_BLOCK_SIZE);\n    ret = wc_AesCbcEncrypt(enc, cipher, msg, (int) sizeof(msg));\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, &enc->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\n    XMEMSET(plain, 0, WC_AES_BLOCK_SIZE);\n    ret = wc_AesCbcDecrypt(dec, plain, cipher, (int) sizeof(cipher));\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, &dec->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    if (XMEMCMP(plain, msg, (int) sizeof(plain))) {\n        ERROR_OUT(WC_TEST_RET_ENC_NC, out);\n    }\n#endif\n#ifndef HAVE_RENESAS_SYNC\n    if (XMEMCMP(cipher, verify, (int) sizeof(cipher)))\n        ERROR_OUT(WC_TEST_RET_ENC_NC, out);\n#endif\n\n#if defined(DEBUG_VECTOR_REGISTER_ACCESS) && defined(WC_C_DYNAMIC_FALLBACK)\n    ret = wc_AesSetKey(enc, key, keySz, iv, AES_ENCRYPTION);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\n    ret = wc_AesSetKey(dec, key, keySz, iv, AES_DECRYPTION);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\n\n    XMEMSET(cipher, 0, WC_AES_BLOCK_SIZE);\n    WC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(WC_NO_ERR_TRACE(SYSLIB_FAILED_E));\n    ret = wc_AesCbcEncrypt(enc, cipher, msg, (int) sizeof(msg));\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, &enc->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    WC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(0);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\n    XMEMSET(plain, 0, WC_AES_BLOCK_SIZE);\n    WC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(WC_NO_ERR_TRACE(SYSLIB_FAILED_E));\n    ret = wc_AesCbcDecrypt(dec, plain, cipher, (int) sizeof(cipher));\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, &dec->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    WC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(0);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    if (XMEMCMP(plain, msg, (int) sizeof(plain))) {\n        ERROR_OUT(WC_TEST_RET_ENC_NC, out);\n    }\n#endif\n#ifndef HAVE_RENESAS_SYNC\n    if (XMEMCMP(cipher, verify, (int) sizeof(cipher)))\n        ERROR_OUT(WC_TEST_RET_ENC_NC, out);\n#endif\n\n    WC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(WC_NO_ERR_TRACE(SYSLIB_FAILED_E));\n    ret = wc_AesSetKey(enc, key, keySz, iv, AES_ENCRYPTION);\n    WC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(0);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\n    WC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(WC_NO_ERR_TRACE(SYSLIB_FAILED_E));\n    ret = wc_AesSetKey(dec, key, keySz, iv, AES_DECRYPTION);\n    WC_DEBUG_SET_VECTOR_REGISTERS_RETVAL(0);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\n\n    XMEMSET(cipher, 0, WC_AES_BLOCK_SIZE);\n    ret = wc_AesCbcEncrypt(enc, cipher, msg, (int) sizeof(msg));\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, &enc->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\n    XMEMSET(plain, 0, WC_AES_BLOCK_SIZE);\n    ret = wc_AesCbcDecrypt(dec, plain, cipher, (int) sizeof(cipher));\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, &dec->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    if (XMEMCMP(plain, msg, (int) sizeof(plain))) {\n        ERROR_OUT(WC_TEST_RET_ENC_NC, out);\n    }\n#endif\n#ifndef HAVE_RENESAS_SYNC\n    if (XMEMCMP(cipher, verify, (int) sizeof(cipher)))\n        ERROR_OUT(WC_TEST_RET_ENC_NC, out);\n#endif\n\n#endif /* DEBUG_VECTOR_REGISTER_ACCESS && WC_C_DYNAMIC_FALLBACK */\n\n  out:\n\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\n    wc_AesDelete(enc, &enc);\n#else\n    wc_AesFree(enc);\n#endif\n#ifdef HAVE_AES_DECRYPT\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\n    wc_AesDelete(dec, &dec);\n#else\n    wc_AesFree(dec);\n#endif\n#endif\n#endif /* HAVE_AES_CBC */\n\n    return ret;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_110",
        "query_text": "SUMMARY: This function performs file output operations. It accepts a file stream input of type FILE*, a character array of input type const char*, and an unsigned integer of input type word32 that indicates the number of bytes to write. The function attempts to write the specified number of bytes from the given character array to the file stream. If the write operation does not complete successfully (i.e., the number of bytes written does not match the specified unsigned integer), it outputs an error message to the standard error stream and returns an integer of output type int with a value indicating failure; otherwise, it returns an integer indicating success.",
        "code_id": "c_group_2_id_110",
        "code_text": "static int WriteFile(FILE* fp, const char* data, word32 len)\n{\n    int ret = 0;\n\n    /* Write data to file. */\n    if (fwrite(data, 1, len, fp) != len) {\n       /* Not all data was written. */\n       fprintf(stderr, \"Failed to write\\n\");\n       ret = 1;\n    }\n\n    return ret;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_111",
        "query_text": "SUMMARY: This function accepts an integer (int) as input and returns an unsigned integer (word32) as output. It determines and provides a corresponding minimum size value based on the numeric identifier provided. Using a switch-case mechanism, it maps specific integer values (enabled by certain preprocessor definitions) to predetermined size values, and if an unrecognized identifier is given, it returns zero.",
        "code_id": "c_group_2_id_111",
        "code_text": "word32 wc_DhGetNamedKeyMinSize(int name)\n{\n    word32 size;\n\n    switch (name) {\n        #ifdef HAVE_FFDHE_2048\n        case WC_FFDHE_2048:\n            size = 29;\n            break;\n        #endif /* HAVE_FFDHE_2048 */\n        #ifdef HAVE_FFDHE_3072\n        case WC_FFDHE_3072:\n            size = 34;\n            break;\n        #endif /* HAVE_FFDHE_3072 */\n        #ifdef HAVE_FFDHE_4096\n        case WC_FFDHE_4096:\n            size = 39;\n            break;\n        #endif /* HAVE_FFDHE_4096 */\n        #ifdef HAVE_FFDHE_6144\n        case WC_FFDHE_6144:\n            size = 46;\n            break;\n        #endif /* HAVE_FFDHE_6144 */\n        #ifdef HAVE_FFDHE_8192\n        case WC_FFDHE_8192:\n            size = 52;\n            break;\n        #endif /* HAVE_FFDHE_8192 */\n        default:\n            size = 0;\n    }\n\n    return size;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_112",
        "query_text": "SUMMARY: This function accepts three inputs \u2013 an optional pointer to a byte (unsigned char*), an integer representing an initial size, and an integer representing a block size. It calculates the number of padding bytes required to extend the initial size to a multiple of the block size. If the provided byte pointer is not null, it appends padding bytes to the data buffer, with each added byte set to the computed padding value (masked to a single byte). The function returns an integer that represents the new total length after the padding has been applied.",
        "code_id": "c_group_2_id_112",
        "code_text": "static int Pkcs8Pad(byte* buf, int sz, int blockSz)\n{\n    int padSz;\n\n    /* calculate pad size */\n    padSz = blockSz - (sz & (blockSz - 1));\n\n    /* pad with padSz value */\n    if (buf) {\n        int i;\n        for (i = 0; i < padSz; i++) {\n            buf[sz+i] = (byte)(padSz & 0xFF);\n        }\n    }\n\n    /* return adjusted length */\n    return sz + padSz;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_113",
        "query_text": "SUMMARY: This function operates on a modifiable character array and a constant character array. It accepts an array segment defined by an unsigned 32-bit integer offset and length, and searches within that segment for a specific substring represented by a constant character array along with its unsigned 32-bit length. If the substring is found, the function assigns its unsigned 32-bit position into a location provided by an output pointer and returns an integer value 0 indicating success; if not, it returns 1 to indicate failure.",
        "code_id": "c_group_2_id_113",
        "code_text": "static int FindStr(char* haystack, word32 offset, word32 len,\n    const char* needle, word32 needle_len, word32* needle_offset)\n{\n    /* Assume failure. */\n    int ret = 1;\n    word32 i;\n\n    /* Ensure there is enough space for needle. */\n    if (len >= needle_len) {\n        /* Look through haystack starting at offset until not enough space for\n         * needle. */\n        for (i = offset; i <= len - needle_len; i++) {\n            /* Check if needle found. */\n            if ((haystack[i] == needle[0]) &&\n                    (strncmp(haystack + i, needle, needle_len) == 0)) {\n                /* Return offset at which needle found. */\n                *needle_offset = i;\n                /* Return success. */\n                ret = 0;\n                /* Stop looking. */\n                break;\n            }\n        }\n    }\n\n    return ret;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_114",
        "query_text": "SUMMARY: This function accepts two inputs of type word32 (unsigned integers) and returns an int. It evaluates whether the provided modulus length meets predefined criteria based on its value and, in conjunction, checks if the accompanying divisor length corresponds to an allowed value. Specifically, for a modulus length equal to 1024, it verifies that the divisor length is 160; for a modulus length equal to 2048, it accepts divisor lengths of either 224 or 256. If a valid pairing is found, the function returns 0; otherwise, it returns -1.",
        "code_id": "c_group_2_id_114",
        "code_text": "static int CheckDhLN(word32 modLen, word32 divLen)\n{\n    int ret = -1;\n\n    switch (modLen) {\n        /* FA */\n        case 1024:\n            if (divLen == 160)\n                ret = 0;\n            break;\n        /* FB, FC */\n        case 2048:\n            if (divLen == 224 || divLen == 256)\n                ret = 0;\n            break;\n        default:\n            break;\n    }\n\n    return ret;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_115",
        "query_text": "SUMMARY: This function performs a self-test of AES encryption (and, if enabled, decryption) in cipher block chaining (CBC) mode using predetermined test vectors. It has no input parameters (void) and returns a 32\u2010bit integer status code (wc_test_ret_t, defined as int). Internally, it initializes AES context structures (either allocated on the heap or on the stack, depending on compile-time flags), sets up encryption (and decryption) keys along with an initialization vector, processes a fixed message by encrypting it, and verifies that the resulting ciphertext matches an expected value. Where decryption is enabled, it decrypts the ciphertext back to plaintext and confirms that it matches the original message. The function cleans up the AES contexts and returns a status code to indicate success or failure of the test.",
        "code_id": "c_group_2_id_115",
        "code_text": "wc_test_ret_t aes192_test(void)\n{\n    wc_test_ret_t ret = 0;\n#ifdef HAVE_AES_CBC\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\n    Aes *enc = NULL;\n#else\n    Aes enc[1];\n#endif\n    byte cipher[WC_AES_BLOCK_SIZE];\n#ifdef HAVE_AES_DECRYPT\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\n    Aes *dec = NULL;\n#else\n    Aes dec[1];\n#endif\n    byte plain[WC_AES_BLOCK_SIZE];\n#endif\n\n    /* Test vectors from NIST Special Publication 800-38A, 2001 Edition\n     * Appendix F.2.3  */\n\n    WOLFSSL_SMALL_STACK_STATIC const byte msg[] = {\n        0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,\n        0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a\n    };\n\n    WOLFSSL_SMALL_STACK_STATIC const byte verify[] =\n    {\n        0x4f,0x02,0x1d,0xb2,0x43,0xbc,0x63,0x3d,\n        0x71,0x78,0x18,0x3a,0x9f,0xa0,0x71,0xe8\n    };\n\n    WOLFSSL_SMALL_STACK_STATIC const byte key[] = {\n        0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52,\n        0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5,\n        0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b\n    };\n    WOLFSSL_SMALL_STACK_STATIC const byte iv[]  = {\n        0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,\n        0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F\n    };\n    WOLFSSL_ENTER(\"aes192_test\");\n\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\n    enc = wc_AesNew(HEAP_HINT, devId, &ret);\n    if (enc == NULL)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    #ifdef HAVE_AES_DECRYPT\n    dec = wc_AesNew(HEAP_HINT, devId, &ret);\n    if (dec == NULL)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    #endif\n#else\n    XMEMSET(enc, 0, sizeof(Aes));\n    #ifdef HAVE_AES_DECRYPT\n    XMEMSET(dec, 0, sizeof(Aes));\n    #endif\n    ret = wc_AesInit(enc, HEAP_HINT, devId);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    #ifdef HAVE_AES_DECRYPT\n    ret = wc_AesInit(dec, HEAP_HINT, devId);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    #endif\n#endif /* WOLFSSL_SMALL_STACK && !WOLFSSL_NO_MALLOC */\n\n    ret = wc_AesSetKey(enc, key, (int) sizeof(key), iv, AES_ENCRYPTION);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#ifdef HAVE_AES_DECRYPT\n    ret = wc_AesSetKey(dec, key, (int) sizeof(key), iv, AES_DECRYPTION);\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n#endif\n\n    XMEMSET(cipher, 0, WC_AES_BLOCK_SIZE);\n    ret = wc_AesCbcEncrypt(enc, cipher, msg, (int) sizeof(msg));\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, &enc->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    if (XMEMCMP(cipher, verify, (int) sizeof(cipher)))\n        ERROR_OUT(WC_TEST_RET_ENC_NC, out);\n\n#ifdef HAVE_AES_DECRYPT\n    XMEMSET(plain, 0, WC_AES_BLOCK_SIZE);\n    ret = wc_AesCbcDecrypt(dec, plain, cipher, (int) sizeof(cipher));\n#if defined(WOLFSSL_ASYNC_CRYPT)\n    ret = wc_AsyncWait(ret, &dec->asyncDev, WC_ASYNC_FLAG_NONE);\n#endif\n    if (ret != 0)\n        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);\n    if (XMEMCMP(plain, msg, (int) sizeof(plain))) {\n        WOLFSSL_MSG(\"failed wc_AesCbcDecrypt plain-msg compare\");\n        ERROR_OUT(WC_TEST_RET_ENC_NC, out);\n    }\n#endif\n\n  out:\n\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\n    wc_AesDelete(enc, &enc);\n#else\n    wc_AesFree(enc);\n#endif\n#ifdef HAVE_AES_DECRYPT\n#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)\n    wc_AesDelete(dec, &dec);\n#else\n    wc_AesFree(dec);\n#endif\n#endif\n#endif /* HAVE_AES_CBC */\n\n    return ret;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_116",
        "query_text": "SUMMARY: This function accepts an input of type int32_t representing a Unicode code point and returns an int32_t output representing its lowercase equivalent. It evaluates the input against multiple code point ranges corresponding to uppercase letters and, based on the range, applies specific arithmetic or bitwise transformations to convert the uppercase code point to its lowercase form. For inputs that do not fall within these typical ranges, it handles several exceptional cases using an explicit mapping to produce the appropriate lowercase value.",
        "code_id": "c_group_2_id_116",
        "code_text": "utf8_int32_t utf8lwrcodepoint(utf8_int32_t cp)\n{\n    if (((0x0041 <= cp) && (0x005a >= cp)) ||\n        ((0x00c0 <= cp) && (0x00d6 >= cp)) ||\n        ((0x00d8 <= cp) && (0x00de >= cp)) ||\n        ((0x0391 <= cp) && (0x03a1 >= cp)) ||\n        ((0x03a3 <= cp) && (0x03ab >= cp))) {\n        cp += 32;\n    } else if (((0x0100 <= cp) && (0x012f >= cp)) ||\n               ((0x0132 <= cp) && (0x0137 >= cp)) ||\n               ((0x014a <= cp) && (0x0177 >= cp)) ||\n               ((0x0182 <= cp) && (0x0185 >= cp)) ||\n               ((0x01a0 <= cp) && (0x01a5 >= cp)) ||\n               ((0x01de <= cp) && (0x01ef >= cp)) ||\n               ((0x01f8 <= cp) && (0x021f >= cp)) ||\n               ((0x0222 <= cp) && (0x0233 >= cp)) ||\n               ((0x0246 <= cp) && (0x024f >= cp)) ||\n               ((0x03d8 <= cp) && (0x03ef >= cp))) {\n        cp |= 0x1;\n    } else if (((0x0139 <= cp) && (0x0148 >= cp)) ||\n               ((0x0179 <= cp) && (0x017e >= cp)) ||\n               ((0x01af <= cp) && (0x01b0 >= cp)) ||\n               ((0x01b3 <= cp) && (0x01b6 >= cp)) ||\n               ((0x01cd <= cp) && (0x01dc >= cp))) {\n        cp += 1;\n        cp &= ~0x1;\n    } else {\n        switch (cp) {\n            default: break;\n            case 0x0178: cp = 0x00ff; break;\n            case 0x0243: cp = 0x0180; break;\n            case 0x018e: cp = 0x01dd; break;\n            case 0x023d: cp = 0x019a; break;\n            case 0x0220: cp = 0x019e; break;\n            case 0x01b7: cp = 0x0292; break;\n            case 0x01c4: cp = 0x01c6; break;\n            case 0x01c7: cp = 0x01c9; break;\n            case 0x01ca: cp = 0x01cc; break;\n            case 0x01f1: cp = 0x01f3; break;\n            case 0x01f7: cp = 0x01bf; break;\n            case 0x0187: cp = 0x0188; break;\n            case 0x018b: cp = 0x018c; break;\n            case 0x0191: cp = 0x0192; break;\n            case 0x0198: cp = 0x0199; break;\n            case 0x01a7: cp = 0x01a8; break;\n            case 0x01ac: cp = 0x01ad; break;\n            case 0x01af: cp = 0x01b0; break;\n            case 0x01b8: cp = 0x01b9; break;\n            case 0x01bc: cp = 0x01bd; break;\n            case 0x01f4: cp = 0x01f5; break;\n            case 0x023b: cp = 0x023c; break;\n            case 0x0241: cp = 0x0242; break;\n            case 0x03fd: cp = 0x037b; break;\n            case 0x03fe: cp = 0x037c; break;\n            case 0x03ff: cp = 0x037d; break;\n            case 0x037f: cp = 0x03f3; break;\n            case 0x0386: cp = 0x03ac; break;\n            case 0x0388: cp = 0x03ad; break;\n            case 0x0389: cp = 0x03ae; break;\n            case 0x038a: cp = 0x03af; break;\n            case 0x038c: cp = 0x03cc; break;\n            case 0x038e: cp = 0x03cd; break;\n            case 0x038f: cp = 0x03ce; break;\n            case 0x0370: cp = 0x0371; break;\n            case 0x0372: cp = 0x0373; break;\n            case 0x0376: cp = 0x0377; break;\n            case 0x03f4: cp = 0x03d1; break;\n            case 0x03cf: cp = 0x03d7; break;\n            case 0x03f9: cp = 0x03f2; break;\n            case 0x03f7: cp = 0x03f8; break;\n            case 0x03fa: cp = 0x03fb; break;\n        };\n    }\n\n    return cp;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_117",
        "query_text": "SUMMARY: This function accepts a 32-bit signed integer (utf8_int32_t) representing a Unicode code point and returns another 32-bit signed integer (utf8_int32_t) corresponding to its uppercase equivalent. It determines whether the input is within particular ranges that follow systematic uppercase transformations\u2014either by subtracting a constant value or by altering specific bits\u2014to perform the conversion efficiently. If the input does not fall into these ranges, the function applies an explicit mapping via a switch statement to convert individual code points to their uppercase forms.",
        "code_id": "c_group_2_id_117",
        "code_text": "utf8_int32_t utf8uprcodepoint(utf8_int32_t cp)\n{\n    if (((0x0061 <= cp) && (0x007a >= cp)) ||\n        ((0x00e0 <= cp) && (0x00f6 >= cp)) ||\n        ((0x00f8 <= cp) && (0x00fe >= cp)) ||\n        ((0x03b1 <= cp) && (0x03c1 >= cp)) ||\n        ((0x03c3 <= cp) && (0x03cb >= cp))) {\n        cp -= 32;\n    } else if (((0x0100 <= cp) && (0x012f >= cp)) ||\n               ((0x0132 <= cp) && (0x0137 >= cp)) ||\n               ((0x014a <= cp) && (0x0177 >= cp)) ||\n               ((0x0182 <= cp) && (0x0185 >= cp)) ||\n               ((0x01a0 <= cp) && (0x01a5 >= cp)) ||\n               ((0x01de <= cp) && (0x01ef >= cp)) ||\n               ((0x01f8 <= cp) && (0x021f >= cp)) ||\n               ((0x0222 <= cp) && (0x0233 >= cp)) ||\n               ((0x0246 <= cp) && (0x024f >= cp)) ||\n               ((0x03d8 <= cp) && (0x03ef >= cp))) {\n        cp &= ~0x1;\n    } else if (((0x0139 <= cp) && (0x0148 >= cp)) ||\n               ((0x0179 <= cp) && (0x017e >= cp)) ||\n               ((0x01af <= cp) && (0x01b0 >= cp)) ||\n               ((0x01b3 <= cp) && (0x01b6 >= cp)) ||\n               ((0x01cd <= cp) && (0x01dc >= cp))) {\n        cp -= 1;\n        cp |= 0x1;\n    } else {\n        switch (cp) {\n            default: break;\n            case 0x00ff: cp = 0x0178; break;\n            case 0x0180: cp = 0x0243; break;\n            case 0x01dd: cp = 0x018e; break;\n            case 0x019a: cp = 0x023d; break;\n            case 0x019e: cp = 0x0220; break;\n            case 0x0292: cp = 0x01b7; break;\n            case 0x01c6: cp = 0x01c4; break;\n            case 0x01c9: cp = 0x01c7; break;\n            case 0x01cc: cp = 0x01ca; break;\n            case 0x01f3: cp = 0x01f1; break;\n            case 0x01bf: cp = 0x01f7; break;\n            case 0x0188: cp = 0x0187; break;\n            case 0x018c: cp = 0x018b; break;\n            case 0x0192: cp = 0x0191; break;\n            case 0x0199: cp = 0x0198; break;\n            case 0x01a8: cp = 0x01a7; break;\n            case 0x01ad: cp = 0x01ac; break;\n            case 0x01b0: cp = 0x01af; break;\n            case 0x01b9: cp = 0x01b8; break;\n            case 0x01bd: cp = 0x01bc; break;\n            case 0x01f5: cp = 0x01f4; break;\n            case 0x023c: cp = 0x023b; break;\n            case 0x0242: cp = 0x0241; break;\n            case 0x037b: cp = 0x03fd; break;\n            case 0x037c: cp = 0x03fe; break;\n            case 0x037d: cp = 0x03ff; break;\n            case 0x03f3: cp = 0x037f; break;\n            case 0x03ac: cp = 0x0386; break;\n            case 0x03ad: cp = 0x0388; break;\n            case 0x03ae: cp = 0x0389; break;\n            case 0x03af: cp = 0x038a; break;\n            case 0x03cc: cp = 0x038c; break;\n            case 0x03cd: cp = 0x038e; break;\n            case 0x03ce: cp = 0x038f; break;\n            case 0x0371: cp = 0x0370; break;\n            case 0x0373: cp = 0x0372; break;\n            case 0x0377: cp = 0x0376; break;\n            case 0x03d1: cp = 0x03f4; break;\n            case 0x03d7: cp = 0x03cf; break;\n            case 0x03f2: cp = 0x03f9; break;\n            case 0x03f8: cp = 0x03f7; break;\n            case 0x03fb: cp = 0x03fa; break;\n        };\n    }\n\n    return cp;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_118",
        "query_text": "SUMMARY: This function accepts three inputs\u2014a pointer to a conversion context structure (of type f_conv_context_t), a pointer to a constant character array (const char*), and a size value (size_t). It verifies that the accessible buffer space in the conversion context is sufficient (when allowing space for a trailing null character) to hold the specified number of characters. If the available space is insufficient, it returns an integer error code (-1). Otherwise, it copies the specified number of characters from the provided character array into the buffer within the conversion context, advances the buffer pointer accordingly, and reduces the remaining available space by that length. It then appends a null terminator to mark the end of the string and returns the number of characters copied as an integer.",
        "code_id": "c_group_2_id_118",
        "code_text": "int ft_nprint(f_conv_context_t *cntx, const char *str, size_t strlen)\n{\n    if (cntx->raw_avail + 1/* for 0 */ < strlen)\n        return -1;\n\n    memcpy(cntx->u.buf, str, strlen);\n    cntx->u.buf += strlen;\n    cntx->raw_avail -= strlen;\n    *cntx->u.buf = '\\0'; /* Do we need this ? */\n    return strlen;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_119",
        "query_text": "SUMMARY: This function accepts an input of type pointer to f_string_buffer_t and returns an output of type void*. It first verifies that the provided pointer is not NULL and then retrieves and returns the underlying data from the structure's union field.",
        "code_id": "c_group_2_id_119",
        "code_text": "void *buffer_get_data(f_string_buffer_t *buffer)\n{\n    assert(buffer);\n    return buffer->str.data;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_120",
        "query_text": "SUMMARY: This function takes as input a constant pointer to a structure of type f_string_buffer_t and returns a size_t value. Its main functionality is to retrieve and output the raw capacity information stored within the structure without performing any additional computations.",
        "code_id": "c_group_2_id_120",
        "code_text": "size_t string_buffer_raw_capacity(const f_string_buffer_t *buffer)\n{\n    return buffer->data_sz;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_121",
        "query_text": "SUMMARY: This function accepts a constant pointer to a f_string_buffer_t structure and returns a size_t value. It verifies the validity of the input pointer and then determines a width capacity based on the contained string type. For a character buffer, it returns the total data size directly; for a wide-character buffer, it returns the data size divided by the size of a wide character; and for a UTF8 buffer, it returns the data size divided by 4. If an unsupported type is encountered, the function triggers a runtime assertion failure.",
        "code_id": "c_group_2_id_121",
        "code_text": "size_t string_buffer_width_capacity(const f_string_buffer_t *buffer)\n{\n    assert(buffer);\n    switch (buffer->type) {\n        case CHAR_BUF:\n            return buffer->data_sz;\n#ifdef FT_HAVE_WCHAR\n        case W_CHAR_BUF:\n            return buffer->data_sz / sizeof(wchar_t);\n#endif\n#ifdef FT_HAVE_UTF8\n        case UTF8_BUF:\n            return buffer->data_sz / 4;\n#endif\n        default:\n            assert(0);\n            return 0;\n    }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_122",
        "query_text": "SUMMARY: This function accepts as inputs a pointer to a conversion context structure (f_conv_context_t*), a pointer to a constant wide-character string (const wchar_t*), and a size value (size_t) representing the length of the string. Its output is an integer (int). The function begins by verifying that the available capacity in the context is sufficient to accommodate the input string (plus a terminating null wide-character). If the capacity is insufficient, it returns -1. Otherwise, it calculates the byte length required for the string (as the product of its length and the size of a wide character), copies that many bytes from the input wide-character string to the buffer described in the context, advances the internal buffer pointer by the number of bytes copied, and reduces the available capacity accordingly. Finally, it appends a terminating wide-character null to the buffer and returns the original length.",
        "code_id": "c_group_2_id_122",
        "code_text": "int ft_nwprint(f_conv_context_t *cntx, const wchar_t *str, size_t strlen)\n{\n    if (cntx->raw_avail + 1/* for 0 */ < strlen)\n        return -1;\n\n    size_t raw_len = strlen * sizeof(wchar_t);\n\n    memcpy(cntx->u.buf, str, raw_len);\n    cntx->u.buf += raw_len;\n    cntx->raw_avail -= raw_len;\n\n    /* Do we need this ? */\n    wchar_t end_of_string = L'\\0';\n    memcpy(cntx->u.buf, &end_of_string, sizeof(wchar_t));\n    return strlen;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_123",
        "query_text": "SUMMARY: This function accepts an integer of type utf8_int32_t (an alias for int32_t) and returns a value of type size_t. Its purpose is to determine the number of bytes required to represent a UTF-8 encoded code point. It does so by examining the bit-pattern of the provided code point and deciding whether it fits within 1, 2, 3, or 4 bytes based on predefined bit-mask thresholds.",
        "code_id": "c_group_2_id_123",
        "code_text": "size_t utf8codepointsize(utf8_int32_t chr)\n{\n    if (0 == ((utf8_int32_t)0xffffff80 & chr)) {\n        return 1;\n    } else if (0 == ((utf8_int32_t)0xfffff800 & chr)) {\n        return 2;\n    } else if (0 == ((utf8_int32_t)0xffff0000 & chr)) {\n        return 3;\n    } else { // if (0 == ((int)0xffe00000 & chr)) {\n        return 4;\n    }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_124",
        "query_text": "SUMMARY: This function accepts an input variable of type f_string_buffer_t* and returns an int. It first validates that the input pointer and the embedded data pointer (of type void* inside a union) are not null. Then, based on the input\u2019s enum type value (of type enum f_string_type), it checks whether the data pointer is properly aligned when necessary. Specifically, for the wide character buffer type (when available), it verifies that the pointer's address is aligned to the size of a wide character; for the standard and UTF8 character buffer types, it simply returns a positive result.",
        "code_id": "c_group_2_id_124",
        "code_text": "int buffer_check_align(f_string_buffer_t *buffer)\n{\n    assert(buffer);\n    assert(buffer->str.data);\n\n    switch (buffer->type) {\n        case CHAR_BUF:\n            return 1;\n#ifdef FT_HAVE_WCHAR\n        case W_CHAR_BUF:\n            return (((uintptr_t)buffer->str.data) & (sizeof(wchar_t) - 1)) == 0;\n#endif\n#ifdef FT_HAVE_UTF8\n        case UTF8_BUF:\n            return 1;\n#endif\n        default:\n            assert(0);\n            return 0;\n    }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_125",
        "query_text": "SUMMARY: The function accepts three inputs\u2014a pointer to a conversion context structure (f_conv_context_t *), and two constant void pointers representing the start and end of a raw byte sequence. It computes the length of this sequence and, after verifying that the available space (inclusive of an extra byte for termination) in the context\u2019s internal character buffer is sufficient, copies the raw byte sequence into that buffer, updates the buffer\u2019s pointer and remaining available space, appends a null terminator at the new end, and returns the number of bytes copied as an integer. If there is insufficient space, it returns -1.",
        "code_id": "c_group_2_id_125",
        "code_text": "int ft_nu8print(f_conv_context_t *cntx, const void *beg, const void *end)\n{\n    const char *bc = (const char *)beg;\n    const char *ec = (const char *)end;\n    size_t raw_len = ec - bc;\n    if (cntx->raw_avail + 1 < raw_len)\n        return -1;\n\n    memcpy(cntx->u.buf, beg, raw_len);\n    cntx->u.buf += raw_len;\n    cntx->raw_avail -= raw_len;\n    *(cntx->u.buf) = '\\0'; /* Do we need this ? */\n    return raw_len; /* what return here ? */\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_126",
        "query_text": "SUMMARY: This function takes an input of type utf8_int32_t (a 32-bit integer) representing a Unicode code point and returns an integer indicating the display width. It first checks whether the code point is zero and returns 0 in that case. If the code point is less than a specified threshold (0x1100), it returns 1. It then examines whether the code point falls within specific ranges for fullwidth characters\u2014returning 2 if so\u2014and likewise tests a number of ranges commonly associated with wide characters, also returning 2 for matches. If none of these conditions apply, it defaults to returning 1.",
        "code_id": "c_group_2_id_126",
        "code_text": "int utf8cwidth(utf8_int32_t c)\n{\n    // TODO: add non printable characters check\n    if (c == 0)\n        return 0;\n\n    if (c < 0x1100)\n        return 1;\n\n    // Fullwidth\n    if ((0x3000 == c) ||\n        (0xFF01 <= c && c <= 0xFF60) ||\n        (0xFFE0 <= c && c <= 0xFFE6)) {\n        return 2;\n    }\n\n    // Wide\n    if ((0x1100 <= c && c <= 0x115F) ||\n        (0x11A3 <= c && c <= 0x11A7) ||\n        (0x11FA <= c && c <= 0x11FF) ||\n        (0x2329 <= c && c <= 0x232A) ||\n        (0x2E80 <= c && c <= 0x2E99) ||\n        (0x2E9B <= c && c <= 0x2EF3) ||\n        (0x2F00 <= c && c <= 0x2FD5) ||\n        (0x2FF0 <= c && c <= 0x2FFB) ||\n        (0x3001 <= c && c <= 0x303E) ||\n        (0x3041 <= c && c <= 0x3096) ||\n        (0x3099 <= c && c <= 0x30FF) ||\n        (0x3105 <= c && c <= 0x312D) ||\n        (0x3131 <= c && c <= 0x318E) ||\n        (0x3190 <= c && c <= 0x31BA) ||\n        (0x31C0 <= c && c <= 0x31E3) ||\n        (0x31F0 <= c && c <= 0x321E) ||\n        (0x3220 <= c && c <= 0x3247) ||\n        (0x3250 <= c && c <= 0x32FE) ||\n        (0x3300 <= c && c <= 0x4DBF) ||\n        (0x4E00 <= c && c <= 0xA48C) ||\n        (0xA490 <= c && c <= 0xA4C6) ||\n        (0xA960 <= c && c <= 0xA97C) ||\n        (0xAC00 <= c && c <= 0xD7A3) ||\n        (0xD7B0 <= c && c <= 0xD7C6) ||\n        (0xD7CB <= c && c <= 0xD7FB) ||\n        (0xF900 <= c && c <= 0xFAFF) ||\n        (0xFE10 <= c && c <= 0xFE19) ||\n        (0xFE30 <= c && c <= 0xFE52) ||\n        (0xFE54 <= c && c <= 0xFE66) ||\n        (0xFE68 <= c && c <= 0xFE6B) ||\n        (0x1B000 <= c && c <= 0x1B001) ||\n        (0x1F200 <= c && c <= 0x1F202) ||\n        (0x1F210 <= c && c <= 0x1F23A) ||\n        (0x1F240 <= c && c <= 0x1F248) ||\n        (0x1F250 <= c && c <= 0x1F251) ||\n        (0x20000 <= c && c <= 0x2F73F) ||\n        (0x2B740 <= c && c <= 0x2FFFD) ||\n        (0x30000 <= c && c <= 0x3FFFD)) {\n        return 2;\n    }\n\n    return 1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_127",
        "query_text": "SUMMARY: This function accepts a pointer to a structure (of type CC_Rbuf, defined as ring_buffer) and returns a boolean value. Its purpose is to determine whether the ring buffer is empty by checking if the size field within the structure is zero, returning true when empty and false when not.",
        "code_id": "c_group_2_id_127",
        "code_text": "bool cc_rbuf_is_empty(CC_Rbuf *rbuf)\n{\n    return (rbuf->size == 0);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_128",
        "query_text": "SUMMARY: This function accepts two inputs: a pointer to a structure (of type CC_Rbuf*) that represents a ring buffer, and an integer that specifies an index. It returns a value of type uint64_t by directly accessing the element located at the provided index within the internal buffer array of the structure.",
        "code_id": "c_group_2_id_128",
        "code_text": "uint64_t cc_rbuf_peek(CC_Rbuf *rbuf, int index)\n{\n    return rbuf->buf[index];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_129",
        "query_text": "SUMMARY: The function accepts a pointer to a ring-buffer structure (of type CC_Rbuf*) and returns an unsigned integer (of type size_t) representing the current size value stored within the structure.",
        "code_id": "c_group_2_id_129",
        "code_text": "size_t cc_rbuf_size(CC_Rbuf *rbuf)\n{\n    return rbuf->size;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_130",
        "query_text": "SUMMARY: This function takes as input a pointer to a structure (of type CC_RbufConf) and initializes its members. It sets a capacity field to a default value (of type size_t) and assigns three function pointer fields to standard dynamic memory allocation functions (of types that take size_t parameters and return void pointers, or take void pointers respectively). The function returns no value (void).",
        "code_id": "c_group_2_id_130",
        "code_text": "void cc_rbuf_conf_init(CC_RbufConf *rconf)\n{\n    rconf->capacity = DEFAULT_CC_RBUF_CAPACITY;\n    rconf->mem_alloc = malloc;\n    rconf->mem_calloc = calloc;\n    rconf->mem_free = free;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_131",
        "query_text": "SUMMARY: The function accepts two inputs\u2014a pointer to a structure representing a ring buffer (CC_Rbuf) and a 64-bit unsigned integer (uint64_t). It enqueues the provided 64-bit value into the ring buffer by storing the value at the current head position, advancing the head pointer circularly within the buffer's capacity, and, if necessary, incrementing the tail position to maintain the proper data ordering when the buffer is full. Additionally, it updates the current element count of the ring buffer (without exceeding its capacity). The function does not produce any output (void).",
        "code_id": "c_group_2_id_131",
        "code_text": "void cc_rbuf_enqueue(CC_Rbuf *rbuf, uint64_t item)\n{\n    if (rbuf->head == rbuf->tail)\n        rbuf->tail = (rbuf->tail + 1) % rbuf->capacity;\n\n    rbuf->buf[rbuf->head] = item;\n\n    rbuf->head = (rbuf->head + 1) % rbuf->capacity;\n\n    if (rbuf->size < rbuf->capacity)\n        ++rbuf->size;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_132",
        "query_text": "SUMMARY: The function accepts a pointer to a CC_Rbuf structure (i.e., an object of type struct ring_buffer) as its input and returns nothing (void). It frees the memory resources associated with the ring buffer by first invoking the memory deallocation callback to release the buffer (an array of uint64_t) and then calling the same deallocation function to release the ring buffer structure itself.",
        "code_id": "c_group_2_id_132",
        "code_text": "void cc_rbuf_destroy(CC_Rbuf *rbuf)\n{\n    rbuf->mem_free(rbuf->buf);\n    rbuf->mem_free(rbuf);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_133",
        "query_text": "SUMMARY: The function accepts two inputs of type \"const void *\" that refer to objects of type \"struct Point\" (with integer fields for coordinates) and returns an \"int\". It compares the two provided Point objects by evaluating whether both of their corresponding coordinate values are equal. If both coordinates in each Point match, the function outputs 0; otherwise, it outputs 1.",
        "code_id": "c_group_2_id_133",
        "code_text": "int point_compare(const void *key1, const void *key2)\n{\n    struct Point p1 = *((struct Point*) key1);\n    struct Point p2 = *((struct Point*) key2);\n    return !(p1.x == p2.x && p1.y == p2.y);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_134",
        "query_text": "SUMMARY: This function accepts three inputs: a reference to an output stream (std::ostream&), a pointer to an encoding function (EncodingFn, defined as void(*)(std::ostream&, int)), and an integer representing a Unicode code point (int). It determines whether the integer exceeds or equals 0x10000. If it does, the function computes two surrogate code unit values corresponding to the high and low parts of the UTF-16 representation of the Unicode code point, calls the encoding function to output these two surrogate integers to the provided output stream, and returns a boolean true. If the integer is below 0x10000, it returns false without processing further.",
        "code_id": "c_group_2_id_134",
        "code_text": "bool SplitUtf16HighChar(std::ostream& stream, EncodingFn encoding, int ch) {\n  int biasedValue = ch - 0x10000;\n  if (biasedValue < 0) {\n    return false;\n  }\n  int high = 0xD800 | (biasedValue >> 10);\n  int low = 0xDC00 | (biasedValue & 0x3FF);\n  encoding(stream, high);\n  encoding(stream, low);\n  return true;\n};\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_135",
        "query_text": "SUMMARY: This function takes a 3-element floating-point vector (vec3) representing Euler angles and computes a 4-element floating-point vector (versor) representing a quaternion. It calculates the half-angle sine and cosine values for each of the Euler angles\u2014negating the sine for the third angle to account for a left-handed coordinate system\u2014and then combines these trigonometric results to derive the quaternion components.",
        "code_id": "c_group_2_id_135",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_zxy_quat_lh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs =  sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys =  sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = -sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] = zc * xs * yc - zs * xc * ys;\n  dest[1] = zc * xc * ys + zs * xs * yc;\n  dest[2] = zc * xs * ys + zs * xc * yc;\n  dest[3] = zc * xc * yc - zs * xs * ys;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_136",
        "query_text": "SUMMARY: This function takes as input a three-element array of floats (vec3) that represent Euler angles and computes a four-element array of floats (versor) representing a quaternion. It converts the Euler angle representation into a quaternion form by calculating the sine and cosine of half-angles for rotations about the three axes in an XYZ order under a left-handed coordinate system, thus encapsulating the 3D rotation in a concise quaternion format.",
        "code_id": "c_group_2_id_136",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_xyz_quat_lh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs =  sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys =  sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = -sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] = xc * ys * zs + xs * yc * zc;\n  dest[1] = xc * ys * zc - xs * yc * zs;\n  dest[2] = xc * yc * zs + xs * ys * zc;\n  dest[3] = xc * yc * zc - xs * ys * zs;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_137",
        "query_text": "SUMMARY: This function transposes a matrix. It accepts an input of type mat4x2 (an array of 4 two-element float arrays representing a 4\u00d72 matrix) and produces an output of type mat2x4 (an array of 2 four-element float arrays representing a 2\u00d74 matrix). The function reorganizes the elements so that the elements of the first column of the input become the elements of the first row of the output, while the elements of the second column become the elements of the second row, thereby interchanging rows and columns.",
        "code_id": "c_group_2_id_137",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x2_transpose(mat4x2 m, mat2x4 dest) {\n  dest[0][0] = m[0][0];\n  dest[0][1] = m[1][0];\n  dest[0][2] = m[2][0];\n  dest[0][3] = m[3][0];\n  dest[1][0] = m[0][1];\n  dest[1][1] = m[1][1];\n  dest[1][2] = m[2][1];\n  dest[1][3] = m[3][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_138",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of type vec4 (a 4-element aligned array of floats). It performs an element-wise operation where it adds the corresponding values from the two input arrays and subtracts the result from the corresponding values in the output array, updating the output parameter with the computed differences.",
        "code_id": "c_group_2_id_138",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_addsub(vec4 a, vec4 b, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_sub(\n          glmm_load(dest),\n          wasm_f32x4_add(glmm_load(a), glmm_load(b))));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_sub_ps(glmm_load(dest),\n                              _mm_add_ps(glmm_load(a),\n                                         glmm_load(b))));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vsubq_f32(vld1q_f32(dest),\n                            vaddq_f32(vld1q_f32(a),\n                                      vld1q_f32(b))));\n#else\n  dest[0] -= a[0] + b[0];\n  dest[1] -= a[1] + b[1];\n  dest[2] -= a[2] + b[2];\n  dest[3] -= a[3] + b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_139",
        "query_text": "SUMMARY: This function receives a 3-element array of floats as input and produces a 3-element array of floats as output. It computes the additive inverse of each element in the input array and stores the results in the output array.",
        "code_id": "c_group_2_id_139",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_negate_to(vec3 v, vec3 dest) {\n  dest[0] = -v[0];\n  dest[1] = -v[1];\n  dest[2] = -v[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_140",
        "query_text": "SUMMARY: This function takes a constant pointer to a float (input type: const float *) and a 2x2 float matrix (output type: mat2, defined as an array of two vec2 where vec2 is an array of 2 floats) as parameters. It constructs the 2x2 matrix by sequentially copying four float values from the input array into the matrix, placing the first two floats into the first row and the next two floats into the second row.",
        "code_id": "c_group_2_id_140",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2_make(const float * __restrict src, mat2 dest) {\n  dest[0][0] = src[0];\n  dest[0][1] = src[1];\n  dest[1][0] = src[2];\n  dest[1][1] = src[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_141",
        "query_text": "SUMMARY: The function takes two input parameters, each being a fixed-size array of 2 integers, and returns an integer. It computes a scalar value by multiplying the first element of the first input with the second element of the second input, then subtracting the product of the second element of the first input with the first element of the second input. This operation effectively calculates the determinant of a 2\u00d72 matrix formed by the input arrays.",
        "code_id": "c_group_2_id_141",
        "code_text": "CGLM_INLINE\nint\nglm_ivec2_cross(ivec2 a, ivec2 b) {\n  return a[0] * b[1] - a[1] * b[0];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_142",
        "query_text": "SUMMARY: This function takes three parameters of type vec4 (each being a 4-element aligned array of floats). It computes the element-wise difference between the first two 4-element float arrays and then adds that difference to the elements of the third 4-element float array, effectively updating it so that for each index the new value becomes the original value plus the difference between the corresponding elements of the first and second arrays. Optimized implementations are used when available, but the core behavior is to perform dest[i] = dest[i] + (a[i] - b[i]) for all indices.",
        "code_id": "c_group_2_id_142",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_subadd(vec4 a, vec4 b, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_add(\n          glmm_load(dest),\n          wasm_f32x4_sub(glmm_load(a), glmm_load(b))));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_add_ps(glmm_load(dest),\n                              _mm_sub_ps(glmm_load(a),\n                                         glmm_load(b))));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),\n                            vsubq_f32(vld1q_f32(a),\n                                      vld1q_f32(b))));\n#else\n  dest[0] += a[0] - b[0];\n  dest[1] += a[1] - b[1];\n  dest[2] += a[2] - b[2];\n  dest[3] += a[3] - b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_143",
        "query_text": "SUMMARY: This function performs component-wise multiplication of two 4-dimensional floating-point vectors. It accepts two inputs of type vec4 (an aligned array of four floats) and produces an output of the same type (vec4) by calculating the product of corresponding elements from the inputs. The function utilizes the available SIMD instruction set on the target platform (such as WebAssembly SIMD, SSE, or NEON) to efficiently compute these multiplications, and it defaults to scalar operations when SIMD is not available.",
        "code_id": "c_group_2_id_143",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_mul(vec4 a, vec4 b, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_mul(glmm_load(a), glmm_load(b)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_mul_ps(glmm_load(a), glmm_load(b)));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vmulq_f32(vld1q_f32(a), vld1q_f32(b)));\n#else\n  dest[0] = a[0] * b[0];\n  dest[1] = a[1] * b[1];\n  dest[2] = a[2] * b[2];\n  dest[3] = a[3] * b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_144",
        "query_text": "SUMMARY: The function takes an input of type \"vec2\" (a two-element array of float values) and produces no explicit output but modifies the input in-place by setting both elements to 0.0f, effectively zeroing the 2D vector.",
        "code_id": "c_group_2_id_144",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_zero(vec2 v) {\n  v[0] = v[1] = 0.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_145",
        "query_text": "SUMMARY: This function takes two input parameters and one output parameter, all of which are arrays consisting of three integers (ivec3). It performs element-wise division of the first integer array by the second integer array and stores the resulting quotients into the output integer array.",
        "code_id": "c_group_2_id_145",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_div(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] = a[0] / b[0];\n  dest[1] = a[1] / b[1];\n  dest[2] = a[2] / b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_146",
        "query_text": "SUMMARY: This function takes as inputs an array of three integers (ivec3), an integer scalar (int), and another array of three integers (ivec3) as output. Its functionality is to update each element of the output array by adding the result of subtracting the scalar from the corresponding element of the input array.",
        "code_id": "c_group_2_id_146",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_subadds(ivec3 a, int s, ivec3 dest) {\n  dest[0] += a[0] - s;\n  dest[1] += a[1] - s;\n  dest[2] += a[2] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_147",
        "query_text": "SUMMARY: This function accepts two inputs: a 3\u00d73 matrix of floats (of type mat3, which is defined as an array of three vec3 arrays where each vec3 is an array of three floats) and a pointer to a FILE stream (of type FILE*). Its purpose is to format and print the matrix to the provided output stream. It first determines the appropriate field widths for each element, then prints the matrix with a header and formatted rows (including colorized output) to ensure proper alignment and visual clarity. The function does not return any value (void).",
        "code_id": "c_group_2_id_147",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3_print(mat3              matrix,\n               FILE * __restrict ostream) {\n  char buff[16];\n  int  i, j, cw[4], cwi;\n\n#define m 3\n#define n 3\n\n  fprintf(ostream, \"Matrix (float%dx%d): \" CGLM_PRINT_COLOR \"\\n\", m, n);\n\n  cw[0] = cw[1] = cw[2] = 0;\n\n  for (i = 0; i < m; i++) {\n    for (j = 0; j < n; j++) {\n      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)\n        cwi = snprintf(buff, sizeof(buff), \"% .*f\", CGLM_PRINT_PRECISION, (double)matrix[i][j]);\n      else\n        cwi = snprintf(buff, sizeof(buff), \"% g\", (double)matrix[i][j]);\n      cw[i] = GLM_MAX(cw[i], cwi);\n    }\n  }\n\n  for (i = 0; i < m; i++) {\n    fprintf(ostream, \"  |\");\n\n    for (j = 0; j < n; j++)\n      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)\n        fprintf(ostream, \" % *.*f\", cw[j], CGLM_PRINT_PRECISION, (double)matrix[j][i]);\n      else\n        fprintf(ostream, \" % *g\", cw[j], (double)matrix[j][i]);\n\n    fprintf(ostream, \"  |\\n\");\n  }\n\n  fprintf(ostream, CGLM_PRINT_COLOR_RESET \"\\n\");\n\n#undef m\n#undef n\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_148",
        "query_text": "SUMMARY: This function accepts an input of type \"mat4\" (a 4x4 matrix of 4-element float vectors) and computes a single output of type \"float\". It operates by summing the three diagonal elements from the first, second, and third rows (i.e., the elements at positions [0][0], [1][1], and [2][2]) of the provided 4x4 matrix, and returns this sum.",
        "code_id": "c_group_2_id_148",
        "code_text": "CGLM_INLINE\nfloat\nglm_mat4_trace3(mat4 m) {\n  return m[0][0] + m[1][1] + m[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_149",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, each of type float[2]. It performs an element-wise multiply-subtraction operation by multiplying each corresponding pair of elements from the input parameters and subtracting the result from the corresponding element in the output parameter.",
        "code_id": "c_group_2_id_149",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_mulsub(vec2 a, vec2 b, vec2 dest) {\n  dest[0] -= a[0] * b[0];\n  dest[1] -= a[1] * b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_150",
        "query_text": "SUMMARY: This function accepts two inputs of type float[2] and produces an output of type float[2]. It computes the element-wise division of the two input arrays, dividing the first element of the first input by the first element of the second input and the second element of the first input by the second element of the second input, and stores the resulting values in the output array.",
        "code_id": "c_group_2_id_150",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_div(vec2 a, vec2 b, vec2 dest) {\n  dest[0] = a[0] / b[0];\n  dest[1] = a[1] / b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_151",
        "query_text": "SUMMARY: This function accepts two input arrays of type float[3] representing three-dimensional vectors and an output array of the same type. It computes the element-wise difference between the two input vectors and then adds each resulting value to the corresponding element in the output vector.",
        "code_id": "c_group_2_id_151",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_subadd(vec3 a, vec3 b, vec3 dest) {\n  dest[0] += a[0] - b[0];\n  dest[1] += a[1] - b[1];\n  dest[2] += a[2] - b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_152",
        "query_text": "SUMMARY: This function operates on three parameters of type 2-element float arrays. It subtracts from each element of the output array the sum of the corresponding elements from the two input arrays, effectively updating the output vector by reducing each component by the combined values of the respective components from the inputs.",
        "code_id": "c_group_2_id_152",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_addsub(vec2 a, vec2 b, vec2 dest) {\n  dest[0] -= a[0] + b[0];\n  dest[1] -= a[1] + b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_153",
        "query_text": "SUMMARY: This function copies a 4\u00d74 matrix (of type mat4, an array of four 4-element float vectors) from an input to an output. It leverages different hardware-specific SIMD instructions (such as those for WASM SIMD, AVX, SSE/SSE2, or NEON) to efficiently transfer each 4-element vector constituting a row of the 4\u00d74 matrix, ensuring that the output precisely replicates the input. In cases where none of these SIMD capabilities are available, it resorts to a generic copy routine to perform the same task.",
        "code_id": "c_group_2_id_153",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_copy(mat4 mat, mat4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest[0], glmm_load(mat[0]));\n  glmm_store(dest[1], glmm_load(mat[1]));\n  glmm_store(dest[2], glmm_load(mat[2]));\n  glmm_store(dest[3], glmm_load(mat[3]));\n#elif defined(__AVX__)\n  glmm_store256(dest[0], glmm_load256(mat[0]));\n  glmm_store256(dest[2], glmm_load256(mat[2]));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest[0], glmm_load(mat[0]));\n  glmm_store(dest[1], glmm_load(mat[1]));\n  glmm_store(dest[2], glmm_load(mat[2]));\n  glmm_store(dest[3], glmm_load(mat[3]));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest[0], vld1q_f32(mat[0]));\n  vst1q_f32(dest[1], vld1q_f32(mat[1]));\n  vst1q_f32(dest[2], vld1q_f32(mat[2]));\n  vst1q_f32(dest[3], vld1q_f32(mat[3]));\n#else\n  glm_mat4_ucopy(mat, dest);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_154",
        "query_text": "SUMMARY: This function takes two input parameters of type float[3] and computes their element-wise multiplication, producing an output parameter also of type float[3]. Specifically, it multiplies the first elements of the input arrays and stores the result as the first element in the output array, then does the same with the second and third elements respectively.",
        "code_id": "c_group_2_id_154",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_mul(vec3 a, vec3 b, vec3 dest) {\n  dest[0] = a[0] * b[0];\n  dest[1] = a[1] * b[1];\n  dest[2] = a[2] * b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_155",
        "query_text": "SUMMARY: This function accepts a 2\u00d72 matrix (of type mat2, which is defined as an aligned array of two 2-element float vectors) and returns a float. It computes the sum of the elements from the top-left and bottom-right positions of the matrix, effectively calculating the trace of the matrix.",
        "code_id": "c_group_2_id_155",
        "code_text": "CGLM_INLINE\nfloat\nglm_mat2_trace(mat2 m) {\n  return m[0][0] + m[1][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_156",
        "query_text": "SUMMARY: This function takes an input consisting of an array of three integers, a scalar integer, and an output array of three integers. It updates each element of the output array by subtracting, from its current value, the difference between the corresponding element of the input array and the scalar.",
        "code_id": "c_group_2_id_156",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_subsubs(ivec3 a, int s, ivec3 dest) {\n  dest[0] -= a[0] - s;\n  dest[1] -= a[1] - s;\n  dest[2] -= a[2] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_157",
        "query_text": "SUMMARY: This function accepts two inputs of type vec2 (arrays of two floats representing complex numbers with the first element as the real component and the second as the imaginary component) and produces an output of type vec2. It performs complex multiplication by calculating the real part as the product of the real components minus the product of the imaginary components, and the imaginary part as the sum of the cross-products of the real and imaginary components. The final computed real and imaginary parts are stored in the output array.",
        "code_id": "c_group_2_id_157",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_complex_mul(vec2 a, vec2 b, vec2 dest) {\n  float tr, ti;\n  tr = a[0] * b[0] - a[1] * b[1];\n  ti = a[0] * b[1] + a[1] * b[0];\n  dest[0] = tr;\n  dest[1] = ti;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_158",
        "query_text": "SUMMARY: This function takes two input parameters and one output parameter, each of type \"int[3]\". It computes the element-wise product of the first two input arrays and adds each resulting product to the corresponding component of the output array.",
        "code_id": "c_group_2_id_158",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_muladd(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] += a[0] * b[0];\n  dest[1] += a[1] * b[1];\n  dest[2] += a[2] * b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_159",
        "query_text": "SUMMARY: This function accepts two input variables and one output variable, each being an array of four integers (ivec4). For each of the four integer positions, it computes the product of the corresponding integers from the two input arrays and then adds that product to the integer at the corresponding position in the output array.",
        "code_id": "c_group_2_id_159",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_muladd(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] += a[0] * b[0];\n  dest[1] += a[1] * b[1];\n  dest[2] += a[2] * b[2];\n  dest[3] += a[3] * b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_160",
        "query_text": "SUMMARY: This function computes the product of a 2\u00d73 matrix and a 3\u00d72 matrix, both consisting of float elements, and stores the result in a 3\u00d73 matrix also composed of float elements. It achieves this by, for each of the three rows in the 3\u00d72 input matrix, calculating three output values through two-element dot products with the two rows of the 2\u00d73 input matrix. The result is a 3\u00d73 matrix that encapsulates these computed dot products.",
        "code_id": "c_group_2_id_160",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x3_mul(mat2x3 m1, mat3x2 m2, mat3 dest) {\n  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], \n        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2],\n\n        b00 = m2[0][0], b01 = m2[0][1],\n        b10 = m2[1][0], b11 = m2[1][1],\n        b20 = m2[2][0], b21 = m2[2][1];\n\n  dest[0][0] = a00 * b00 + a10 * b01;\n  dest[0][1] = a01 * b00 + a11 * b01;\n  dest[0][2] = a02 * b00 + a12 * b01;\n\n  dest[1][0] = a00 * b10 + a10 * b11;\n  dest[1][1] = a01 * b10 + a11 * b11;\n  dest[1][2] = a02 * b10 + a12 * b11;\n\n  dest[2][0] = a00 * b20 + a10 * b21;\n  dest[2][1] = a01 * b20 + a11 * b21;\n  dest[2][2] = a02 * b20 + a12 * b21;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_161",
        "query_text": "SUMMARY: This function takes a source and a destination, each of type mat3x2 (an array of three vec2, where each vec2 is an array of two floats), and copies the entire 3x2 matrix from the source to the destination by directly assigning each corresponding floating-point element.",
        "code_id": "c_group_2_id_161",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x2_copy(mat3x2 mat, mat3x2 dest) {\n  dest[0][0] = mat[0][0];\n  dest[0][1] = mat[0][1];\n\n  dest[1][0] = mat[1][0];\n  dest[1][1] = mat[1][1];\n\n  dest[2][0] = mat[2][0];\n  dest[2][1] = mat[2][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_162",
        "query_text": "SUMMARY: This function receives a 3\u00d73 matrix of floating-point numbers (type mat3) as input and computes a single floating-point value (type float) by summing the elements located on the matrix's main diagonal (the first element of the first row, the second element of the second row, and the third element of the third row).",
        "code_id": "c_group_2_id_162",
        "code_text": "CGLM_INLINE\nfloat\nglm_mat3_trace(mat3 m) {\n  return m[0][0] + m[1][1] + m[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_163",
        "query_text": "SUMMARY: This function accepts a two-element integer array (ivec2, equivalent to int[2]) as its input/output parameter and sets each of its two elements to zero. It does not return any value, effectively producing a two-dimensional integer vector with all elements zero.",
        "code_id": "c_group_2_id_163",
        "code_text": "CGLM_INLINE\nvoid \nglm_ivec2_zero(ivec2 v) {\n  v[0] = v[1] = 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_164",
        "query_text": "SUMMARY: This function accepts a single input of type vec4 (an array of 4 single-precision floats) and does not return any value. Its functionality is to reset all elements within the provided vector to zero. It accomplishes this by utilizing platform-specific SIMD operations if available (such as WebAssembly SIMD, SSE, or NEON floating-point instructions) and defaults to assigning zero to each element individually when those optimizations are not available.",
        "code_id": "c_group_2_id_164",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_zero(vec4 v) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(v, wasm_f32x4_const_splat(0.f));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(v, _mm_setzero_ps());\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(v, vdupq_n_f32(0.0f));\n#else\n  v[0] = 0.0f;\n  v[1] = 0.0f;\n  v[2] = 0.0f;\n  v[3] = 0.0f;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_165",
        "query_text": "SUMMARY: This function accepts an input of type float and an output variable of type vec3 (a 3-element array of float). It assigns the float value to every element in the array, effectively replicating (broadcasting) the input value across all three positions.",
        "code_id": "c_group_2_id_165",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_broadcast(float val, vec3 d) {\n  d[0] = d[1] = d[2] = val;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_166",
        "query_text": "SUMMARY: This function accepts two input parameters of type float[3] and one output parameter of type float[3]. It computes the element\u2010wise sum of the two input float[3] arrays and stores the resulting float[3] array in the output parameter.",
        "code_id": "c_group_2_id_166",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_add(vec3 a, vec3 b, vec3 dest) {\n  dest[0] = a[0] + b[0];\n  dest[1] = a[1] + b[1];\n  dest[2] = a[2] + b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_167",
        "query_text": "SUMMARY: This function accepts a 2\u00d72 matrix (of type mat2) and a 2-dimensional vector (of type vec2) as inputs, and computes their product, yielding a 2-dimensional vector (of type vec2) as the result. On the first line, it calculates the first component of the result by taking the dot product of the first column of the matrix with the input vector, and on the second line, it calculates the second component by taking the dot product of the second column of the matrix with the input vector.",
        "code_id": "c_group_2_id_167",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2_mulv(mat2 m, vec2 v, vec2 dest) {\n  dest[0] = m[0][0] * v[0] + m[1][0] * v[1];\n  dest[1] = m[0][1] * v[0] + m[1][1] * v[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_168",
        "query_text": "SUMMARY: This function accepts a source input of type const float* and an output of type mat3x4 (a 3-element array where each element is an aligned 4-element array of floats). It sequentially copies 12 float values from the flat source array into the 3x4 matrix, populating each of the three rows with four consecutive float values in order.",
        "code_id": "c_group_2_id_168",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x4_make(const float * __restrict src, mat3x4 dest) {\n  dest[0][0] = src[0];\n  dest[0][1] = src[1];\n  dest[0][2] = src[2];\n  dest[0][3] = src[3];\n\n  dest[1][0] = src[4];\n  dest[1][1] = src[5];\n  dest[1][2] = src[6];\n  dest[1][3] = src[7];\n\n  dest[2][0] = src[8];\n  dest[2][1] = src[9];\n  dest[2][2] = src[10];\n  dest[2][3] = src[11];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_169",
        "query_text": "SUMMARY: This function accepts a perspective projection matrix (of type \"mat4\", an aligned 4\u00d74 array of 4-element float vectors) and a pointer to a float variable. It computes a specific scalar value corresponding to the near clipping distance by dividing the element from the matrix\u2019s fourth row and third column by the difference of the element from the third row and third column with 1.0, then stores the result in the provided float output.",
        "code_id": "c_group_2_id_169",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_near_rh_no(mat4 proj, float * __restrict nearZ) {\n  *nearZ = proj[3][2] / (proj[2][2] - 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_170",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two floats) and a scalar of type float, and it produces an output of type vec2. It computes a new vector by subtracting the scalar from each element of the input vector and stores the result in the output vector.",
        "code_id": "c_group_2_id_170",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_subs(vec2 v, float s, vec2 dest) {\n  dest[0] = v[0] - s;\n  dest[1] = v[1] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_171",
        "query_text": "SUMMARY: This function takes as input a two-element integer array, an integer scalar, and a two-element integer array as output. It updates the output array by subtracting, from each of its elements, the result of subtracting the scalar from the corresponding element of the input array.",
        "code_id": "c_group_2_id_171",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_subsubs(ivec2 a, int s, ivec2 dest) {\n  dest[0] -= a[0] - s;\n  dest[1] -= a[1] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_172",
        "query_text": "SUMMARY: This function operates on three-element arrays of integers (ivec3). It takes two such input arrays, each containing three integers, and produces one output array (ivec3) where each position is assigned the greater of the corresponding elements from the two input arrays.",
        "code_id": "c_group_2_id_172",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_maxv(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] = a[0] > b[0] ? a[0] : b[0];\n  dest[1] = a[1] > b[1] ? a[1] : b[1];\n  dest[2] = a[2] > b[2] ? a[2] : b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_173",
        "query_text": "SUMMARY: This function accepts an input of type int[4] and an integer scalar, and produces an output of type int[4]. It subtracts the scalar value from each element of the input array and stores the results in the output array.",
        "code_id": "c_group_2_id_173",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_subs(ivec4 v, int s, ivec4 dest) {\n  dest[0] = v[0] - s;\n  dest[1] = v[1] - s;\n  dest[2] = v[2] - s;\n  dest[3] = v[3] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_174",
        "query_text": "SUMMARY: This function accepts an input of type const float pointer and produces an output of type mat2x4 (i.e., a two-element array where each element is a four-component float vector). It organizes the eight sequential float values from the input into a 2\u00d74 matrix format by assigning the first four float values to the first row of the matrix and the subsequent four float values to the second row.",
        "code_id": "c_group_2_id_174",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x4_make(const float * __restrict src, mat2x4 dest) {\n  dest[0][0] = src[0];\n  dest[0][1] = src[1];\n  dest[0][2] = src[2];\n  dest[0][3] = src[3];\n\n  dest[1][0] = src[4];\n  dest[1][1] = src[5];\n  dest[1][2] = src[6];\n  dest[1][3] = src[7];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_175",
        "query_text": "SUMMARY: This function accepts a 2-element integer array, an integer scalar, and a second 2-element integer array as inputs. It updates the output array by adding the sum of the corresponding element in the input array and the provided integer to each element in the output array.",
        "code_id": "c_group_2_id_175",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_addadds(ivec2 a, int s, ivec2 dest) {\n  dest[0] += a[0] + s;\n  dest[1] += a[1] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_176",
        "query_text": "SUMMARY: This function receives an input of type vec4 (an array of four 32-bit floats) and a scalar of type float, and produces an output of type vec4. It scales the input vector by multiplying each of its four components by the scalar value, storing the resulting values into the output vector. Depending on the platform, it may use specialized SIMD operations for enhanced performance.",
        "code_id": "c_group_2_id_176",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_scale(vec4 v, float s, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_mul(glmm_load(v), wasm_f32x4_splat(s)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_mul_ps(glmm_load(v), _mm_set1_ps(s)));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vmulq_f32(vld1q_f32(v), vdupq_n_f32(s)));\n#else\n  dest[0] = v[0] * s;\n  dest[1] = v[1] * s;\n  dest[2] = v[2] * s;\n  dest[3] = v[3] * s;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_177",
        "query_text": "SUMMARY: The function takes two inputs, each being an array of four integers (int[4]), and computes their element-wise differences by subtracting corresponding entries. The resulting array of four integers (int[4]) is then produced as the output.",
        "code_id": "c_group_2_id_177",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_sub(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] = a[0] - b[0];\n  dest[1] = a[1] - b[1];\n  dest[2] = a[2] - b[2];\n  dest[3] = a[3] - b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_178",
        "query_text": "SUMMARY: This function accepts three inputs, each being a two-element integer array (ivec2). It performs a component-wise addition by summing the corresponding elements of the first two inputs and then accumulates these sums with the corresponding elements of the third input. The modified third input, serving as the output, contains the results of this accumulation.",
        "code_id": "c_group_2_id_178",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_addadd(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] += a[0] + b[0];\n  dest[1] += a[1] + b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_179",
        "query_text": "SUMMARY: This function performs a component-wise subtraction between two 3-element integer arrays, where each input is of type ivec3 (an array of three integers). It subtracts the corresponding element of the second array from the first array and stores each resulting difference in a third ivec3 output array.",
        "code_id": "c_group_2_id_179",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_sub(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] = a[0] - b[0];\n  dest[1] = a[1] - b[1];\n  dest[2] = a[2] - b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_180",
        "query_text": "SUMMARY: This function receives two inputs\u2014a 4x4 matrix of floats (mat4) and a single float\u2014and it operates in place without returning a value (void). It adjusts the matrix by adding the float input to the element located in the fourth row and third column, effectively modifying the translation component along the z-axis of the transformation represented by the matrix.",
        "code_id": "c_group_2_id_180",
        "code_text": "CGLM_INLINE\nvoid\nglm_translated_z(mat4 m, float z) {\n  m[3][2] += z;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_181",
        "query_text": "SUMMARY: This function takes as input a constant 4-element integer array and an integer scalar, and it updates a destination 4-element integer array. For each element in the destination array, it adds the result of subtracting the scalar from the corresponding element of the input array. The operation is performed element-wise for all four positions of the arrays, and no value is returned.",
        "code_id": "c_group_2_id_181",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_subadds(ivec4 a, int s, ivec4 dest) {\n  dest[0] += a[0] - s;\n  dest[1] += a[1] - s;\n  dest[2] += a[2] - s;\n  dest[3] += a[3] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_182",
        "query_text": "SUMMARY: This function takes a 4\u00d74 floating\u2010point matrix (input type: mat4) and computes a 3-element floating\u2010point vector (output type: vec3) representing Euler angles. It extracts specific values from the matrix and then determines the Euler angles via conditional checks on one of the extracted values to handle different rotation scenarios while addressing potential singularities. The computed angles, corresponding to rotations about three principal axes, are then stored in the output vector.",
        "code_id": "c_group_2_id_182",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_angles(mat4 m, vec3 dest) {\n  float m00, m01, m10, m11, m20, m21, m22;\n  float thetaX, thetaY, thetaZ;\n\n  m00 = m[0][0];  m10 = m[1][0];  m20 = m[2][0];\n  m01 = m[0][1];  m11 = m[1][1];  m21 = m[2][1];\n                                  m22 = m[2][2];\n\n  if (m20 < 1.0f) {\n    if (m20 > -1.0f) {\n      thetaY = asinf(m20);\n      thetaX = atan2f(-m21, m22);\n      thetaZ = atan2f(-m10, m00);\n    } else { /* m20 == -1 */\n      /* Not a unique solution */\n      thetaY = -GLM_PI_2f;\n      thetaX = -atan2f(m01, m11);\n      thetaZ =  0.0f;\n    }\n  } else { /* m20 == +1 */\n    thetaY = GLM_PI_2f;\n    thetaX = atan2f(m01, m11);\n    thetaZ = 0.0f;\n  }\n\n  dest[0] = thetaX;\n  dest[1] = thetaY;\n  dest[2] = thetaZ;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_183",
        "query_text": "SUMMARY: This function takes as input a 2-element float array, a float scalar, and another 2-element float array as its output container. It multiplies each element of the first array by the scalar value and then adds the resulting products to the corresponding elements in the output array, updating it in place.",
        "code_id": "c_group_2_id_183",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_muladds(vec2 a, float s, vec2 dest) {\n  dest[0] += a[0] * s;\n  dest[1] += a[1] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_184",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 floating-point matrix (of type mat4) and two pointers to floats (float *), and it computes the near and far clipping plane distances from the provided projection matrix. It does so by extracting two specific elements from the matrix and then performing simple division operations: one value divided by (the other value minus 1) to yield the near clipping distance, and the same value divided by (the other value plus 1) to yield the far clipping distance. The resulting float values are stored via the provided pointers.",
        "code_id": "c_group_2_id_184",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_z_rh_no(mat4 proj,\n                      float * __restrict nearZ,\n                      float * __restrict farZ) {\n  float m32, m22;\n\n  m32 = proj[3][2];\n  m22 = proj[2][2];\n\n  *nearZ = m32 / (m22 - 1.0f);\n  *farZ  = m32 / (m22 + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_185",
        "query_text": "SUMMARY: This function accepts a three-element floating-point array as input and produces another three-element floating-point array as output. For each element, it computes the fractional part by subtracting the floor of the input value from the input value itself. It then ensures that the computed fractional value does not exceed approximately 0.99999994 by clamping it to that upper bound.",
        "code_id": "c_group_2_id_185",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_fract(vec3 v, vec3 dest) {\n  dest[0] = fminf(v[0] - floorf(v[0]), 0.999999940395355224609375f);\n  dest[1] = fminf(v[1] - floorf(v[1]), 0.999999940395355224609375f);\n  dest[2] = fminf(v[2] - floorf(v[2]), 0.999999940395355224609375f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_186",
        "query_text": "SUMMARY: This function accepts a mutable 3\u00d73 matrix of floats (of type mat3) and two integer values specifying row indices. Its purpose is to exchange the two specified rows within the matrix, modifying the input matrix in place without returning any value.",
        "code_id": "c_group_2_id_186",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3_swap_row(mat3 mat, int row1, int row2) {\n  vec3 tmp;\n  tmp[0] = mat[0][row1];\n  tmp[1] = mat[1][row1];\n  tmp[2] = mat[2][row1];\n\n  mat[0][row1] = mat[0][row2];\n  mat[1][row1] = mat[1][row2];\n  mat[2][row1] = mat[2][row2];\n\n  mat[0][row2] = tmp[0];\n  mat[1][row2] = tmp[1];\n  mat[2][row2] = tmp[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_187",
        "query_text": "SUMMARY: This function takes as inputs a float value and a 4x4 matrix (of type vec4[4]). The function checks if the first element of the matrix (i.e., the first element of the first row) is zero; if it is, no changes occur. Otherwise, the function updates that element by dividing the second diagonal element of the matrix by the float input. The function returns no output as it modifies the matrix in place.",
        "code_id": "c_group_2_id_187",
        "code_text": "CGLM_INLINE\nvoid\nglm_perspective_resize_lh_no(float aspect, mat4 proj) {\n  if (proj[0][0] == 0.0f)\n    return;\n\n  proj[0][0] = proj[1][1] / aspect;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_188",
        "query_text": "SUMMARY: The function receives a three-element array of floats serving as a 3-dimensional vector, a float scalar, and an output three-element float array. It computes the result of dividing each component of the input vector by the scalar, and stores these quotient values into the output vector.",
        "code_id": "c_group_2_id_188",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_divs(vec3 v, float s, vec3 dest) {\n  dest[0] = v[0] / s;\n  dest[1] = v[1] / s;\n  dest[2] = v[2] / s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_189",
        "query_text": "SUMMARY: This function computes the product of a 4\u00d72 matrix and a 4-dimensional vector. It takes as input a matrix represented as an array of four 2-dimensional vectors (type mat4x2, i.e. float[2] arrays), and a 4-dimensional vector (type vec4, i.e. a 4-element float array with specific alignment). The function multiplies each element of the input vector with the corresponding elements in the matrix's columns, sums the products for each row of the matrix, and outputs the resulting 2-dimensional vector (type vec2, a 2-element float array).",
        "code_id": "c_group_2_id_189",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x2_mulv(mat4x2 m, vec4 v, vec2 dest) {\n  float v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n\n  dest[0] = m[0][0] * v0 + m[1][0] * v1 + m[2][0] * v2 + m[3][0] * v3;\n  dest[1] = m[0][1] * v0 + m[1][1] * v1 + m[2][1] * v2 + m[3][1] * v3;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_190",
        "query_text": "SUMMARY: This function accepts two input arrays, each consisting of 3 integers, and an output array of 3 integers. For each of the three positions, it evaluates the sum of the respective integers from the two input arrays and then adds this result to the corresponding integer already present in the output array.",
        "code_id": "c_group_2_id_190",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_addadd(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] += a[0] + b[0];\n  dest[1] += a[1] + b[1];\n  dest[2] += a[2] + b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_191",
        "query_text": "SUMMARY: This function accepts three parameters, each of type float[2] (an array of two floats). The first and second inputs represent complex numbers (with the first element as the real part and the second as the imaginary part). The function computes the division of the first complex number by the second complex number, following the standard formula for complex division. It calculates the reciprocal of the squared norm of the second complex number, uses this value to compute the real part (as the sum of the products of corresponding real and imaginary components) and the imaginary part (as the difference of the cross products) of the quotient, and then stores these two components in the output parameter, which is also a float[2] array.",
        "code_id": "c_group_2_id_191",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_complex_div(vec2 a, vec2 b, vec2 dest) {\n  float tr, ti;\n  float const ibnorm2 = 1.0f / (b[0] * b[0] + b[1] * b[1]);\n  tr = ibnorm2 * (a[0] * b[0] + a[1] * b[1]);\n  ti = ibnorm2 * (a[1] * b[0] - a[0] * b[1]);\n  dest[0] = tr;\n  dest[1] = ti;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_192",
        "query_text": "SUMMARY: This function accepts an input variable of type vec4 (a CGLM-aligned array of four floats) and produces an output variable of the same type. It computes, for each floating-point element in the input array, the largest integer value not greater than that element (i.e., the floor operation), and assigns these computed values to the corresponding elements in the output array.",
        "code_id": "c_group_2_id_192",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_floor(vec4 v, vec4 dest) {\n  dest[0] = floorf(v[0]);\n  dest[1] = floorf(v[1]);\n  dest[2] = floorf(v[2]);\n  dest[3] = floorf(v[3]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_193",
        "query_text": "SUMMARY: This function takes as input a matrix of type mat4 (an array of four aligned vec4 elements, where each vec4 is an array of four floats) and produces no direct output (void return). It sets every element of the provided 4\u00d74 matrix to zero. Depending on the hardware capabilities (WebAssembly SIMD, AVX, SSE, NEON), it uses specific SIMD instructions to efficiently fill the matrix with zeros; if none are available, it falls back to a standard method to achieve the same zero-initialization.",
        "code_id": "c_group_2_id_193",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_zero(mat4 mat) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_128 x0;\n  x0 = wasm_f32x4_const_splat(0.f);\n  glmm_store(mat[0], x0);\n  glmm_store(mat[1], x0);\n  glmm_store(mat[2], x0);\n  glmm_store(mat[3], x0);\n#elif defined(__AVX__)\n  __m256 y0;\n  y0 = _mm256_setzero_ps();\n  glmm_store256(mat[0], y0);\n  glmm_store256(mat[2], y0);\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_128 x0;\n  x0 = _mm_setzero_ps();\n  glmm_store(mat[0], x0);\n  glmm_store(mat[1], x0);\n  glmm_store(mat[2], x0);\n  glmm_store(mat[3], x0);\n#elif defined(CGLM_NEON_FP)\n  glmm_128 x0;\n  x0 = vdupq_n_f32(0.0f);\n  vst1q_f32(mat[0], x0);\n  vst1q_f32(mat[1], x0);\n  vst1q_f32(mat[2], x0);\n  vst1q_f32(mat[3], x0);\n#else\n  CGLM_ALIGN_MAT mat4 t = GLM_MAT4_ZERO_INIT;\n  glm_mat4_copy(t, mat);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_194",
        "query_text": "SUMMARY: The function accepts a 3x3 matrix of type float (mat3) and a scalar of type float as inputs, and it does not return any value (void). It modifies the input matrix by applying a 2D translation along the y-axis. Specifically, it updates the elements in the third row of the matrix by incrementing them with the product of a corresponding element from the second row and the scalar input, effectively incorporating a translation component along the y direction into the matrix representation.",
        "code_id": "c_group_2_id_194",
        "code_text": "CGLM_INLINE\nvoid\nglm_translate2d_y(mat3 m, float y) {\n  m[2][0] = m[1][0] * y + m[2][0];\n  m[2][1] = m[1][1] * y + m[2][1];\n  m[2][2] = m[1][2] * y + m[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_195",
        "query_text": "SUMMARY: This function takes two 3-element arrays of floats (vec3) as inputs and a third 3-element array of floats (vec3) as the output. It computes the element-wise product of the two input arrays and then adds each resulting product to the corresponding element of the output array.",
        "code_id": "c_group_2_id_195",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_muladd(vec3 a, vec3 b, vec3 dest) {\n  dest[0] += a[0] * b[0];\n  dest[1] += a[1] * b[1];\n  dest[2] += a[2] * b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_196",
        "query_text": "SUMMARY: This function takes a three-element integer array (ivec3), a scalar integer, and another three-element integer array (ivec3) as inputs. It updates the latter by adding, element-wise, the sum of the corresponding element from the first array and the scalar to each element already present in the output array.",
        "code_id": "c_group_2_id_196",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_addadds(ivec3 a, int s, ivec3 dest) {\n  dest[0] += a[0] + s;\n  dest[1] += a[1] + s;\n  dest[2] += a[2] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_197",
        "query_text": "SUMMARY: This function accepts two inputs of type vec4 (which is an array of four floats) and produces an output also of type vec4. It computes the element-wise arithmetic negation of the input vector and stores the resulting values in the output vector. The implementation adapts to available hardware acceleration (such as WebAssembly SIMD, SSE, or NEON) to perform the negation efficiently, with a fallback to scalar operations if necessary.",
        "code_id": "c_group_2_id_197",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_negate_to(vec4 v, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_neg(glmm_load(v)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_xor_ps(glmm_load(v), glmm_float32x4_SIGNMASK_NEG));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vnegq_f32(vld1q_f32(v)));\n#else\n  dest[0] = -v[0];\n  dest[1] = -v[1];\n  dest[2] = -v[2];\n  dest[3] = -v[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_198",
        "query_text": "SUMMARY: This function operates on three variables, each of type integer vector of size 3 (int[3]). It modifies the output vector by subtracting, for each of its three components, the difference between the corresponding components of the first and second integer vectors. In effect, for every component index, the function computes \"output component minus (first vector component minus second vector component)\".",
        "code_id": "c_group_2_id_198",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_subsub(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] -= a[0] - b[0];\n  dest[1] -= a[1] - b[1];\n  dest[2] -= a[2] - b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_199",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of which are arrays of three floats (vec3). It updates the output parameter by subtracting, for each component, the difference between the corresponding elements of the first and second input arrays. Essentially, for each index (0, 1, 2), it performs the operation output[i] = output[i] - (first_input[i] - second_input[i]).",
        "code_id": "c_group_2_id_199",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_subsub(vec3 a, vec3 b, vec3 dest) {\n  dest[0] -= a[0] - b[0];\n  dest[1] -= a[1] - b[1];\n  dest[2] -= a[2] - b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_200",
        "query_text": "SUMMARY: This function computes and returns the trace of a 4\u00d74 matrix. It takes as input a parameter of type mat4 (an aligned 4\u00d74 matrix composed of four arrays of four floating-point numbers each) and produces a scalar output of type float. Specifically, the function sums the diagonal elements of the matrix, which are the elements located at the positions (0,0), (1,1), (2,2), and (3,3).",
        "code_id": "c_group_2_id_200",
        "code_text": "CGLM_INLINE\nfloat\nglm_mat4_trace(mat4 m) {\n  return m[0][0] + m[1][1] + m[2][2] + m[3][3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_201",
        "query_text": "SUMMARY: This function computes the determinant of a 2\u00d72 matrix. It accepts as input a matrix of type mat2 (a 2\u00d72 array of floats, with each row represented as a vec2) and returns a float. Internally, it multiplies the top-left element with the bottom-right element and subtracts the product of the bottom-left element with the top-right element to produce the determinant as output.",
        "code_id": "c_group_2_id_201",
        "code_text": "CGLM_INLINE\nfloat\nglm_mat2_det(mat2 mat) {\n  return mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_202",
        "query_text": "SUMMARY: This function accepts two inputs of type ivec3 (arrays containing three integers) and computes an output of the same type. It performs an element-wise modulo operation by taking, for each index, the remainder of the division of the corresponding integer from the first input by the integer from the second input, and stores the result in the matching index of the output.",
        "code_id": "c_group_2_id_202",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_mod(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] = a[0] % b[0];\n  dest[1] = a[1] % b[1];\n  dest[2] = a[2] % b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_203",
        "query_text": "SUMMARY: This function operates on a 4\u00d74 matrix of floats (input type: mat4) and produces two float outputs (output type: float*, representing left and right boundaries). It extracts specific coefficients from the matrix that are related to the perspective projection setup, computes the near-plane depth from these coefficients, and then calculates the horizontal extents (left and right) of the viewing frustum for a right\u2010handed, no-offset configuration.",
        "code_id": "c_group_2_id_203",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_x_rh_no(mat4 proj,\n                         float * __restrict left,\n                         float * __restrict right) {\n  float nearZ, m20, m00, m22;\n\n  m00 = proj[0][0];\n  m20 = proj[2][0];\n  m22 = proj[2][2];\n\n  nearZ = proj[3][2] / (m22 - 1.0f);\n  *left   = nearZ * (m20 - 1.0f) / m00;\n  *right  = nearZ * (m20 + 1.0f) / m00;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_204",
        "query_text": "SUMMARY: This function takes as inputs an array of two floats (vec2) and a pointer to a FILE stream. It produces a formatted text representation of the two-element vector by writing to the provided FILE stream. Specifically, it outputs a header indicating the vector's type with color formatting, then prints each float element using either a fixed-precision or general format depending on its value relative to a defined threshold, and finally resets the formatting before finishing. The function does not return any value.",
        "code_id": "c_group_2_id_204",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_print(vec2              vec,\n               FILE * __restrict ostream) {\n  int i;\n\n#define m 2\n\n  fprintf(ostream, \"Vector (float%d): \" CGLM_PRINT_COLOR \"\\n  (\", m);\n\n  for (i = 0; i < m; i++) {\n    if (vec[i] < CGLM_PRINT_MAX_TO_SHORT)\n      fprintf(ostream, \" % .*f\", CGLM_PRINT_PRECISION, (double)vec[i]);\n    else\n      fprintf(ostream, \" % g\", (double)vec[i]);\n  }\n\n  fprintf(ostream, \"  )\" CGLM_PRINT_COLOR_RESET \"\\n\\n\");\n\n#undef m\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_205",
        "query_text": "SUMMARY: This function accepts two input parameters of type ivec3 (arrays of three integers) and one output parameter of the same type. For each of the three integer elements, it computes the product of the corresponding elements from the input parameters and then subtracts that product from the corresponding element in the output array.",
        "code_id": "c_group_2_id_205",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_mulsub(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] -= a[0] * b[0];\n  dest[1] -= a[1] * b[1];\n  dest[2] -= a[2] * b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_206",
        "query_text": "SUMMARY: This function takes a 3-element floating\u2010point vector (vec3) representing Euler angles and produces a 4\u00d74 floating\u2010point matrix (mat4) that encodes a 3D rotation using a Z\u2013Y\u2013X rotation order. It computes the sine and cosine of each angle and uses intermediate multiplications to construct the rotation submatrix, then sets the remaining parts of the matrix to form a proper homogeneous transformation matrix with zero translation and a unit scale for the homogeneous coordinate.",
        "code_id": "c_group_2_id_206",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_zyx(vec3 angles, mat4 dest) {\n  float cx, cy, cz,\n        sx, sy, sz, czsx, cxcz, sysz;\n\n  sx   = sinf(angles[0]); cx = cosf(angles[0]);\n  sy   = sinf(angles[1]); cy = cosf(angles[1]);\n  sz   = sinf(angles[2]); cz = cosf(angles[2]);\n\n  czsx = cz * sx;\n  cxcz = cx * cz;\n  sysz = sy * sz;\n\n  dest[0][0] =  cy * cz;\n  dest[0][1] =  cy * sz;\n  dest[0][2] = -sy;\n  dest[1][0] =  czsx * sy - cx * sz;\n  dest[1][1] =  cxcz + sx * sysz;\n  dest[1][2] =  cy * sx;\n  dest[2][0] =  cxcz * sy + sx * sz;\n  dest[2][1] = -czsx + cx * sysz;\n  dest[2][2] =  cx * cy;\n  dest[0][3] =  0.0f;\n  dest[1][3] =  0.0f;\n  dest[2][3] =  0.0f;\n  dest[3][0] =  0.0f;\n  dest[3][1] =  0.0f;\n  dest[3][2] =  0.0f;\n  dest[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_207",
        "query_text": "SUMMARY: This function accepts a three-element array of floats (vec3) as input along with a float value. It assigns the given float value to each element of the array, effectively filling the vector. The function does not return any value.",
        "code_id": "c_group_2_id_207",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_fill(vec3 v, float val) {\n  v[0] = v[1] = v[2] = val;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_208",
        "query_text": "SUMMARY: This function processes a matrix of type mat3 (a 3\u00d73 array of float values) by computing its transpose in place. It effectively interchanges the matrix's off-diagonal elements so that the rows become columns and vice versa, updating the original matrix with its transposed form.",
        "code_id": "c_group_2_id_208",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3_transpose(mat3 m) {\n  CGLM_ALIGN_MAT mat3 tmp;\n\n  tmp[0][1] = m[1][0];\n  tmp[0][2] = m[2][0];\n  tmp[1][0] = m[0][1];\n  tmp[1][2] = m[2][1];\n  tmp[2][0] = m[0][2];\n  tmp[2][1] = m[1][2];\n\n  m[0][1] = tmp[0][1];\n  m[0][2] = tmp[0][2];\n  m[1][0] = tmp[1][0];\n  m[1][2] = tmp[1][2];\n  m[2][0] = tmp[2][0];\n  m[2][1] = tmp[2][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_209",
        "query_text": "SUMMARY: This function takes two inputs of type int[2] and produces an output of type int[2] by computing the element-wise product of the two input arrays. Specifically, it multiplies the first element of one input with the first element of the other, and similarly for the second element, placing the results in the output array.",
        "code_id": "c_group_2_id_209",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_mul(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] = a[0] * b[0];\n  dest[1] = a[1] * b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_210",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of 2 floats) and produces an output of the same type. For each element in the input, the function computes its fractional component by subtracting the integer part (as determined by the floor operation), and then limits the resulting value so that it does not exceed approximately 0.99999994.",
        "code_id": "c_group_2_id_210",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_fract(vec2 v, vec2 dest) {\n  dest[0] = fminf(v[0] - floorf(v[0]), 0.999999940395355224609375f);\n  dest[1] = fminf(v[1] - floorf(v[1]), 0.999999940395355224609375f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_211",
        "query_text": "SUMMARY: This inline function takes a single parameter\u2014a three-element array of floats (type: float[3])\u2014as input and produces no return value (type: void). Its functionality is to initialize each element of the provided array to 0.0f, effectively setting the vector to a zero state.",
        "code_id": "c_group_2_id_211",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_zero(vec3 v) {\n  v[0] = v[1] = v[2] = 0.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_212",
        "query_text": "SUMMARY: This function accepts an input of a three-element array of integers and a single integer scalar, then outputs a three-element array of integers. It performs element-wise division of the array's integers by the scalar and stores the results in the output array.",
        "code_id": "c_group_2_id_212",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_divs(ivec3 v, int s, ivec3 dest) {\n  dest[0] = v[0] / s;\n  dest[1] = v[1] / s;\n  dest[2] = v[2] / s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_213",
        "query_text": "SUMMARY: This function takes a 4\u00d74 projection matrix (of type mat4, defined as an array of four vec4, where each vec4 is a float[4]) as its primary input. It then decomposes this matrix into its perspective frustum parameters by computing the near and far clipping distances (as floats) and the top, bottom, left, and right extents (also as floats). The outputs are provided via pointers to floats. Essentially, the function interprets the projection matrix for a left-handed, zero-depth configuration and extracts the corresponding frustum boundaries without delving into low-level detail of the underlying transformation mechanics.",
        "code_id": "c_group_2_id_213",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_lh_zo(mat4 proj,\n                    float * __restrict nearZ, float * __restrict farZ,\n                    float * __restrict top,     float * __restrict bottom,\n                    float * __restrict left,    float * __restrict right) {\n  float m00, m11, m20, m21, m22, m32, n, f;\n  float n_m11, n_m00;\n\n  m00 = proj[0][0];\n  m11 = proj[1][1];\n  m20 = proj[2][0];\n  m21 = proj[2][1];\n  m22 =-proj[2][2];\n  m32 = proj[3][2];\n\n  n = m32 / m22;\n  f = m32 / (m22 + 1.0f);\n\n  n_m11 = n / m11;\n  n_m00 = n / m00;\n\n  *nearZ = n;\n  *farZ  = f;\n  *bottom  = n_m11 * (m21 - 1.0f);\n  *top     = n_m11 * (m21 + 1.0f);\n  *left    = n_m00 * (m20 - 1.0f);\n  *right   = n_m00 * (m20 + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_214",
        "query_text": "SUMMARY: This function accepts three parameters: the first is an input two-element vector of type int[2], the second is a scalar integer (type int), and the third is an output two-element vector of type int[2]. The function multiplies each element of the input vector by the scalar integer and then adds the resulting product to the corresponding element of the output vector.",
        "code_id": "c_group_2_id_214",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_muladds(ivec2 a, int s, ivec2 dest) {\n  dest[0] += a[0] * s;\n  dest[1] += a[1] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_215",
        "query_text": "SUMMARY: This function takes two inputs of type mat4x2 (an array of 4 vec2 arrays, where each vec2 is defined as an array of 2 floats) and copies the elements from the source input to the destination output. Specifically, it transfers each of the four rows, with their two float components, from the input mat4x2 to the corresponding positions in the output mat4x2.",
        "code_id": "c_group_2_id_215",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x2_copy(mat4x2 mat, mat4x2 dest) {\n  dest[0][0] = mat[0][0];\n  dest[0][1] = mat[0][1];\n\n  dest[1][0] = mat[1][0];\n  dest[1][1] = mat[1][1];\n\n  dest[2][0] = mat[2][0];\n  dest[2][1] = mat[2][1];\n\n  dest[3][0] = mat[3][0];\n  dest[3][1] = mat[3][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_216",
        "query_text": "SUMMARY: This function takes as input a two-dimensional matrix of type \"mat2\" (an aligned array of two 2-element \"vec2\" arrays containing floats) and two integers representing row indices. Its functionality is to exchange the data of the two specified rows within the matrix by swapping the corresponding float values in each column, without returning any value (the matrix is modified in place).",
        "code_id": "c_group_2_id_216",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2_swap_row(mat2 mat, int row1, int row2) {\n  float a, b;\n\n  a = mat[0][row1];\n  b = mat[1][row1];\n\n  mat[0][row1] = mat[0][row2];\n  mat[1][row1] = mat[1][row2];\n\n  mat[0][row2] = a;\n  mat[1][row2] = b;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_217",
        "query_text": "SUMMARY: This function performs an element-wise subtraction between two inputs of type float[3] and stores the result in an output of type float[3]. Specifically, it computes the subtraction for each corresponding index of the input arrays and assigns the result to the corresponding index of the output array.",
        "code_id": "c_group_2_id_217",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_sub(vec3 a, vec3 b, vec3 dest) {\n  dest[0] = a[0] - b[0];\n  dest[1] = a[1] - b[1];\n  dest[2] = a[2] - b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_218",
        "query_text": "SUMMARY: This function converts a set of Euler angles to a quaternion representation using a right-handed coordinate system with a YXZ rotation order. It accepts an input of type vec3 (a three-element array of floats representing the Euler angles) and produces an output of type versor (a four-element array of floats representing the resulting quaternion). The function computes sine and cosine values of half of each angle and then combines these to form the quaternion's components through a series of multiplications and additions.",
        "code_id": "c_group_2_id_218",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_yxz_quat_rh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs = sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys = sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] =  yc * xs * zc + ys * xc * zs;\n  dest[1] = -yc * xs * zs + ys * xc * zc;\n  dest[2] =  yc * xc * zs - ys * xs * zc;\n  dest[3] =  yc * xc * zc + ys * xs * zs;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_219",
        "query_text": "SUMMARY: This function takes an input of type ivec2 (an array of two integers), a scalar integer, and an output of type ivec2. It computes, for each element of the input array, the difference between that element and the scalar, and then adds the result to the corresponding element of the output array.",
        "code_id": "c_group_2_id_219",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_subadds(ivec2 a, int s, ivec2 dest) {\n  dest[0] += a[0] - s;\n  dest[1] += a[1] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_220",
        "query_text": "SUMMARY: The function accepts two input arrays of type int[2] and produces an output array of type int[2]. It computes the component-wise minimum between the corresponding elements of the two input arrays and stores the resulting minimum values in the output array.",
        "code_id": "c_group_2_id_220",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_minv(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] = a[0] < b[0] ? a[0] : b[0];\n  dest[1] = a[1] < b[1] ? a[1] : b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_221",
        "query_text": "SUMMARY: This function operates on two variables of the type \"mat3\", where \"mat3\" is defined as a 3x3 array of floats. It takes a source 3x3 float matrix and copies each element of the source matrix to a destination 3x3 float matrix, effectively duplicating all nine elements from the input to the output.",
        "code_id": "c_group_2_id_221",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3_copy(mat3 mat, mat3 dest) {\n  dest[0][0] = mat[0][0];\n  dest[0][1] = mat[0][1];\n  dest[0][2] = mat[0][2];\n\n  dest[1][0] = mat[1][0];\n  dest[1][1] = mat[1][1];\n  dest[1][2] = mat[1][2];\n\n  dest[2][0] = mat[2][0];\n  dest[2][1] = mat[2][1];\n  dest[2][2] = mat[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_222",
        "query_text": "SUMMARY: This function takes as input a matrix of type mat3x4 (an array of 3 vectors, each containing 4 floats) and outputs a matrix of type mat4x3 (an array of 4 vectors, each containing 3 floats). Its functionality is to compute the transpose of the input 3\u00d74 matrix, effectively converting rows into columns by reassigning each element\u2019s position accordingly.",
        "code_id": "c_group_2_id_222",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x4_transpose(mat3x4 m, mat4x3 dest) {\n  dest[0][0] = m[0][0];  dest[0][1] = m[1][0];  dest[0][2] = m[2][0];\n  dest[1][0] = m[0][1];  dest[1][1] = m[1][1];  dest[1][2] = m[2][1];\n  dest[2][0] = m[0][2];  dest[2][1] = m[1][2];  dest[2][2] = m[2][2];\n  dest[3][0] = m[0][3];  dest[3][1] = m[1][3];  dest[3][2] = m[2][3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_223",
        "query_text": "SUMMARY: This function accepts two arrays of four integers and one integer scalar. It multiplies each element of the first integer array by the scalar and then subtracts the resulting product from the corresponding element of the second integer array, updating the second array with these new values.",
        "code_id": "c_group_2_id_223",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_mulsubs(ivec4 a, int s, ivec4 dest) {\n  dest[0] -= a[0] * s;\n  dest[1] -= a[1] * s;\n  dest[2] -= a[2] * s;\n  dest[3] -= a[3] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_224",
        "query_text": "SUMMARY: This function operates on an input of type mat4 (a 4x4 array of float values) along with a float scalar. It scales the entire mat4 matrix by multiplying every element within it by the float. The operation modifies the input matrix in place, and the function returns no value.",
        "code_id": "c_group_2_id_224",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_scale_p(mat4 m, float s) {\n  m[0][0] *= s; m[0][1] *= s; m[0][2] *= s; m[0][3] *= s;\n  m[1][0] *= s; m[1][1] *= s; m[1][2] *= s; m[1][3] *= s;\n  m[2][0] *= s; m[2][1] *= s; m[2][2] *= s; m[2][3] *= s;\n  m[3][0] *= s; m[3][1] *= s; m[3][2] *= s; m[3][3] *= s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_225",
        "query_text": "SUMMARY: This function accepts two input parameters, each of type vec2 (a float array of two elements), and returns a float. It calculates and outputs a scalar value by computing the difference between the product of the first element of the first input and the second element of the second input, and the product of the second element of the first input and the first element of the second input.",
        "code_id": "c_group_2_id_225",
        "code_text": "CGLM_INLINE\nfloat\nglm_vec2_cross(vec2 a, vec2 b) {\n  /* just calculate the z-component */\n  return a[0] * b[1] - a[1] * b[0];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_226",
        "query_text": "SUMMARY: This function accepts an input of type a three-element array of float values (vec3) and produces an output of the same type. It computes the absolute value of each of the three float components in the input array and assigns these computed values into the corresponding positions of the output array. Line by line, the function applies a floating-point absolute value operation individually to each of the three elements.",
        "code_id": "c_group_2_id_226",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_abs(vec3 v, vec3 dest) {\n  dest[0] = fabsf(v[0]);\n  dest[1] = fabsf(v[1]);\n  dest[2] = fabsf(v[2]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_227",
        "query_text": "SUMMARY: This function takes an input of type mat3 (a 3x3 matrix of floats) and uses it to initialize the top-left 3x3 portion of an output of type mat4 (a 4x4 matrix of floats). Specifically, each element of the 3x3 input matrix is copied into the corresponding position in the 4x4 output matrix from the first row and column up to the third, leaving the rest of the output matrix unaffected.",
        "code_id": "c_group_2_id_227",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_ins3(mat3 mat, mat4 dest) {\n  dest[0][0] = mat[0][0];\n  dest[0][1] = mat[0][1];\n  dest[0][2] = mat[0][2];\n\n  dest[1][0] = mat[1][0];\n  dest[1][1] = mat[1][1];\n  dest[1][2] = mat[1][2];\n\n  dest[2][0] = mat[2][0];\n  dest[2][1] = mat[2][1];\n  dest[2][2] = mat[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_228",
        "query_text": "SUMMARY: This function takes an input of a 3-element array of floats and a scalar float, and produces an output of a 3-element array of floats where each element is the result of multiplying the corresponding element of the input array by the scalar. The function multiplies the first element by the scalar, then the second, and finally the third, storing each result in the output array.",
        "code_id": "c_group_2_id_228",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_scale(vec3 v, float s, vec3 dest) {\n  dest[0] = v[0] * s;\n  dest[1] = v[1] * s;\n  dest[2] = v[2] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_229",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (type: mat4) and a float (type: float) as input, and it outputs a modified 4\u00d74 matrix. It adjusts the perspective projection parameters by recalculating the near and far plane distances based on specific entries in the input matrix and an additional scalar offset. The function then updates particular entries of the matrix to effectively shift the far plane position further along the depth axis for a right-handed coordinate system with a zero-to-one depth range.",
        "code_id": "c_group_2_id_229",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_move_far_rh_zo(mat4 proj, float deltaFar) {\n  float fn, farZ, nearZ, p22, p32;\n\n  p22        = proj[2][2];\n  p32        = proj[3][2];\n\n  nearZ    = p32 / p22;\n  farZ     = p32 / (p22 + 1.0f) + deltaFar;\n  fn         = 1.0f / (nearZ - farZ);\n\n  proj[2][2] = farZ * fn;\n  proj[3][2] = nearZ * farZ * fn;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_230",
        "query_text": "SUMMARY: This function converts a set of Euler angles (an input of type vec3, i.e. an array of three floats) into a quaternion (an output of type versor, i.e. an array of four floats) based on a right-handed coordinate system using the ZXY rotation order. It computes the sine and cosine for half of each Euler angle and then combines these intermediate results to produce the four components of the quaternion representing the equivalent rotation.",
        "code_id": "c_group_2_id_230",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_zxy_quat_rh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs = sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys = sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] = zc * xs * yc - zs * xc * ys;\n  dest[1] = zc * xc * ys + zs * xs * yc;\n  dest[2] = zc * xs * ys + zs * xc * yc;\n  dest[3] = zc * xc * yc - zs * xs * ys;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_231",
        "query_text": "SUMMARY: This function accepts as input a 3-element floating\u2010point vector (vec3) representing Euler angles (assumed in zxy order) and produces as output a 4\u00d74 floating\u2010point matrix (mat4) that represents the corresponding rotation transformation. It computes the sine and cosine values for each angle, evaluates intermediate products based on these trigonometric results, and uses them to assemble the rotation matrix. The output matrix is structured as a homogeneous transformation matrix\u2014with the rotational submatrix in its upper 3\u00d73 portion and the remainder set to form the identity in terms of translation and scaling.",
        "code_id": "c_group_2_id_231",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_zxy(vec3 angles, mat4 dest) {\n  float cx, cy, cz,\n        sx, sy, sz, cycz, sxsy, cysz;\n\n  sx   = sinf(angles[0]); cx = cosf(angles[0]);\n  sy   = sinf(angles[1]); cy = cosf(angles[1]);\n  sz   = sinf(angles[2]); cz = cosf(angles[2]);\n\n  cycz = cy * cz;\n  sxsy = sx * sy;\n  cysz = cy * sz;\n\n  dest[0][0] =  cycz - sxsy * sz;\n  dest[0][1] =  cz * sxsy + cysz;\n  dest[0][2] = -cx * sy;\n  dest[1][0] = -cx * sz;\n  dest[1][1] =  cx * cz;\n  dest[1][2] =  sx;\n  dest[2][0] =  cz * sy + cysz * sx;\n  dest[2][1] = -cycz * sx + sy * sz;\n  dest[2][2] =  cx * cy;\n  dest[0][3] =  0.0f;\n  dest[1][3] =  0.0f;\n  dest[2][3] =  0.0f;\n  dest[3][0] =  0.0f;\n  dest[3][1] =  0.0f;\n  dest[3][2] =  0.0f;\n  dest[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_232",
        "query_text": "SUMMARY: The function accepts two 2-element arrays of integers as input and a 2-element array of integers as output. It subtracts the sum of the corresponding elements of the input arrays from the corresponding elements in the output array. Specifically, it decreases the first element of the output by the sum of the first elements from both inputs and does the same for the second element.",
        "code_id": "c_group_2_id_232",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_addsub(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] -= a[0] + b[0];\n  dest[1] -= a[1] + b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_233",
        "query_text": "SUMMARY: This function accepts a 4x4 floating point matrix (mat4) and a floating point value (float) as inputs and produces no direct output (void). It modifies the received matrix by adding the provided float value to the element located at the fourth row and second column, thereby adjusting the y-direction translation component of the matrix.",
        "code_id": "c_group_2_id_233",
        "code_text": "CGLM_INLINE\nvoid\nglm_translated_y(mat4 m, float y) {\n  m[3][1] += y;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_234",
        "query_text": "SUMMARY: This function converts a set of three Euler angles (input as a vec3, which is an array of three floats) into a quaternion representation (output as a versor, which is an array of four floats) for a left-handed coordinate system using a YZX rotation order. The function begins by computing the half-angle sine and cosine values for each of the three input angles\u2014modifying the third component by inverting the sine to accommodate the left-handed system. It then combines these trigonometric values in a specific manner to calculate the four components of the quaternion, representing the rotation defined by the original Euler angles.",
        "code_id": "c_group_2_id_234",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_yzx_quat_lh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs =  sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys =  sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = -sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] = yc * zc * xs + ys * zs * xc;\n  dest[1] = yc * zs * xs + ys * zc * xc;\n  dest[2] = yc * zs * xc - ys * zc * xs;\n  dest[3] = yc * zc * xc - ys * zs * xs;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_235",
        "query_text": "SUMMARY: This function takes as input a 3\u00d73 matrix (of type float[3][3]) and a floating-point value representing an angle. It modifies the matrix in place by applying a 2D rotation transformation based on the given angle. Internally, it calculates the sine and cosine of the angle and updates the matrix\u2019s first two rows to represent the rotated coordinates, leaving the remainder of the matrix unchanged. The output is the transformed 3\u00d73 matrix.",
        "code_id": "c_group_2_id_235",
        "code_text": "CGLM_INLINE\nvoid\nglm_rotate2d(mat3 m, float angle) {\n  float m00 = m[0][0],  m10 = m[1][0],\n        m01 = m[0][1],  m11 = m[1][1],\n        m02 = m[0][2],  m12 = m[1][2];\n  float c, s;\n\n  s = sinf(angle);\n  c = cosf(angle);\n  \n  m[0][0] = m00 * c + m10 * s;\n  m[0][1] = m01 * c + m11 * s;\n  m[0][2] = m02 * c + m12 * s;\n\n  m[1][0] = m00 * -s + m10 * c;\n  m[1][1] = m01 * -s + m11 * c;\n  m[1][2] = m02 * -s + m12 * c;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_236",
        "query_text": "SUMMARY: This function takes a two-element integer array (ivec2) and an integer scalar as inputs, and it produces a two-element integer array as output. It adds the scalar value to each element of the input array and stores the results in the output array.",
        "code_id": "c_group_2_id_236",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_adds(ivec2 v, int s, ivec2 dest) {\n  dest[0] = v[0] + s;\n  dest[1] = v[1] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_237",
        "query_text": "SUMMARY: This function accepts two input variables and one output variable, each being a 3-element array of floats (vec3). It updates every component of the output array by subtracting the combined sum of the corresponding components from the two input arrays. Specifically, for each of the three positions, the function deducts the sum of the respective float values from the input arrays from the float value at the corresponding position in the output array.",
        "code_id": "c_group_2_id_237",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_addsub(vec3 a, vec3 b, vec3 dest) {\n  dest[0] -= a[0] + b[0];\n  dest[1] -= a[1] + b[1];\n  dest[2] -= a[2] + b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_238",
        "query_text": "SUMMARY: The function receives an input of type const float* (an array of consecutive floating\u2010point numbers) and produces an output of type mat2x3 (a 2-element array where each element is a 3-element float vector). It constructs a 2\u00d73 matrix by assigning the first three floats from the input to populate the first row (3-element vector) of the matrix and the next three floats to the second row.",
        "code_id": "c_group_2_id_238",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x3_make(const float * __restrict src, mat2x3 dest) {\n  dest[0][0] = src[0];\n  dest[0][1] = src[1];\n  dest[0][2] = src[2];\n\n  dest[1][0] = src[3];\n  dest[1][1] = src[4];\n  dest[1][2] = src[5];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_239",
        "query_text": "SUMMARY: This function takes an input of type vec2 (an array of 2 floats representing a complex number with a real and an imaginary part) and produces an output of the same type. It computes the conjugate of the complex number represented by the input, maintaining the real component unchanged while negating the imaginary component. Specifically, it assigns the first element of the input to the first element of the output and assigns the negative of the second element of the input to the second element of the output.",
        "code_id": "c_group_2_id_239",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_complex_conjugate(vec2 a, vec2 dest) {\n  dest[0] =  a[0];\n  dest[1] = -a[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_240",
        "query_text": "SUMMARY: This function accepts as inputs an array consisting of two three-dimensional vectors (each vector is a float[3]), a constant character pointer (serving as an optional tag), and an output stream pointer of type FILE*. Its output is void. The function prints a formatted representation of an axis\u2010aligned bounding box by displaying the two 3D vectors (typically representing the minimum and maximum corners) to the given output stream. It begins by printing a header that includes the provided tag (or a default string if none is provided) with specific color formatting. Then, for each of the two vectors, it prints their three float components using a conditional format based on the magnitude of the value\u2014using a fixed decimal precision for smaller numbers or a general format otherwise. Finally, it concludes by resetting the color format.",
        "code_id": "c_group_2_id_240",
        "code_text": "CGLM_INLINE\nvoid\nglm_aabb_print(vec3                    bbox[2],\n               const char * __restrict tag,\n               FILE       * __restrict ostream) {\n  int i, j;\n\n#define m 3\n\n  fprintf(ostream, \"AABB (%s): \" CGLM_PRINT_COLOR \"\\n\", tag ? tag: \"float\");\n\n  for (i = 0; i < 2; i++) {\n    fprintf(ostream, \"  (\");\n\n    for (j = 0; j < m; j++) {\n      if (bbox[i][j] < CGLM_PRINT_MAX_TO_SHORT)\n        fprintf(ostream, \" % .*f\", CGLM_PRINT_PRECISION, (double)bbox[i][j]);\n      else\n        fprintf(ostream, \" % g\", (double)bbox[i][j]);\n    }\n\n    fprintf(ostream, \"  )\\n\");\n  }\n\n  fprintf(ostream, CGLM_PRINT_COLOR_RESET \"\\n\");\n\n#undef m\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_241",
        "query_text": "SUMMARY: This function converts a 3\u00d73 rotation matrix (input type: an array of three 3-element float vectors) into a quaternion (output type: a 4-element aligned float vector). It first computes the sum of the three diagonal elements of the matrix and then, based on whether this trace is nonnegative or if one of the specific diagonal elements is dominant, it selects one of several computation paths. Each path calculates a scaling factor from the square root of an expression involving the trace or a diagonal element, and then uses this factor to compute the four components of the quaternion from specific differences and sums of the matrix\u2019s off-diagonal elements.",
        "code_id": "c_group_2_id_241",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3_quat(mat3 m, versor dest) {\n  float trace, r, rinv;\n\n  /* it seems using like m12 instead of m[1][2] causes extra instructions */\n\n  trace = m[0][0] + m[1][1] + m[2][2];\n  if (trace >= 0.0f) {\n    r       = sqrtf(1.0f + trace);\n    rinv    = 0.5f / r;\n\n    dest[0] = rinv * (m[1][2] - m[2][1]);\n    dest[1] = rinv * (m[2][0] - m[0][2]);\n    dest[2] = rinv * (m[0][1] - m[1][0]);\n    dest[3] = r    * 0.5f;\n  } else if (m[0][0] >= m[1][1] && m[0][0] >= m[2][2]) {\n    r       = sqrtf(1.0f - m[1][1] - m[2][2] + m[0][0]);\n    rinv    = 0.5f / r;\n\n    dest[0] = r    * 0.5f;\n    dest[1] = rinv * (m[0][1] + m[1][0]);\n    dest[2] = rinv * (m[0][2] + m[2][0]);\n    dest[3] = rinv * (m[1][2] - m[2][1]);\n  } else if (m[1][1] >= m[2][2]) {\n    r       = sqrtf(1.0f - m[0][0] - m[2][2] + m[1][1]);\n    rinv    = 0.5f / r;\n\n    dest[0] = rinv * (m[0][1] + m[1][0]);\n    dest[1] = r    * 0.5f;\n    dest[2] = rinv * (m[1][2] + m[2][1]);\n    dest[3] = rinv * (m[2][0] - m[0][2]);\n  } else {\n    r       = sqrtf(1.0f - m[0][0] - m[1][1] + m[2][2]);\n    rinv    = 0.5f / r;\n\n    dest[0] = rinv * (m[0][2] + m[2][0]);\n    dest[1] = rinv * (m[1][2] + m[2][1]);\n    dest[2] = r    * 0.5f;\n    dest[3] = rinv * (m[0][1] - m[1][0]);\n  }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_242",
        "query_text": "SUMMARY: This function takes a 3-element float array (vec3) and a 4x4 matrix of float values (mat4) as inputs and returns a float. It calculates a transformed depth value by performing two separate dot products between the input vector and specific columns of the matrix, then divides the result of the first computation by that of the second. Essentially, it projects the input 3D coordinate onto the depth axis within a normalized (0 to 1) space using transformation and perspective division.",
        "code_id": "c_group_2_id_242",
        "code_text": "CGLM_INLINE\nfloat\nglm_project_z_zo(vec3 v, mat4 m) {\n  float z, w;\n\n  z = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2];\n  w = m[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3];\n\n  return z / w;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_243",
        "query_text": "SUMMARY: This function takes as input a 4x4 matrix of floats (mat4) representing a perspective projection and a pointer to a float (float*). It computes the near clipping distance by processing specific entries from the given matrix and then stores the resulting float value at the provided memory location.",
        "code_id": "c_group_2_id_243",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_near_lh_no(mat4 proj, float * __restrict nearZ) {\n  *nearZ = proj[3][2] / (-proj[2][2] - 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_244",
        "query_text": "SUMMARY: This function takes a two-element integer array and a single integer as inputs, and outputs a two-element integer array. It multiplies each element of the input array by the given scalar integer, then subtracts each resulting product from the corresponding element in the output array.",
        "code_id": "c_group_2_id_244",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_mulsubs(ivec2 a, int s, ivec2 dest) {\n  dest[0] -= a[0] * s;\n  dest[1] -= a[1] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_245",
        "query_text": "SUMMARY: This function decomposes a 4\u00d74 perspective projection matrix (input type: mat4, which is defined as an array of four 4-element float vectors) into its fundamental frustum parameters. It calculates and outputs the distances to the near and far clipping planes, as well as the top, bottom, left, and right boundaries of the viewing volume. The outputs are provided through pointers to floats (output type: float*). The function extracts specific elements from the matrix and uses arithmetic operations to derive these parameters, effectively reversing the projection transformation to yield the frustum dimensions.",
        "code_id": "c_group_2_id_245",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_rh_zo(mat4 proj,\n                    float * __restrict nearZ, float * __restrict farZ,\n                    float * __restrict top,     float * __restrict bottom,\n                    float * __restrict left,    float * __restrict right) {\n  float m00, m11, m20, m21, m22, m32, n, f;\n  float n_m11, n_m00;\n\n  m00 = proj[0][0];\n  m11 = proj[1][1];\n  m20 = proj[2][0];\n  m21 = proj[2][1];\n  m22 = proj[2][2];\n  m32 = proj[3][2];\n\n  n = m32 / m22;\n  f = m32 / (m22 + 1.0f);\n\n  n_m11 = n / m11;\n  n_m00 = n / m00;\n\n  *nearZ = n;\n  *farZ  = f;\n  *bottom  = n_m11 * (m21 - 1.0f);\n  *top     = n_m11 * (m21 + 1.0f);\n  *left    = n_m00 * (m20 - 1.0f);\n  *right   = n_m00 * (m20 + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_246",
        "query_text": "SUMMARY: This function accepts two inputs of type ivec2 (arrays of two integers) and computes a single integer output. It calculates the dot product by multiplying the first element of the first input with the first element of the second input and then adding the product of the second elements from both inputs.",
        "code_id": "c_group_2_id_246",
        "code_text": "CGLM_INLINE\nint\nglm_ivec2_dot(ivec2 a, ivec2 b) {\n  return a[0] * b[0] + a[1] * b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_247",
        "query_text": "SUMMARY: This function takes an input of type int[2] and produces an output of type int[2]. It computes the absolute value of each element in the input array and assigns these computed absolute values to the corresponding elements in the output array. Specifically, it applies the absolute value operation individually to the first and second elements of the input.",
        "code_id": "c_group_2_id_247",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_abs(ivec2 v, ivec2 dest) {\n  dest[0] = abs(v[0]);\n  dest[1] = abs(v[1]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_248",
        "query_text": "SUMMARY: The function accepts two input vectors and one output vector, each defined as a 2-element array of floats (vec2). It updates the output vector by subtracting, from each element, the difference between the corresponding elements of the first and second input vectors. Specifically, for each index, the function decreases the current value in the output vector by the result of subtracting the second input\u2019s element from the first input\u2019s element.",
        "code_id": "c_group_2_id_248",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_subsub(vec2 a, vec2 b, vec2 dest) {\n  dest[0] -= a[0] - b[0];\n  dest[1] -= a[1] - b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_249",
        "query_text": "SUMMARY: The function takes a scalar (float) and a four-by-four matrix of floats (mat4) as inputs, modifying the matrix to update its horizontal scaling based on the given aspect ratio. It first checks a critical element in the matrix to determine if adjustment is required; if that element is zero, it returns without change. Otherwise, it recalculates that element using another scaling value from the matrix divided by the input scalar, thereby adjusting the perspective projection parameters accordingly.",
        "code_id": "c_group_2_id_249",
        "code_text": "CGLM_INLINE\nvoid\nglm_perspective_resize(float aspect, mat4 proj) {\n  if (proj[0][0] == 0.0f)\n    return;\n\n  proj[0][0] = proj[1][1] / aspect;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_250",
        "query_text": "SUMMARY: This function takes an input of type mat3x2 (an array of three 2-element float arrays) and produces an output of type mat2x3 (an array of two 3-element float arrays). It computes the transpose of the matrix by swapping the rows and columns, assigning each element from the input to the corresponding position in the output matrix.",
        "code_id": "c_group_2_id_250",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x2_transpose(mat3x2 m, mat2x3 dest) {\n  dest[0][0] = m[0][0];  dest[0][1] = m[1][0];  dest[0][2] = m[2][0];\n  dest[1][0] = m[0][1];  dest[1][1] = m[1][1];  dest[1][2] = m[2][1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_251",
        "query_text": "SUMMARY: This function accepts an input of type float[2] and produces an output of type float[2]. It computes the absolute value for each element of the input array and assigns these results to the corresponding elements of the output array.",
        "code_id": "c_group_2_id_251",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_abs(vec2 v, vec2 dest) {\n  dest[0] = fabsf(v[0]);\n  dest[1] = fabsf(v[1]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_252",
        "query_text": "SUMMARY: This function accepts an input of type mat4 (a 4\u00d74 matrix composed of vec4 elements) and produces an output of type mat3 (a 3\u00d73 matrix composed of vec3 elements). It extracts the top-left 3\u00d73 block from the 4\u00d74 matrix and assigns its elements to the output matrix in a transposed arrangement. Specifically, for each of the first three rows and columns, it maps the element from the column of the input to the row of the output, effectively transposing that 3\u00d73 portion.",
        "code_id": "c_group_2_id_252",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_pick3t(mat4 mat, mat3 dest) {\n  dest[0][0] = mat[0][0];\n  dest[0][1] = mat[1][0];\n  dest[0][2] = mat[2][0];\n\n  dest[1][0] = mat[0][1];\n  dest[1][1] = mat[1][1];\n  dest[1][2] = mat[2][1];\n\n  dest[2][0] = mat[0][2];\n  dest[2][1] = mat[1][2];\n  dest[2][2] = mat[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_253",
        "query_text": "SUMMARY: This function receives a 3-element integer array (type: int[3]) and a pointer to a file stream (type: FILE*) as inputs, and it outputs information to that stream. It formats and prints the vector elements by first indicating the vector's type and size, then listing each integer element with specified formatting (including color settings), and finally resetting the formatting. The function does not return any value.",
        "code_id": "c_group_2_id_253",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_print(ivec3             vec,\n                FILE * __restrict ostream) {\n  int i;\n\n#define m 3\n\n  fprintf(ostream, \"Vector (int%d): \" CGLM_PRINT_COLOR \"\\n  (\", m);\n\n  for (i = 0; i < m; i++)\n    fprintf(ostream, \" % d\", vec[i]);\n\n  fprintf(ostream, \"  )\" CGLM_PRINT_COLOR_RESET \"\\n\\n\");\n\n#undef m\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_254",
        "query_text": "SUMMARY: This function takes an input of type mat2x3 (which is defined as an array of 2 vectors, each being an array of 3 floats) and produces an output of the same type by copying the entire content of the input to the output. It sequentially copies each element from the first vector (3 floats) and then from the second vector (3 floats), ensuring that every float in the 2x3 matrix is duplicated in the destination.",
        "code_id": "c_group_2_id_254",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x3_copy(mat2x3 mat, mat2x3 dest) {\n  dest[0][0] = mat[0][0];\n  dest[0][1] = mat[0][1];\n  dest[0][2] = mat[0][2];\n\n  dest[1][0] = mat[1][0];\n  dest[1][1] = mat[1][1];\n  dest[1][2] = mat[1][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_255",
        "query_text": "SUMMARY: This function accepts an input and an output of type mat4 (an array of four vec4 arrays of float values, representing a 4\u00d74 matrix). It duplicates the matrix by copying each float element from the input matrix to its corresponding position in the output matrix. The process is implemented through explicit element-wise assignment for all rows and columns of the 4\u00d74 matrix.",
        "code_id": "c_group_2_id_255",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_ucopy(mat4 mat, mat4 dest) {\n  dest[0][0] = mat[0][0];  dest[1][0] = mat[1][0];\n  dest[0][1] = mat[0][1];  dest[1][1] = mat[1][1];\n  dest[0][2] = mat[0][2];  dest[1][2] = mat[1][2];\n  dest[0][3] = mat[0][3];  dest[1][3] = mat[1][3];\n\n  dest[2][0] = mat[2][0];  dest[3][0] = mat[3][0];\n  dest[2][1] = mat[2][1];  dest[3][1] = mat[3][1];\n  dest[2][2] = mat[2][2];  dest[3][2] = mat[3][2];\n  dest[2][3] = mat[2][3];  dest[3][3] = mat[3][3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_256",
        "query_text": "SUMMARY: This function accepts a 3\u00d73 matrix (type: mat3) and a 2-element vector (type: vec2) as inputs, and produces a 3\u00d73 matrix (type: mat3) as output. Its behavior involves scaling the first row of the input matrix by the first element of the 2-element vector and scaling the second row by the second element of the vector, while the third row remains unaltered, effectively applying a two-dimensional non-uniform scaling transformation to the matrix.",
        "code_id": "c_group_2_id_256",
        "code_text": "CGLM_INLINE\nvoid\nglm_scale2d_to(mat3 m, vec2 v, mat3 dest) {\n  dest[0][0] = m[0][0] * v[0];\n  dest[0][1] = m[0][1] * v[0];\n  dest[0][2] = m[0][2] * v[0];\n  \n  dest[1][0] = m[1][0] * v[1];\n  dest[1][1] = m[1][1] * v[1];\n  dest[1][2] = m[1][2] * v[1];\n  \n  dest[2][0] = m[2][0];\n  dest[2][1] = m[2][1];\n  dest[2][2] = m[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_257",
        "query_text": "SUMMARY: This function accepts an input of type mat2x4 (a two-element array where each element is a four-element float vector) and produces an output of type mat4x2 (a four-element array where each element is a two-element float vector). The function computes the transpose of a 2\u00d74 matrix by assigning each element from the corresponding position in the input matrix to its transposed position in the output matrix. Specifically, it maps elements from the rows of the input matrix into the columns of the output matrix, effectively rearranging the data to represent the transposed matrix.",
        "code_id": "c_group_2_id_257",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x4_transpose(mat2x4 m, mat4x2 dest) {\n  dest[0][0] = m[0][0];  dest[0][1] = m[1][0];\n  dest[1][0] = m[0][1];  dest[1][1] = m[1][1];\n  dest[2][0] = m[0][2];  dest[2][1] = m[1][2];\n  dest[3][0] = m[0][3];  dest[3][1] = m[1][3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_258",
        "query_text": "SUMMARY: The function accepts an input variable of type vec4 (an aligned array of 4 floats) and outputs a variable of the same type. It computes the square root of each of the four floating-point numbers in the input, storing the results in the corresponding positions of the output. The implementation automatically selects an optimized vectorized computation path based on the available hardware (using SIMD instructions for WebAssembly or SSE when available), and falls back to a scalar computation using the standard square root function if those are not present.",
        "code_id": "c_group_2_id_258",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_sqrt(vec4 v, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_sqrt(glmm_load(v)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_sqrt_ps(glmm_load(v)));\n#else\n  dest[0] = sqrtf(v[0]);\n  dest[1] = sqrtf(v[1]);\n  dest[2] = sqrtf(v[2]);\n  dest[3] = sqrtf(v[3]);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_259",
        "query_text": "SUMMARY: This function accepts a 3-element floating-point vector (type vec3) representing Euler angles and produces a 4\u00d74 floating-point matrix (type mat4) that encodes a rotation transformation. It computes the sine and cosine of the three angles, calculates specific product combinations of these trigonometric values, and then populates the upper-left 3\u00d73 submatrix with values defining the rotation in 3D space following a Y\u2013Z\u2013X sequence. The remaining matrix elements are set to form an identity in the homogeneous coordinate, ensuring the resulting matrix is suitable for use as a transformation matrix in 3D graphics.",
        "code_id": "c_group_2_id_259",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_yzx(vec3 angles, mat4 dest) {\n  float cx, cy, cz,\n        sx, sy, sz, sxsy, cxcy, cysx, cxsy;\n\n  sx   = sinf(angles[0]); cx = cosf(angles[0]);\n  sy   = sinf(angles[1]); cy = cosf(angles[1]);\n  sz   = sinf(angles[2]); cz = cosf(angles[2]);\n\n  sxsy = sx * sy;\n  cxcy = cx * cy;\n  cysx = cy * sx;\n  cxsy = cx * sy;\n\n  dest[0][0] =  cy * cz;\n  dest[0][1] =  sz;\n  dest[0][2] = -cz * sy;\n  dest[1][0] =  sxsy - cxcy * sz;\n  dest[1][1] =  cx * cz;\n  dest[1][2] =  cysx + cxsy * sz;\n  dest[2][0] =  cxsy + cysx * sz;\n  dest[2][1] = -cz * sx;\n  dest[2][2] =  cxcy - sxsy * sz;\n  dest[0][3] =  0.0f;\n  dest[1][3] =  0.0f;\n  dest[2][3] =  0.0f;\n  dest[3][0] =  0.0f;\n  dest[3][1] =  0.0f;\n  dest[3][2] =  0.0f;\n  dest[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_260",
        "query_text": "SUMMARY: This function operates on three arrays of two integers each. It performs an element-wise multiplication of the first two integer arrays and then subtracts each resulting product from the corresponding element in the output integer array.",
        "code_id": "c_group_2_id_260",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_mulsub(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] -= a[0] * b[0];\n  dest[1] -= a[1] * b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_261",
        "query_text": "SUMMARY: The function accepts an input of type vec3 (a 3-element array of floats) and produces an output of the same type, vec3. It computes the square root of each element in the input array and stores the results in the corresponding elements of the output array.",
        "code_id": "c_group_2_id_261",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_sqrt(vec3 v, vec3 dest) {\n  dest[0] = sqrtf(v[0]);\n  dest[1] = sqrtf(v[1]);\n  dest[2] = sqrtf(v[2]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_262",
        "query_text": "SUMMARY: This function takes an input of type \"const float *\" and an output of type \"mat4x2\" (an array of four \"vec2\" elements, where each \"vec2\" is an array of two floats). It sequentially assigns the eight consecutive float values from the input array into the four rows of the output matrix, mapping each pair of floats to the two elements of each row.",
        "code_id": "c_group_2_id_262",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x2_make(const float * __restrict src, mat4x2 dest) {\n  dest[0][0] = src[0];\n  dest[0][1] = src[1];\n\n  dest[1][0] = src[2];\n  dest[1][1] = src[3];\n\n  dest[2][0] = src[4];\n  dest[2][1] = src[5];\n\n  dest[3][0] = src[6];\n  dest[3][1] = src[7];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_263",
        "query_text": "SUMMARY: This function takes an input variable of type vec4 (an array of 4 floats with potential 16-byte alignment) and copies its contents to an output variable of the same type. The function conditionally uses architecture-specific SIMD instructions when available (such as those from WebAssembly, SSE, or NEON) to perform an efficient copy; otherwise, it falls back to copying each of the four float components individually.",
        "code_id": "c_group_2_id_263",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_copy(vec4 v, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, glmm_load(v));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, glmm_load(v));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vld1q_f32(v));\n#else\n  dest[0] = v[0];\n  dest[1] = v[1];\n  dest[2] = v[2];\n  dest[3] = v[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_264",
        "query_text": "SUMMARY: This function operates on three variables, each being an array of four integers. It takes two input arrays of integers, compares corresponding elements from both arrays, and populates an output array (also of four integers) with the smaller value from each pair.",
        "code_id": "c_group_2_id_264",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_minv(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] = a[0] < b[0] ? a[0] : b[0];\n  dest[1] = a[1] < b[1] ? a[1] : b[1];\n  dest[2] = a[2] < b[2] ? a[2] : b[2];\n  dest[3] = a[3] < b[3] ? a[3] : b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_265",
        "query_text": "SUMMARY: This function takes a 3-element array of floats (representing Euler angles) as input and computes a 4-element array of floats (representing a quaternion) as output. Specifically, it calculates the sine and cosine of half of each Euler angle, with the third angle\u2019s sine negated to accommodate a left-handed coordinate system. It then combines these half-angle trigonometric values using fixed multiplications and additions to form a quaternion that corresponds to an XZY rotation order.",
        "code_id": "c_group_2_id_265",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_xzy_quat_lh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs =  sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys =  sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = -sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] = -xc * zs * ys + xs * zc * yc;\n  dest[1] =  xc * zc * ys - xs * zs * yc;\n  dest[2] =  xc * zs * yc + xs * zc * ys;\n  dest[3] =  xc * zc * yc + xs * zs * ys;  \n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_266",
        "query_text": "SUMMARY: This function accepts a scalar input of type float and an output matrix of type mat4 (a 4\u00d74 array of floats). It adjusts the perspective projection values within the provided matrix by modifying one of its elements: if the matrix's top-left element is nonzero, it is replaced with the value derived from dividing another specific matrix element (from the second row, second column) by the input float, thereby recalibrating the projection based on the aspect ratio.",
        "code_id": "c_group_2_id_266",
        "code_text": "CGLM_INLINE\nvoid\nglm_perspective_resize_rh_zo(float aspect, mat4 proj) {\n  if (proj[0][0] == 0.0f)\n    return;\n\n  proj[0][0] = proj[1][1] / aspect;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_267",
        "query_text": "SUMMARY: This function performs a component-wise subtraction between two two-element integer arrays (type: int[2]), storing the result in a third integer array (type: int[2]). It subtracts the first element of the second array from the first element of the first array and similarly subtracts the second element of the second array from the second element of the first array.",
        "code_id": "c_group_2_id_267",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_sub(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] = a[0] - b[0];\n  dest[1] = a[1] - b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_268",
        "query_text": "SUMMARY: This function accepts two inputs of type integer array of size 3 (representing 3-dimensional integer vectors) and computes, for each of the three positions, the smaller of the corresponding integers. The resulting set of three minimum integers is then stored in an output variable, which is also a 3-element integer array.",
        "code_id": "c_group_2_id_268",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_minv(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] = a[0] < b[0] ? a[0] : b[0];\n  dest[1] = a[1] < b[1] ? a[1] : b[1];\n  dest[2] = a[2] < b[2] ? a[2] : b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_269",
        "query_text": "SUMMARY: This function receives as input a 3x3 transformation matrix (a matrix consisting of three 3-element float arrays) and a 2D translation vector (an array of two floats). It updates the matrix in place by modifying its bottom row. Specifically, for each element in the bottom row, it adds a weighted sum of the corresponding top-row entries\u2014where the weights are the translation vector\u2019s float components\u2014to the existing bottom row value. The function does not return a value.",
        "code_id": "c_group_2_id_269",
        "code_text": "CGLM_INLINE\nvoid\nglm_translate2d(mat3 m, vec2 v) {\n  m[2][0] = m[0][0] * v[0] + m[1][0] * v[1] + m[2][0];\n  m[2][1] = m[0][1] * v[0] + m[1][1] * v[1] + m[2][1];\n  m[2][2] = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_270",
        "query_text": "SUMMARY: This function takes two inputs\u2014a 4-element array of floating-point numbers (vec4) and a standard I/O stream pointer of type FILE*\u2014and produces no output value (void). It formats and prints the elements of the 4-element vector to the provided output stream. Specifically, it writes a header indicating that the content is a vector of four floats, then iterates over the four elements, printing each with formatting that adapts based on the magnitude of the number, and finally appends formatting to reset any applied text colors.",
        "code_id": "c_group_2_id_270",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_print(vec4              vec,\n               FILE * __restrict ostream) {\n  int i;\n\n#define m 4\n\n  fprintf(ostream, \"Vector (float%d): \" CGLM_PRINT_COLOR \"\\n  (\", m);\n\n  for (i = 0; i < m; i++) {\n    if (vec[i] < CGLM_PRINT_MAX_TO_SHORT)\n      fprintf(ostream, \" % .*f\", CGLM_PRINT_PRECISION, (double)vec[i]);\n    else\n      fprintf(ostream, \" % g\", (double)vec[i]);\n  }\n\n  fprintf(ostream, \"  )\" CGLM_PRINT_COLOR_RESET \"\\n\\n\");\n\n#undef m\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_271",
        "query_text": "SUMMARY: This function multiplies two matrices to produce a 2\u00d72 matrix. It takes as inputs a matrix of type mat4x2 (an array of four 2-element float vectors, representing a 2\u00d74 matrix in column-major format) and a matrix of type mat2x4 (an array of two 4-element float vectors, representing a 4\u00d72 matrix in column-major format). The function computes each element of the output matrix (of type mat2, which is an array of two 2-element float vectors, representing a 2\u00d72 matrix) by calculating the dot products between corresponding rows (derived from the columns of the first input) and columns (derived from the columns of the second input).",
        "code_id": "c_group_2_id_271",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x2_mul(mat4x2 m1, mat2x4 m2, mat2 dest) {\n  float a00 = m1[0][0], a01 = m1[0][1],\n        a10 = m1[1][0], a11 = m1[1][1],\n        a20 = m1[2][0], a21 = m1[2][1],\n        a30 = m1[3][0], a31 = m1[3][1],\n\n        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2], b03 = m2[0][3],\n        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2], b13 = m2[1][3];\n\n  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n\n  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_272",
        "query_text": "SUMMARY: This function accepts a 3-element float array (vec3) representing Euler angles (in radians) and produces a 4\u00d74 float matrix (mat4) that encodes the corresponding rotation transformation. It computes the sine and cosine of each Euler angle, combines these trigonometric results into intermediate values, and assigns them to specific elements in the matrix to construct a homogeneous rotation matrix based on rotations about the X, Y, and Z axes.",
        "code_id": "c_group_2_id_272",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_xyz(vec3 angles, mat4 dest) {\n  float cx, cy, cz,\n        sx, sy, sz, czsx, cxcz, sysz;\n\n  sx   = sinf(angles[0]); cx = cosf(angles[0]);\n  sy   = sinf(angles[1]); cy = cosf(angles[1]);\n  sz   = sinf(angles[2]); cz = cosf(angles[2]);\n\n  czsx = cz * sx;\n  cxcz = cx * cz;\n  sysz = sy * sz;\n\n  dest[0][0] =  cy * cz;\n  dest[0][1] =  czsx * sy + cx * sz;\n  dest[0][2] = -cxcz * sy + sx * sz;\n  dest[1][0] = -cy * sz;\n  dest[1][1] =  cxcz - sx * sysz;\n  dest[1][2] =  czsx + cx * sysz;\n  dest[2][0] =  sy;\n  dest[2][1] = -cy * sx;\n  dest[2][2] =  cx * cy;\n  dest[0][3] =  0.0f;\n  dest[1][3] =  0.0f;\n  dest[2][3] =  0.0f;\n  dest[3][0] =  0.0f;\n  dest[3][1] =  0.0f;\n  dest[3][2] =  0.0f;\n  dest[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_273",
        "query_text": "SUMMARY: This function takes a 3-element floating\u2010point array (vec3) representing Euler angles and computes a 4\u00d74 floating\u2010point matrix (mat4) that represents a rotation transformation. It first calculates the sine and cosine for each of the three angles and then uses their combinations to form the components of the rotation matrix according to an XZY rotation order. Finally, it ensures that the matrix is in homogeneous form by setting the appropriate elements for translation and scaling (with the bottom row having [0, 0, 0, 1]).",
        "code_id": "c_group_2_id_273",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_xzy(vec3 angles, mat4 dest) {\n  float cx, cy, cz,\n  sx, sy, sz, sxsy, cysx, cxsy, cxcy;\n\n  sx   = sinf(angles[0]); cx = cosf(angles[0]);\n  sy   = sinf(angles[1]); cy = cosf(angles[1]);\n  sz   = sinf(angles[2]); cz = cosf(angles[2]);\n\n  sxsy = sx * sy;\n  cysx = cy * sx;\n  cxsy = cx * sy;\n  cxcy = cx * cy;\n\n  dest[0][0] =  cy * cz;\n  dest[0][1] =  sxsy + cxcy * sz;\n  dest[0][2] = -cxsy + cysx * sz;\n  dest[1][0] = -sz;\n  dest[1][1] =  cx * cz;\n  dest[1][2] =  cz * sx;\n  dest[2][0] =  cz * sy;\n  dest[2][1] = -cysx + cxsy * sz;\n  dest[2][2] =  cxcy + sxsy * sz;\n  dest[0][3] =  0.0f;\n  dest[1][3] =  0.0f;\n  dest[2][3] =  0.0f;\n  dest[3][0] =  0.0f;\n  dest[3][1] =  0.0f;\n  dest[3][2] =  0.0f;\n  dest[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_274",
        "query_text": "SUMMARY: This function accepts an input of a 4\u00d74 matrix of floats (mat4) representing a right-handed perspective projection and computes six frustum parameters, outputting them as float values via pointer arguments. Specifically, it calculates the near and far plane distances as well as the top, bottom, left, and right boundaries of the view frustum based on the elements of the input matrix, and then stores these computed values in the provided float pointers.",
        "code_id": "c_group_2_id_274",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_rh_no(mat4 proj,\n                       float * __restrict nearZ, float * __restrict farZ,\n                       float * __restrict top,     float * __restrict bottom,\n                       float * __restrict left,    float * __restrict right) {\n  float m00, m11, m20, m21, m22, m32, n, f;\n  float n_m11, n_m00;\n\n  m00 = proj[0][0];\n  m11 = proj[1][1];\n  m20 = proj[2][0];\n  m21 = proj[2][1];\n  m22 = proj[2][2];\n  m32 = proj[3][2];\n\n  n = m32 / (m22 - 1.0f);\n  f = m32 / (m22 + 1.0f);\n\n  n_m11 = n / m11;\n  n_m00 = n / m00;\n\n  *nearZ = n;\n  *farZ  = f;\n  *bottom  = n_m11 * (m21 - 1.0f);\n  *top     = n_m11 * (m21 + 1.0f);\n  *left    = n_m00 * (m20 - 1.0f);\n  *right   = n_m00 * (m20 + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_275",
        "query_text": "SUMMARY: This function accepts a 2\u00d72 matrix of 2-element floating\u2010point arrays (a 2\u00d72 float matrix with potential 16\u2011byte alignment) and a pointer to a FILE stream as its inputs, and it produces no output (void return type). Its purpose is to print the matrix in a formatted and human-readable way. Initially, it writes a header stating the type and dimensions of the matrix, then it calculates the appropriate column widths for each matrix element based on a chosen precision and a threshold that decides between fixed-point and general formatting. Finally, it prints each row of the matrix with the elements right\u2010aligned using the determined widths, ensuring the output is neatly formatted within decorative boundary characters, and resets any applied formatting at the end.",
        "code_id": "c_group_2_id_275",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2_print(mat2              matrix,\n               FILE * __restrict ostream) {\n  char buff[16];\n  int  i, j, cw[4], cwi;\n\n#define m 2\n#define n 2\n\n  fprintf(ostream, \"Matrix (float%dx%d): \" CGLM_PRINT_COLOR \"\\n\", m, n);\n\n  cw[0] = cw[1] = 0;\n\n  for (i = 0; i < m; i++) {\n    for (j = 0; j < n; j++) {\n      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)\n        cwi = snprintf(buff, sizeof(buff), \"% .*f\", CGLM_PRINT_PRECISION, (double)matrix[i][j]);\n      else\n        cwi = snprintf(buff, sizeof(buff), \"% g\", (double)matrix[i][j]);\n      cw[i] = GLM_MAX(cw[i], cwi);\n    }\n  }\n\n  for (i = 0; i < m; i++) {\n    fprintf(ostream, \"  |\");\n\n    for (j = 0; j < n; j++)\n      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)\n        fprintf(ostream, \" % *.*f\", cw[j], CGLM_PRINT_PRECISION, (double)matrix[j][i]);\n      else\n        fprintf(ostream, \" % *g\", cw[j], (double)matrix[j][i]);\n\n    fprintf(ostream, \"  |\\n\");\n  }\n\n  fprintf(ostream, CGLM_PRINT_COLOR_RESET \"\\n\");\n\n#undef m\n#undef n\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_276",
        "query_text": "SUMMARY: This function takes as input a 4-element float array (type vec4) and a single float scalar, and produces an output 4-element float array (type vec4). Its behavior is to add the scalar to each component of the input array and store the resulting values in the output array. The implementation optimizes this addition using platform-specific SIMD operations when available, but the core functionality remains adding the scalar value to every element of the input vector.",
        "code_id": "c_group_2_id_276",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_adds(vec4 v, float s, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_add(glmm_load(v), wasm_f32x4_splat(s)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_add_ps(glmm_load(v), _mm_set1_ps(s)));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vaddq_f32(vld1q_f32(v), vdupq_n_f32(s)));\n#else\n  dest[0] = v[0] + s;\n  dest[1] = v[1] + s;\n  dest[2] = v[2] + s;\n  dest[3] = v[3] + s;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_277",
        "query_text": "SUMMARY: The function accepts an input of type \"mat4\" (a 4x4 matrix composed of four float[4] vectors) and an output pointer of type \"float*\". It extracts a specific element from the projection matrix and uses it, along with another matrix element, to calculate the value representing the far clipping plane distance, which is then stored via the provided float pointer.",
        "code_id": "c_group_2_id_277",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_far_rh_zo(mat4 proj, float * __restrict farZ) {\n  *farZ = proj[3][2] / (proj[2][2] + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_278",
        "query_text": "SUMMARY: This function converts a set of Euler angles into a quaternion using a right-handed coordinate system. It accepts as input a three-element floating\u2011point array (vec3) representing the Euler angles and produces as output a four-element floating\u2011point array (versor) representing the quaternion. The function computes the sine and cosine of half each Euler angle and then combines these intermediate values to form the quaternion components.",
        "code_id": "c_group_2_id_278",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_zyx_quat_rh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs = sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys = sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] =  zc * yc * xs - zs * ys * xc;\n  dest[1] =  zc * ys * xc + zs * yc * xs;\n  dest[2] = -zc * ys * xs + zs * yc * xc;\n  dest[3] =  zc * yc * xc + zs * ys * xs;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_279",
        "query_text": "SUMMARY: This function accepts two input arrays of three floats each and modifies a third array of three floats. For each of the three components, it sums the corresponding float from each of the two input arrays and then adds this sum to the corresponding component in the output array. The function operates in-place on the output array without returning a value.",
        "code_id": "c_group_2_id_279",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_addadd(vec3 a, vec3 b, vec3 dest) {\n  dest[0] += a[0] + b[0];\n  dest[1] += a[1] + b[1];\n  dest[2] += a[2] + b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_280",
        "query_text": "SUMMARY: This function receives three parameters: an input array of 4 integers (ivec4), an integer scalar, and an output array of 4 integers (ivec4). It multiplies each element of the input array by the scalar and then adds the resulting product to the corresponding element of the output array, executing these operations component-wise.",
        "code_id": "c_group_2_id_280",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_muladds(ivec4 a, int s, ivec4 dest) {\n  dest[0] += a[0] * s;\n  dest[1] += a[1] * s;\n  dest[2] += a[2] * s;\n  dest[3] += a[3] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_281",
        "query_text": "SUMMARY: This function accepts two input parameters of type integer array with 2 elements each and a destination output parameter of the same type. It computes the product of the first element from each of the input arrays and adds the result to the first element of the destination array, then does the same for the second element.",
        "code_id": "c_group_2_id_281",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_muladd(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] += a[0] * b[0];\n  dest[1] += a[1] * b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_282",
        "query_text": "SUMMARY: This function accepts two input parameters of type vec3 (an array of 3 floats) and produces no direct return value. It copies the three floating-point numbers from the source array (input type: vec3) into the destination array (output type: vec3) by individually assigning each corresponding element, effectively duplicating the entire 3-component vector.",
        "code_id": "c_group_2_id_282",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_copy(vec3 a, vec3 dest) {\n  dest[0] = a[0];\n  dest[1] = a[1];\n  dest[2] = a[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_283",
        "query_text": "SUMMARY: This function takes as inputs a matrix of type mat3 (a 3\u00d73 array of floats) and a scalar of type float. Its purpose is to scale the matrix by the given scalar factor. Line by line, each element of the 3\u00d73 matrix is multiplied by the scalar, modifying the matrix in place. There is no explicit output since the transformation occurs directly on the provided matrix.",
        "code_id": "c_group_2_id_283",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3_scale(mat3 m, float s) {\n  m[0][0] *= s; m[0][1] *= s; m[0][2] *= s;\n  m[1][0] *= s; m[1][1] *= s; m[1][2] *= s;\n  m[2][0] *= s; m[2][1] *= s; m[2][2] *= s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_284",
        "query_text": "SUMMARY: This function accepts two 4-element arrays of integers (type: ivec4) and returns an integer (type: int). It computes the squared Euclidean distance between the two 4-dimensional integer vectors by subtracting corresponding components, squaring each difference, and summing the squared values.",
        "code_id": "c_group_2_id_284",
        "code_text": "CGLM_INLINE\nint\nglm_ivec4_distance2(ivec4 a, ivec4 b) {\n  int xd, yd, zd, wd;\n  xd = a[0] - b[0];\n  yd = a[1] - b[1];\n  zd = a[2] - b[2];\n  wd = a[3] - b[3];\n  return xd * xd + yd * yd + zd * zd + wd * wd;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_285",
        "query_text": "SUMMARY: This function accepts two inputs, each being an array of three integers (ivec3), multiplies their corresponding elements, sums these products, and returns the resulting sum as an integer.",
        "code_id": "c_group_2_id_285",
        "code_text": "CGLM_INLINE\nint\nglm_ivec3_dot(ivec3 a, ivec3 b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_286",
        "query_text": "SUMMARY: This function takes a 3x3 matrix of floats (mat3), a floating-point rotation angle (float), and produces a 3x3 matrix of floats (mat3) as its output. It applies a two-dimensional rotation by the specified angle to the first two rows of the input matrix while keeping the third row unchanged, effectively transforming the input matrix with the given rotation.",
        "code_id": "c_group_2_id_286",
        "code_text": "CGLM_INLINE\nvoid\nglm_rotate2d_to(mat3 m, float angle, mat3 dest) {\n  float m00 = m[0][0],  m10 = m[1][0],\n        m01 = m[0][1],  m11 = m[1][1],\n        m02 = m[0][2],  m12 = m[1][2];\n  float c, s;\n\n  s = sinf(angle);\n  c = cosf(angle);\n  \n  dest[0][0] = m00 * c + m10 * s;\n  dest[0][1] = m01 * c + m11 * s;\n  dest[0][2] = m02 * c + m12 * s;\n\n  dest[1][0] = m00 * -s + m10 * c;\n  dest[1][1] = m01 * -s + m11 * c;\n  dest[1][2] = m02 * -s + m12 * c;\n  \n  dest[2][0] = m[2][0];\n  dest[2][1] = m[2][1];\n  dest[2][2] = m[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_287",
        "query_text": "SUMMARY: This function receives two inputs, each being an array of three integers (type int[3]), and computes a component-wise multiplication of these arrays. The result, which is also an array of three integers (type int[3]), is produced by multiplying the corresponding elements of the input arrays.",
        "code_id": "c_group_2_id_287",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_mul(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] = a[0] * b[0];\n  dest[1] = a[1] * b[1];\n  dest[2] = a[2] * b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_288",
        "query_text": "SUMMARY: This function accepts two parameters, both of which are arrays of three integers (type: ivec3). It replicates the entire content of the first array into the second array by copying each of the three elements individually.",
        "code_id": "c_group_2_id_288",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_copy(ivec3 a, ivec3 dest) {\n  dest[0] = a[0];\n  dest[1] = a[1];\n  dest[2] = a[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_289",
        "query_text": "SUMMARY: The function accepts a two-element integer array (ivec2) and two integers representing a lower and an upper bound. It operates in place by adjusting the values of the array so that each element lies within the inclusive range defined by these minimum and maximum bounds, returning the modified array as the output.",
        "code_id": "c_group_2_id_289",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_clamp(ivec2 v, int minVal, int maxVal) {\n  if (v[0] < minVal)\n    v[0] = minVal;\n  else if(v[0] > maxVal)\n    v[0] = maxVal;\n\n  if (v[1] < minVal)\n    v[1] = minVal;\n  else if(v[1] > maxVal)\n    v[1] = maxVal;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_290",
        "query_text": "SUMMARY: This function accepts three inputs of type vec4 (each being an array of four floats) and updates a fourth vector (also of type vec4) by adding the corresponding components of the first two inputs to those of the output variable. In essence, it performs an element-wise addition where each output component becomes the sum of its previous value plus the corresponding components from the two input vectors. The computation is carried out using platform-specific SIMD instructions when available, resorting to a straightforward element-wise computation otherwise.",
        "code_id": "c_group_2_id_290",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_addadd(vec4 a, vec4 b, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_add(\n          glmm_load(dest),\n          wasm_f32x4_add(glmm_load(a), glmm_load(b))));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_add_ps(glmm_load(dest),\n                              _mm_add_ps(glmm_load(a),\n                                         glmm_load(b))));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vaddq_f32(vld1q_f32(dest),\n                            vaddq_f32(vld1q_f32(a),\n                                      vld1q_f32(b))));\n#else\n  dest[0] += a[0] + b[0];\n  dest[1] += a[1] + b[1];\n  dest[2] += a[2] + b[2];\n  dest[3] += a[3] + b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_291",
        "query_text": "SUMMARY: This function takes as input a two-dimensional matrix (of type \"mat2\", which is a two-element array of 2-element float vectors) along with two integer indices. It operates by exchanging the entire contents of the two columns specified by the integer inputs. The matrix, which serves as the output (modified in place), has its specified columns swapped, and no new data is returned.",
        "code_id": "c_group_2_id_291",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2_swap_col(mat2 mat, int col1, int col2) {\n  float a, b;\n\n  a = mat[col1][0];\n  b = mat[col1][1];\n\n  mat[col1][0] = mat[col2][0];\n  mat[col1][1] = mat[col2][1];\n\n  mat[col2][0] = a;\n  mat[col2][1] = b;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_292",
        "query_text": "SUMMARY: This function accepts two inputs\u2014a one-dimensional array containing two integers and a single integer scalar\u2014and produces an output as a one-dimensional array containing two integers. The function divides each element of the input array by the scalar value and assigns the resulting quotient to the respective element in the output array, performing an element-wise scalar division.",
        "code_id": "c_group_2_id_292",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_divs(ivec2 v, int s, ivec2 dest) {\n  dest[0] = v[0] / s;\n  dest[1] = v[1] / s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_293",
        "query_text": "SUMMARY: This function takes a constant pointer to a float (const float *) as input and produces an output of type mat4x3 (an array of 4 vectors, each being an array of 3 floats). It sequentially assigns groups of three floats from the input array to each of the four vectors in the output, effectively constructing a 4x3 matrix from a flat array of 12 floats.",
        "code_id": "c_group_2_id_293",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x3_make(const float * __restrict src, mat4x3 dest) {\n  dest[0][0] = src[0];\n  dest[0][1] = src[1];\n  dest[0][2] = src[2];\n\n  dest[1][0] = src[3];\n  dest[1][1] = src[4];\n  dest[1][2] = src[5];\n\n  dest[2][0] = src[6];\n  dest[2][1] = src[7];\n  dest[2][2] = src[8];\n\n  dest[3][0] = src[9];\n  dest[3][1] = src[10];\n  dest[3][2] = src[11];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_294",
        "query_text": "SUMMARY: This function accepts an input of type float[3] (a 3-dimensional vector) and a float scalar, then produces an output of type float[3] by subtracting the scalar from each element of the input vector individually.",
        "code_id": "c_group_2_id_294",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_subs(vec3 v, float s, vec3 dest) {\n  dest[0] = v[0] - s;\n  dest[1] = v[1] - s;\n  dest[2] = v[2] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_295",
        "query_text": "SUMMARY: This function takes as inputs a 2x4 matrix (implemented as an array of 2 vectors, where each vector is an aligned array of 4 floats) and a scalar float value. It scales the matrix in place by multiplying each of its elements by the provided scalar, and it returns no value (void).",
        "code_id": "c_group_2_id_295",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x4_scale(mat2x4 m, float s) {\n  m[0][0] *= s;  m[0][1] *= s;  m[0][2] *= s;  m[0][3] *= s;\n  m[1][0] *= s;  m[1][1] *= s;  m[1][2] *= s;  m[1][3] *= s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_296",
        "query_text": "SUMMARY: This function takes two inputs and one output, each being an array of 4 integers (ivec4). For each of the four positions, the function compares the corresponding integers from the two input arrays and places the larger value into the same index of the output array.",
        "code_id": "c_group_2_id_296",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_maxv(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] = a[0] > b[0] ? a[0] : b[0];\n  dest[1] = a[1] > b[1] ? a[1] : b[1];\n  dest[2] = a[2] > b[2] ? a[2] : b[2];\n  dest[3] = a[3] > b[3] ? a[3] : b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_297",
        "query_text": "SUMMARY: This function accepts a parameter of type mat2 (a 2x2 matrix represented as an array of two vec2, where each vec2 is an array of two floats) and transposes it in place. It operates by swapping the two off-diagonal elements of the input matrix, leaving the diagonal elements unchanged, and produces no return value (void).",
        "code_id": "c_group_2_id_297",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2_transpose(mat2 m) {\n  float tmp;\n  tmp     = m[0][1];\n  m[0][1] = m[1][0];\n  m[1][0] = tmp;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_298",
        "query_text": "SUMMARY: The function receives an input of type ivec3 (an array of three integers) and a scalar integer, subtracts the scalar from each element of the input ivec3, and stores the results in an output variable of type ivec3 (an array of three integers). The function processes the subtraction element-wise for all three components of the input integer vector.",
        "code_id": "c_group_2_id_298",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_subs(ivec3 v, int s, ivec3 dest) {\n  dest[0] = v[0] - s;\n  dest[1] = v[1] - s;\n  dest[2] = v[2] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_299",
        "query_text": "SUMMARY: This function takes a vector of type float[4] (an aligned array of four 32-bit floating-point numbers) as its input and outputs no value (void return). Its functionality is to set every element of the input vector to the constant value 1.0. It uses platform-specific SIMD instructions (such as those available for WASM, SSE, or NEON) when available for optimized performance, otherwise it sets the elements individually.",
        "code_id": "c_group_2_id_299",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_one(vec4 v) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(v, wasm_f32x4_const_splat(1.0f));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(v, _mm_set1_ps(1.0f));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(v, vdupq_n_f32(1.0f));\n#else\n  v[0] = 1.0f;\n  v[1] = 1.0f;\n  v[2] = 1.0f;\n  v[3] = 1.0f;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_300",
        "query_text": "SUMMARY: This function receives a two-dimensional array of floats with dimensions 3\u00d73 (mat3) and returns a float. It calculates the determinant of the provided 3\u00d73 matrix by accessing each element in the matrix and applying the standard determinant formula for a 3\u00d73 matrix. Specifically, it computes the determinant by performing arithmetic operations involving the multiplication and subtraction of products of selected elements from the matrix, and then returns the resulting value.",
        "code_id": "c_group_2_id_300",
        "code_text": "CGLM_INLINE\nfloat\nglm_mat3_det(mat3 mat) {\n  float a = mat[0][0], b = mat[0][1], c = mat[0][2],\n        d = mat[1][0], e = mat[1][1], f = mat[1][2],\n        g = mat[2][0], h = mat[2][1], i = mat[2][2];\n\n  return a * (e * i - h * f) - d * (b * i - c * h) + g * (b * f - c * e);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_301",
        "query_text": "SUMMARY: This function accepts two inputs: one is a three-element array of floats (type vec3) and the other is a pointer to a FILE stream (type FILE *). It produces no return value (void). Its purpose is to output a formatted representation of the three floating-point values to the provided stream. The function prints a header indicating the vector type and then iterates through the array, printing each float with conditional formatting based on its value relative to a preset threshold. It also incorporates color formatting directives to enhance the visual output on compatible terminals.",
        "code_id": "c_group_2_id_301",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_print(vec3              vec,\n               FILE * __restrict ostream) {\n  int i;\n\n#define m 3\n\n  fprintf(ostream, \"Vector (float%d): \" CGLM_PRINT_COLOR \"\\n  (\", m);\n\n  for (i = 0; i < m; i++) {\n    if (vec[i] < CGLM_PRINT_MAX_TO_SHORT)\n      fprintf(ostream, \" % .*f\", CGLM_PRINT_PRECISION, (double)vec[i]);\n    else\n      fprintf(ostream, \" % g\", (double)vec[i]);\n  }\n\n  fprintf(ostream, \"  )\" CGLM_PRINT_COLOR_RESET \"\\n\\n\");\n\n#undef m\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_302",
        "query_text": "SUMMARY: This function takes an input of type vec2 (a two-element array of floats) and copies its contents to an output also of type vec2, thereby duplicating the two floating-point values from the source to the destination.",
        "code_id": "c_group_2_id_302",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_copy(vec2 a, vec2 dest) {\n  dest[0] = a[0];\n  dest[1] = a[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_303",
        "query_text": "SUMMARY: The function accepts an input parameter of type int[4] and two additional integer parameters representing a minimum and a maximum value. It reviews each element of the int[4] array and modifies it in place so that every element is confined within the specified range: if an element is lower than the minimum value, it is set to the minimum; if it exceeds the maximum value, it is set to the maximum. The output is the modified int[4] array where all elements satisfy the constraint min \u2264 element \u2264 max.",
        "code_id": "c_group_2_id_303",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_clamp(ivec4 v, int minVal, int maxVal) {\n  if (v[0] < minVal)\n    v[0] = minVal;\n  else if(v[0] > maxVal)\n    v[0] = maxVal;\n\n  if (v[1] < minVal)\n    v[1] = minVal;\n  else if(v[1] > maxVal)\n    v[1] = maxVal;\n\n  if (v[2] < minVal)\n    v[2] = minVal;\n  else if(v[2] > maxVal)\n    v[2] = maxVal;\n\n  if (v[3] < minVal)\n    v[3] = minVal;\n  else if(v[3] > maxVal)\n    v[3] = maxVal;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_304",
        "query_text": "SUMMARY: This function takes as inputs a 3-element array of floats (vec3) and a float scalar, and produces as output another 3-element array of floats (vec3). It operates by adding the float scalar to each element of the input 3-element float array individually, storing each computed sum into the corresponding index of the output array.",
        "code_id": "c_group_2_id_304",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_adds(vec3 v, float s, vec3 dest) {\n  dest[0] = v[0] + s;\n  dest[1] = v[1] + s;\n  dest[2] = v[2] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_305",
        "query_text": "SUMMARY: This function takes a two-element array of single-precision floating-point numbers (vec2) as input and produces a two-element array of single-precision floating-point numbers (vec2) as output. It computes the square root of each element from the input array and assigns the results to the corresponding elements of the output array.",
        "code_id": "c_group_2_id_305",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_sqrt(vec2 v, vec2 dest) {\n  dest[0] = sqrtf(v[0]);\n  dest[1] = sqrtf(v[1]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_306",
        "query_text": "SUMMARY: This function accepts an input of type \"integer array of length 3\" and a scalar of type \"integer\", and it outputs a modified integer array of length 3. Specifically, for each element in the three-element output array, it subtracts the sum of the corresponding element from the input array and the scalar. Line by line, each element in the output is updated by deducting (element from the input array + scalar) from its current value.",
        "code_id": "c_group_2_id_306",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_addsubs(ivec3 a, int s, ivec3 dest) {\n  dest[0] -= a[0] + s;\n  dest[1] -= a[1] + s;\n  dest[2] -= a[2] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_307",
        "query_text": "SUMMARY: This function accepts a 3x4 matrix (an array of three 4-element float vectors, with 16-byte alignment) and a scalar value of type float. It scales the matrix by multiplying each of the 12 individual float elements by the scalar, and it performs the operation in place, returning no value (void).",
        "code_id": "c_group_2_id_307",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x4_scale(mat3x4 m, float s) {\n  m[0][0] *= s; m[0][1] *= s; m[0][2] *= s; m[0][3] *= s;\n  m[1][0] *= s; m[1][1] *= s; m[1][2] *= s; m[1][3] *= s;\n  m[2][0] *= s; m[2][1] *= s; m[2][2] *= s; m[2][3] *= s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_308",
        "query_text": "SUMMARY: This function performs a linear transformation by multiplying a 2\u00d73 matrix (an array of two 3-element float arrays) with a 2-element vector (a float array of length 2) to produce a 3-element vector (a float array of length 3). It extracts the two float values from the input vector, then computes each of the three output float values by forming a weighted sum of corresponding elements from the two rows of the matrix, and finally stores these computed sums in the output vector.",
        "code_id": "c_group_2_id_308",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x3_mulv(mat2x3 m, vec2 v, vec3 dest) {\n  float v0 = v[0], v1 = v[1];\n\n  dest[0] = m[0][0] * v0 + m[1][0] * v1;\n  dest[1] = m[0][1] * v0 + m[1][1] * v1;\n  dest[2] = m[0][2] * v0 + m[1][2] * v1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_309",
        "query_text": "SUMMARY: This routine performs component-wise addition on two input arrays of four 32-bit floating-point values (defined as vec4) and stores the result into an output array of the same type. The implementation conditionally leverages platform-specific SIMD instructions\u2014using WebAssembly SIMD, SSE/SSE2, or NEON\u2014in order to efficiently load, add, and store the 4-element vectors. In the absence of such hardware features, it manually adds each corresponding element from the input arrays.",
        "code_id": "c_group_2_id_309",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_add(vec4 a, vec4 b, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_add(glmm_load(a), glmm_load(b)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_add_ps(glmm_load(a), glmm_load(b)));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vaddq_f32(vld1q_f32(a), vld1q_f32(b)));\n#else\n  dest[0] = a[0] + b[0];\n  dest[1] = a[1] + b[1];\n  dest[2] = a[2] + b[2];\n  dest[3] = a[3] + b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_310",
        "query_text": "SUMMARY: This inline function initializes a quaternion represented by a 4-element float array. It takes as inputs one output parameter (a modifiable array of four floats) and four individual floats. The function assigns the four input float values to the elements of the float array sequentially, updating it in place.",
        "code_id": "c_group_2_id_310",
        "code_text": "CGLM_INLINE\nvoid\nglm_quat_init(versor q, float x, float y, float z, float w) {\n  q[0] = x;\n  q[1] = y;\n  q[2] = z;\n  q[3] = w;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_311",
        "query_text": "SUMMARY: This function takes a 4\u00d74 matrix of floats (mat4) as input along with a pointer to a float variable as output. It computes a quotient by dividing the float value in the fourth row and third column of the matrix by the result of subtracting the element in the third row and third column from 1.0. The computed value is then stored in the provided float pointer, effectively extracting the far clipping plane distance from the perspective projection matrix under a left-handed coordinate system with no depth range transformation.",
        "code_id": "c_group_2_id_311",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_far_lh_no(mat4 proj, float * __restrict farZ) {\n  *farZ = proj[3][2] / (-proj[2][2] + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_312",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 single-precision floating-point matrix (representing a perspective projection transformation) and two pointers to float variables as inputs. It calculates the near clipping plane distance from the matrix and then computes the horizontal bounds on the near plane of the projection, storing these computed boundary values into the provided float outputs.",
        "code_id": "c_group_2_id_312",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_x_lh_zo(mat4 proj,\n                         float * __restrict left,\n                         float * __restrict right) {\n  float nearZ, m20, m00;\n\n  m00 = proj[0][0];\n  m20 = proj[2][0];\n\n  nearZ = proj[3][2] / (proj[3][3]);\n  *left   = nearZ * (m20 - 1.0f) / m00;\n  *right  = nearZ * (m20 + 1.0f) / m00;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_313",
        "query_text": "SUMMARY: This function accepts one input of type mat4 (a 4\u00d74 floating-point matrix) and returns a float. It extracts two elements from the matrix\u2014specifically the component at index [1][1] and the component at index [0][0]\u2014and returns their quotient, effectively computing the aspect ratio represented in the perspective projection matrix.",
        "code_id": "c_group_2_id_313",
        "code_text": "CGLM_INLINE\nfloat\nglm_persp_aspect(mat4 proj) {\n  return proj[1][1] / proj[0][0];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_314",
        "query_text": "SUMMARY: This function takes as inputs a 2\u00d74 matrix (represented as an array of 2 arrays, each containing 4 floats) and a 2-dimensional vector (an array of 2 floats). It computes a 4-dimensional vector (an array of 4 floats) as output by performing a component-wise linear combination of the two rows of the matrix using the two scalar elements from the vector. Each element of the resulting vector is calculated by multiplying the corresponding element from the first row of the matrix by the first scalar and adding it to the product of the corresponding element from the second row with the second scalar.",
        "code_id": "c_group_2_id_314",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x4_mulv(mat2x4 m, vec2 v, vec4 dest) {\n  float v0 = v[0], v1 = v[1];\n\n  dest[0] = m[0][0] * v0 + m[1][0] * v1;\n  dest[1] = m[0][1] * v0 + m[1][1] * v1;\n  dest[2] = m[0][2] * v0 + m[1][2] * v1;\n  dest[3] = m[0][3] * v0 + m[1][3] * v1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_315",
        "query_text": "SUMMARY: This function accepts two parameters, both of type vec4 (an array of 4 floats). It copies the contents from the first vec4 (input) into the second vec4 (output), ensuring that the destination receives an exact replica of the input vector. The implementation employs optimized methods for certain platform-specific conditions but ultimately achieves a straightforward element-by-element copy of the four floating-point values.",
        "code_id": "c_group_2_id_315",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_ucopy(vec4 v, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  /* note here wasm v128.load/v128.store support unaligned loads and stores */\n  wasm_v128_store(dest, wasm_v128_load(v));\n#else\n  dest[0] = v[0];\n  dest[1] = v[1];\n  dest[2] = v[2];\n  dest[3] = v[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_316",
        "query_text": "SUMMARY: This function accepts a single floating-point value (type: float) and a destination array of four floats (type: vec4, which is a 16-byte aligned float[4]). Its primary functionality is to assign the given float value to every element of the output array, effectively broadcasting the value. Depending on the platform, it may use specialized SIMD instructions (WebAssembly SIMD or SSE/SSE2) to perform the broadcast efficiently; otherwise, it individually assigns the value to each position in the array.",
        "code_id": "c_group_2_id_316",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_broadcast(float val, vec4 d) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(d, wasm_f32x4_splat(val));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(d, _mm_set1_ps(val));\n#else\n  d[0] = d[1] = d[2] = d[3] = val;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_317",
        "query_text": "SUMMARY: This function takes as input a 4\u00d74 floating-point matrix (of type mat4) representing a specific perspective projection and a pointer to a float (output type). It computes the near clipping plane distance by extracting particular elements from the matrix and assigns the resulting float to the provided output pointer. Specifically, it derives the output by dividing the element from the fourth row and third column by the negation of the element from the third row and third column.",
        "code_id": "c_group_2_id_317",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_near_lh_zo(mat4 proj, float * __restrict nearZ) {\n  *nearZ = proj[3][2] / -proj[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_318",
        "query_text": "SUMMARY: This function takes as inputs a 2\u00d74 matrix (of type mat2x4, represented as an array of 2 vec4\u2019s) and a 4\u00d72 matrix (of type mat4x2, represented as an array of 4 vec2\u2019s) and computes their product, storing the result in a 4\u00d74 matrix (of type mat4, represented as an array of 4 vec4\u2019s). In essence, it forms each column of the 4\u00d74 output by taking a linear combination of the two columns of the 2\u00d74 input, with the weights being the corresponding elements from a column (or row, depending on conceptual layout) of the 4\u00d72 input.",
        "code_id": "c_group_2_id_318",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x4_mul(mat2x4 m1, mat4x2 m2, mat4 dest) {\n  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],\n        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],\n\n        b00 = m2[0][0], b01 = m2[0][1],\n        b10 = m2[1][0], b11 = m2[1][1],\n        b20 = m2[2][0], b21 = m2[2][1],\n        b30 = m2[3][0], b31 = m2[3][1];\n\n  dest[0][0] = a00 * b00 + a10 * b01;\n  dest[0][1] = a01 * b00 + a11 * b01;\n  dest[0][2] = a02 * b00 + a12 * b01;\n  dest[0][3] = a03 * b00 + a13 * b01;\n\n  dest[1][0] = a00 * b10 + a10 * b11;\n  dest[1][1] = a01 * b10 + a11 * b11;\n  dest[1][2] = a02 * b10 + a12 * b11;\n  dest[1][3] = a03 * b10 + a13 * b11;\n\n  dest[2][0] = a00 * b20 + a10 * b21;\n  dest[2][1] = a01 * b20 + a11 * b21;\n  dest[2][2] = a02 * b20 + a12 * b21;\n  dest[2][3] = a03 * b20 + a13 * b21;\n\n  dest[3][0] = a00 * b30 + a10 * b31;\n  dest[3][1] = a01 * b30 + a11 * b31;\n  dest[3][2] = a02 * b30 + a12 * b31;\n  dest[3][3] = a03 * b30 + a13 * b31;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_319",
        "query_text": "SUMMARY: This function accepts an input of type mat3 (a 3\u00d73 float matrix) and produces an output of the same type. It calculates the transpose of the provided 3\u00d73 matrix by reassigning elements such that the element at the ith row and jth column in the input is placed at the jth row and ith column in the output. Each assignment explicitly swaps the indices, ensuring that the matrix's rows and columns are interchanged.",
        "code_id": "c_group_2_id_319",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3_transpose_to(mat3 m, mat3 dest) {\n  dest[0][0] = m[0][0];\n  dest[0][1] = m[1][0];\n  dest[0][2] = m[2][0];\n  dest[1][0] = m[0][1];\n  dest[1][1] = m[1][1];\n  dest[1][2] = m[2][1];\n  dest[2][0] = m[0][2];\n  dest[2][1] = m[1][2];\n  dest[2][2] = m[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_320",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of type int[4]. It updates the output parameter by adding, component-wise, the difference between the corresponding elements of the first two input parameters. In other words, for each of the four components, it subtracts the second input's element from the first input's element and then adds that result to the corresponding element in the output.",
        "code_id": "c_group_2_id_320",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_subadd(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] += a[0] - b[0];\n  dest[1] += a[1] - b[1];\n  dest[2] += a[2] - b[2];\n  dest[3] += a[3] - b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_321",
        "query_text": "SUMMARY: This function accepts two parameters of type \"int[2]\"\u2014a source vector and a destination vector. It copies the two integer elements from the source vector into the destination vector, ensuring that the output vector contains the same pair of integer values as the input vector.",
        "code_id": "c_group_2_id_321",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_copy(ivec2 a, ivec2 dest) {\n  dest[0] = a[0];\n  dest[1] = a[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_322",
        "query_text": "SUMMARY: This function multiplies a 3\u00d72 matrix (an array consisting of 3 elements, each being an array of 2 floats) with a 3-dimensional vector (an array of 3 floats) to produce a 2-dimensional vector (an array of 2 floats). It first extracts the three float components from the input vector, then computes each component of the resulting vector as a linear combination of the extracted components weighted by corresponding elements from the matrix. The first output float is calculated by summing the products of the first element of each matrix sub-array with the respective vector components, while the second output float is generated using the second elements from the matrix sub-arrays.",
        "code_id": "c_group_2_id_322",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x2_mulv(mat3x2 m, vec3 v, vec2 dest) {\n  float v0 = v[0], v1 = v[1], v2 = v[2];\n\n  dest[0] = m[0][0] * v0 + m[1][0] * v1 + m[2][0] * v2;\n  dest[1] = m[0][1] * v0 + m[1][1] * v1 + m[2][1] * v2;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_323",
        "query_text": "SUMMARY: This function accepts a two-element floating-point array (vec2) and a floating-point scalar as inputs. It multiplies each element of the input array by the scalar, then stores the resulting two-element floating-point array (vec2) as output.",
        "code_id": "c_group_2_id_323",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_scale(vec2 v, float s, vec2 dest) {\n  dest[0] = v[0] * s;\n  dest[1] = v[1] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_324",
        "query_text": "SUMMARY: This function takes a 4x4 matrix of floats (representing a perspective projection in a left-handed coordinate system with a zero-to-one depth range) and a float value as inputs. It adjusts the projection matrix by shifting its far clipping plane by the given delta value. The function recalculates key elements related to the near and far clipping distances and updates the corresponding matrix entries to reflect the new far plane position, while maintaining the proper perspective transformation. The output is the modified 4x4 matrix (the changes are applied in-place), and the function returns no value.",
        "code_id": "c_group_2_id_324",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_move_far_lh_zo(mat4 proj, float deltaFar) {\n  float fn, farZ, nearZ, p22, p32;\n\n  p22        = -proj[2][2];\n  p32        = proj[3][2];\n\n  nearZ    = p32 / p22;\n  farZ     = p32 / (p22 + 1.0f) + deltaFar;\n  fn         = 1.0f / (nearZ - farZ);\n\n  proj[2][2] = -farZ * fn;\n  proj[3][2] = nearZ * farZ * fn;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_325",
        "query_text": "SUMMARY: This function accepts an input of type pointer to float and an output of type vec2 (an array of 2 floats). It copies the first two float values from the input pointer into the output vec2, effectively transferring a 2-dimensional vector from one representation to another.",
        "code_id": "c_group_2_id_325",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2(float * __restrict v, vec2 dest) {\n  dest[0] = v[0];\n  dest[1] = v[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_326",
        "query_text": "SUMMARY: This function accepts an input variable of type \"vec2\" (an array of two floats) and computes the floor value for each element. The resulting values are then stored in an output variable of type \"vec2\" (also an array of two floats). Essentially, it rounds each of the two input float components down to the nearest integer value and writes the result to the corresponding position in the output array.",
        "code_id": "c_group_2_id_326",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_floor(vec2 v, vec2 dest) {\n  dest[0] = floorf(v[0]);\n  dest[1] = floorf(v[1]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_327",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (mat4) and two pointers to floats (float*) as inputs. It decomposes the provided perspective projection matrix, extracting parameters associated with the vertical extents along the y-axis in a left-handed coordinate system. Essentially, the function calculates a near clipping distance and then computes two float values representing the top and bottom bounds of the view frustum. The computed values are stored in the output float pointers.",
        "code_id": "c_group_2_id_327",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_y_lh_no(mat4 proj,\n                         float * __restrict top,\n                         float * __restrict bottom) {\n  float nearZ, m21, m11, m22;\n\n  m21 = proj[2][1];\n  m11 = proj[1][1];\n  m22 =-proj[2][2];\n\n  nearZ = proj[3][2] / (m22 - 1.0f);\n  *bottom = nearZ * (m21 - 1.0f) / m11;\n  *top    = nearZ * (m21 + 1.0f) / m11;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_328",
        "query_text": "SUMMARY: This function converts a three-component float array (vec3) representing Euler rotation angles into a corresponding four-component float array (versor) representing a quaternion based on a ZYX rotation order for a left-handed coordinate system. It computes half-angle sine and cosine values for each of the three angles, combines these intermediate values with appropriate sign adjustments, and then calculates each component of the quaternion, which encodes the final rotation.",
        "code_id": "c_group_2_id_328",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_zyx_quat_lh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs =  sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys =  sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = -sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] =  zc * yc * xs - zs * ys * xc;\n  dest[1] =  zc * ys * xc + zs * yc * xs;\n  dest[2] = -zc * ys * xs + zs * yc * xc;\n  dest[3] =  zc * yc * xc + zs * ys * xs;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_329",
        "query_text": "SUMMARY: This function takes two inputs of type int[4] and produces an output of the same type. It transfers the contents of the first int[4] array into the second int[4] array by copying each of the four integer elements in order.",
        "code_id": "c_group_2_id_329",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_copy(ivec4 a, ivec4 dest) {\n  dest[0] = a[0];\n  dest[1] = a[1];\n  dest[2] = a[2];\n  dest[3] = a[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_330",
        "query_text": "SUMMARY: This function multiplies two matrices and produces a new matrix as a result. It takes an input of type mat3x4 (an array of 3 vec4, representing a 3\u2010column by 4\u2011row matrix in column-major order) and an input of type mat4x3 (an array of 4 vec3, representing a 4\u2011column by 3\u2011row matrix in column-major order), and it computes their product to store in an output of type mat4 (an array of 4 vec4, representing a 4\u2011column by 4\u2011row matrix). The function works by extracting the individual floating\u2013point components of the first and second matrices and then computing each element of the resulting matrix as the dot product between the corresponding column from the first matrix and the appropriate row from the second matrix.",
        "code_id": "c_group_2_id_330",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x4_mul(mat3x4 m1, mat4x3 m2, mat4 dest) {\n  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],\n        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],\n        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],\n\n        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],\n        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],\n        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2],\n        b30 = m2[3][0], b31 = m2[3][1], b32 = m2[3][2];\n\n  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;\n  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;\n  dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02;\n  dest[0][3] = a03 * b00 + a13 * b01 + a23 * b02;\n\n  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;\n  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;\n  dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12;\n  dest[1][3] = a03 * b10 + a13 * b11 + a23 * b12;\n\n  dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22;\n  dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22;\n  dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22;\n  dest[2][3] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  dest[3][0] = a00 * b30 + a10 * b31 + a20 * b32;\n  dest[3][1] = a01 * b30 + a11 * b31 + a21 * b32;\n  dest[3][2] = a02 * b30 + a12 * b31 + a22 * b32;\n  dest[3][3] = a03 * b30 + a13 * b31 + a23 * b32;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_331",
        "query_text": "SUMMARY: This function accepts an output variable of type mat3 (which is a 3\u00d73 array of floats) and an input variable of type float representing an angle. Its purpose is to construct a 3\u00d73 transformation matrix that encapsulates a two-dimensional rotation in homogeneous coordinates. The function computes the sine and cosine of the given angle and organizes these values within the matrix to represent the standard 2D rotational transformation. No value is returned.",
        "code_id": "c_group_2_id_331",
        "code_text": "CGLM_INLINE\nvoid\nglm_rotate2d_make(mat3 m, float angle) {\n  float c, s;\n\n  s = sinf(angle);\n  c = cosf(angle);\n  \n  m[0][0] = c;\n  m[0][1] = s;\n  m[0][2] = 0;\n\n  m[1][0] = -s;\n  m[1][1] = c;\n  m[1][2] = 0;\n  \n  m[2][0] = 0.0f;\n  m[2][1] = 0.0f;\n  m[2][2] = 1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_332",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (of type mat4, which is an array of four aligned 4-element float vectors) and two pointers to floats. It extracts specific elements from the matrix, calculates a near clipping distance from one of the matrix\u2019s entries, and then computes two horizontal frustum bounds (left and right) based on that near distance and other matrix elements. The results are stored in the floats pointed to by the two pointer arguments.",
        "code_id": "c_group_2_id_332",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_x_lh_no(mat4 proj,\n                         float * __restrict left,\n                         float * __restrict right) {\n  float nearZ, m20, m00, m22;\n\n  m00 = proj[0][0];\n  m20 = proj[2][0];\n  m22 =-proj[2][2];\n\n  nearZ = proj[3][2] / (m22 - 1.0f);\n  *left   = nearZ * (m20 - 1.0f) / m00;\n  *right  = nearZ * (m20 + 1.0f) / m00;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_333",
        "query_text": "SUMMARY: This function multiplies each element of an input 2-dimensional integer vector (ivec2) by an integer scalar and stores the resulting values in an output 2-dimensional integer vector (ivec2). Specifically, the first element of the input vector is multiplied by the scalar and assigned to the first element of the output vector, and the second element is similarly processed for the second output element.",
        "code_id": "c_group_2_id_333",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_scale(ivec2 v, int s, ivec2 dest) {\n  dest[0] = v[0] * s;\n  dest[1] = v[1] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_334",
        "query_text": "SUMMARY: This function takes an input of type vec3 (an array of three floats) and returns a float as output. It examines the three components of the input vector to determine which one has the greatest value, ultimately returning that highest float value. The function initially considers the first element as the maximum, then sequentially compares the second and third elements to update the maximum when a larger value is found, and finally outputs the largest value.",
        "code_id": "c_group_2_id_334",
        "code_text": "CGLM_INLINE\nfloat\nglm_vec3_max(vec3 v) {\n  float max;\n\n  max = v[0];\n  if (v[1] > max)\n    max = v[1];\n  if (v[2] > max)\n    max = v[2];\n\n  return max;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_335",
        "query_text": "SUMMARY: This function operates on three input variables: a three-element float array (representing a vector), a single float (scalar), and another three-element float array (representing a destination vector to be modified). For each of the three elements, the function multiplies the corresponding element of the first array by the scalar, then subtracts that product from the corresponding element of the destination array.",
        "code_id": "c_group_2_id_335",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_mulsubs(vec3 a, float s, vec3 dest) {\n  dest[0] -= a[0] * s;\n  dest[1] -= a[1] * s;\n  dest[2] -= a[2] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_336",
        "query_text": "SUMMARY: This function accepts two input variables and one output variable, each of which is a three-element array of integers (ivec3). It computes the element-wise difference between the first and second input arrays, then adds each resulting difference to the corresponding element of the output array.",
        "code_id": "c_group_2_id_336",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_subadd(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] += a[0] - b[0];\n  dest[1] += a[1] - b[1];\n  dest[2] += a[2] - b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_337",
        "query_text": "SUMMARY: This function takes two inputs\u2014a three-element array of floats (vec3) and a float scalar\u2014and produces an output that is also a three-element array of floats (vec3). It computes the floating-point remainder of each element in the input array when divided by the scalar, storing the three corresponding results in the output array.",
        "code_id": "c_group_2_id_337",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_mods(vec3 v, float s, vec3 dest) {\n  dest[0] = fmodf(v[0], s);\n  dest[1] = fmodf(v[1], s);\n  dest[2] = fmodf(v[2], s);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_338",
        "query_text": "SUMMARY: This function operates on three variables of type ivec2 (which are int[2]). It subtracts the difference between the corresponding elements of the first two input variables from each element of the output variable. Specifically, for each coordinate index, it updates the output by subtracting the result of the difference (first input minus second input).",
        "code_id": "c_group_2_id_338",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_subsub(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] -= a[0] - b[0];\n  dest[1] -= a[1] - b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_339",
        "query_text": "SUMMARY: This function takes an input of type int[4] and produces an output of type int[3]. It sequentially copies the first three integers from the input array into the output array, effectively transferring the initial three elements while ignoring the fourth element.",
        "code_id": "c_group_2_id_339",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3(ivec4 v4, ivec3 dest) {\n  dest[0] = v4[0];\n  dest[1] = v4[1];\n  dest[2] = v4[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_340",
        "query_text": "SUMMARY: This function accepts an input matrix of type mat2x3 (an array consisting of 2 vectors, each containing 3 floats) and produces an output matrix of type mat3x2 (an array consisting of 3 vectors, each containing 2 floats) that is the transpose of the input. The function rearranges the elements by swapping the row and column indices, so that each element in the output matrix is taken from the corresponding transposed position of the input matrix.",
        "code_id": "c_group_2_id_340",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x3_transpose(mat2x3 m, mat3x2 dest) {\n  dest[0][0] = m[0][0];  dest[0][1] = m[1][0];\n  dest[1][0] = m[0][1];  dest[1][1] = m[1][1];\n  dest[2][0] = m[0][2];  dest[2][1] = m[1][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_341",
        "query_text": "SUMMARY: This function accepts three parameters of type vec2 (a two-element float array). It computes the element-wise difference between the first and second vec2 inputs, and then adds each resulting component to the corresponding component of the output vec2. Essentially, it updates the output by accumulating the differences between the two input vectors.",
        "code_id": "c_group_2_id_341",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_subadd(vec2 a, vec2 b, vec2 dest) {\n  dest[0] += a[0] - b[0];\n  dest[1] += a[1] - b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_342",
        "query_text": "SUMMARY: This function receives an aligned 4\u00d74 matrix (of type mat4, where each row is a 4-element aligned float vector) and two pointers to float, which serve as outputs. Its purpose is to decompose the provided perspective projection matrix (configured for a right-handed coordinate system with a zero-to-one depth range) by extracting certain matrix components to calculate the horizontal extents of the view frustum at the near clipping plane. In detail, it computes the distance to the near clipping plane from an element of the matrix and then uses this distance together with other matrix elements to derive the left and right boundaries of the frustum. The resulting left and right boundary values are written to the locations indicated by the input float pointers.",
        "code_id": "c_group_2_id_342",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_x_rh_zo(mat4 proj,\n                         float * __restrict left,\n                         float * __restrict right) {\n  float nearZ, m20, m00, m22;\n\n  m00 = proj[0][0];\n  m20 = proj[2][0];\n  m22 = proj[2][2];\n\n  nearZ = proj[3][2] / m22;\n  *left   = nearZ * (m20 - 1.0f) / m00;\n  *right  = nearZ * (m20 + 1.0f) / m00;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_343",
        "query_text": "SUMMARY: The function accepts two inputs\u2014a 3-element array of type int (int[3]) and an integer scalar (int)\u2014and produces an output that is a 3-element array of type int (int[3]). It multiplies each element of the input array by the scalar value and assigns the resulting values to the corresponding elements of the output array.",
        "code_id": "c_group_2_id_343",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_scale(ivec3 v, int s, ivec3 dest) {\n  dest[0] = v[0] * s;\n  dest[1] = v[1] * s;\n  dest[2] = v[2] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_344",
        "query_text": "SUMMARY: This function takes an input consisting of an array of four integers and a single integer scalar, and produces an output array of four integers. For each element in the input array, it adds the scalar to the element and stores the result in the corresponding element of the output array.",
        "code_id": "c_group_2_id_344",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_adds(ivec4 v, int s, ivec4 dest) {\n  dest[0] = v[0] + s;\n  dest[1] = v[1] + s;\n  dest[2] = v[2] + s;\n  dest[3] = v[3] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_345",
        "query_text": "SUMMARY: This function takes two inputs of type int[4] and produces an output of type int[4]. It computes element-wise multiplication by multiplying each corresponding integer in the input arrays and stores the resulting products in the output array.",
        "code_id": "c_group_2_id_345",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_mul(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] = a[0] * b[0];\n  dest[1] = a[1] * b[1];\n  dest[2] = a[2] * b[2];\n  dest[3] = a[3] * b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_346",
        "query_text": "SUMMARY: This function takes three arrays of three integers each (int[3]). It subtracts, element by element, the sum of the corresponding elements of the first two integer arrays from the corresponding element of the third array, updating the output array with the result.",
        "code_id": "c_group_2_id_346",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_addsub(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] -= a[0] + b[0];\n  dest[1] -= a[1] + b[1];\n  dest[2] -= a[2] + b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_347",
        "query_text": "SUMMARY: This function receives a 4x4 matrix (type: mat4) and a single precision floating-point number (type: float) as inputs, and it produces no output (return type: void). Its behavior is to modify the input matrix by incrementally adjusting the element located at the fourth row and first column by adding the provided floating-point value.",
        "code_id": "c_group_2_id_347",
        "code_text": "CGLM_INLINE\nvoid\nglm_translated_x(mat4 m, float x) {\n  m[3][0] += x;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_348",
        "query_text": "SUMMARY: This function accepts an input of type mat2x3 (a two-by-three array of floats) and a scalar of type float, and produces no return value (void). Its primary operation is to uniformly scale each element of the two-by-three matrix by the provided floating-point scalar, updating the matrix in place.",
        "code_id": "c_group_2_id_348",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2x3_scale(mat2x3 m, float s) {\n  m[0][0] *= s;  m[0][1] *= s;  m[0][2] *= s;\n  m[1][0] *= s;  m[1][1] *= s;  m[1][2] *= s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_349",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (of type mat4, which is an array of four aligned vec4 arrays of floats) and a pointer to a float (of type float*). It computes the far clipping plane distance from a perspective projection matrix configured for a left-handed coordinate system with a depth range from zero to one. Specifically, it performs a calculation using selected elements from the input matrix and stores the computed far-plane distance in the output float variable.",
        "code_id": "c_group_2_id_349",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_far_lh_zo(mat4 proj, float * __restrict farZ) {\n  *farZ = proj[3][2] / (-proj[2][2] + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_350",
        "query_text": "SUMMARY: This function accepts an input of type float[3] and returns a float. Its purpose is to determine the smallest value among the three elements in the input array by comparing each element and selecting the minimum, then returning that value as output.",
        "code_id": "c_group_2_id_350",
        "code_text": "CGLM_INLINE\nfloat\nglm_vec3_min(vec3 v) {\n  float min;\n\n  min = v[0];\n  if (v[1] < min)\n    min = v[1];\n  if (v[2] < min)\n    min = v[2];\n\n  return min;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_351",
        "query_text": "SUMMARY: The function accepts a constant two-element integer array (ivec2) and a pointer to a FILE (output stream). It produces no return value. Its primary role is to write a formatted representation of the two-element integer vector to the provided output stream. Specifically, it outputs a label indicating an integer vector with two elements, then prints each integer in the array within parentheses with preset spacing and color formatting, concluding with a reset of the formatting and additional newlines.",
        "code_id": "c_group_2_id_351",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_print(ivec2             vec,\n                FILE * __restrict ostream) {\n  int i;\n\n#define m 2\n\n  fprintf(ostream, \"Vector (int%d): \" CGLM_PRINT_COLOR \"\\n  (\", m);\n\n  for (i = 0; i < m; i++)\n    fprintf(ostream, \" % d\", vec[i]);\n\n  fprintf(ostream, \"  )\" CGLM_PRINT_COLOR_RESET \"\\n\\n\");\n\n#undef m\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_352",
        "query_text": "SUMMARY: This function takes a vector of 4 integers as one input, an integer scalar as another input, and a second vector of 4 integers as the output. It performs an element-wise operation whereby each element of the output vector is incremented by the sum of the corresponding element from the input vector and the scalar integer.",
        "code_id": "c_group_2_id_352",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_addadds(ivec4 a, int s, ivec4 dest) {\n  dest[0] += a[0] + s;\n  dest[1] += a[1] + s;\n  dest[2] += a[2] + s;\n  dest[3] += a[3] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_353",
        "query_text": "SUMMARY: This function takes an input of type \"pointer to constant float\" (representing an array of at least four floats) and an output of type \"vec4\" (an aligned array of four floats). It copies each of the four individual float values from the input array to the corresponding position in the output array, effectively building a 4-dimensional vector from the provided source data.",
        "code_id": "c_group_2_id_353",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_make(const float * __restrict src, vec4 dest) {\n  dest[0] = src[0]; dest[1] = src[1];\n  dest[2] = src[2]; dest[3] = src[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_354",
        "query_text": "SUMMARY: This function receives a 2\u00d72 matrix (mat2, which is defined as an array of two float[2] vectors with potential 16\u2010byte alignment) as an in/out parameter and a float scalar as an input. It scales the matrix by multiplying each element in the matrix by the scalar value, updating the matrix directly.",
        "code_id": "c_group_2_id_354",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2_scale(mat2 m, float s) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(m[0], wasm_f32x4_mul(wasm_v128_load(m[0]),\n                                  wasm_f32x4_splat(s)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(m[0], _mm_mul_ps(_mm_loadu_ps(m[0]), _mm_set1_ps(s)));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(m[0], vmulq_f32(vld1q_f32(m[0]), vdupq_n_f32(s)));\n#else\n  m[0][0] = m[0][0] * s;\n  m[0][1] = m[0][1] * s;\n  m[1][0] = m[1][0] * s;\n  m[1][1] = m[1][1] * s;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_355",
        "query_text": "SUMMARY: The function performs multiplication between a 3x2 matrix (an array of three 2-element float arrays) and a 2x3 matrix (an array of two 3-element float arrays), producing a 2x2 matrix (an array of two 2-element float arrays) as the output. In essence, it computes each element of the resulting matrix by evaluating the dot products between appropriate rows of the first matrix and columns of the second matrix.",
        "code_id": "c_group_2_id_355",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x2_mul(mat3x2 m1, mat2x3 m2, mat2 dest) {\n  float a00 = m1[0][0], a01 = m1[0][1],\n        a10 = m1[1][0], a11 = m1[1][1],\n        a20 = m1[2][0], a21 = m1[2][1],\n\n        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],\n        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2];\n\n  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;\n  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;\n\n  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;\n  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_356",
        "query_text": "SUMMARY: This function scales a 4x2 matrix in place. It takes as input a 4x2 matrix (an array of four arrays of 2 floats each) and a scalar of type float. The function multiplies each element of the input matrix by the scalar, effectively applying a uniform scaling transformation to the matrix, and produces no explicit output (void return type).",
        "code_id": "c_group_2_id_356",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x2_scale(mat4x2 m, float s) {\n  m[0][0] *= s;  m[0][1] *= s;  m[1][0] *= s;  m[1][1] *= s;\n  m[2][0] *= s;  m[2][1] *= s;  m[3][0] *= s;  m[3][1] *= s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_357",
        "query_text": "SUMMARY: This function accepts a 4x4 matrix (of type mat4, which is an aligned array of four vec4, where each vec4 is an aligned array of four floats) and two integer indices. It exchanges the rows of the matrix corresponding to those two indices, effectively swapping their positions in the 4x4 matrix. The function directly modifies the input matrix and does not return any value.",
        "code_id": "c_group_2_id_357",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_swap_row(mat4 mat, int row1, int row2) {\n  CGLM_ALIGN(16) vec4 tmp;\n  tmp[0] = mat[0][row1];\n  tmp[1] = mat[1][row1];\n  tmp[2] = mat[2][row1];\n  tmp[3] = mat[3][row1];\n\n  mat[0][row1] = mat[0][row2];\n  mat[1][row1] = mat[1][row2];\n  mat[2][row1] = mat[2][row2];\n  mat[3][row1] = mat[3][row2];\n\n  mat[0][row2] = tmp[0];\n  mat[1][row2] = tmp[1];\n  mat[2][row2] = tmp[2];\n  mat[3][row2] = tmp[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_358",
        "query_text": "SUMMARY: This function accepts three arrays of three floating-point numbers (vec3) as inputs. It processes an in-place update on the third array by subtracting, for each corresponding index, the product of the elements from the first and second arrays. In essence, each element of the output array is reduced by the product of the corresponding elements of the two input arrays.",
        "code_id": "c_group_2_id_358",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_mulsub(vec3 a, vec3 b, vec3 dest) {\n  dest[0] -= a[0] * b[0];\n  dest[1] -= a[1] * b[1];\n  dest[2] -= a[2] * b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_359",
        "query_text": "SUMMARY: This function accepts two inputs, each being an array of four integers (ivec4), and computes their element-wise addition. It produces an output that is also an array of four integers (ivec4), where each position is the sum of the corresponding elements from the two input arrays.",
        "code_id": "c_group_2_id_359",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_add(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] = a[0] + b[0];\n  dest[1] = a[1] + b[1];\n  dest[2] = a[2] + b[2];\n  dest[3] = a[3] + b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_360",
        "query_text": "SUMMARY: This function accepts an input of type const float* and an output of type vec3 (an array of three floats). It sequentially copies three float values from the input to the output array by assigning the first float to the first element, the second float to the second element, and the third float to the third element.",
        "code_id": "c_group_2_id_360",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_make(const float * __restrict src, vec3 dest) {\n  dest[0] = src[0];\n  dest[1] = src[1];\n  dest[2] = src[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_361",
        "query_text": "SUMMARY: This function computes the inverse of a 2x2 matrix. It accepts an input of type mat2 (an array of two vec2, with each vec2 being a 2-element array of float) representing the matrix to be inverted, and produces an output of the same type (mat2) that contains the inverse matrix. The function extracts the four individual float elements from the input matrix, calculates the reciprocal of its determinant, and then computes each element of the inverse matrix using the standard inversion formula for 2x2 matrices.",
        "code_id": "c_group_2_id_361",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2_inv(mat2 mat, mat2 dest) {\n  float det;\n  float a = mat[0][0], b = mat[0][1],\n        c = mat[1][0], d = mat[1][1];\n\n  det = 1.0f / (a * d - b * c);\n\n  dest[0][0] =  d * det;\n  dest[0][1] = -b * det;\n  dest[1][0] = -c * det;\n  dest[1][1] =  a * det;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_362",
        "query_text": "SUMMARY: This function takes two inputs of type \"int[3]\" (3-element integer arrays) and computes an output of type int. It calculates each corresponding difference between the elements of the inputs, squares these differences, and returns the sum, which represents the squared Euclidean distance.",
        "code_id": "c_group_2_id_362",
        "code_text": "CGLM_INLINE\nint\nglm_ivec3_distance2(ivec3 a, ivec3 b) {\n  int xd, yd, zd;\n  xd = a[0] - b[0];\n  yd = a[1] - b[1];\n  zd = a[2] - b[2];\n  return xd * xd + yd * yd + zd * zd;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_363",
        "query_text": "SUMMARY: This function accepts three arguments, each being an array of two single-precision floating-point values (vec2). It multiplies the corresponding components of the two input arrays and then adds each product to the respective component of the destination array, updating it in place.",
        "code_id": "c_group_2_id_363",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_muladd(vec2 a, vec2 b, vec2 dest) {\n  dest[0] += a[0] * b[0];\n  dest[1] += a[1] * b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_364",
        "query_text": "SUMMARY: This function takes as input a 4-element array of integers (ivec4) and modifies it in-place by setting all four elements to the integer value zero, without returning any value.",
        "code_id": "c_group_2_id_364",
        "code_text": "CGLM_INLINE\nvoid \nglm_ivec4_zero(ivec4 v) {\n  v[0] = v[1] = v[2] = v[3] = 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_365",
        "query_text": "SUMMARY: This function accepts a two-element array of integers (ivec2) and an integer scalar as its inputs. It performs element-wise subtraction by deducting the scalar from each component of the two-element integer array, and then stores the resulting values into an output two-element array of integers.",
        "code_id": "c_group_2_id_365",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_subs(ivec2 v, int s, ivec2 dest) {\n  dest[0] = v[0] - s;\n  dest[1] = v[1] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_366",
        "query_text": "SUMMARY: This function accepts an input of type vec4 (a 4-element array of 32-bit floats) and computes, for each element, its fractional part by subtracting the floor of the element\u2019s value. It then clamps each fractional result so that it does not exceed approximately 0.99999994, and stores the resulting 4-element array in an output variable of the same type.",
        "code_id": "c_group_2_id_366",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_fract(vec4 v, vec4 dest) {\n  dest[0] = fminf(v[0] - floorf(v[0]), 0.999999940395355224609375f);\n  dest[1] = fminf(v[1] - floorf(v[1]), 0.999999940395355224609375f);\n  dest[2] = fminf(v[2] - floorf(v[2]), 0.999999940395355224609375f);\n  dest[3] = fminf(v[3] - floorf(v[3]), 0.999999940395355224609375f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_367",
        "query_text": "SUMMARY: This function accepts as inputs a 4\u00d74 floating\u2010point matrix (mat4) representing a right-handed no-clip perspective projection and a single floating-point scalar (float) that specifies an adjustment to the far clipping plane. It computes the current near and far clipping distances using specific elements from the matrix, adjusts the far distance by the provided scalar, and then recalculates and updates the corresponding entries in the matrix. The output is the modified projection matrix (mat4) reflecting the new far clipping plane position.",
        "code_id": "c_group_2_id_367",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_move_far_rh_no(mat4 proj, float deltaFar) {\n  float fn, farZ, nearZ, p22, p32;\n\n  p22        = proj[2][2];\n  p32        = proj[3][2];\n\n  nearZ    = p32 / (p22 - 1.0f);\n  farZ     = p32 / (p22 + 1.0f) + deltaFar;\n  fn         = 1.0f / (nearZ - farZ);\n\n  proj[2][2] = (farZ + nearZ) * fn;\n  proj[3][2] = 2.0f * nearZ * farZ * fn;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_368",
        "query_text": "SUMMARY: This inline function accepts an input of type integer array with three elements (ivec3) and returns no output (void). The function's behavior is to set each of the three integer elements in the array to zero, effectively initializing or resetting the array's contents.",
        "code_id": "c_group_2_id_368",
        "code_text": "CGLM_INLINE\nvoid \nglm_ivec3_zero(ivec3 v) {\n  v[0] = v[1] = v[2] = 0;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_369",
        "query_text": "SUMMARY: This function accepts a 3\u00d74 matrix (type mat3x4: an array of three 4-element float vectors) and a 3D vector (type vec3: an array of three floats) as inputs and produces a 4D vector (type vec4: an array of four floats) as output. It extracts the three scalar components of the 3D vector and, for each of the four output components, computes the sum of the products of these scalars with the corresponding elements from the 3\u00d74 matrix. Essentially, it performs a multiplication of the 3\u00d74 matrix with the 3D vector to generate a transformed 4D vector.",
        "code_id": "c_group_2_id_369",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x4_mulv(mat3x4 m, vec3 v, vec4 dest) {\n  float v0 = v[0], v1 = v[1], v2 = v[2];\n\n  dest[0] = m[0][0] * v0 + m[1][0] * v1 + m[2][0] * v2;\n  dest[1] = m[0][1] * v0 + m[1][1] * v1 + m[2][1] * v2;\n  dest[2] = m[0][2] * v0 + m[1][2] * v1 + m[2][2] * v2;\n  dest[3] = m[0][3] * v0 + m[1][3] * v1 + m[2][3] * v2;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_370",
        "query_text": "SUMMARY: This function takes as input an integer array of two elements and an integer scalar, and it modifies an output integer array of two elements by subtracting from each of its elements the sum of the corresponding element in the input integer array and the scalar.",
        "code_id": "c_group_2_id_370",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_addsubs(ivec2 a, int s, ivec2 dest) {\n  dest[0] -= a[0] + s;\n  dest[1] -= a[1] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_371",
        "query_text": "SUMMARY: This function takes an input 4\u00d74 matrix (of type mat4, which is an array of four 16-byte aligned float[4] vectors) and produces its transposed version as an output 4\u00d74 matrix (also of type mat4). It loads the rows of the input matrix into SIMD registers, transposes the 4\u00d74 data using SSE2 operations, and then stores the resulting vectors into the output matrix.",
        "code_id": "c_group_2_id_371",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_transp_sse2(mat4 m, mat4 dest) {\n  __m128 r0, r1, r2, r3;\n\n  r0 = glmm_load(m[0]);\n  r1 = glmm_load(m[1]);\n  r2 = glmm_load(m[2]);\n  r3 = glmm_load(m[3]);\n\n  _MM_TRANSPOSE4_PS(r0, r1, r2, r3);\n\n  glmm_store(dest[0], r0);\n  glmm_store(dest[1], r1);\n  glmm_store(dest[2], r2);\n  glmm_store(dest[3], r3);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_372",
        "query_text": "SUMMARY: This function takes as input a 4\u00d74 floating\u2010point matrix (of type mat4) representing a left-handed perspective projection and a single floating-point scalar (of type float). It recalculates and updates two specific elements of the matrix to effectively adjust the far clipping distance of the projection. To do so, the function derives the current near and far distances from the matrix\u2019s existing coefficients, adds an offset to the computed far distance, and then updates the matrix accordingly to maintain the correct projection transformation. The matrix is modified in place as the output.",
        "code_id": "c_group_2_id_372",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_move_far_lh_no(mat4 proj, float deltaFar) {\n  float fn, farZ, nearZ, p22, p32;\n\n  p22        = -proj[2][2];\n  p32        = proj[3][2];\n\n  nearZ    = p32 / (p22 - 1.0f);\n  farZ     = p32 / (p22 + 1.0f) + deltaFar;\n  fn         = 1.0f / (nearZ - farZ);\n\n  proj[2][2] = -(farZ + nearZ) * fn;\n  proj[3][2] = 2.0f * nearZ * farZ * fn;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_373",
        "query_text": "SUMMARY: This function accepts a 3x3 matrix (of type mat3, which is defined as an array of three vec3 arrays of floats) and a float scalar. It applies an in-place 2D translation along the horizontal axis to the matrix by updating its translation components. Specifically, it modifies the last row of the matrix by adding the product of the corresponding elements from the first row (representing the x-axis scale factors) and the float value to the existing values. The function does not return a value; instead, it directly alters the matrix.",
        "code_id": "c_group_2_id_373",
        "code_text": "CGLM_INLINE\nvoid\nglm_translate2d_x(mat3 m, float x) {\n  m[2][0] = m[0][0] * x + m[2][0];\n  m[2][1] = m[0][1] * x + m[2][1];\n  m[2][2] = m[0][2] * x + m[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_374",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 floating-point matrix (an array of four 4-element float vectors) and two pointers to floats as inputs. It computes two scalar floating-point outputs representing near and far clipping distances by extracting specific elements from the input matrix and applying division operations using those elements. Specifically, it derives the near clipping distance by dividing one matrix element by another, and the far clipping distance by dividing the same element by an incremented version of the other. The resulting values are stored in the provided float pointers.",
        "code_id": "c_group_2_id_374",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_z_rh_zo(mat4 proj,\n                         float * __restrict nearZ,\n                         float * __restrict farZ) {\n  float m32, m22;\n\n  m32 = proj[3][2];\n  m22 = proj[2][2];\n\n  *nearZ = m32 / m22;\n  *farZ  = m32 / (m22 + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_375",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two floats) and produces an output of the same type (an array of two floats) by computing the element-wise arithmetic negation of the input values. Specifically, it negates each of the two float elements from the input array and stores the results into the corresponding positions in the output array.",
        "code_id": "c_group_2_id_375",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_negate_to(vec2 v, vec2 dest) {\n  dest[0] = -v[0];\n  dest[1] = -v[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_376",
        "query_text": "SUMMARY: This function takes two inputs\u2014a 3-element integer array and a scalar integer\u2014and produces an output in the form of a 4-element integer array. It populates the first three elements of the output with the values from the input 3-element array and assigns the scalar integer to the fourth element of the output.",
        "code_id": "c_group_2_id_376",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4(ivec3 v3, int last, ivec4 dest) {\n  dest[0] = v3[0];\n  dest[1] = v3[1];\n  dest[2] = v3[2];\n  dest[3] = last;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_377",
        "query_text": "SUMMARY: This function accepts as inputs a 4\u00d74 float matrix (of type vec4[4]) and a pointer to a FILE stream (of type FILE*). It does not return any value. Its functionality is to print a formatted textual representation of the 4\u00d74 matrix to the given FILE stream. The function begins by outputting a header that indicates the dimensions of the matrix, then measures the formatted width of each element (using either fixed decimal precision or general formatting based on a preset threshold) to determine appropriate column widths. Using these computed column widths, it generates and prints each row of the matrix within a bordered layout and applies designated color formatting, finally resetting the color output once printing completes.",
        "code_id": "c_group_2_id_377",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_print(mat4              matrix,\n               FILE * __restrict ostream) {\n  char buff[16];\n  int  i, j, cw[4], cwi;\n\n#define m 4\n#define n 4\n\n  fprintf(ostream, \"Matrix (float%dx%d): \" CGLM_PRINT_COLOR \"\\n\" , m, n);\n\n  cw[0] = cw[1] = cw[2] = cw[3] = 0;\n\n  for (i = 0; i < m; i++) {\n    for (j = 0; j < n; j++) {\n      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)\n        cwi = snprintf(buff, sizeof(buff), \"% .*f\", CGLM_PRINT_PRECISION, (double)matrix[i][j]);\n      else\n        cwi = snprintf(buff, sizeof(buff), \"% g\", (double)matrix[i][j]);\n      cw[i] = GLM_MAX(cw[i], cwi);\n    }\n  }\n\n  for (i = 0; i < m; i++) {\n    fprintf(ostream, \"  |\");\n\n    for (j = 0; j < n; j++)\n      if (matrix[i][j] < CGLM_PRINT_MAX_TO_SHORT)\n        fprintf(ostream, \" % *.*f\", cw[j], CGLM_PRINT_PRECISION, (double)matrix[j][i]);\n      else\n        fprintf(ostream, \" % *g\", cw[j], (double)matrix[j][i]);\n\n    fprintf(ostream, \"  |\\n\");\n  }\n\n  fprintf(ostream, CGLM_PRINT_COLOR_RESET \"\\n\");\n\n#undef m\n#undef n\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_378",
        "query_text": "SUMMARY: This function accepts two inputs, each being an array of two integers (ivec2), representing 2D integer vectors. It calculates the squared differences between the corresponding components of these two arrays and returns the sum of these squared values as an integer.",
        "code_id": "c_group_2_id_378",
        "code_text": "CGLM_INLINE\nint\nglm_ivec2_distance2(ivec2 a, ivec2 b) {\n  int xd, yd;\n  xd = a[0] - b[0];\n  yd = a[1] - b[1];\n  return xd * xd + yd * yd;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_379",
        "query_text": "SUMMARY: This function accepts two input variables, each of type ivec2 (an array of 2 integers), and an output variable of the same type. It calculates the integer division of each corresponding element from the two input arrays and stores each result in the output array.",
        "code_id": "c_group_2_id_379",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_div(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] = a[0] / b[0];\n  dest[1] = a[1] / b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_380",
        "query_text": "SUMMARY: This function operates on three variables of type ivec2 (arrays of two integers). It computes the element-wise remainder of the integers from the first input against the corresponding integers from the second input and stores the results in the output variable of type ivec2.",
        "code_id": "c_group_2_id_380",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_mod(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] = a[0] % b[0];\n  dest[1] = a[1] % b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_381",
        "query_text": "SUMMARY: This function operates on three variables of type ivec2 (i.e., arrays of two integers). It computes the element-wise difference between the first and second input vectors and then adds each difference to the corresponding element of the output vector. Specifically, for the first element, it adds the difference (first input's element minus second input's element) to the first element of the output vector, and similarly for the second element.",
        "code_id": "c_group_2_id_381",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec2_subadd(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] += a[0] - b[0];\n  dest[1] += a[1] - b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_382",
        "query_text": "SUMMARY: This function operates on a 4-element integer array (ivec4) and an integer scalar as inputs, and it produces an output in a 4-element integer array (ivec4). For each corresponding element, it subtracts the result of subtracting the scalar from the input vector element, then updates the output array element with this computed difference.",
        "code_id": "c_group_2_id_382",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_subsubs(ivec4 a, int s, ivec4 dest) {\n  dest[0] -= a[0] - s;\n  dest[1] -= a[1] - s;\n  dest[2] -= a[2] - s;\n  dest[3] -= a[3] - s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_383",
        "query_text": "SUMMARY: This function takes an integer vector of three elements (ivec3) and two integer values representing a minimum and a maximum. It ensures that each element of the vector is adjusted to lie within the inclusive range defined by these minimum and maximum values. If any element is less than the minimum, it is set to the minimum; if it is greater than the maximum, it is set to the maximum. The function performs these modifications in place and does not return a value.",
        "code_id": "c_group_2_id_383",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_clamp(ivec3 v, int minVal, int maxVal) {\n  if (v[0] < minVal)\n    v[0] = minVal;\n  else if(v[0] > maxVal)\n    v[0] = maxVal;\n\n  if (v[1] < minVal)\n    v[1] = minVal;\n  else if(v[1] > maxVal)\n    v[1] = maxVal;\n\n  if (v[2] < minVal)\n    v[2] = minVal;\n  else if(v[2] > maxVal)\n    v[2] = maxVal;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_384",
        "query_text": "SUMMARY: This function operates on three input parameters, each of type vec4 (an aligned array of 4 floating-point values). It computes an element-wise subtraction between the first and second vec4 values and then subtracts the resulting difference from the third vec4 value, updating it in place with the outcome. The operation essentially performs, for each of the 4 elements, a calculation akin to: output element = original output element minus (first element minus second element), using the most appropriate vectorized instructions available for the current platform.",
        "code_id": "c_group_2_id_384",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_subsub(vec4 a, vec4 b, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_sub(\n          glmm_load(dest),\n          wasm_f32x4_sub(glmm_load(a), glmm_load(b))));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_sub_ps(glmm_load(dest),\n                              _mm_sub_ps(glmm_load(a),\n                                         glmm_load(b))));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vsubq_f32(vld1q_f32(dest),\n                            vsubq_f32(vld1q_f32(a),\n                                      vld1q_f32(b))));\n#else\n  dest[0] -= a[0] - b[0];\n  dest[1] -= a[1] - b[1];\n  dest[2] -= a[2] - b[2];\n  dest[3] -= a[3] - b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_385",
        "query_text": "SUMMARY: This function processes an input of type int[4] and an integer scalar. It multiplies each of the four integer elements from the input by the scalar and stores the results in an output of type int[4].",
        "code_id": "c_group_2_id_385",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_scale(ivec4 v, int s, ivec4 dest) {\n  dest[0] = v[0] * s;\n  dest[1] = v[1] * s;\n  dest[2] = v[2] * s;\n  dest[3] = v[3] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_386",
        "query_text": "SUMMARY: This function accepts a 3-element vector of floats (vec3) representing Euler angles and computes a corresponding quaternion (versor, a 4-element aligned float array) that applies the rotation defined by a Y-X-Z ordering in a left-handed coordinate system. It calculates half-angle sine and cosine components for each Euler angle (with the sine of the third angle negated to account for the coordinate system), then combines these values to produce the four components of the resulting quaternion.",
        "code_id": "c_group_2_id_386",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_yxz_quat_lh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs =  sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys =  sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = -sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] =  yc * xs * zc + ys * xc * zs;\n  dest[1] = -yc * xs * zs + ys * xc * zc;\n  dest[2] =  yc * xc * zs - ys * xs * zc;\n  dest[3] =  yc * xc * zc + ys * xs * zs;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_387",
        "query_text": "SUMMARY: This function takes a 4\u00d73 matrix (of type mat4x3, i.e., an array of four 3-element single-precision floating-point vectors) and a scalar (of type float) as inputs. It scales every element of the provided matrix by multiplying each float value by the scalar, modifying the matrix in place. The function does not return any value.",
        "code_id": "c_group_2_id_387",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x3_scale(mat4x3 m, float s) {\n  m[0][0] *= s;  m[0][1] *= s;  m[0][2] *= s;  m[1][0] *= s;\n  m[1][1] *= s;  m[1][2] *= s;  m[2][0] *= s;  m[2][1] *= s;\n  m[2][2] *= s;  m[3][0] *= s;  m[3][1] *= s;  m[3][2] *= s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_388",
        "query_text": "SUMMARY: This function accepts a scalar of type float and computes a four-element vector (vec4, an array of 4 floats). It calculates the cube, square, and the first power of the input value and then sets a constant value, resulting in an output vector whose elements correspond respectively to the cubic term, quadratic term, linear term, and the constant 1.0.",
        "code_id": "c_group_2_id_388",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_cubic(float s, vec4 dest) {\n  float ss;\n\n  ss = s * s;\n\n  dest[0] = ss * s;\n  dest[1] = ss;\n  dest[2] = s;\n  dest[3] = 1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_389",
        "query_text": "SUMMARY: This function accepts an input parameter of type ivec2 (an array of 2 integers) and assigns the value 1 to both of its elements. It operates directly on the provided array and does not return any value.",
        "code_id": "c_group_2_id_389",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_one(ivec2 v) {\n  v[0] = v[1] = 1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_390",
        "query_text": "SUMMARY: This function accepts an input of type vec3 (an array of three floats) and returns an output of type float. It computes the sum of the three float values contained in the input array by adding them together and then returns the resulting float.",
        "code_id": "c_group_2_id_390",
        "code_text": "CGLM_INLINE\nfloat\nglm_vec3_hadd(vec3 v) {\n  return v[0] + v[1] + v[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_391",
        "query_text": "SUMMARY: This function accepts two input parameters: one of type int[4] (a four-element integer array) and one of type FILE* (a pointer to a file stream). It outputs no value. Its behavior is to format and print the provided 4-element integer array to the given file stream, including a header indicating the vector\u2019s size and a list of its elements, with additional formatting (such as color markers) applied to the output.",
        "code_id": "c_group_2_id_391",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_print(ivec4             vec,\n                FILE * __restrict ostream) {\n  int i;\n\n#define m 4\n\n  fprintf(ostream, \"Vector (int%d): \" CGLM_PRINT_COLOR \"\\n  (\", m);\n\n  for (i = 0; i < m; i++)\n    fprintf(ostream, \" % d\", vec[i]);\n\n  fprintf(ostream, \"  )\" CGLM_PRINT_COLOR_RESET \"\\n\\n\");\n\n#undef m\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_392",
        "query_text": "SUMMARY: This function accepts a floating-point value and a 4\u00d74 matrix of floats (where the matrix is represented as an array of four aligned 4-element vectors) and outputs no value (performing in-place modification). It verifies if the top-left element of the matrix is nonzero; if so, it updates that element by dividing another matrix element (the one representing the vertical scale) by the given float. Essentially, it adjusts the projection matrix\u2019s horizontal scaling based on an aspect ratio.",
        "code_id": "c_group_2_id_392",
        "code_text": "CGLM_INLINE\nvoid\nglm_perspective_resize_rh_no(float aspect, mat4 proj) {\n  if (proj[0][0] == 0.0f)\n    return;\n\n  proj[0][0] = proj[1][1] / aspect;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_393",
        "query_text": "SUMMARY: The function accepts three variables of type ivec4 (which are arrays of four integers). It modifies the output array by subtracting, for each of its four elements, the sum of the corresponding elements from the two input arrays.",
        "code_id": "c_group_2_id_393",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_addsub(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] -= a[0] + b[0];\n  dest[1] -= a[1] + b[1];\n  dest[2] -= a[2] + b[2];\n  dest[3] -= a[3] + b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_394",
        "query_text": "SUMMARY: This function takes an input parameter of type \"array of 4 integers\" (ivec4) and performs an in-place modification where each element of the array is set to the integer value 1. There is no return value, as the function directly modifies the input.",
        "code_id": "c_group_2_id_394",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_one(ivec4 v) {\n  v[0] = v[1] = v[2] = v[3] = 1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_395",
        "query_text": "SUMMARY: This function takes two input parameters, each being an array of 2 floats, and returns a single float. It computes the dot product of the two 2-dimensional float vectors by performing element-wise multiplication and summing the results.",
        "code_id": "c_group_2_id_395",
        "code_text": "CGLM_INLINE\nfloat\nglm_vec2_dot(vec2 a, vec2 b) {\n  return a[0] * b[0] + a[1] * b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_396",
        "query_text": "SUMMARY: This function takes a 3-element floating-point vector (vec3) and a 4\u00d74 floating-point matrix (mat4) as inputs, and returns a floating-point value. It computes two intermediate scalar values by linearly combining the vector's components with specific columns of the matrix. The first scalar represents the transformed depth (from the matrix\u2019s third column and translation component), while the second represents a homogeneous coordinate (using the matrix\u2019s fourth column and translation component). The function then performs a perspective division of these two scalars and scales/shifts the result to yield a normalized depth value in a 0 to 1 range.",
        "code_id": "c_group_2_id_396",
        "code_text": "CGLM_INLINE\nfloat\nglm_project_z_no(vec3 v, mat4 m) {\n  float z, w;\n\n  z = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2];\n  w = m[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3];\n\n  return 0.5f * (z / w) + 0.5f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_397",
        "query_text": "SUMMARY: This function accepts one parameter of type int[3] (an array of three integers) and sets each element of the array to the integer value 1, modifying the array in place without returning any value.",
        "code_id": "c_group_2_id_397",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_one(ivec3 v) {\n  v[0] = v[1] = v[2] = 1;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_398",
        "query_text": "SUMMARY: This function takes an input vector (an aligned array of four floats), a scalar value (a float), and an output vector (an aligned array of four floats). It subtracts the scalar from each element of the input vector and stores the resulting values in the output vector. The implementation uses architecture-specific vectorized operations for platforms supporting WebAssembly SIMD, SSE, or NEON, and falls back to element-wise subtraction if those optimizations are not available.",
        "code_id": "c_group_2_id_398",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_subs(vec4 v, float s, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_sub(glmm_load(v), wasm_f32x4_splat(s)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_sub_ps(glmm_load(v), _mm_set1_ps(s)));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vsubq_f32(vld1q_f32(v), vdupq_n_f32(s)));\n#else\n  dest[0] = v[0] - s;\n  dest[1] = v[1] - s;\n  dest[2] = v[2] - s;\n  dest[3] = v[3] - s;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_399",
        "query_text": "SUMMARY: This function accepts a constant pointer to a float (input type: const float*) and populates a 3 by 2 matrix (output type: mat3x2, defined as an array of 3 float arrays of length 2) with values. It sequentially assigns the first two floats from the input to the first row of the matrix, the next two floats to the second row, and the final two floats to the third row.",
        "code_id": "c_group_2_id_399",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x2_make(const float * __restrict src, mat3x2 dest) {\n  dest[0][0] = src[0];\n  dest[0][1] = src[1];\n\n  dest[1][0] = src[2];\n  dest[1][1] = src[3];\n\n  dest[2][0] = src[4];\n  dest[2][1] = src[5];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_400",
        "query_text": "SUMMARY: This function accepts two input parameters, each being an array of three integers (int[3]), and calculates a component-wise sum of these arrays. The resulting array of three integers (int[3]) holds the sum of the corresponding elements from the two input arrays, with each position in the output computed by adding the respective integers from the inputs.",
        "code_id": "c_group_2_id_400",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_add(ivec3 a, ivec3 b, ivec3 dest) {\n  dest[0] = a[0] + b[0];\n  dest[1] = a[1] + b[1];\n  dest[2] = a[2] + b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_401",
        "query_text": "SUMMARY: This function accepts two input variables, each of type ivec4 (a 4-element integer array), along with an output variable of the same type. For each of the four integer elements, it computes the product of the corresponding elements from the two input arrays and subtracts that product from the corresponding element in the output array. In other words, it performs an element-wise multiply\u2013subtract operation on the output array.",
        "code_id": "c_group_2_id_401",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_mulsub(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] -= a[0] * b[0];\n  dest[1] -= a[1] * b[1];\n  dest[2] -= a[2] * b[2];\n  dest[3] -= a[3] * b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_402",
        "query_text": "SUMMARY: This function takes a 3-element float array, a float, and another 3-element float array as inputs. It multiplies each element of the first 3-element array by the float and then adds the resulting product to the corresponding element of the second 3-element array, updating it in place as the output.",
        "code_id": "c_group_2_id_402",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_muladds(vec3 a, float s, vec3 dest) {\n  dest[0] += a[0] * s;\n  dest[1] += a[1] * s;\n  dest[2] += a[2] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_403",
        "query_text": "SUMMARY: This function operates on two-dimensional floating-point arrays (vec2) and a floating-point scalar. It subtracts, for each element, the product of the corresponding element of the first two-dimensional array and the scalar from the respective element of the second two-dimensional array, thereby updating the second array in place.",
        "code_id": "c_group_2_id_403",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_mulsubs(vec2 a, float s, vec2 dest) {\n  dest[0] -= a[0] * s;\n  dest[1] -= a[1] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_404",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two float values) and a float scalar, computes the floating-point remainder (using the fmod operation) of each element in the input array with the scalar, and outputs a vec2 (an array of two float values) containing these remainders.",
        "code_id": "c_group_2_id_404",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_mods(vec2 v, float s, vec2 dest) {\n  dest[0] = fmodf(v[0], s);\n  dest[1] = fmodf(v[1], s);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_405",
        "query_text": "SUMMARY: This function accepts an input of type mat4 (a 4x4 matrix of floats with 16-byte alignment) and a pointer to a float as output. It computes the near clipping plane distance for a right-handed perspective projection with a zero to one depth range. Specifically, it calculates the near distance by dividing a specific element from the fourth row by an element from the third row of the input matrix, and then stores the result via the provided float pointer.",
        "code_id": "c_group_2_id_405",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_near_rh_zo(mat4 proj, float * __restrict nearZ) {\n  *nearZ = proj[3][2] / proj[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_406",
        "query_text": "SUMMARY: This function takes as input a 4-element array of floats (vec4) and a single float value, and it produces an output 4-element array of floats (vec4). It computes the floating-point remainder (using fmodf) of each component of the input array with respect to the provided float, storing the result in the corresponding component of the output array.",
        "code_id": "c_group_2_id_406",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_mods(vec4 v, float s, vec4 dest) {\n  dest[0] = fmodf(v[0], s);\n  dest[1] = fmodf(v[1], s);\n  dest[2] = fmodf(v[2], s);\n  dest[3] = fmodf(v[3], s);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_407",
        "query_text": "SUMMARY: This function converts a set of Euler angles, provided as an array of 3 floats (vec3), into a quaternion represented as an array of 4 floats (versor) using right-handed conventions. Initially, it computes the sine and cosine of half of each Euler angle. Then, it combines these trigonometric values to calculate the four components of the quaternion, encapsulating the rotation defined by the Euler angles.",
        "code_id": "c_group_2_id_407",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_xyz_quat_rh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs = sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys = sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] = xc * ys * zs + xs * yc * zc;\n  dest[1] = xc * ys * zc - xs * yc * zs;\n  dest[2] = xc * yc * zs + xs * ys * zc;\n  dest[3] = xc * yc * zc - xs * ys * zs;\n\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_408",
        "query_text": "SUMMARY: This function takes two inputs\u2014a matrix of type mat3 (which is a 3\u00d73 array of floats) and a scalar of type float\u2014and modifies the matrix in place. It multiplies every element in the first and second rows of the matrix by the scalar value (performing a uniform scaling in the 2D sense), while leaving the third row unchanged. The function does not return any value (void output).",
        "code_id": "c_group_2_id_408",
        "code_text": "CGLM_INLINE\nvoid\nglm_scale2d_uni(mat3 m, float s) {\n  m[0][0] = m[0][0] * s;\n  m[0][1] = m[0][1] * s;\n  m[0][2] = m[0][2] * s;\n\n  m[1][0] = m[1][0] * s;\n  m[1][1] = m[1][1] * s;\n  m[1][2] = m[1][2] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_409",
        "query_text": "SUMMARY: This function performs an element-wise addition by adding a scalar (float) to each component of a two-dimensional vector (float array of two elements). It takes two inputs\u2014a two-element floating-point vector and a scalar of type float\u2014and produces an output of the same two-element float array type where each element is the sum of the corresponding input element and the scalar value.",
        "code_id": "c_group_2_id_409",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_adds(vec2 v, float s, vec2 dest) {\n  dest[0] = v[0] + s;\n  dest[1] = v[1] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_410",
        "query_text": "SUMMARY: This function accepts an input of type vec2 (an array of two floats) and a scalar of type float. It computes the quotient of each element in the vec2 by the float scalar and returns the results in an output vec2 (an array of two floats).",
        "code_id": "c_group_2_id_410",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_divs(vec2 v, float s, vec2 dest) {\n  dest[0] = v[0] / s;\n  dest[1] = v[1] / s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_411",
        "query_text": "SUMMARY: This function accepts a 4x4 matrix (an array of four aligned 4-element float vectors) and a pointer to a float output. It computes the far clipping plane distance for a right-handed perspective projection without a near plane by performing arithmetic on specific elements of the input matrix, then writes the computed value to the float pointed to by the second argument.",
        "code_id": "c_group_2_id_411",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_far_rh_no(mat4 proj, float * __restrict farZ) {\n  *farZ = proj[3][2] / (proj[2][2] + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_412",
        "query_text": "SUMMARY: This function accepts a constant pointer to a float (type: const float *) that points to a sequence of nine float values and produces a 3x3 matrix (type: mat3, an array of three vec3 arrays). It sequentially copies the nine float values into the matrix by mapping the first three values to the first vector, the next three to the second vector, and the final three to the third vector.",
        "code_id": "c_group_2_id_412",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3_make(const float * __restrict src, mat3 dest) {\n  dest[0][0] = src[0];\n  dest[0][1] = src[1];\n  dest[0][2] = src[2];\n\n  dest[1][0] = src[3];\n  dest[1][1] = src[4];\n  dest[1][2] = src[5];\n\n  dest[2][0] = src[6];\n  dest[2][1] = src[7];\n  dest[2][2] = src[8];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_413",
        "query_text": "SUMMARY: This function receives a 4\u00d74 matrix (of type mat4, which is an array of four 4-element float vectors) and a floating-point scalar value. It multiplies every element of the matrix by the scalar, performing the operation in a vectorized manner using SSE2 instructions. The scaled matrix is updated in place and returned as type mat4.",
        "code_id": "c_group_2_id_413",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_scale_sse2(mat4 m, float s) {\n  __m128 x0;\n  x0 = _mm_set1_ps(s);\n\n  glmm_store(m[0], _mm_mul_ps(glmm_load(m[0]), x0));\n  glmm_store(m[1], _mm_mul_ps(glmm_load(m[1]), x0));\n  glmm_store(m[2], _mm_mul_ps(glmm_load(m[2]), x0));\n  glmm_store(m[3], _mm_mul_ps(glmm_load(m[3]), x0));\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_414",
        "query_text": "SUMMARY: This function receives an array of two integers (ivec2) and a single integer (int) as inputs, then assigns the integer value to both elements of the array. It performs this operation by directly updating the first and second elements of the array, effectively filling the two-element vector with the same integer value. There is no explicit return value, as the output is provided by modifying the input array in place.",
        "code_id": "c_group_2_id_414",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_fill(ivec2 v, int val) {\n  v[0] = v[1] = val;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_415",
        "query_text": "SUMMARY: This function accepts a 4x4 matrix of floats (mat4) and two pointers to floats as inputs and outputs. Its purpose is to decompose a perspective projection matrix, extracting the vertical extents (top and bottom values) based on the given projection parameters. Internally, it reads specific elements from the matrix to compute an effective near clip distance and then uses this near value along with other matrix elements to derive the top and bottom extents. These computed float values are written to the provided memory locations for further use.",
        "code_id": "c_group_2_id_415",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_y_lh_zo(mat4 proj,\n                         float * __restrict top,\n                         float * __restrict bottom) {\n  float nearZ, m21, m11;\n\n  m21 = proj[2][1];\n  m11 = proj[1][1];\n\n  nearZ = proj[3][2] / (proj[3][3]);\n  *bottom = nearZ * (m21 - 1) / m11;\n  *top    = nearZ * (m21 + 1) / m11;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_416",
        "query_text": "SUMMARY: This function takes two arrays of three floats (vec3) as arguments. It processes the input by applying the floor mathematical operation (which rounds each float down to the nearest integer value) to every element of the first array, and writes the resulting three values into the corresponding positions of the second array. The function does not return a value.",
        "code_id": "c_group_2_id_416",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_floor(vec3 v, vec3 dest) {\n  dest[0] = floorf(v[0]);\n  dest[1] = floorf(v[1]);\n  dest[2] = floorf(v[2]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_417",
        "query_text": "SUMMARY: This function accepts an input of type int[3] and an int value. It assigns the provided int to every element of the int[3] array, resulting in all entries containing the same integer. The function does not return any value (void).",
        "code_id": "c_group_2_id_417",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_fill(ivec3 v, int val) {\n  v[0] = v[1] = v[2] = val;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_418",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (represented as an array of four aligned 4-element floating-point vectors) as its input along with two output pointers to floating-point numbers. It computes two values by extracting specific elements from the matrix, processing them through simple arithmetic, and then assigns the results to the two output floats, which represent the near and far clipping plane distances derived from the perspective projection parameters.",
        "code_id": "c_group_2_id_418",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_z_lh_zo(mat4 proj,\n                         float * __restrict nearZ,\n                         float * __restrict farZ) {\n  float m32, m22;\n\n  m32 = proj[3][2];\n  m22 = -proj[2][2];\n\n  *nearZ = m32 / m22;\n  *farZ  = m32 / (m22 + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_419",
        "query_text": "SUMMARY: This function takes a single precision floating-point value as input along with a four-by-four matrix (an array of four vec4, where each vec4 is an array of four floats). It first checks whether the (0,0) element of the matrix is zero, and if so, it exits without modification. Otherwise, it recalculates that (0,0) element by dividing the (1,1) element of the matrix by the input floating-point value. The modified matrix serves as the function's output.",
        "code_id": "c_group_2_id_419",
        "code_text": "CGLM_INLINE\nvoid\nglm_perspective_resize_lh_zo(float aspect, mat4 proj) {\n  if (proj[0][0] == 0.0f)\n    return;\n\n  proj[0][0] = proj[1][1] / aspect;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_420",
        "query_text": "SUMMARY: This function multiplies a 4x3 matrix (defined as an array of 4 vectors, where each vector is an array of 3 floats) by a 4-dimensional vector (aligned array of 4 floats) to compute a resulting 3-dimensional vector (array of 3 floats). It operates by individually extracting the four float components of the 4-dimensional input and then calculating each component of the 3-dimensional result as the sum of products of corresponding entries from the matrix and vector.",
        "code_id": "c_group_2_id_420",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x3_mulv(mat4x3 m, vec4 v, vec3 dest) {\n  float v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n\n  dest[0] = m[0][0] * v0 + m[1][0] * v1 + m[2][0] * v2 + m[3][0] * v3;\n  dest[1] = m[0][1] * v0 + m[1][1] * v1 + m[2][1] * v2 + m[3][1] * v3;\n  dest[2] = m[0][2] * v0 + m[1][2] * v1 + m[2][2] * v2 + m[3][2] * v3;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_421",
        "query_text": "SUMMARY: This function performs a copy operation from one 4\u00d73 matrix to another. It takes an input of type mat4x3 (an array of 4 vectors, where each vector consists of 3 floats) and outputs a mat4x3 by copying each element individually from the input to the destination matrix. Line by line, the function assigns each float from the corresponding positions in the source matrix to the destination matrix, effectively replicating the entire matrix.",
        "code_id": "c_group_2_id_421",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x3_copy(mat4x3 mat, mat4x3 dest) {\n  dest[0][0] = mat[0][0];\n  dest[0][1] = mat[0][1];\n  dest[0][2] = mat[0][2];\n\n  dest[1][0] = mat[1][0];\n  dest[1][1] = mat[1][1];\n  dest[1][2] = mat[1][2];\n\n  dest[2][0] = mat[2][0];\n  dest[2][1] = mat[2][1];\n  dest[2][2] = mat[2][2];\n\n  dest[3][0] = mat[3][0];\n  dest[3][1] = mat[3][1];\n  dest[3][2] = mat[3][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_422",
        "query_text": "SUMMARY: This function accepts two input variables of type float[2] and computes a new float[2] by performing component-wise multiplication. Specifically, it multiplies the first element of the first input with the first element of the second input and the second element of the first input with the second element of the second input, storing the results in the output variable of type float[2].",
        "code_id": "c_group_2_id_422",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_mul(vec2 a, vec2 b, vec2 dest) {\n  dest[0] = a[0] * b[0];\n  dest[1] = a[1] * b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_423",
        "query_text": "SUMMARY: This function takes a 4\u00d74 matrix (an array of four 4-element float vectors, type mat4) as input and returns a float. It computes a perspective field-of-view angle in radians by accessing a specific element from the matrix (the one at the second row and second column), calculating the reciprocal of that element, applying the arctan function to this reciprocal, and finally multiplying the result by two.",
        "code_id": "c_group_2_id_423",
        "code_text": "CGLM_INLINE\nfloat\nglm_persp_fovy(mat4 proj) {\n  return 2.0f * atanf(1.0f / proj[1][1]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_424",
        "query_text": "SUMMARY: This function accepts a 4-element floating-point vector (type: vec4, which is an array of 4 floats) and returns a single floating-point value (type: float). The function retrieves and returns the fourth element from the input vector.",
        "code_id": "c_group_2_id_424",
        "code_text": "CGLM_INLINE\nfloat\nglm_sphere_radii(vec4 s) {\n  return s[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_425",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 single\u2010precision floating-point matrix and two pointers to single-precision floats as inputs and computes two scalar values representing vertical boundaries. It extracts specific elements from the matrix corresponding to vertical scaling and translation parameters, computes a near-plane distance using another matrix element, and then calculates the upper and lower vertical limits based on these extracted values. The resulting computed single-precision floats are output via the provided pointer parameters.",
        "code_id": "c_group_2_id_425",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_y_rh_no(mat4 proj,\n                         float * __restrict top,\n                         float * __restrict bottom) {\n  float nearZ, m21, m11, m22;\n\n  m21 = proj[2][1];\n  m11 = proj[1][1];\n  m22 = proj[2][2];\n\n  nearZ = proj[3][2] / (m22 - 1.0f);\n  *bottom = nearZ * (m21 - 1.0f) / m11;\n  *top    = nearZ * (m21 + 1.0f) / m11;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_426",
        "query_text": "SUMMARY: This function converts a rotation specified by Euler angles to a quaternion. It accepts a three-element float array (vec3) representing Euler angles in radians and produces a four-element float array (versor) representing the corresponding quaternion rotation in a right-handed coordinate system. The function computes the sine and cosine of half of each Euler angle and then combines these intermediary values to generate the quaternion components.",
        "code_id": "c_group_2_id_426",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_xzy_quat_rh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs = sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys = sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] = -xc * zs * ys + xs * zc * yc;\n  dest[1] =  xc * zc * ys - xs * zs * yc;\n  dest[2] =  xc * zs * yc + xs * zc * ys;\n  dest[3] =  xc * zc * yc + xs * zs * ys;  \n\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_427",
        "query_text": "SUMMARY: This inline function takes two inputs: a 3-component float array and a float number, and it produces a 4-component float array as output. The function assigns the elements of the input 3-component float array to the first three positions of the output array, and then it assigns the float number to the fourth position of the output array.",
        "code_id": "c_group_2_id_427",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4(vec3 v3, float last, vec4 dest) {\n  dest[0] = v3[0];\n  dest[1] = v3[1];\n  dest[2] = v3[2];\n  dest[3] = last;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_428",
        "query_text": "SUMMARY: This function computes the transpose of a matrix. It takes an input of type mat4x3 (an array of four vectors, each containing three float elements, representing a 4\u00d73 matrix) and produces an output of type mat3x4 (an array of three vectors, each containing four float elements, representing a 3\u00d74 matrix). The function rearranges the elements so that the element originally at the position (row, column) in the input matrix is placed at the position (column, row) in the output matrix.",
        "code_id": "c_group_2_id_428",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x3_transpose(mat4x3 m, mat3x4 dest) {\n  dest[0][0] = m[0][0];\n  dest[0][1] = m[1][0];\n  dest[0][2] = m[2][0];\n  dest[0][3] = m[3][0];\n\n  dest[1][0] = m[0][1];\n  dest[1][1] = m[1][1];\n  dest[1][2] = m[2][1];\n  dest[1][3] = m[3][1];\n\n  dest[2][0] = m[0][2];\n  dest[2][1] = m[1][2];\n  dest[2][2] = m[2][2];\n  dest[2][3] = m[3][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_429",
        "query_text": "SUMMARY: This function computes the element-wise subtraction of two four-element floating-point vectors (each defined as a 16-byte aligned float array) and stores the resulting vector in a provided output. It accepts two input arrays of type vec4 (which are essentially float[4] arrays) and produces a vec4 as output, utilizing platform-specific SIMD operations when available, or performing manual subtraction for each component otherwise.",
        "code_id": "c_group_2_id_429",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_sub(vec4 a, vec4 b, vec4 dest) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(dest, wasm_f32x4_sub(glmm_load(a), glmm_load(b)));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(dest, _mm_sub_ps(glmm_load(a), glmm_load(b)));\n#elif defined(CGLM_NEON_FP)\n  vst1q_f32(dest, vsubq_f32(vld1q_f32(a), vld1q_f32(b)));\n#else\n  dest[0] = a[0] - b[0];\n  dest[1] = a[1] - b[1];\n  dest[2] = a[2] - b[2];\n  dest[3] = a[3] - b[3];\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_430",
        "query_text": "SUMMARY: This function takes a 3-element integer array and an integer as inputs, and produces a 3-element integer array as output. It adds the integer input to each element of the input array and stores the resulting values in the output array.",
        "code_id": "c_group_2_id_430",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_adds(ivec3 v, int s, ivec3 dest) {\n  dest[0] = v[0] + s;\n  dest[1] = v[1] + s;\n  dest[2] = v[2] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_431",
        "query_text": "SUMMARY: This function accepts an input of type float[2] (a two-dimensional vector) and a float value, then it updates the vector in place so that both of its elements match the provided float value. It does not return any value.",
        "code_id": "c_group_2_id_431",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_fill(vec2 v, float val) {\n  v[0] = v[1] = val;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_432",
        "query_text": "SUMMARY: The function takes two input parameters\u2014a 3-element integer array (ivec3) and an integer scalar\u2014along with an output parameter, which is also a 3-element integer array (ivec3). It multiplies each element of the input array by the scalar and then adds the resulting product to the corresponding element of the output array.",
        "code_id": "c_group_2_id_432",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_muladds(ivec3 a, int s, ivec3 dest) {\n  dest[0] += a[0] * s;\n  dest[1] += a[1] * s;\n  dest[2] += a[2] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_433",
        "query_text": "SUMMARY: This function takes a float[3] array as its input and returns no output. The function's behavior is to set each of the three float elements in the array to the value 1.0f.",
        "code_id": "c_group_2_id_433",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_one(vec3 v) {\n  v[0] = v[1] = v[2] = 1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_434",
        "query_text": "SUMMARY: The function takes as input a projection matrix (of type vec4 mat4) and several pointers to floating\u2010point variables (of type float*), and it decomposes the matrix to extract the parameters of a left-handed perspective projection. Specifically, it calculates the near and far clipping distances and determines the boundaries (top, bottom, left, right) of the projection frustum by extracting specific elements from the matrix and using them in arithmetic expressions. The computed values are then stored via the provided output pointers.",
        "code_id": "c_group_2_id_434",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_lh_no(mat4 proj,\n                       float * __restrict nearZ, float * __restrict farZ,\n                       float * __restrict top,   float * __restrict bottom,\n                       float * __restrict left,  float * __restrict right) {\n  float m00, m11, m20, m21, m22, m32, n, f;\n  float n_m11, n_m00;\n\n  m00 = proj[0][0];\n  m11 = proj[1][1];\n  m20 = proj[2][0];\n  m21 = proj[2][1];\n  m22 =-proj[2][2];\n  m32 = proj[3][2];\n\n  n = m32 / (m22 - 1.0f);\n  f = m32 / (m22 + 1.0f);\n\n  n_m11 = n / m11;\n  n_m00 = n / m00;\n\n  *nearZ = n;\n  *farZ  = f;\n  *bottom  = n_m11 * (m21 - 1.0f);\n  *top     = n_m11 * (m21 + 1.0f);\n  *left    = n_m00 * (m20 - 1.0f);\n  *right   = n_m00 * (m20 + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_435",
        "query_text": "SUMMARY: This function takes a four-element array of integers (int[4]) as input and computes the absolute value of each element, storing the results in a separate four-element array of integers (int[4]).",
        "code_id": "c_group_2_id_435",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec4_abs(ivec4 v, ivec4 dest) {\n  dest[0] = abs(v[0]);\n  dest[1] = abs(v[1]);\n  dest[2] = abs(v[2]);\n  dest[3] = abs(v[3]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_436",
        "query_text": "SUMMARY: This function takes a 4x4 floating-point matrix (mat4) as input and produces a 3x3 floating-point matrix (mat3) as output. It extracts the upper-left 3x3 submatrix by copying the first three elements of the first three rows from the 4x4 matrix into the 3x3 matrix.",
        "code_id": "c_group_2_id_436",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_pick3(mat4 mat, mat3 dest) {\n  dest[0][0] = mat[0][0];\n  dest[0][1] = mat[0][1];\n  dest[0][2] = mat[0][2];\n\n  dest[1][0] = mat[1][0];\n  dest[1][1] = mat[1][1];\n  dest[1][2] = mat[1][2];\n\n  dest[2][0] = mat[2][0];\n  dest[2][1] = mat[2][1];\n  dest[2][2] = mat[2][2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_437",
        "query_text": "SUMMARY: This function processes an input 4-element array of floats and writes to an output 4-element array of floats by computing the sign value for each component. For each float in the input, the corresponding output is determined to be \u20131.0 if the input is negative, 1.0 if positive, and 0.0 if the input is zero. The implementation uses optimized vectorized operations with SSE when available, and falls back to individual element processing otherwise.",
        "code_id": "c_group_2_id_437",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_sign(vec4 v, vec4 dest) {\n#if defined( __SSE__ ) || defined( __SSE2__ )\n  __m128 x0, x1, x2, x3, x4;\n\n  x0 = glmm_load(v);\n  x1 = _mm_set_ps(0.0f, 0.0f, 1.0f, -1.0f);\n  x2 = glmm_splat(x1, 2);\n\n  x3 = _mm_and_ps(_mm_cmpgt_ps(x0, x2), glmm_splat(x1, 1));\n  x4 = _mm_and_ps(_mm_cmplt_ps(x0, x2), glmm_splat(x1, 0));\n\n  glmm_store(dest, _mm_or_ps(x3, x4));\n#else\n  dest[0] = glm_signf(v[0]);\n  dest[1] = glm_signf(v[1]);\n  dest[2] = glm_signf(v[2]);\n  dest[3] = glm_signf(v[3]);\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_438",
        "query_text": "SUMMARY: This function computes the transpose of a 2\u00d72 matrix of 32\u2010bit floats. It takes as input a matrix of type \"2-element array of 2-element float vectors\" (each vector being 16\u2010byte aligned) and produces as output another matrix of the same type, with its elements rearranged to achieve the transpose. The implementation uses SSE2 operations to load the four floating\u2010point values from the input, shuffle them appropriately, and then store the result into the output matrix.",
        "code_id": "c_group_2_id_438",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat2_transp_sse2(mat2 m, mat2 dest) {\n  /* d c b a */\n  /* d b c a */\n  glmm_store(dest[0], glmm_shuff1(glmm_load(m[0]), 3, 1, 2, 0));\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_439",
        "query_text": "SUMMARY: This function takes two input variables of type int[2] (representing two-element integer vectors) and produces an output variable of the same type. It evaluates each corresponding element of the two input vectors and assigns the greater of each pair to the respective position in the output vector.",
        "code_id": "c_group_2_id_439",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_maxv(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] = a[0] > b[0] ? a[0] : b[0];\n  dest[1] = a[1] > b[1] ? a[1] : b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_440",
        "query_text": "SUMMARY: This function takes a constant pointer to a sequence of float values (input type: const float*) and transforms it into a 4\u00d74 matrix (output type: an array of 4 float[4] vectors) by mapping 16 sequential floats into a structured matrix layout. More specifically, it reorganizes the input flat array by distributing its values into two groups, with the first eight values populating the first two columns and the remaining eight values populating the last two columns of the destination matrix.",
        "code_id": "c_group_2_id_440",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_make(const float * __restrict src, mat4 dest) {\n  dest[0][0] = src[0];   dest[1][0] = src[4];\n  dest[0][1] = src[1];   dest[1][1] = src[5];\n  dest[0][2] = src[2];   dest[1][2] = src[6];\n  dest[0][3] = src[3];   dest[1][3] = src[7];\n\n  dest[2][0] = src[8];   dest[3][0] = src[12];\n  dest[2][1] = src[9];   dest[3][1] = src[13];\n  dest[2][2] = src[10];  dest[3][2] = src[14];\n  dest[2][3] = src[11];  dest[3][3] = src[15];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_441",
        "query_text": "SUMMARY: This function accepts two input parameters of type float[3] and produces an output of the same type. It performs an element-wise division by computing the quotient of the corresponding elements from the first and second input arrays, storing these results sequentially in the output array.",
        "code_id": "c_group_2_id_441",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3_div(vec3 a, vec3 b, vec3 dest) {\n  dest[0] = a[0] / b[0];\n  dest[1] = a[1] / b[1];\n  dest[2] = a[2] / b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_442",
        "query_text": "SUMMARY: This function takes three parameters of type int[4]. It computes, for each corresponding element, the subtraction of the difference between the first and second input values from the value in the third parameter. In other words, it updates each element of the output int[4] by subtracting the result of the difference between the two input int[4] elements.",
        "code_id": "c_group_2_id_442",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_subsub(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] -= a[0] - b[0];\n  dest[1] -= a[1] - b[1];\n  dest[2] -= a[2] - b[2];\n  dest[3] -= a[3] - b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_443",
        "query_text": "SUMMARY: This inline function accepts two input parameters, each being a 3-element array of floats (float[3]), and computes their dot product by multiplying corresponding elements and summing the results. It returns a single float value representing this computed dot product.",
        "code_id": "c_group_2_id_443",
        "code_text": "CGLM_INLINE\nfloat\nglm_vec3_dot(vec3 a, vec3 b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_444",
        "query_text": "SUMMARY: This function accepts two input parameters\u2014an integer vector of four elements (ivec4) and an integer scalar\u2014and one output parameter, an integer vector of four elements (ivec4). For each index from 0 to 3, it subtracts the sum of the corresponding element from the input vector and the scalar from the corresponding element in the output vector, updating the output vector with the result.",
        "code_id": "c_group_2_id_444",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_addsubs(ivec4 a, int s, ivec4 dest) {\n  dest[0] -= a[0] + s;\n  dest[1] -= a[1] + s;\n  dest[2] -= a[2] + s;\n  dest[3] -= a[3] + s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_445",
        "query_text": "SUMMARY: This function receives an input array of three integers (type int[3]) and computes the absolute value of each element. It then stores these absolute values element-by-element into an output array of three integers (type int[3]).",
        "code_id": "c_group_2_id_445",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec3_abs(ivec3 v, ivec3 dest) {\n  dest[0] = abs(v[0]);\n  dest[1] = abs(v[1]);\n  dest[2] = abs(v[2]);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_446",
        "query_text": "SUMMARY: This function accepts an input variable of type vec4 (an aligned four-element float array) and an output variable of type vec3 (a three-element float array). Its functionality is to copy the first three float elements from the input to the output, effectively trimming the fourth element.",
        "code_id": "c_group_2_id_446",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_copy3(vec4 a, vec3 dest) {\n  dest[0] = a[0];\n  dest[1] = a[1];\n  dest[2] = a[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_447",
        "query_text": "SUMMARY: This function accepts two input variables, each of type float[2], and one output variable, also of type float[2]. Its purpose is to add, for each coordinate, the corresponding values from the two input arrays and then increment the corresponding value in the output array by that sum. Specifically, it updates each element of the output array by adding the sum of the corresponding elements of the two input arrays.",
        "code_id": "c_group_2_id_447",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_addadd(vec2 a, vec2 b, vec2 dest) {\n  dest[0] += a[0] + b[0];\n  dest[1] += a[1] + b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_448",
        "query_text": "SUMMARY: This function converts a 3-element floating-point vector (vec3) representing Euler angles into a 4-element floating-point quaternion (versor) using a YZX rotation order in a right-handed coordinate system. It calculates the sine and cosine of half of each Euler angle and then combines them to produce the quaternion components that represent the equivalent rotation. Each line of the function performs a step in computing these trigonometric values and then assembles the resulting quaternion from their products and sums.",
        "code_id": "c_group_2_id_448",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_yzx_quat_rh(vec3 angles, versor dest) {\n  float xc, yc, zc,\n        xs, ys, zs;\n\n  xs = sinf(angles[0] * 0.5f); xc = cosf(angles[0] * 0.5f);\n  ys = sinf(angles[1] * 0.5f); yc = cosf(angles[1] * 0.5f);\n  zs = sinf(angles[2] * 0.5f); zc = cosf(angles[2] * 0.5f);\n\n  dest[0] = yc * zc * xs + ys * zs * xc;\n  dest[1] = yc * zs * xs + ys * zc * xc;\n  dest[2] = yc * zs * xc - ys * zc * xs;\n  dest[3] = yc * zc * xc - ys * zs * xs;\n\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_449",
        "query_text": "SUMMARY: This function accepts a 4\u00d74 matrix (of type vec4[4]) representing a perspective projection and two pointers to floats (which are the output variables for the near and far clipping distances). It first extracts two specific floating\u2010point elements from distinct positions within the matrix and then computes the near and far clipping distances by dividing one extracted value by a modified form of the other\u2014subtracting 1.0 for the near distance and adding 1.0 for the far distance. The function does not return a value, instead writing the computed near and far distances directly to the provided output float pointers.",
        "code_id": "c_group_2_id_449",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_z_lh_no(mat4 proj,\n                         float * __restrict nearZ,\n                         float * __restrict farZ) {\n  float m32, m22;\n\n  m32 = proj[3][2];\n  m22 =-proj[2][2];\n\n  *nearZ = m32 / (m22 - 1.0f);\n  *farZ  = m32 / (m22 + 1.0f);\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_450",
        "query_text": "SUMMARY: This function performs a component-wise subtraction of two two-dimensional vectors. It accepts two input parameters of type float[2] (representing the vectors to subtract) and produces an output parameter of type float[2] containing the result of subtracting the corresponding elements of the second input from the first.",
        "code_id": "c_group_2_id_450",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_sub(vec2 a, vec2 b, vec2 dest) {\n  dest[0] = a[0] - b[0];\n  dest[1] = a[1] - b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_451",
        "query_text": "SUMMARY: This function takes a triple of floating\u2010point values (vec3) representing three Euler angles and produces a 4\u00d74 matrix (mat4) transformation that encodes a rotation using a Y\u2013X\u2013Z rotation order. It computes the sine and cosine of each angle, combines these trigonometric results into intermediate products, and assembles them into the rotation matrix's elements; the remaining matrix components are set to yield an identity transformation in the homogeneous coordinate.",
        "code_id": "c_group_2_id_451",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_yxz(vec3 angles, mat4 dest) {\n  float cx, cy, cz,\n        sx, sy, sz, cycz, sysz, czsy, cysz;\n\n  sx   = sinf(angles[0]); cx = cosf(angles[0]);\n  sy   = sinf(angles[1]); cy = cosf(angles[1]);\n  sz   = sinf(angles[2]); cz = cosf(angles[2]);\n\n  cycz = cy * cz;\n  sysz = sy * sz;\n  czsy = cz * sy;\n  cysz = cy * sz;\n\n  dest[0][0] =  cycz + sx * sysz;\n  dest[0][1] =  cx * sz;\n  dest[0][2] = -czsy + cysz * sx;\n  dest[1][0] = -cysz + czsy * sx;\n  dest[1][1] =  cx * cz;\n  dest[1][2] =  cycz * sx + sysz;\n  dest[2][0] =  cx * sy;\n  dest[2][1] = -sx;\n  dest[2][2] =  cx * cy;\n  dest[0][3] =  0.0f;\n  dest[1][3] =  0.0f;\n  dest[2][3] =  0.0f;\n  dest[3][0] =  0.0f;\n  dest[3][1] =  0.0f;\n  dest[3][2] =  0.0f;\n  dest[3][3] =  1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_452",
        "query_text": "SUMMARY: This function converts a 4\u00d74 floating\u2010point matrix (mat4) representing a rotation into a quaternion (versor), also composed of four floating\u2011point values. It calculates the sum of the matrix\u2019s three main diagonal elements and, based on whether this trace is nonnegative or one of the diagonal elements is largest, it selects an appropriate branch. In each branch, it computes a scaling factor and then produces the four quaternion components using combinations of the matrix\u2019s off\u2011diagonal elements. This procedure effectively maps the rotation encoded in the matrix to its equivalent quaternion representation.",
        "code_id": "c_group_2_id_452",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4_quat(mat4 m, versor dest) {\n  float trace, r, rinv;\n\n  /* it seems using like m12 instead of m[1][2] causes extra instructions */\n\n  trace = m[0][0] + m[1][1] + m[2][2];\n  if (trace >= 0.0f) {\n    r       = sqrtf(1.0f + trace);\n    rinv    = 0.5f / r;\n\n    dest[0] = rinv * (m[1][2] - m[2][1]);\n    dest[1] = rinv * (m[2][0] - m[0][2]);\n    dest[2] = rinv * (m[0][1] - m[1][0]);\n    dest[3] = r    * 0.5f;\n  } else if (m[0][0] >= m[1][1] && m[0][0] >= m[2][2]) {\n    r       = sqrtf(1.0f - m[1][1] - m[2][2] + m[0][0]);\n    rinv    = 0.5f / r;\n\n    dest[0] = r    * 0.5f;\n    dest[1] = rinv * (m[0][1] + m[1][0]);\n    dest[2] = rinv * (m[0][2] + m[2][0]);\n    dest[3] = rinv * (m[1][2] - m[2][1]);\n  } else if (m[1][1] >= m[2][2]) {\n    r       = sqrtf(1.0f - m[0][0] - m[2][2] + m[1][1]);\n    rinv    = 0.5f / r;\n\n    dest[0] = rinv * (m[0][1] + m[1][0]);\n    dest[1] = r    * 0.5f;\n    dest[2] = rinv * (m[1][2] + m[2][1]);\n    dest[3] = rinv * (m[2][0] - m[0][2]);\n  } else {\n    r       = sqrtf(1.0f - m[0][0] - m[1][1] + m[2][2]);\n    rinv    = 0.5f / r;\n\n    dest[0] = rinv * (m[0][2] + m[2][0]);\n    dest[1] = rinv * (m[1][2] + m[2][1]);\n    dest[2] = r    * 0.5f;\n    dest[3] = rinv * (m[0][1] - m[1][0]);\n  }\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_453",
        "query_text": "SUMMARY: This function takes two inputs\u2014a 3\u00d73 matrix composed of three arrays of three floats (mat3) and a 2-element array of floats (vec2)\u2014and modifies the matrix in place. It applies a two-dimensional scaling transformation by multiplying every element in the first row of the matrix by the first float from the vector and every element in the second row by the second float. The third row of the matrix remains unchanged.",
        "code_id": "c_group_2_id_453",
        "code_text": "CGLM_INLINE\nvoid\nglm_scale2d(mat3 m, vec2 v) {\n  m[0][0] = m[0][0] * v[0];\n  m[0][1] = m[0][1] * v[0];\n  m[0][2] = m[0][2] * v[0];\n\n  m[1][0] = m[1][0] * v[1];\n  m[1][1] = m[1][1] * v[1];\n  m[1][2] = m[1][2] * v[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_454",
        "query_text": "SUMMARY: This function accepts an input of type int pointer and an output of type ivec2 (an array of two integers). It copies the first two integers from the input array into the two-element output array.",
        "code_id": "c_group_2_id_454",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2(int * __restrict v, ivec2 dest) {\n  dest[0] = v[0];\n  dest[1] = v[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_455",
        "query_text": "SUMMARY: This function accepts an input of type \"CGLM_ALIGN_IF(16) float[4]\" (a vector of four floats) and an input of type \"float\", and it modifies the vector by filling all four elements with the provided floating-point value. It uses platform-specific SIMD operations when available, defaulting to individual assignments otherwise.",
        "code_id": "c_group_2_id_455",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec4_fill(vec4 v, float val) {\n#if defined(__wasm__) && defined(__wasm_simd128__)\n  glmm_store(v, wasm_f32x4_splat(val));\n#elif defined( __SSE__ ) || defined( __SSE2__ )\n  glmm_store(v, _mm_set1_ps(val));\n#else\n  v[0] = v[1] = v[2] = v[3] = val;\n#endif\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_456",
        "query_text": "SUMMARY: This function performs a component-wise addition of two two-dimensional vectors. It takes two input variables of type vec2 (each defined as an array of two floats) and computes a new vec2 by adding the corresponding elements from the inputs, then stores the resulting two-float array in the output variable of type vec2.",
        "code_id": "c_group_2_id_456",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_add(vec2 a, vec2 b, vec2 dest) {\n  dest[0] = a[0] + b[0];\n  dest[1] = a[1] + b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_457",
        "query_text": "SUMMARY: This function takes a three-by-two matrix of floats (type: mat3x2, defined as an array of three two-element float arrays) and a scalar float as inputs. It multiplies each of the six elements within the matrix by the scalar value, updating the matrix in place. The function returns no value (void).",
        "code_id": "c_group_2_id_457",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat3x2_scale(mat3x2 m, float s) {\n  m[0][0] *= s;  m[0][1] *= s;  m[1][0] *= s;\n  m[1][1] *= s;  m[2][0] *= s;  m[2][1] *= s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_458",
        "query_text": "SUMMARY: This function takes an input of type vec2 (an array of two floats) and modifies it so that both elements are set to 1.0f. It returns no value.",
        "code_id": "c_group_2_id_458",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec2_one(vec2 v) {\n  v[0] = v[1] = 1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_459",
        "query_text": "SUMMARY: The function takes two inputs, each being an array of two integers (type: int[2]), and produces an output of the same type. It computes the function by adding the first integer from the first array to the first integer from the second array, and similarly adding the second integers together. The resulting array holds these two sums as its elements.",
        "code_id": "c_group_2_id_459",
        "code_text": "CGLM_INLINE\nvoid\nglm_ivec2_add(ivec2 a, ivec2 b, ivec2 dest) {\n  dest[0] = a[0] + b[0];\n  dest[1] = a[1] + b[1];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_460",
        "query_text": "SUMMARY: This function performs matrix multiplication between two matrices. The first input is of type mat4x3 (an array of four 3-element float vectors representing a 4\u00d73 matrix in column-major order), and the second input is of type mat3x4 (an array of three 4-element float vectors representing a 3\u00d74 matrix). The function computes the product, which is a 3\u00d73 matrix, and stores the result in the output of type mat3 (an array of three 3-element float vectors). Each element of the output is obtained by summing the products of corresponding float components from the inputs.",
        "code_id": "c_group_2_id_460",
        "code_text": "CGLM_INLINE\nvoid\nglm_mat4x3_mul(mat4x3 m1, mat3x4 m2, mat3 dest) {\n  float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2],\n        a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2],\n        a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2],\n        a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2],\n\n        b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2], b03 = m2[0][3],\n        b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2], b13 = m2[1][3],\n        b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2], b23 = m2[2][3];\n\n  dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n  dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n  dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n\n  dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n  dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n  dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n\n  dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n  dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n  dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_461",
        "query_text": "SUMMARY: This function accepts two input parameters and one output parameter, all of type \"ivec4\" (arrays of four integers). For each of the four components, it calculates the sum of the corresponding elements from the two input arrays and then adds this result to the corresponding element in the output array. Essentially, it performs an element-wise accumulation where each output element becomes its original value increased by the sum of the two corresponding input values.",
        "code_id": "c_group_2_id_461",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec4_addadd(ivec4 a, ivec4 b, ivec4 dest) {\n  dest[0] += a[0] + b[0];\n  dest[1] += a[1] + b[1];\n  dest[2] += a[2] + b[2];\n  dest[3] += a[3] + b[3];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_462",
        "query_text": "SUMMARY: This function takes as input a 4\u00d74 matrix of single-precision floating-point numbers (mat4) and two pointers to float variables. It decomposes the projection matrix to compute and output two scalar values, representing the top and bottom extents along the y-axis in eye space for a perspective projection using a right-handed coordinate system with a depth range from zero to one. The function internally extracts specific elements from the matrix to determine the near clipping plane distance along the z-axis and then uses this value to calculate the desired top and bottom boundaries.",
        "code_id": "c_group_2_id_462",
        "code_text": "CGLM_INLINE\nvoid\nglm_persp_decomp_y_rh_zo(mat4 proj,\n                         float * __restrict top,\n                         float * __restrict bottom) {\n  float nearZ, m21, m11, m22;\n\n  m21 = proj[2][1];\n  m11 = proj[1][1];\n  m22 = proj[2][2];\n\n  nearZ = proj[3][2] / m22;\n  *bottom = nearZ * (m21 - 1) / m11;\n  *top    = nearZ * (m21 + 1) / m11;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_463",
        "query_text": "SUMMARY: The function accepts an input of type vec4 (an array of four floats) and an output of type vec3 (an array of three floats). It sequentially copies the first three elements from the vec4 input into the vec3 output, effectively converting a four-dimensional floating-point vector into a three-dimensional one by discarding the fourth component.",
        "code_id": "c_group_2_id_463",
        "code_text": "CGLM_INLINE\nvoid\nglm_vec3(vec4 v4, vec3 dest) {\n  dest[0] = v4[0];\n  dest[1] = v4[1];\n  dest[2] = v4[2];\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_464",
        "query_text": "SUMMARY: This function accepts two inputs\u2014one of type versor (an aligned array of four floats) and one of type pointer to FILE\u2014and returns no value. It formats and prints the contents of the quaternion (the four-component float vector) to the provided output stream. The printing process includes labeling the output (indicating a quaternion of four floats), applying precision formatting based on the component's magnitude, and using color formatting macros for enhanced visual presentation.",
        "code_id": "c_group_2_id_464",
        "code_text": "CGLM_INLINE\nvoid\nglm_versor_print(versor            vec,\n                 FILE * __restrict ostream) {\n  int i;\n\n#define m 4\n\n  fprintf(ostream, \"Quaternion (float%d): \" CGLM_PRINT_COLOR \"\\n  (\", m);\n\n  for (i = 0; i < m; i++) {\n    if (vec[i] < CGLM_PRINT_MAX_TO_SHORT)\n      fprintf(ostream, \" % .*f\", CGLM_PRINT_PRECISION, (double)vec[i]);\n    else\n      fprintf(ostream, \" % g\", (double)vec[i]);\n  }\n\n\n  fprintf(ostream, \"  )\" CGLM_PRINT_COLOR_RESET \"\\n\\n\");\n\n#undef m\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_465",
        "query_text": "SUMMARY: This function accepts a three-element float array (vec3) representing Euler angles and an enumeration (glm_euler_seq) specifying one of six rotation orders as input. It computes the sine and cosine values for these angles, uses the provided rotation order to assemble the appropriate 3\u00d73 rotation submatrix, and then constructs a 4\u00d74 float matrix (mat4) by embedding this rotation and appending homogeneous coordinates (with zero translation and a one in the lower-right corner).",
        "code_id": "c_group_2_id_465",
        "code_text": "CGLM_INLINE\nvoid\nglm_euler_by_order(vec3 angles, glm_euler_seq ord, mat4 dest) {\n  float cx, cy, cz,\n        sx, sy, sz;\n\n  float cycz, cysz, cysx, cxcy,\n        czsy, cxcz, czsx, cxsz,\n        sysz;\n\n  sx = sinf(angles[0]); cx = cosf(angles[0]);\n  sy = sinf(angles[1]); cy = cosf(angles[1]);\n  sz = sinf(angles[2]); cz = cosf(angles[2]);\n\n  cycz = cy * cz; cysz = cy * sz;\n  cysx = cy * sx; cxcy = cx * cy;\n  czsy = cz * sy; cxcz = cx * cz;\n  czsx = cz * sx; cxsz = cx * sz;\n  sysz = sy * sz;\n\n  switch (ord) {\n    case GLM_EULER_XZY:\n      dest[0][0] =  cycz;\n      dest[0][1] =  sx * sy + cx * cysz;\n      dest[0][2] = -cx * sy + cysx * sz;\n      dest[1][0] = -sz;\n      dest[1][1] =  cxcz;\n      dest[1][2] =  czsx;\n      dest[2][0] =  czsy;\n      dest[2][1] = -cysx + cx * sysz;\n      dest[2][2] =  cxcy + sx * sysz;\n      break;\n    case GLM_EULER_XYZ:\n      dest[0][0] =  cycz;\n      dest[0][1] =  czsx * sy + cxsz;\n      dest[0][2] = -cx * czsy + sx * sz;\n      dest[1][0] = -cysz;\n      dest[1][1] =  cxcz - sx * sysz;\n      dest[1][2] =  czsx + cx * sysz;\n      dest[2][0] =  sy;\n      dest[2][1] = -cysx;\n      dest[2][2] =  cxcy;\n      break;\n    case GLM_EULER_YXZ:\n      dest[0][0] =  cycz + sx * sysz;\n      dest[0][1] =  cxsz;\n      dest[0][2] = -czsy + cysx * sz;\n      dest[1][0] =  czsx * sy - cysz;\n      dest[1][1] =  cxcz;\n      dest[1][2] =  cycz * sx + sysz;\n      dest[2][0] =  cx * sy;\n      dest[2][1] = -sx;\n      dest[2][2] =  cxcy;\n      break;\n    case GLM_EULER_YZX:\n      dest[0][0] =  cycz;\n      dest[0][1] =  sz;\n      dest[0][2] = -czsy;\n      dest[1][0] =  sx * sy - cx * cysz;\n      dest[1][1] =  cxcz;\n      dest[1][2] =  cysx + cx * sysz;\n      dest[2][0] =  cx * sy + cysx * sz;\n      dest[2][1] = -czsx;\n      dest[2][2] =  cxcy - sx * sysz;\n      break;\n    case GLM_EULER_ZXY:\n      dest[0][0] =  cycz - sx * sysz;\n      dest[0][1] =  czsx * sy + cysz;\n      dest[0][2] = -cx * sy;\n      dest[1][0] = -cxsz;\n      dest[1][1] =  cxcz;\n      dest[1][2] =  sx;\n      dest[2][0] =  czsy + cysx * sz;\n      dest[2][1] = -cycz * sx + sysz;\n      dest[2][2] =  cxcy;\n      break;\n    case GLM_EULER_ZYX:\n      dest[0][0] =  cycz;\n      dest[0][1] =  cysz;\n      dest[0][2] = -sy;\n      dest[1][0] =  czsx * sy - cxsz;\n      dest[1][1] =  cxcz + sx * sysz;\n      dest[1][2] =  cysx;\n      dest[2][0] =  cx * czsy + sx * sz;\n      dest[2][1] = -czsx + cx * sysz;\n      dest[2][2] =  cxcy;\n      break;\n  }\n\n  dest[0][3] = 0.0f;\n  dest[1][3] = 0.0f;\n  dest[2][3] = 0.0f;\n  dest[3][0] = 0.0f;\n  dest[3][1] = 0.0f;\n  dest[3][2] = 0.0f;\n  dest[3][3] = 1.0f;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_466",
        "query_text": "SUMMARY: This function takes three inputs: a 3-element integer array, an integer scalar, and another 3-element integer array intended for output, and it subtracts from each element of the output array the product of the corresponding element of the input array with the scalar. Concretely, for each of the three positions, the function computes the multiplication of the integer from the first array by the scalar and subtracts this result from the corresponding integer in the output array.",
        "code_id": "c_group_2_id_466",
        "code_text": "CGLM_INLINE \nvoid \nglm_ivec3_mulsubs(ivec3 a, int s, ivec3 dest) {\n  dest[0] -= a[0] * s;\n  dest[1] -= a[1] * s;\n  dest[2] -= a[2] * s;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_467",
        "query_text": "SUMMARY: This function accepts a pointer to an AUDIO_OUT structure (type: AUDIO_OUT *) as its sole input parameter and produces no return value (output type: void). It performs no meaningful operations; essentially, it reassigns the input parameter to itself and then exits without modifying any data or releasing any resources.",
        "code_id": "c_group_2_id_467",
        "code_text": "void\naudio_close (AUDIO_OUT *audio_out)\n{\n\taudio_out = audio_out ;\n\n\treturn ;\n};",
        "relevance": 2
    },
    {
        "query_id": "q_group_2_id_468",
        "query_text": "SUMMARY: This function accepts three inputs: a function pointer of type get_audio_callback_t, a pointer to an AUDIO_OUT structure, and a generic void pointer used as callback data. It returns no value (void). In its implementation, it disregards all provided arguments and terminates immediately without performing any operations or modifications.",
        "code_id": "c_group_2_id_468",
        "code_text": "void\naudio_play (get_audio_callback_t callback, AUDIO_OUT *audio_out, void *callback_data)\n{\n\t(void) callback ;\n\t(void) audio_out ;\n\t(void) callback_data ;\n\n\treturn ;\n};",
        "relevance": 2
    }
]