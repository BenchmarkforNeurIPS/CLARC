[
    {
        "query_id": "q_group_1_id_0",
        "query_text": "The function receives a constant reference to a string as input. It checks whether the input string is equal to one of several predefined representations that denote an infinity value. Specifically, the function determines if the string matches any of the designated patterns (such as those beginning with an optional plus sign followed by \".inf\" in various cases). If a match is found, it returns a boolean true; otherwise, it returns false. The input is of type std::string, and the output is a bool.",
        "code_id": "c_group_1_id_0",
        "code_text": "(func (;2;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 65550\nlocal.set 5\nlocal.get 4\nlocal.get 5\ncall 3\nlocal.set 6\ni32.const 1\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 7\nlocal.set 10\nblock  ;; label = @1\nlocal.get 9\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 11\ni32.const 65556\nlocal.set 12\nlocal.get 11\nlocal.get 12\ncall 3\nlocal.set 13\ni32.const 1\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 13\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 14\nlocal.set 10\nlocal.get 16\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 17\ni32.const 65562\nlocal.set 18\nlocal.get 17\nlocal.get 18\ncall 3\nlocal.set 19\ni32.const 1\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 19\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 20\nlocal.set 10\nlocal.get 22\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 23\ni32.const 65549\nlocal.set 24\nlocal.get 23\nlocal.get 24\ncall 3\nlocal.set 25\ni32.const 1\nlocal.set 26\ni32.const 1\nlocal.set 27\nlocal.get 25\nlocal.get 27\ni32.and\nlocal.set 28\nlocal.get 26\nlocal.set 10\nlocal.get 28\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 29\ni32.const 65555\nlocal.set 30\nlocal.get 29\nlocal.get 30\ncall 3\nlocal.set 31\ni32.const 1\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 31\nlocal.get 33\ni32.and\nlocal.set 34\nlocal.get 32\nlocal.set 10\nlocal.get 34\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 35\ni32.const 65561\nlocal.set 36\nlocal.get 35\nlocal.get 36\ncall 3\nlocal.set 37\nlocal.get 37\nlocal.set 10\nend\nlocal.get 10\nlocal.set 38\ni32.const 1\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.and\nlocal.set 40\ni32.const 16\nlocal.set 41\nlocal.get 3\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 42\nglobal.set 0\nlocal.get 40\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_1",
        "query_text": "The function accepts a constant character string as its sole input and immediately returns the integer value 0. It does not perform any operations or checks on the input; instead, the parameter is explicitly cast to void to indicate that it is unused. The input type is a pointer to a constant character, and the output type is an integer.",
        "code_id": "c_group_1_id_1",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 0\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_2",
        "query_text": "The function takes a wide character string as input and immediately returns the integer 0. It does not perform any operations on the input string.",
        "code_id": "c_group_1_id_2",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 0\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_3",
        "query_text": "The function accepts a boolean input and immediately returns that identical boolean value. It performs no additional processing or transformation, effectively serving as a simple pass-through.",
        "code_id": "c_group_1_id_3",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_4",
        "query_text": "This function is intended to write output to the standard error stream. It accepts no input parameters and does not return any value. However, its current implementation features an empty body, so it does not perform any logging or output operations.",
        "code_id": "c_group_1_id_4",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_5",
        "query_text": "This function accepts a file pointer as input and returns the file's size in bytes as an unsigned integer type. It determines the size by repositioning the stream's pointer to the end of the file and then retrieving the current pointer position, which corresponds to the file size.",
        "code_id": "c_group_1_id_5",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 0\nlocal.set 5\ni32.const 2\nlocal.set 6\nlocal.get 4\nlocal.get 5\nlocal.get 6\ncall 8\ndrop\nlocal.get 3\ni32.load offset=12\nlocal.set 7\nlocal.get 7\ncall 11\nlocal.set 8\ni32.const 16\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nglobal.set 0\nlocal.get 8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_6",
        "query_text": "The function accepts a file pointer (of type FILE*) as input and returns an integer (of type int) that identifies the corresponding file descriptor. This integer is a unique identifier assigned by the operating system to the open file. Implemented as an inline function, it expands directly at the call site for enhanced efficiency.",
        "code_id": "c_group_1_id_6",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 6\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_7",
        "query_text": "The function accepts an integer representing a file descriptor and determines whether it is associated with a terminal device. It returns a non-zero integer if the file descriptor is connected to a terminal and zero otherwise. The function serves as a lightweight wrapper around an underlying system call that performs this check.",
        "code_id": "c_group_1_id_7",
        "code_text": "(func (;2;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 5\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_8",
        "query_text": "The function takes two input parameters, both of which are pointers to constant characters (C-style strings). It compares the two strings in a case-insensitive manner using an internal library function. If the strings are identical in a case-insensitive comparison, it returns 0; if the first string is lexicographically greater, it returns a positive value; and if it is lexicographically smaller, it returns a negative value. The input parameters are two pointers to constant characters, and the output is an integer representing the comparison result.",
        "code_id": "c_group_1_id_8",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 16\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nglobal.set 0\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_9",
        "query_text": "The function takes a constant character pointer as input (representing a C-style null-terminated string) and uses a standard library routine to create a duplicate of that string. It returns a pointer to the newly allocated duplicate, and the caller is responsible for freeing the allocated memory to prevent memory leaks.",
        "code_id": "c_group_1_id_9",
        "code_text": "(func (;1;) (type 1) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 4\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_10",
        "query_text": "The function accepts a single character string input that specifies a directory path. Its role is to delete the specified directory by calling the underlying system removal operation. After attempting the deletion, it returns an integer where a value of 0 indicates that the directory was removed successfully, while any non-zero value signals an error occurred during the operation.",
        "code_id": "c_group_1_id_10",
        "code_text": "(func (;2;) (type 1) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 4\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_11",
        "query_text": "The function accepts a single input, a string (type const char*), representing a directory path. It then passes this string to a system-level operation to update the program's current working directory to the specified location. The function returns an integer that indicates the outcome of this change: 0 signifies a successful update, while a non-zero value indicates an error occurred.",
        "code_id": "c_group_1_id_11",
        "code_text": "(func (;2;) (type 1) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 4\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_12",
        "query_text": "This function reopens an existing file stream using a new file path and mode. It takes three parameters: a constant string representing the file path, a constant string defining the mode for opening the file, and a pointer to a file stream. Internally, it utilizes a standard C library call that reassigns the provided stream to the new file specified by the input path and mode. The function returns a pointer to the updated file stream\u2014if the underlying library call fails, it returns a null pointer.",
        "code_id": "c_group_1_id_12",
        "code_text": "(func (;6;) (type 1) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nlocal.get 5\ni32.load offset=12\nlocal.set 6\nlocal.get 5\ni32.load offset=8\nlocal.set 7\nlocal.get 5\ni32.load offset=4\nlocal.set 8\nlocal.get 6\nlocal.get 7\nlocal.get 8\ncall 29\nlocal.set 9\ni32.const 16\nlocal.set 10\nlocal.get 5\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 11\nglobal.set 0\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_13",
        "query_text": "The function takes two inputs: an integer representing a file descriptor and a string indicating the file mode. It returns a pointer to a file stream object, which allows the use of standard file operations on the opened file. Internally, it associates the given file descriptor with a file stream by invoking a system library routine designed for this purpose.",
        "code_id": "c_group_1_id_13",
        "code_text": "(func (;5;) (type 4) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 12\nlocal.set 7\ni32.const 16\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nglobal.set 0\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_14",
        "query_text": "The function accepts a pointer to a file stream (of type FILE*), and it returns an integer. It closes the file stream by invoking the standard library's function for closing file streams. The returned integer indicates whether the operation was successful (with 0 denoting success and any non-zero value indicating failure).",
        "code_id": "c_group_1_id_14",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 6\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_15",
        "query_text": "The function receives three inputs. The first input is an integer representing a file descriptor. The second input is a pointer to a buffer (of type const void*), and the third input is an unsigned integer that indicates the number of bytes to write. It acts as a wrapper around a system call to write the data from the buffer to the file associated with the file descriptor. The function returns an integer representing the number of bytes successfully written, or -1 if an error occurs.",
        "code_id": "c_group_1_id_15",
        "code_text": "(func (;2;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nlocal.get 5\ni32.load offset=12\nlocal.set 6\nlocal.get 5\ni32.load offset=8\nlocal.set 7\nlocal.get 5\ni32.load offset=4\nlocal.set 8\nlocal.get 6\nlocal.get 7\nlocal.get 8\ncall 6\nlocal.set 9\ni32.const 16\nlocal.set 10\nlocal.get 5\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 11\nglobal.set 0\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_16",
        "query_text": "The function accepts an integer representing a file descriptor associated with an open resource and returns an integer indicating the result of the closure operation. It operates as a simple wrapper around the system call that performs the actual closing. A return value of 0 signifies a successful closure, while a return value of -1 indicates a failure.",
        "code_id": "c_group_1_id_16",
        "code_text": "(func (;2;) (type 1) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 5\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_17",
        "query_text": "The function takes an integer input that represents an error code and returns a string describing the associated error. The function internally serves as a wrapper for the standard library function that converts error codes into their corresponding error messages. The input is of type int, and the output is a pointer to a constant character string (const char*).",
        "code_id": "c_group_1_id_17",
        "code_text": "(func (;1;) (type 3) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 10\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_18",
        "query_text": "The function takes no input parameters and returns no value (void). It is an inline function that, when called, immediately terminates the program by invoking the standard library routine to abort execution, resulting in abnormal termination.",
        "code_id": "c_group_1_id_18",
        "code_text": "(func (;2;) (type 0)\ncall 4\nunreachable)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_19",
        "query_text": "This function converts the content of a string stream into a standard string. It processes each character from the string stream one at a time and checks whether it is a null character. If a null character is detected, it appends the escape sequence \"\\0\" to the output string; all other characters are directly copied. The function also reserves extra capacity in the output string to accommodate the potential increase in size due to the replacement of null characters. The input is a pointer to a string stream, and the output is a standard string containing the transformed content.",
        "code_id": "c_group_1_id_19",
        "code_text": "(func (;2;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 48\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=44\nlocal.get 4\nlocal.get 1\ni32.store offset=40\nlocal.get 4\ni32.load offset=40\nlocal.set 5\ni32.const 24\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.set 8\nlocal.get 8\nlocal.get 5\ncall 3\ni32.const 24\nlocal.set 9\nlocal.get 4\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nlocal.set 11\nlocal.get 4\nlocal.get 11\ni32.store offset=36\nlocal.get 4\ni32.load offset=36\nlocal.set 12\nlocal.get 12\ncall 4\nlocal.set 13\nlocal.get 4\nlocal.get 13\ni32.store offset=20\nlocal.get 4\ni32.load offset=20\nlocal.set 14\nlocal.get 4\ni32.load offset=36\nlocal.set 15\nlocal.get 15\ncall 5\nlocal.set 16\nlocal.get 14\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.store offset=16\ni32.const 0\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\nlocal.get 4\nlocal.get 20\ni32.store8 offset=15\nlocal.get 0\ncall 6\ndrop\nlocal.get 4\ni32.load offset=16\nlocal.set 21\nlocal.get 4\ni32.load offset=20\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.sub\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.shl\nlocal.set 25\nlocal.get 0\nlocal.get 25\ncall 155\nlocal.get 4\ni32.load offset=20\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.store offset=8\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=8\nlocal.set 27\nlocal.get 4\ni32.load offset=16\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.ne\nlocal.set 29\ni32.const 1\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.and\nlocal.set 31\nlocal.get 31\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=8\nlocal.set 32\nlocal.get 32\ni32.load8_u\nlocal.set 33\ni32.const 24\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.shl\nlocal.set 35\nlocal.get 35\nlocal.get 34\ni32.shr_s\nlocal.set 36\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 36\nbr_if 0 (;@4;)\ni32.const 65549\nlocal.set 37\nlocal.get 0\nlocal.get 37\ncall 7\ndrop\nbr 1 (;@3;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 38\nlocal.get 38\ni32.load8_u\nlocal.set 39\ni32.const 24\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.shl\nlocal.set 41\nlocal.get 41\nlocal.get 40\ni32.shr_s\nlocal.set 42\nlocal.get 0\nlocal.get 42\ncall 8\ndrop\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 43\ni32.const 1\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.add\nlocal.set 45\nlocal.get 4\nlocal.get 45\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\ni32.const 1\nlocal.set 46\ni32.const 1\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.and\nlocal.set 48\nlocal.get 4\nlocal.get 48\ni32.store8 offset=15\nlocal.get 4\ni32.load8_u offset=15\nlocal.set 49\ni32.const 1\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.and\nlocal.set 51\nblock  ;; label = @1\nlocal.get 51\nbr_if 0 (;@1;)\nlocal.get 0\ncall 154\ndrop\nend\ni32.const 24\nlocal.set 52\nlocal.get 4\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\nlocal.set 54\nlocal.get 54\ncall 154\ndrop\ni32.const 48\nlocal.set 55\nlocal.get 4\nlocal.get 55\ni32.add\nlocal.set 56\nlocal.get 56\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_20",
        "query_text": "The function accepts a C-style string as input. It searches the string for the first occurrence of a comma and returns a std::string containing the characters from the beginning of the string up to, but not including, that comma. If the comma is not found, it returns the entire input string as a std::string. The input is of type const char*, and the output is of type std::string.",
        "code_id": "c_group_1_id_20",
        "code_text": "(func (;2;) (type 4) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 44\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 3\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store offset=4\nlocal.get 4\ni32.load offset=4\nlocal.set 8\ni32.const 0\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.eq\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 12\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=8\nlocal.set 13\nlocal.get 0\nlocal.get 13\ncall 4\ndrop\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 14\nlocal.get 4\ni32.load offset=4\nlocal.set 15\nlocal.get 0\nlocal.get 14\nlocal.get 15\ncall 5\ndrop\nend\ni32.const 16\nlocal.set 16\nlocal.get 4\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_21",
        "query_text": "The function takes a boolean input and writes its corresponding string representation (\"true\" or \"false\") to an output stream. It employs a conditional operator to determine the appropriate string based on the input value, and then outputs this string to a stream of type std::ostream. The function does not return any value.",
        "code_id": "c_group_1_id_21",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store8 offset=15\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 4\ni32.load8_u offset=15\nlocal.set 7\ni32.const 65565\nlocal.set 8\ni32.const 65570\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 7\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 8\nlocal.get 9\nlocal.get 11\nselect\nlocal.set 12\nlocal.get 6\nlocal.get 12\ncall 3\ndrop\ni32.const 16\nlocal.set 13\nlocal.get 4\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_22",
        "query_text": "The function accepts a single input of type string. It first checks if the string is enclosed in double quotes and, if so, ignores the outermost quotes. The function then examines the string for escaped characters, particularly looking for the sequence representing an escaped newline (a backslash followed by the character 'n'). Each time such an escaped newline is found, the function splits the string at that point. Finally, it returns a vector of strings containing the substrings obtained by splitting the input string, with the escaped newline delimiters removed.",
        "code_id": "c_group_1_id_22",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 64\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=60\nlocal.get 4\nlocal.get 1\ni32.store offset=56\ni32.const 0\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store8 offset=55\nlocal.get 0\ncall 3\ndrop\ni32.const 0\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=48\nlocal.get 4\ni32.load offset=56\nlocal.set 9\nlocal.get 9\ncall 4\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.store offset=44\nlocal.get 4\ni32.load offset=44\nlocal.set 11\ni32.const 2\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.gt_u\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nblock  ;; label = @1\nlocal.get 15\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=56\nlocal.set 16\ni32.const 0\nlocal.set 17\nlocal.get 16\nlocal.get 17\ncall 5\nlocal.set 18\nlocal.get 18\ni32.load8_u\nlocal.set 19\ni32.const 24\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 21\nlocal.get 20\ni32.shr_s\nlocal.set 22\ni32.const 34\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.eq\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nlocal.get 26\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=56\nlocal.set 27\nlocal.get 4\ni32.load offset=44\nlocal.set 28\ni32.const 1\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.sub\nlocal.set 30\nlocal.get 27\nlocal.get 30\ncall 5\nlocal.set 31\nlocal.get 31\ni32.load8_u\nlocal.set 32\ni32.const 24\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.shl\nlocal.set 34\nlocal.get 34\nlocal.get 33\ni32.shr_s\nlocal.set 35\ni32.const 34\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.eq\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.and\nlocal.set 39\nlocal.get 39\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=48\nlocal.set 40\ni32.const 1\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 4\nlocal.get 42\ni32.store offset=48\nlocal.get 4\ni32.load offset=44\nlocal.set 43\ni32.const -1\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.add\nlocal.set 45\nlocal.get 4\nlocal.get 45\ni32.store offset=44\nend\ni32.const 0\nlocal.set 46\nlocal.get 4\nlocal.get 46\ni32.store8 offset=43\nlocal.get 4\ni32.load offset=48\nlocal.set 47\nlocal.get 4\nlocal.get 47\ni32.store offset=36\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=36\nlocal.set 48\ni32.const 1\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.add\nlocal.set 50\nlocal.get 4\ni32.load offset=44\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.lt_u\nlocal.set 52\ni32.const 1\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.and\nlocal.set 54\nlocal.get 54\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load8_u offset=43\nlocal.set 55\ni32.const 1\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.and\nlocal.set 57\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 57\ni32.eqz\nbr_if 0 (;@4;)\ni32.const 0\nlocal.set 58\nlocal.get 4\nlocal.get 58\ni32.store8 offset=43\nlocal.get 4\ni32.load offset=56\nlocal.set 59\nlocal.get 4\ni32.load offset=36\nlocal.set 60\nlocal.get 59\nlocal.get 60\ncall 5\nlocal.set 61\nlocal.get 61\ni32.load8_u\nlocal.set 62\ni32.const 24\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.shl\nlocal.set 64\nlocal.get 64\nlocal.get 63\ni32.shr_s\nlocal.set 65\ni32.const 110\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.eq\nlocal.set 67\ni32.const 1\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.and\nlocal.set 69\nblock  ;; label = @5\nlocal.get 69\ni32.eqz\nbr_if 0 (;@5;)\nlocal.get 4\ni32.load offset=56\nlocal.set 70\nlocal.get 4\ni32.load offset=48\nlocal.set 71\nlocal.get 4\ni32.load offset=36\nlocal.set 72\nlocal.get 4\ni32.load offset=48\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.sub\nlocal.set 74\ni32.const 1\nlocal.set 75\nlocal.get 74\nlocal.get 75\ni32.sub\nlocal.set 76\ni32.const 24\nlocal.set 77\nlocal.get 4\nlocal.get 77\ni32.add\nlocal.set 78\nlocal.get 78\nlocal.set 79\nlocal.get 79\nlocal.get 70\nlocal.get 71\nlocal.get 76\ncall 6\ni32.const 24\nlocal.set 80\nlocal.get 4\nlocal.get 80\ni32.add\nlocal.set 81\nlocal.get 81\nlocal.set 82\nlocal.get 0\nlocal.get 82\ncall 7\ni32.const 24\nlocal.set 83\nlocal.get 4\nlocal.get 83\ni32.add\nlocal.set 84\nlocal.get 84\nlocal.set 85\nlocal.get 85\ncall 208\ndrop\nlocal.get 4\ni32.load offset=36\nlocal.set 86\ni32.const 1\nlocal.set 87\nlocal.get 86\nlocal.get 87\ni32.add\nlocal.set 88\nlocal.get 4\nlocal.get 88\ni32.store offset=48\nend\nbr 1 (;@3;)\nend\nlocal.get 4\ni32.load offset=56\nlocal.set 89\nlocal.get 4\ni32.load offset=36\nlocal.set 90\nlocal.get 89\nlocal.get 90\ncall 5\nlocal.set 91\nlocal.get 91\ni32.load8_u\nlocal.set 92\ni32.const 24\nlocal.set 93\nlocal.get 92\nlocal.get 93\ni32.shl\nlocal.set 94\nlocal.get 94\nlocal.get 93\ni32.shr_s\nlocal.set 95\ni32.const 92\nlocal.set 96\nlocal.get 95\nlocal.get 96\ni32.eq\nlocal.set 97\ni32.const 1\nlocal.set 98\nlocal.get 97\nlocal.get 98\ni32.and\nlocal.set 99\nlocal.get 4\nlocal.get 99\ni32.store8 offset=43\nend\nlocal.get 4\ni32.load offset=36\nlocal.set 100\ni32.const 1\nlocal.set 101\nlocal.get 100\nlocal.get 101\ni32.add\nlocal.set 102\nlocal.get 4\nlocal.get 102\ni32.store offset=36\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=56\nlocal.set 103\nlocal.get 4\ni32.load offset=48\nlocal.set 104\nlocal.get 4\ni32.load offset=44\nlocal.set 105\nlocal.get 4\ni32.load offset=48\nlocal.set 106\nlocal.get 105\nlocal.get 106\ni32.sub\nlocal.set 107\ni32.const 12\nlocal.set 108\nlocal.get 4\nlocal.get 108\ni32.add\nlocal.set 109\nlocal.get 109\nlocal.set 110\nlocal.get 110\nlocal.get 103\nlocal.get 104\nlocal.get 107\ncall 6\ni32.const 12\nlocal.set 111\nlocal.get 4\nlocal.get 111\ni32.add\nlocal.set 112\nlocal.get 112\nlocal.set 113\nlocal.get 0\nlocal.get 113\ncall 7\ni32.const 12\nlocal.set 114\nlocal.get 4\nlocal.get 114\ni32.add\nlocal.set 115\nlocal.get 115\nlocal.set 116\nlocal.get 116\ncall 208\ndrop\ni32.const 1\nlocal.set 117\ni32.const 1\nlocal.set 118\nlocal.get 117\nlocal.get 118\ni32.and\nlocal.set 119\nlocal.get 4\nlocal.get 119\ni32.store8 offset=55\nlocal.get 4\ni32.load8_u offset=55\nlocal.set 120\ni32.const 1\nlocal.set 121\nlocal.get 120\nlocal.get 121\ni32.and\nlocal.set 122\nblock  ;; label = @1\nlocal.get 122\nbr_if 0 (;@1;)\nlocal.get 0\ncall 8\ndrop\nend\ni32.const 64\nlocal.set 123\nlocal.get 4\nlocal.get 123\ni32.add\nlocal.set 124\nlocal.get 124\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_23",
        "query_text": "The function receives two inputs, each of type const wchar_t* (wide-character strings). It first checks if either string is NULL and, if so, returns a bool value that is true only when both inputs are NULL. If neither input is NULL, the function uses a standard library routine to determine whether the first string is a substring of the second. It then returns true if the substring is found, and false otherwise.",
        "code_id": "c_group_1_id_23",
        "code_text": "(func (;1;) (type 0) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.eq\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 9\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=4\nlocal.set 10\ni32.const 0\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.eq\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nlocal.get 14\ni32.eqz\nbr_if 1 (;@2;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 15\nlocal.get 4\ni32.load offset=4\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.eq\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.store8 offset=15\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=4\nlocal.set 20\nlocal.get 4\ni32.load offset=8\nlocal.set 21\nlocal.get 20\nlocal.get 21\ncall 2\nlocal.set 22\ni32.const 0\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.ne\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.store8 offset=15\nend\nlocal.get 4\ni32.load8_u offset=15\nlocal.set 27\ni32.const 1\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.and\nlocal.set 29\ni32.const 16\nlocal.set 30\nlocal.get 4\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 31\nglobal.set 0\nlocal.get 29\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_24",
        "query_text": "The function takes an input of type int, where the value determines the number of space characters. It then returns a std::string that consists precisely of that many spaces.",
        "code_id": "c_group_1_id_24",
        "code_text": "(func (;2;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 32\nlocal.set 6\ni32.const 24\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.shl\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.shr_s\nlocal.set 9\nlocal.get 0\nlocal.get 5\nlocal.get 9\ncall 3\ndrop\ni32.const 16\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 11\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_25",
        "query_text": "The function accepts two inputs: a pointer to a null-terminated constant character array and an integer specifying the maximum number of characters allowed in the output. It processes the string by printing it on a single line to the standard output. During this process, any newline characters found within the string are substituted with the literal characters \"\\\" followed by \"n\". If the count of printed characters reaches the specified maximum length before the entire string is processed, the function stops printing further characters and appends an ellipsis (\"...\") to indicate that the string has been truncated. The function does not produce a return value and its primary role is to output a processed version of the input string directly to the standard output.",
        "code_id": "c_group_1_id_25",
        "code_text": "(func (;2;) (type 4) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.ne\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nlocal.get 9\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 0\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.store offset=4\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 4\ni32.load offset=12\nlocal.set 11\nlocal.get 11\ni32.load8_u\nlocal.set 12\ni32.const 24\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.shl\nlocal.set 14\nlocal.get 14\nlocal.get 13\ni32.shr_s\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 4\ni32.load offset=4\nlocal.set 16\nlocal.get 4\ni32.load offset=8\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.ge_s\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\nblock  ;; label = @4\nlocal.get 20\ni32.eqz\nbr_if 0 (;@4;)\ni32.const 65587\nlocal.set 21\ni32.const 0\nlocal.set 22\nlocal.get 21\nlocal.get 22\ncall 4\ndrop\nbr 2 (;@2;)\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 23\nlocal.get 23\ni32.load8_u\nlocal.set 24\ni32.const 24\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.shl\nlocal.set 26\nlocal.get 26\nlocal.get 25\ni32.shr_s\nlocal.set 27\ni32.const 10\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.eq\nlocal.set 29\ni32.const 1\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.and\nlocal.set 31\nblock  ;; label = @4\nblock  ;; label = @5\nlocal.get 31\ni32.eqz\nbr_if 0 (;@5;)\ni32.const 65569\nlocal.set 32\ni32.const 0\nlocal.set 33\nlocal.get 32\nlocal.get 33\ncall 4\ndrop\nlocal.get 4\ni32.load offset=4\nlocal.set 34\ni32.const 2\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 4\nlocal.get 36\ni32.store offset=4\nbr 1 (;@4;)\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 37\nlocal.get 37\ni32.load8_u\nlocal.set 38\ni32.const 24\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.shl\nlocal.set 40\nlocal.get 40\nlocal.get 39\ni32.shr_s\nlocal.set 41\nlocal.get 4\nlocal.get 41\ni32.store\ni32.const 65576\nlocal.set 42\nlocal.get 42\nlocal.get 4\ncall 4\ndrop\nlocal.get 4\ni32.load offset=4\nlocal.set 43\ni32.const 1\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.add\nlocal.set 45\nlocal.get 4\nlocal.get 45\ni32.store offset=4\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 46\ni32.const 1\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.add\nlocal.set 48\nlocal.get 4\nlocal.get 48\ni32.store offset=12\nbr 0 (;@3;)\nend\nunreachable\nend\nend\ni32.const 16\nlocal.set 49\nlocal.get 4\nlocal.get 49\ni32.add\nlocal.set 50\nlocal.get 50\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_26",
        "query_text": "The function takes a wide character (wchar_t) as input and returns a boolean value. It checks whether the input character is a printable ASCII character by verifying if its value lies within the range of 0x20 to 0x7E. If the character falls within this range, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_26",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 32\nlocal.set 5\nlocal.get 5\nlocal.get 4\ni32.le_s\nlocal.set 6\ni32.const 0\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 7\nlocal.set 10\nblock  ;; label = @1\nlocal.get 9\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 11\ni32.const 126\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.le_s\nlocal.set 13\nlocal.get 13\nlocal.set 10\nend\nlocal.get 10\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 16\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_27",
        "query_text": "The function accepts an 8-bit unsigned integer as input and returns a boolean value. It checks if the provided value is between 0x80 and 0xbf (inclusive). If the value satisfies this condition, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_27",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\ni32.const 128\nlocal.set 7\nlocal.get 7\nlocal.get 6\ni32.le_s\nlocal.set 8\ni32.const 0\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 8\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 9\nlocal.set 12\nblock  ;; label = @1\nlocal.get 11\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 13\ni32.const 255\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\ni32.const 191\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.le_s\nlocal.set 17\nlocal.get 17\nlocal.set 12\nend\nlocal.get 12\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\nlocal.get 20\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_28",
        "query_text": "This function takes no input parameters and returns a reference to a stream used for standard output operations. Specifically, the output is an object of type std::ostream that enables printing messages to the console.",
        "code_id": "c_group_1_id_28",
        "code_text": "(func (;8;) (type 9) (result i32)\n(local i32)\ni32.const 82808\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_29",
        "query_text": "This function retrieves the standard error output stream by returning a reference to the underlying error stream object. It does not require any input arguments and outputs a reference to an object of type std::ostream. This returned stream is generally used for printing error messages or diagnostic information during program execution.",
        "code_id": "c_group_1_id_29",
        "code_text": "(func (;8;) (type 9) (result i32)\n(local i32)\ni32.const 82976\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_30",
        "query_text": "The function returns a reference to the program\u2019s standard logging stream. It takes no input parameters and outputs an object of type std::ostream that is used for logging and diagnostic messages. This function essentially provides access to the global logging utility in C++ programs by wrapping the standard logging stream.",
        "code_id": "c_group_1_id_30",
        "code_text": "(func (;8;) (type 9) (result i32)\n(local i32)\ni32.const 83144\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_31",
        "query_text": "The function takes no input arguments. It retrieves the current system time with high precision by utilizing a high-resolution clock, then computes the elapsed time in nanoseconds since the Unix epoch (typically January 1, 1970). Finally, it returns the resulting value as a 64-bit unsigned integer representing the nanoseconds count.",
        "code_id": "c_group_1_id_31",
        "code_text": "(func (;3;) (type 5) (result i64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 0\ni32.const 32\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ncall 18\nlocal.set 14\nlocal.get 2\nlocal.get 14\ni64.store offset=8\ni32.const 8\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.add\nlocal.set 4\nlocal.get 4\nlocal.set 5\nlocal.get 5\ncall 4\nlocal.set 15\nlocal.get 2\nlocal.get 15\ni64.store offset=16\ni32.const 16\nlocal.set 6\nlocal.get 2\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.set 8\nlocal.get 8\ncall 5\nlocal.set 16\nlocal.get 2\nlocal.get 16\ni64.store offset=24\ni32.const 24\nlocal.set 9\nlocal.get 2\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nlocal.set 11\nlocal.get 11\ncall 6\nlocal.set 17\ni32.const 32\nlocal.set 12\nlocal.get 2\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_32",
        "query_text": "The function accepts three parameters: a reference to a modifiable string and two constant strings representing the target substring and the replacement substring, respectively. It scans the string for occurrences of the target substring and replaces each found instance with the replacement substring, modifying the string in-place. The function returns a boolean value\u2014true if at least one replacement was made and false if none were found.",
        "code_id": "c_group_1_id_32",
        "code_text": "(func (;2;) (type 1) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 80\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=76\nlocal.get 5\nlocal.get 1\ni32.store offset=72\nlocal.get 5\nlocal.get 2\ni32.store offset=68\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store8 offset=67\nlocal.get 5\ni32.load offset=76\nlocal.set 7\nlocal.get 5\ni32.load offset=72\nlocal.set 8\ni32.const 0\nlocal.set 9\nlocal.get 7\nlocal.get 8\nlocal.get 9\ncall 3\nlocal.set 10\nlocal.get 5\nlocal.get 10\ni32.store offset=60\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=60\nlocal.set 11\ni32.const -1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.ne\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@1;)\ni32.const 1\nlocal.set 16\nlocal.get 5\nlocal.get 16\ni32.store8 offset=67\nlocal.get 5\ni32.load offset=76\nlocal.set 17\nlocal.get 5\ni32.load offset=60\nlocal.set 18\ni32.const 24\nlocal.set 19\nlocal.get 5\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\nlocal.set 21\ni32.const 0\nlocal.set 22\nlocal.get 21\nlocal.get 17\nlocal.get 22\nlocal.get 18\ncall 4\nlocal.get 5\ni32.load offset=68\nlocal.set 23\ni32.const 36\nlocal.set 24\nlocal.get 5\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\nlocal.set 26\ni32.const 24\nlocal.set 27\nlocal.get 5\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 28\nlocal.set 29\nlocal.get 26\nlocal.get 29\nlocal.get 23\ncall 5\nlocal.get 5\ni32.load offset=76\nlocal.set 30\nlocal.get 5\ni32.load offset=60\nlocal.set 31\nlocal.get 5\ni32.load offset=72\nlocal.set 32\nlocal.get 32\ncall 6\nlocal.set 33\nlocal.get 31\nlocal.get 33\ni32.add\nlocal.set 34\ni32.const 12\nlocal.set 35\nlocal.get 5\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 36\nlocal.set 37\ni32.const -1\nlocal.set 38\nlocal.get 37\nlocal.get 30\nlocal.get 34\nlocal.get 38\ncall 4\ni32.const 48\nlocal.set 39\nlocal.get 5\nlocal.get 39\ni32.add\nlocal.set 40\nlocal.get 40\nlocal.set 41\ni32.const 36\nlocal.set 42\nlocal.get 5\nlocal.get 42\ni32.add\nlocal.set 43\nlocal.get 43\nlocal.set 44\ni32.const 12\nlocal.set 45\nlocal.get 5\nlocal.get 45\ni32.add\nlocal.set 46\nlocal.get 46\nlocal.set 47\nlocal.get 41\nlocal.get 44\nlocal.get 47\ncall 7\nlocal.get 5\ni32.load offset=76\nlocal.set 48\ni32.const 48\nlocal.set 49\nlocal.get 5\nlocal.get 49\ni32.add\nlocal.set 50\nlocal.get 50\nlocal.set 51\nlocal.get 48\nlocal.get 51\ncall 8\ndrop\ni32.const 48\nlocal.set 52\nlocal.get 5\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\nlocal.set 54\nlocal.get 54\ncall 121\ndrop\ni32.const 12\nlocal.set 55\nlocal.get 5\nlocal.get 55\ni32.add\nlocal.set 56\nlocal.get 56\nlocal.set 57\nlocal.get 57\ncall 121\ndrop\ni32.const 36\nlocal.set 58\nlocal.get 5\nlocal.get 58\ni32.add\nlocal.set 59\nlocal.get 59\nlocal.set 60\nlocal.get 60\ncall 121\ndrop\ni32.const 24\nlocal.set 61\nlocal.get 5\nlocal.get 61\ni32.add\nlocal.set 62\nlocal.get 62\nlocal.set 63\nlocal.get 63\ncall 121\ndrop\nlocal.get 5\ni32.load offset=60\nlocal.set 64\nlocal.get 5\ni32.load offset=76\nlocal.set 65\nlocal.get 65\ncall 6\nlocal.set 66\nlocal.get 5\ni32.load offset=68\nlocal.set 67\nlocal.get 67\ncall 6\nlocal.set 68\nlocal.get 66\nlocal.get 68\ni32.sub\nlocal.set 69\nlocal.get 64\nlocal.get 69\ni32.lt_u\nlocal.set 70\ni32.const 1\nlocal.set 71\nlocal.get 70\nlocal.get 71\ni32.and\nlocal.set 72\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 72\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 5\ni32.load offset=76\nlocal.set 73\nlocal.get 5\ni32.load offset=72\nlocal.set 74\nlocal.get 5\ni32.load offset=60\nlocal.set 75\nlocal.get 5\ni32.load offset=68\nlocal.set 76\nlocal.get 76\ncall 6\nlocal.set 77\nlocal.get 75\nlocal.get 77\ni32.add\nlocal.set 78\nlocal.get 73\nlocal.get 74\nlocal.get 78\ncall 3\nlocal.set 79\nlocal.get 5\nlocal.get 79\ni32.store offset=60\nbr 1 (;@3;)\nend\ni32.const -1\nlocal.set 80\nlocal.get 5\nlocal.get 80\ni32.store offset=60\nend\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 5\ni32.load8_u offset=67\nlocal.set 81\ni32.const 1\nlocal.set 82\nlocal.get 81\nlocal.get 82\ni32.and\nlocal.set 83\ni32.const 80\nlocal.set 84\nlocal.get 5\nlocal.get 84\ni32.add\nlocal.set 85\nlocal.get 85\nglobal.set 0\nlocal.get 83\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_33",
        "query_text": "The function takes a single input\u2014a character of type char. It then checks whether this character is a member of a specific set of symbols, which includes closing brackets, punctuation marks, and various mathematical operators. If the character is found within the set, the function returns a boolean value of true; otherwise, it returns false.",
        "code_id": "c_group_1_id_33",
        "code_text": "(func (;2;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\nlocal.set 4\ni32.const 65549\nlocal.set 5\nlocal.get 4\nlocal.get 5\ncall 3\ndrop\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 6\nlocal.get 3\nlocal.set 7\ni32.const 0\nlocal.set 8\ni32.const 24\nlocal.set 9\nlocal.get 6\nlocal.get 9\ni32.shl\nlocal.set 10\nlocal.get 10\nlocal.get 9\ni32.shr_s\nlocal.set 11\nlocal.get 7\nlocal.get 11\nlocal.get 8\ncall 76\nlocal.set 12\ni32.const -1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.ne\nlocal.set 14\nlocal.get 3\nlocal.set 15\nlocal.get 15\ncall 72\ndrop\ni32.const 1\nlocal.set 16\nlocal.get 14\nlocal.get 16\ni32.and\nlocal.set 17\ni32.const 16\nlocal.set 18\nlocal.get 3\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 19\nglobal.set 0\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_34",
        "query_text": "The function accepts a string input provided as a constant reference and returns a string. On Windows platforms, if the first character of the input string is a forward slash ('/'), it returns a modified string where the initial forward slash is replaced with a hyphen ('-'). For non-Windows platforms or if the input string does not start with a forward slash, it returns the original string unchanged.",
        "code_id": "c_group_1_id_34",
        "code_text": "(func (;2;) (type 5) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\nlocal.get 0\nlocal.get 5\ncall 3\ndrop\ni32.const 16\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_35",
        "query_text": "The function takes no input and returns a boolean value. It determines whether color output should be enabled by verifying environmental conditions. Specifically, on certain platforms such as macOS or iOS, it checks that a debugger is not active. It also verifies that the standard output is connected to a terminal (using an isatty-like check), unless the platform enforces strict ANSI compliance (as in some DJGPP environments). If these conditions are not met, the function returns false, indicating that color output should not be used.",
        "code_id": "c_group_1_id_35",
        "code_text": "(func (;2;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32 i32)\ni32.const 1\nlocal.set 0\nlocal.get 0\ncall 5\nlocal.set 1\ni32.const 0\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.ne\nlocal.set 3\ni32.const 1\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.and\nlocal.set 5\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_36",
        "query_text": "The function takes a single floating-point value as input and returns a 32-bit integer as its output. It operates by directly copying the binary representation of the input float into the memory space of a 32-bit integer. This technique ensures that the integer holds exactly the same bit pattern as the original floating-point value, without performing any arithmetic conversion. An internal check confirms that the size of the floating-point type matches the size of the 32-bit integer type, as required by the implementation.",
        "code_id": "c_group_1_id_36",
        "code_text": "(func (;1;) (type 2) (param f32) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 5\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_37",
        "query_text": "The function accepts a double-precision floating-point value as input and returns a 64-bit integer. It performs the conversion by directly copying the binary representation of the floating-point value into a 64-bit integer variable, effectively reinterpreting the bits without modifying them. The function also enforces an assumption that the size of the floating-point type is equal to the size of the 64-bit integer type.",
        "code_id": "c_group_1_id_37",
        "code_text": "(func (;1;) (type 2) (param f64) (result i64)\n(local i32 i32 i32 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni64.store\nlocal.get 3\ni64.load\nlocal.set 5\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_38",
        "query_text": "The function takes no input arguments and returns a boolean value indicating whether there are any uncaught exceptions in the current execution context. It adapts its behavior based on the compilation environment and configuration: if exception support is disabled, it always returns false; if compiled with C++17 support and the appropriate configuration is defined, it uses a standard library function to check if the number of uncaught exceptions is greater than zero; otherwise, it employs another standard library function to determine the presence of any uncaught exception.",
        "code_id": "c_group_1_id_38",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\ncall 3\nlocal.set 0\ni32.const 0\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.gt_s\nlocal.set 2\ni32.const 1\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.and\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_39",
        "query_text": "The function accepts a reference to an output stream and an unsigned character as input. It formats the unsigned character into a hexadecimal escape sequence, outputting the literal \"\\x\" followed by the two-digit uppercase hexadecimal representation of the character. After writing the formatted output, the function restores the original state of the output stream\u2019s formatting flags to prevent side effects on any subsequent output operations. The input is an output stream and an unsigned character, while the output consists of the hexadecimal escape sequence written to the provided stream.",
        "code_id": "c_group_1_id_39",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store8 offset=27\nlocal.get 4\ni32.load offset=28\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\ni32.const -12\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\ni32.load\nlocal.set 9\nlocal.get 5\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\ncall 3\nlocal.set 11\nlocal.get 4\nlocal.get 11\ni32.store offset=20\nlocal.get 4\ni32.load offset=28\nlocal.set 12\ni32.const 65536\nlocal.set 13\nlocal.get 12\nlocal.get 13\ncall 4\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ncall 6\nlocal.set 16\ni32.const 2\nlocal.set 17\nlocal.get 16\nlocal.get 17\ncall 6\nlocal.set 18\ni32.const 48\nlocal.set 19\ni32.const 24\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 21\nlocal.get 20\ni32.shr_s\nlocal.set 22\nlocal.get 22\ncall 8\nlocal.set 23\nlocal.get 4\nlocal.get 23\ni32.store8 offset=19\ni32.const 19\nlocal.set 24\nlocal.get 4\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\nlocal.set 26\nlocal.get 18\nlocal.get 26\ncall 9\nlocal.set 27\ni32.const 2\nlocal.set 28\nlocal.get 28\ncall 10\nlocal.set 29\nlocal.get 4\nlocal.get 29\ni32.store offset=12\ni32.const 12\nlocal.set 30\nlocal.get 4\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 31\nlocal.set 32\nlocal.get 27\nlocal.get 32\ncall 11\nlocal.set 33\nlocal.get 4\ni32.load8_u offset=27\nlocal.set 34\ni32.const 255\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.and\nlocal.set 36\nlocal.get 33\nlocal.get 36\ncall 98\ndrop\nlocal.get 4\ni32.load offset=28\nlocal.set 37\nlocal.get 37\ni32.load\nlocal.set 38\ni32.const -12\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.add\nlocal.set 40\nlocal.get 40\ni32.load\nlocal.set 41\nlocal.get 37\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 4\ni32.load offset=20\nlocal.set 43\nlocal.get 42\nlocal.get 43\ncall 12\ndrop\ni32.const 32\nlocal.set 44\nlocal.get 4\nlocal.get 44\ni32.add\nlocal.set 45\nlocal.get 45\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_40",
        "query_text": "The function takes no input arguments and returns a fixed, immutable string literal. Specifically, it outputs a pointer to a constant character array containing a predefined failure message. No modifications can be made to this string, and the primary purpose of the function is to provide a standard error indicator.",
        "code_id": "c_group_1_id_40",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 65536\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_41",
        "query_text": "The function accepts no input arguments and returns a constant string literal. Its return type is a pointer to constant characters (const char*), ensuring that the returned string cannot be altered. The function\u2019s primary purpose is to provide a fixed immutable string without performing any additional operations.",
        "code_id": "c_group_1_id_41",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 65536\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_42",
        "query_text": "The function accepts two unsigned integer inputs representing a part and a whole. It begins by checking whether the whole is nonzero; if it is, the function scales the part by a predefined constant and divides the product by the whole to compute a ratio. If the whole is zero, the function avoids division by zero by immediately returning zero. Additionally, if the computed ratio is zero even though the part is nonzero, the function adjusts the result to be at least one. The final output is an unsigned integer representing the computed, scaled ratio.",
        "code_id": "c_group_1_id_42",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.gt_u\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 10\ni32.const 80\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.mul\nlocal.set 12\nlocal.get 4\ni32.load offset=8\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.div_u\nlocal.set 14\nlocal.get 14\nlocal.set 15\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 16\nlocal.get 16\nlocal.set 15\nend\nlocal.get 15\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.store offset=4\nlocal.get 4\ni32.load offset=4\nlocal.set 18\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 18\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 19\ni32.const 0\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.gt_u\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.and\nlocal.set 23\nlocal.get 23\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 1\nlocal.set 24\nlocal.get 24\nlocal.set 25\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=4\nlocal.set 26\nlocal.get 26\nlocal.set 25\nend\nlocal.get 25\nlocal.set 27\nlocal.get 27\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_43",
        "query_text": "The function accepts three input parameters, each being a reference to an unsigned integer, and it determines which of these values is the largest. It performs comparisons among the three inputs: if the first value exceeds both the second and third, it returns a reference to the first; if not, it checks whether the second value is greater than the third and returns a reference to the second if true; otherwise, it returns a reference to the third value. The function does not modify any of the input values but provides direct access to the maximum value via the returned reference.",
        "code_id": "c_group_1_id_43",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=8\nlocal.get 5\nlocal.get 1\ni32.store offset=4\nlocal.get 5\nlocal.get 2\ni32.store\nlocal.get 5\ni32.load offset=8\nlocal.set 6\nlocal.get 6\ni32.load\nlocal.set 7\nlocal.get 5\ni32.load offset=4\nlocal.set 8\nlocal.get 8\ni32.load\nlocal.set 9\nlocal.get 7\nlocal.get 9\ni32.gt_u\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 12\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 5\ni32.load offset=8\nlocal.set 13\nlocal.get 13\ni32.load\nlocal.set 14\nlocal.get 5\ni32.load\nlocal.set 15\nlocal.get 15\ni32.load\nlocal.set 16\nlocal.get 14\nlocal.get 16\ni32.gt_u\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 19\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 5\ni32.load offset=8\nlocal.set 20\nlocal.get 5\nlocal.get 20\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 5\ni32.load offset=4\nlocal.set 21\nlocal.get 21\ni32.load\nlocal.set 22\nlocal.get 5\ni32.load\nlocal.set 23\nlocal.get 23\ni32.load\nlocal.set 24\nlocal.get 22\nlocal.get 24\ni32.gt_u\nlocal.set 25\ni32.const 1\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.and\nlocal.set 27\nblock  ;; label = @2\nlocal.get 27\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 5\ni32.load offset=4\nlocal.set 28\nlocal.get 5\nlocal.get 28\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 5\ni32.load\nlocal.set 29\nlocal.get 5\nlocal.get 29\ni32.store offset=12\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 30\nlocal.get 30\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_44",
        "query_text": "The function generates and returns a string that represents the current date and time formatted according to the ISO 8601 standard in UTC. It accepts no input parameters and outputs a string. Internally, it obtains the current system time, converts it to Coordinated Universal Time (UTC), and then formats it into a character array following the pattern \"YYYY-MM-DDTHH:MM:SSZ\". The implementation also manages platform-specific differences in time retrieval and formatting to ensure consistent behavior across various environments.",
        "code_id": "c_group_1_id_44",
        "code_text": "(func (;6;) (type 6) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 64\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=60\ni32.const 48\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.add\nlocal.set 5\nlocal.get 5\nlocal.set 6\nlocal.get 6\ncall 42\ndrop\ni32.const 21\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.store offset=44\ni32.const 48\nlocal.set 8\nlocal.get 3\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nlocal.set 10\nlocal.get 10\ncall 53\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.store offset=40\ni32.const 65688\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.store offset=12\ni32.const 16\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\nlocal.set 15\nlocal.get 3\ni32.load offset=40\nlocal.set 16\ni32.const 21\nlocal.set 17\ni32.const 65688\nlocal.set 18\nlocal.get 15\nlocal.get 17\nlocal.get 18\nlocal.get 16\ncall 30\ndrop\ni32.const 16\nlocal.set 19\nlocal.get 3\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\nlocal.set 21\ni32.const 20\nlocal.set 22\nlocal.get 0\nlocal.get 21\nlocal.get 22\ncall 7\ndrop\ni32.const 64\nlocal.set 23\nlocal.get 3\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_45",
        "query_text": "The function accepts a constant reference to a vector of strings and returns a string. It iterates over the vector to locate the first element that begins with the '#' character. If such an element is identified, the function extracts a substring from this element starting from the second character and returns it. If none of the strings in the vector satisfy the condition, the function returns an empty string.",
        "code_id": "c_group_1_id_45",
        "code_text": "(func (;2;) (type 5) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 5\ncall 3\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=16\nlocal.get 4\ni32.load offset=24\nlocal.set 7\nlocal.get 7\ncall 4\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=12\nlocal.get 4\ni32.load offset=16\nlocal.set 9\nlocal.get 4\ni32.load offset=12\nlocal.set 10\nlocal.get 9\nlocal.get 10\ncall 5\nlocal.set 11\nlocal.get 4\nlocal.get 11\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 12\nlocal.get 12\ncall 6\nlocal.set 13\nlocal.get 4\nlocal.get 13\ni32.store offset=4\ni32.const 20\nlocal.set 14\nlocal.get 4\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nlocal.set 16\ni32.const 4\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 18\nlocal.set 19\nlocal.get 16\nlocal.get 19\ncall 7\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 22\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 20\nlocal.set 23\nlocal.get 4\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nlocal.set 25\nlocal.get 25\ncall 8\nlocal.set 26\ni32.const 1\nlocal.set 27\ni32.const -1\nlocal.set 28\nlocal.get 0\nlocal.get 26\nlocal.get 27\nlocal.get 28\ncall 9\nbr 1 (;@1;)\nend\nlocal.get 0\ncall 10\ndrop\nend\ni32.const 32\nlocal.set 29\nlocal.get 4\nlocal.get 29\ni32.add\nlocal.set 30\nlocal.get 30\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_46",
        "query_text": "The function accepts an unsigned 64-bit integer as its sole parameter. It calculates and returns an integer that represents the number of consecutive zero bits starting from the least significant bit of the input's binary representation. Note that if the input is zero, the behavior is undefined.",
        "code_id": "c_group_1_id_46",
        "code_text": "(func (;1;) (type 2) (param i64) (result i32)\n(local i32 i32 i32 i32 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 5\nlocal.get 5\ni64.ctz\nlocal.set 6\nlocal.get 6\ni32.wrap_i64\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_47",
        "query_text": "The function accepts three inputs: a string representing a file name, an integer representing a line number, and another string representing an error message. It prints a formatted error message to the standard error stream that includes the file name, line number, and error message, and then terminates the program by invoking an abort function. The function does not return any value.",
        "code_id": "c_group_1_id_47",
        "code_text": "(func (;5;) (type 5) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\ni32.const 0\nlocal.set 6\nlocal.get 6\ni32.load offset=65620\nlocal.set 7\nlocal.get 5\ni32.load offset=28\nlocal.set 8\nlocal.get 5\ni32.load offset=24\nlocal.set 9\nlocal.get 5\ni32.load offset=20\nlocal.set 10\nlocal.get 5\nlocal.get 10\ni32.store offset=8\nlocal.get 5\nlocal.get 9\ni32.store offset=4\nlocal.get 5\nlocal.get 8\ni32.store\ni32.const 65565\nlocal.set 11\nlocal.get 7\nlocal.get 11\nlocal.get 5\ncall 10\ndrop\ncall 7\nunreachable)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_48",
        "query_text": "The function takes no input arguments. It evaluates the system's byte order to determine if it is big-endian. Depending on the platform, the function uses a combination of predefined macros and a runtime check. On one platform, it directly returns false, assuming little-endian ordering; on others, it first checks for compile-time macros that indicate big-endian order, and if they are not available, it performs a runtime check by examining the byte representation of a numeric value. Ultimately, the function returns a boolean value: true if the system is big-endian, and false otherwise.",
        "code_id": "c_group_1_id_48",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32)\ni32.const 0\nlocal.set 0\ni32.const 1\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.and\nlocal.set 2\nlocal.get 2\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_49",
        "query_text": "The function receives an unsigned 32-bit integer (of type uint32_t) and returns an integer representing the number of digits in the input. It calculates this digit count by employing a precomputed table alongside bitwise operations to avoid explicitly iterating through each digit. The design emphasizes performance by leveraging built-in compiler optimizations.",
        "code_id": "c_group_1_id_49",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 288\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=284\ni32.const 65536\nlocal.set 4\ni32.const 256\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.get 4\nlocal.get 5\ncall 3\ndrop\nlocal.get 3\ni32.load offset=284\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.or\nlocal.set 10\nlocal.get 10\ni32.clz\nlocal.set 11\ni32.const 31\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.xor\nlocal.set 13\ni32.const 16\nlocal.set 14\nlocal.get 3\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nlocal.set 16\ni32.const 3\nlocal.set 17\nlocal.get 13\nlocal.get 17\ni32.shl\nlocal.set 18\nlocal.get 16\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 19\ni64.load\nlocal.set 25\nlocal.get 3\nlocal.get 25\ni64.store offset=8\nlocal.get 3\ni32.load offset=284\nlocal.set 20\nlocal.get 20\nlocal.set 21\nlocal.get 21\ni64.extend_i32_u\nlocal.set 26\nlocal.get 3\ni64.load offset=8\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni64.add\nlocal.set 28\ni64.const 32\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni64.shr_u\nlocal.set 30\nlocal.get 30\ni32.wrap_i64\nlocal.set 22\ni32.const 288\nlocal.set 23\nlocal.get 3\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nglobal.set 0\nlocal.get 22\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_50",
        "query_text": "The function takes two inputs, both of type unsigned. It modifies the first input in place by appending the second value using bitwise operations. Specifically, if the first input is non-zero, the second input is shifted left by 8 bits before being combined; otherwise, it is appended as is. Additionally, the function increments a counter stored in the higher bits of the first input. This counter is increased by a base value of 1, with an extra increment if the second input exceeds a certain threshold. The final result is an updated unsigned integer that reflects both the appended value and the incremented counter.",
        "code_id": "c_group_1_id_50",
        "code_text": "(func (;1;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 6\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=8\nlocal.set 7\ni32.const 8\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shl\nlocal.set 9\nlocal.get 9\nlocal.set 10\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 11\nlocal.get 11\nlocal.set 10\nend\nlocal.get 10\nlocal.set 12\nlocal.get 4\ni32.load offset=12\nlocal.set 13\nlocal.get 13\ni32.load\nlocal.set 14\nlocal.get 14\nlocal.get 12\ni32.or\nlocal.set 15\nlocal.get 13\nlocal.get 15\ni32.store\nlocal.get 4\ni32.load offset=8\nlocal.set 16\ni32.const 255\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.gt_u\nlocal.set 18\ni32.const 1\nlocal.set 19\ni32.const 0\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 18\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 19\nlocal.get 20\nlocal.get 22\nselect\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.add\nlocal.set 25\ni32.const 24\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.shl\nlocal.set 27\nlocal.get 4\ni32.load offset=12\nlocal.set 28\nlocal.get 28\ni32.load\nlocal.set 29\nlocal.get 29\nlocal.get 27\ni32.add\nlocal.set 30\nlocal.get 28\nlocal.get 30\ni32.store\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_51",
        "query_text": "The function takes an integer as input and returns a 32-bit unsigned integer. It uses the input value as an index to retrieve a corresponding element from a fixed array of eight predefined 32-bit unsigned integer values that are encoded within Unicode string literals. The function essentially acts as a lookup table, returning the element associated with the provided index.",
        "code_id": "c_group_1_id_51",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 65536\nlocal.set 5\ni32.const 2\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.shl\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\ni32.load\nlocal.set 9\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_52",
        "query_text": "The function accepts two 32-bit unsigned integers. The first is treated as the value to be rotated, and the second as the number of positions to rotate that value to the right. Initially, it ensures that the rotation count is within the valid range (0 to 31) by applying a mask. The function then shifts the input value to the right by the specified count and combines it with the value shifted to the left by the complement (32 minus the rotation count). Ultimately, it returns a 32-bit unsigned integer that represents the value after the rotation operation.",
        "code_id": "c_group_1_id_52",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 31\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 8\nlocal.get 4\ni32.load offset=8\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.shr_u\nlocal.set 10\nlocal.get 4\ni32.load offset=12\nlocal.set 11\nlocal.get 4\ni32.load offset=8\nlocal.set 12\ni32.const 32\nlocal.set 13\nlocal.get 13\nlocal.get 12\ni32.sub\nlocal.set 14\nlocal.get 11\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 10\nlocal.get 15\ni32.or\nlocal.set 16\nlocal.get 16\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_53",
        "query_text": "The function accepts two inputs: the first is a 32-bit unsigned integer and the second is a 64-bit unsigned integer. It multiplies these values together and returns the lower 64 bits of the resultant product as a 64-bit unsigned integer. The implementation is optimized for performance, being defined as inline and marked as noexcept, ensuring that it does not throw exceptions.",
        "code_id": "c_group_1_id_53",
        "code_text": "(func (;1;) (type 2) (param i32 i64) (result i64)\n(local i32 i32 i32 i32 i32 i64 i64 i64)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni64.store\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\nlocal.set 6\nlocal.get 6\ni64.extend_i32_u\nlocal.set 7\nlocal.get 4\ni64.load\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni64.mul\nlocal.set 9\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_54",
        "query_text": "The function accepts a 32-bit unsigned integer as input. It first converts the input to a 64-bit value to ensure accuracy during the ensuing arithmetic operation. It then multiplies this value by a predetermined constant (1374389535) and subsequently shifts the result to the right by 37 bits. Finally, the result is cast back to a 32-bit unsigned integer and returned. This sequence of operations is designed to be efficient and is implemented in a way that guarantees no exceptions are thrown.",
        "code_id": "c_group_1_id_54",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i64 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nlocal.set 5\nlocal.get 5\ni64.extend_i32_u\nlocal.set 7\ni64.const 1374389535\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni64.mul\nlocal.set 9\ni64.const 37\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni64.shr_u\nlocal.set 11\nlocal.get 11\ni32.wrap_i64\nlocal.set 6\nlocal.get 6\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_55",
        "query_text": "The function accepts an integer input representing a month index and returns a string containing the full name of that month. Internally, it uses a static lookup table that maps indices 0 through 11 to month names (from January to December). If the input is outside this valid range, the function returns a placeholder string, \"?\". The function is designed to take an input type of int and output a pointer to a constant character array (const char*).",
        "code_id": "c_group_1_id_55",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 64\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=60\ni32.const 0\nlocal.set 4\nlocal.get 4\ni64.load offset=65672\nlocal.set 32\ni32.const 40\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\nlocal.get 32\ni64.store\nlocal.get 4\ni64.load offset=65664\nlocal.set 33\ni32.const 32\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\nlocal.get 33\ni64.store\nlocal.get 4\ni64.load offset=65656\nlocal.set 34\ni32.const 24\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nlocal.get 34\ni64.store\nlocal.get 4\ni64.load offset=65648\nlocal.set 35\ni32.const 16\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nlocal.get 35\ni64.store\nlocal.get 4\ni64.load offset=65640\nlocal.set 36\nlocal.get 3\nlocal.get 36\ni64.store offset=8\nlocal.get 4\ni64.load offset=65632\nlocal.set 37\nlocal.get 3\nlocal.get 37\ni64.store\nlocal.get 3\ni32.load offset=60\nlocal.set 13\ni32.const 0\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.ge_s\nlocal.set 15\ni32.const 1\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.and\nlocal.set 17\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 17\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=60\nlocal.set 18\ni32.const 11\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.le_s\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 22\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=60\nlocal.set 23\nlocal.get 3\nlocal.set 24\ni32.const 2\nlocal.set 25\nlocal.get 23\nlocal.get 25\ni32.shl\nlocal.set 26\nlocal.get 24\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\ni32.load\nlocal.set 28\nlocal.get 28\nlocal.set 29\nbr 1 (;@1;)\nend\ni32.const 65622\nlocal.set 30\nlocal.get 30\nlocal.set 29\nend\nlocal.get 29\nlocal.set 31\nlocal.get 31\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_57",
        "query_text": "The function takes no input parameters and returns a boolean value. It is implemented as a constexpr function that always returns the constant value true. Its primary purpose is to serve as an indicator that the functionality is deprecated, with a suggestion to use an alternative implementation instead. This function does not involve any complex operations or computations.",
        "code_id": "c_group_1_id_57",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32)\ni32.const 1\nlocal.set 0\ni32.const 1\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.and\nlocal.set 2\nlocal.get 2\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_58",
        "query_text": "The function takes no input parameters and returns a boolean value. It is declared as a constant expression function (constexpr), allowing its return value to be determined at compile time. The constant output is the boolean value true, which serves as a marker to signal that a particular feature is deprecated.",
        "code_id": "c_group_1_id_58",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32)\ni32.const 1\nlocal.set 0\ni32.const 1\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.and\nlocal.set 2\nlocal.get 2\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_59",
        "query_text": "The function accepts a single parameter\u2014a 16-bit character value\u2014and returns a constant pointer to a null-terminated string. Regardless of the input value, it consistently returns the string \"u\". The function performs no additional operations or conditional logic, making its behavior invariant to the provided input.",
        "code_id": "c_group_1_id_59",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store16 offset=14\ni32.const 65536\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_60",
        "query_text": "The function takes two double-precision floating-point numbers as input and returns a double-precision floating-point number as output. It computes the next representable value after the first input, moving in the direction indicated by the second input. Essentially, it provides the minimal increment or decrement from the first value toward the second value, following the precision rules of double-precision arithmetic.",
        "code_id": "c_group_1_id_60",
        "code_text": "(func (;1;) (type 2) (param f64 f64) (result f64)\n(local i32 i32 i32 i32 i32 f64 f64 f64)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\nf64.store offset=8\nlocal.get 4\nlocal.get 1\nf64.store\nlocal.get 4\nf64.load offset=8\nlocal.set 7\nlocal.get 4\nf64.load\nlocal.set 8\nlocal.get 7\nlocal.get 8\ncall 1\nlocal.set 9\ni32.const 16\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\nglobal.set 0\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_61",
        "query_text": "The function takes one input: a floating-point value representing an angle in degrees. It computes the equivalent angle in radians by multiplying the input by the constant factor \u03c0/180. The function then returns the calculated floating-point value, performing the unit conversion directly on the provided argument.",
        "code_id": "c_group_1_id_61",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nf32.const 0x1.921fb6p+1 (;=3.14159;)\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf32.mul\nlocal.set 6\nf32.const 0x1.68p+7 (;=180;)\nlocal.set 7\nlocal.get 6\nlocal.get 7\nf32.div\nlocal.set 8\nlocal.get 8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_62",
        "query_text": "The function takes two integer inputs. It compares these values and, if the first integer is less than the second, returns the first; otherwise, it returns the second integer. The function\u2019s return type is an integer.",
        "code_id": "c_group_1_id_62",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 5\nlocal.get 4\ni32.load offset=4\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.lt_s\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=8\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=4\nlocal.set 11\nlocal.get 4\nlocal.get 11\ni32.store offset=12\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 12\nlocal.get 12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_63",
        "query_text": "The function accepts two inputs: an array of unsigned character pointers and a size parameter of type size_t. It processes the array by scanning through consecutive pairs of pointers and evaluates three possible issues. First, it counts how many consecutive pairs are identical. Second, it checks for pairs where at least one pointer is NULL. Third, for pairs where both pointers are valid, it compares the strings they reference and counts how many pairs are not in ascending order. If any of these conditions are met, the function outputs warning messages to the standard error stream that detail the number of identical pointers, invalid pointers, and incorrectly ordered pairs. Finally, the function returns an integer value\u2014returning 1 if any of the issues are detected, otherwise returning 0.",
        "code_id": "c_group_1_id_63",
        "code_text": "(func (;4;) (type 4) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 64\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=56\nlocal.get 4\nlocal.get 1\ni32.store offset=52\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=48\ni32.const 0\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=44\ni32.const 0\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store offset=40\ni32.const 0\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=36\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=36\nlocal.set 9\nlocal.get 4\ni32.load offset=52\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.sub\nlocal.set 12\nlocal.get 9\nlocal.get 12\ni32.lt_u\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=56\nlocal.set 16\nlocal.get 4\ni32.load offset=36\nlocal.set 17\ni32.const 2\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.shl\nlocal.set 19\nlocal.get 16\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\ni32.load\nlocal.set 21\nlocal.get 4\ni32.load offset=56\nlocal.set 22\nlocal.get 4\ni32.load offset=36\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.add\nlocal.set 25\ni32.const 2\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.shl\nlocal.set 27\nlocal.get 22\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 28\ni32.load\nlocal.set 29\nlocal.get 21\nlocal.get 29\ni32.eq\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nblock  ;; label = @3\nlocal.get 32\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=44\nlocal.set 33\ni32.const 1\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 4\nlocal.get 35\ni32.store offset=44\nend\nlocal.get 4\ni32.load offset=56\nlocal.set 36\nlocal.get 4\ni32.load offset=36\nlocal.set 37\ni32.const 2\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.shl\nlocal.set 39\nlocal.get 36\nlocal.get 39\ni32.add\nlocal.set 40\nlocal.get 40\ni32.load\nlocal.set 41\ni32.const 0\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.eq\nlocal.set 43\ni32.const 1\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.and\nlocal.set 45\nblock  ;; label = @3\nblock  ;; label = @4\nblock  ;; label = @5\nlocal.get 45\nbr_if 0 (;@5;)\nlocal.get 4\ni32.load offset=56\nlocal.set 46\nlocal.get 4\ni32.load offset=36\nlocal.set 47\ni32.const 1\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.add\nlocal.set 49\ni32.const 2\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.shl\nlocal.set 51\nlocal.get 46\nlocal.get 51\ni32.add\nlocal.set 52\nlocal.get 52\ni32.load\nlocal.set 53\ni32.const 0\nlocal.set 54\nlocal.get 53\nlocal.get 54\ni32.eq\nlocal.set 55\ni32.const 1\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.and\nlocal.set 57\nlocal.get 57\ni32.eqz\nbr_if 1 (;@4;)\nend\nlocal.get 4\ni32.load offset=40\nlocal.set 58\ni32.const 1\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.add\nlocal.set 60\nlocal.get 4\nlocal.get 60\ni32.store offset=40\nbr 1 (;@3;)\nend\nlocal.get 4\ni32.load offset=56\nlocal.set 61\nlocal.get 4\ni32.load offset=36\nlocal.set 62\ni32.const 2\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.shl\nlocal.set 64\nlocal.get 61\nlocal.get 64\ni32.add\nlocal.set 65\nlocal.get 65\ni32.load\nlocal.set 66\nlocal.get 4\ni32.load offset=56\nlocal.set 67\nlocal.get 4\ni32.load offset=36\nlocal.set 68\ni32.const 1\nlocal.set 69\nlocal.get 68\nlocal.get 69\ni32.add\nlocal.set 70\ni32.const 2\nlocal.set 71\nlocal.get 70\nlocal.get 71\ni32.shl\nlocal.set 72\nlocal.get 67\nlocal.get 72\ni32.add\nlocal.set 73\nlocal.get 73\ni32.load\nlocal.set 74\nlocal.get 66\nlocal.get 74\ncall 12\nlocal.set 75\ni32.const 0\nlocal.set 76\nlocal.get 75\nlocal.get 76\ni32.gt_s\nlocal.set 77\ni32.const 1\nlocal.set 78\nlocal.get 77\nlocal.get 78\ni32.and\nlocal.set 79\nblock  ;; label = @4\nlocal.get 79\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 4\ni32.load offset=48\nlocal.set 80\ni32.const 1\nlocal.set 81\nlocal.get 80\nlocal.get 81\ni32.add\nlocal.set 82\nlocal.get 4\nlocal.get 82\ni32.store offset=48\nend\nend\nlocal.get 4\ni32.load offset=36\nlocal.set 83\ni32.const 1\nlocal.set 84\nlocal.get 83\nlocal.get 84\ni32.add\nlocal.set 85\nlocal.get 4\nlocal.get 85\ni32.store offset=36\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=44\nlocal.set 86\nblock  ;; label = @1\nlocal.get 86\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 0\nlocal.set 87\nlocal.get 87\ni32.load offset=65712\nlocal.set 88\nlocal.get 4\ni32.load offset=44\nlocal.set 89\nlocal.get 4\nlocal.get 89\ni32.store offset=32\ni32.const 65590\nlocal.set 90\ni32.const 32\nlocal.set 91\nlocal.get 4\nlocal.get 91\ni32.add\nlocal.set 92\nlocal.get 88\nlocal.get 90\nlocal.get 92\ncall 6\ndrop\nend\nlocal.get 4\ni32.load offset=48\nlocal.set 93\nblock  ;; label = @1\nlocal.get 93\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 0\nlocal.set 94\nlocal.get 94\ni32.load offset=65712\nlocal.set 95\nlocal.get 4\ni32.load offset=48\nlocal.set 96\nlocal.get 4\nlocal.get 96\ni32.store offset=16\ni32.const 65668\nlocal.set 97\ni32.const 16\nlocal.set 98\nlocal.get 4\nlocal.get 98\ni32.add\nlocal.set 99\nlocal.get 95\nlocal.get 97\nlocal.get 99\ncall 6\ndrop\nend\nlocal.get 4\ni32.load offset=40\nlocal.set 100\nblock  ;; label = @1\nlocal.get 100\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 0\nlocal.set 101\nlocal.get 101\ni32.load offset=65712\nlocal.set 102\nlocal.get 4\ni32.load offset=40\nlocal.set 103\nlocal.get 4\nlocal.get 103\ni32.store\ni32.const 65630\nlocal.set 104\nlocal.get 102\nlocal.get 104\nlocal.get 4\ncall 6\ndrop\nend\nlocal.get 4\ni32.load offset=44\nlocal.set 105\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 105\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=48\nlocal.set 106\nlocal.get 106\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=40\nlocal.set 107\nlocal.get 107\ni32.eqz\nbr_if 1 (;@2;)\nend\ni32.const 1\nlocal.set 108\nlocal.get 4\nlocal.get 108\ni32.store offset=60\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 109\nlocal.get 4\nlocal.get 109\ni32.store offset=60\nend\nlocal.get 4\ni32.load offset=60\nlocal.set 110\ni32.const 64\nlocal.set 111\nlocal.get 4\nlocal.get 111\ni32.add\nlocal.set 112\nlocal.get 112\nglobal.set 0\nlocal.get 110\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_64",
        "query_text": "The function takes two 16-bit unsigned integers as input and returns an unsigned integer as output. It first verifies through an assertion that the two input values are not equal. It then isolates the higher 8 bits of each input value by applying a bitmask. The function checks if these isolated higher 8 bits are equal and non-zero; if both conditions are met, it returns 1, otherwise it returns 0.",
        "code_id": "c_group_1_id_64",
        "code_text": "(func (;5;) (type 5) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store16 offset=10\nlocal.get 4\nlocal.get 1\ni32.store16 offset=8\nlocal.get 4\ni32.load16_u offset=10\nlocal.set 5\ni32.const 65535\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 4\ni32.load16_u offset=8\nlocal.set 8\ni32.const 65535\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 7\nlocal.get 10\ni32.ne\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 13\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 65650\nlocal.set 14\ni32.const 65565\nlocal.set 15\ni32.const 19\nlocal.set 16\ni32.const 65667\nlocal.set 17\nlocal.get 14\nlocal.get 15\nlocal.get 16\nlocal.get 17\ncall 7\nunreachable\nend\nlocal.get 4\ni32.load16_u offset=10\nlocal.set 18\ni32.const 65535\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\ni32.const 65280\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 4\nlocal.get 22\ni32.store offset=4\nlocal.get 4\ni32.load16_u offset=8\nlocal.set 23\ni32.const 65535\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\ni32.const 65280\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.and\nlocal.set 27\nlocal.get 4\nlocal.get 27\ni32.store\nlocal.get 4\ni32.load offset=4\nlocal.set 28\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 28\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=4\nlocal.set 29\nlocal.get 4\ni32.load\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.ne\nlocal.set 31\ni32.const 1\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.and\nlocal.set 33\nlocal.get 33\ni32.eqz\nbr_if 1 (;@2;)\nend\ni32.const 0\nlocal.set 34\nlocal.get 4\nlocal.get 34\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const 1\nlocal.set 35\nlocal.get 4\nlocal.get 35\ni32.store offset=12\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 36\ni32.const 16\nlocal.set 37\nlocal.get 4\nlocal.get 37\ni32.add\nlocal.set 38\nlocal.get 38\nglobal.set 0\nlocal.get 36\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_65",
        "query_text": "The function takes no input arguments and returns a double-precision floating-point value. It uses a standard library function to generate a random integer, then scales and converts this value to produce a number in the inclusive range from 1 to 100. The input is absent, and the output is of type double.",
        "code_id": "c_group_1_id_65",
        "code_text": "(func (;1;) (type 2) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ncall 3\nlocal.set 3\ni32.const 100\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.rem_s\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nf64.convert_i32_s\nlocal.set 10\nlocal.get 2\nlocal.get 10\nf64.store offset=8\nlocal.get 2\nf64.load offset=8\nlocal.set 11\ni32.const 16\nlocal.set 8\nlocal.get 2\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nglobal.set 0\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_66",
        "query_text": "This function receives two arrays of doubles representing approximation and detail coefficients, two filter arrays (one low-pass and one high-pass), and several integer parameters defining the lengths of the coefficient and filter arrays as well as input and output stride values. It reconstructs the original signal by iterating over a calculated range and computing paired output values at each step. For each iteration, the function applies the filter coefficients to a subset of the approximation and detail arrays, multiplying the values accordingly and summing them into two output positions while accounting for the provided strides. The function also handles boundary conditions by wrapping around the coefficient arrays when necessary. The resulting reconstructed signal is written directly into the output array without returning any value.",
        "code_id": "c_group_1_id_66",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32 i32 i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 9\ni32.const 80\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.sub\nlocal.set 11\nlocal.get 11\nlocal.get 0\ni32.store offset=76\nlocal.get 11\nlocal.get 1\ni32.store offset=72\nlocal.get 11\nlocal.get 2\ni32.store offset=68\nlocal.get 11\nlocal.get 3\ni32.store offset=64\nlocal.get 11\nlocal.get 4\ni32.store offset=60\nlocal.get 11\nlocal.get 5\ni32.store offset=56\nlocal.get 11\nlocal.get 6\ni32.store offset=52\nlocal.get 11\nlocal.get 7\ni32.store offset=48\nlocal.get 11\nlocal.get 8\ni32.store offset=44\nlocal.get 11\ni32.load offset=56\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.store offset=40\nlocal.get 11\ni32.load offset=40\nlocal.set 13\ni32.const 2\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.div_s\nlocal.set 15\nlocal.get 11\nlocal.get 15\ni32.store offset=16\ni32.const -2\nlocal.set 16\nlocal.get 11\nlocal.get 16\ni32.store offset=28\ni32.const -1\nlocal.set 17\nlocal.get 11\nlocal.get 17\ni32.store offset=24\ni32.const 0\nlocal.set 18\nlocal.get 11\nlocal.get 18\ni32.store offset=36\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 11\ni32.load offset=36\nlocal.set 19\nlocal.get 11\ni32.load offset=72\nlocal.set 20\nlocal.get 11\ni32.load offset=16\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.add\nlocal.set 22\ni32.const 1\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.sub\nlocal.set 24\nlocal.get 19\nlocal.get 24\ni32.lt_s\nlocal.set 25\ni32.const 1\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.and\nlocal.set 27\nlocal.get 27\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 11\ni32.load offset=28\nlocal.set 28\ni32.const 2\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.add\nlocal.set 30\nlocal.get 11\nlocal.get 30\ni32.store offset=28\nlocal.get 11\ni32.load offset=24\nlocal.set 31\ni32.const 2\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.add\nlocal.set 33\nlocal.get 11\nlocal.get 33\ni32.store offset=24\nlocal.get 11\ni32.load offset=28\nlocal.set 34\nlocal.get 11\ni32.load offset=44\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.mul\nlocal.set 36\nlocal.get 11\nlocal.get 36\ni32.store offset=8\nlocal.get 11\ni32.load offset=24\nlocal.set 37\nlocal.get 11\ni32.load offset=44\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.mul\nlocal.set 39\nlocal.get 11\nlocal.get 39\ni32.store offset=4\nlocal.get 11\ni32.load offset=52\nlocal.set 40\nlocal.get 11\ni32.load offset=8\nlocal.set 41\ni32.const 3\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.shl\nlocal.set 43\nlocal.get 40\nlocal.get 43\ni32.add\nlocal.set 44\ni32.const 0\nlocal.set 45\nlocal.get 45\nf64.convert_i32_s\nlocal.set 296\nlocal.get 44\nlocal.get 296\nf64.store\nlocal.get 11\ni32.load offset=52\nlocal.set 46\nlocal.get 11\ni32.load offset=4\nlocal.set 47\ni32.const 3\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.shl\nlocal.set 49\nlocal.get 46\nlocal.get 49\ni32.add\nlocal.set 50\ni32.const 0\nlocal.set 51\nlocal.get 51\nf64.convert_i32_s\nlocal.set 297\nlocal.get 50\nlocal.get 297\nf64.store\ni32.const 0\nlocal.set 52\nlocal.get 11\nlocal.get 52\ni32.store offset=32\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 11\ni32.load offset=32\nlocal.set 53\nlocal.get 11\ni32.load offset=16\nlocal.set 54\nlocal.get 53\nlocal.get 54\ni32.lt_s\nlocal.set 55\ni32.const 1\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.and\nlocal.set 57\nlocal.get 57\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 11\ni32.load offset=32\nlocal.set 58\ni32.const 1\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.shl\nlocal.set 60\nlocal.get 11\nlocal.get 60\ni32.store offset=20\nlocal.get 11\ni32.load offset=36\nlocal.set 61\nlocal.get 11\ni32.load offset=32\nlocal.set 62\nlocal.get 61\nlocal.get 62\ni32.sub\nlocal.set 63\ni32.const 0\nlocal.set 64\nlocal.get 63\nlocal.get 64\ni32.ge_s\nlocal.set 65\ni32.const 1\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.and\nlocal.set 67\nblock  ;; label = @5\nblock  ;; label = @6\nlocal.get 67\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 11\ni32.load offset=36\nlocal.set 68\nlocal.get 11\ni32.load offset=32\nlocal.set 69\nlocal.get 68\nlocal.get 69\ni32.sub\nlocal.set 70\nlocal.get 11\ni32.load offset=72\nlocal.set 71\nlocal.get 70\nlocal.get 71\ni32.lt_s\nlocal.set 72\ni32.const 1\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.and\nlocal.set 74\nlocal.get 74\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 11\ni32.load offset=36\nlocal.set 75\nlocal.get 11\ni32.load offset=32\nlocal.set 76\nlocal.get 75\nlocal.get 76\ni32.sub\nlocal.set 77\nlocal.get 11\ni32.load offset=48\nlocal.set 78\nlocal.get 77\nlocal.get 78\ni32.mul\nlocal.set 79\nlocal.get 11\nlocal.get 79\ni32.store offset=12\nlocal.get 11\ni32.load offset=64\nlocal.set 80\nlocal.get 11\ni32.load offset=20\nlocal.set 81\ni32.const 3\nlocal.set 82\nlocal.get 81\nlocal.get 82\ni32.shl\nlocal.set 83\nlocal.get 80\nlocal.get 83\ni32.add\nlocal.set 84\nlocal.get 84\nf64.load\nlocal.set 298\nlocal.get 11\ni32.load offset=76\nlocal.set 85\nlocal.get 11\ni32.load offset=12\nlocal.set 86\ni32.const 3\nlocal.set 87\nlocal.get 86\nlocal.get 87\ni32.shl\nlocal.set 88\nlocal.get 85\nlocal.get 88\ni32.add\nlocal.set 89\nlocal.get 89\nf64.load\nlocal.set 299\nlocal.get 11\ni32.load offset=60\nlocal.set 90\nlocal.get 11\ni32.load offset=20\nlocal.set 91\ni32.const 3\nlocal.set 92\nlocal.get 91\nlocal.get 92\ni32.shl\nlocal.set 93\nlocal.get 90\nlocal.get 93\ni32.add\nlocal.set 94\nlocal.get 94\nf64.load\nlocal.set 300\nlocal.get 11\ni32.load offset=68\nlocal.set 95\nlocal.get 11\ni32.load offset=12\nlocal.set 96\ni32.const 3\nlocal.set 97\nlocal.get 96\nlocal.get 97\ni32.shl\nlocal.set 98\nlocal.get 95\nlocal.get 98\ni32.add\nlocal.set 99\nlocal.get 99\nf64.load\nlocal.set 301\nlocal.get 300\nlocal.get 301\nf64.mul\nlocal.set 302\nlocal.get 298\nlocal.get 299\nf64.mul\nlocal.set 303\nlocal.get 303\nlocal.get 302\nf64.add\nlocal.set 304\nlocal.get 11\ni32.load offset=52\nlocal.set 100\nlocal.get 11\ni32.load offset=8\nlocal.set 101\ni32.const 3\nlocal.set 102\nlocal.get 101\nlocal.get 102\ni32.shl\nlocal.set 103\nlocal.get 100\nlocal.get 103\ni32.add\nlocal.set 104\nlocal.get 104\nf64.load\nlocal.set 305\nlocal.get 305\nlocal.get 304\nf64.add\nlocal.set 306\nlocal.get 104\nlocal.get 306\nf64.store\nlocal.get 11\ni32.load offset=64\nlocal.set 105\nlocal.get 11\ni32.load offset=20\nlocal.set 106\ni32.const 1\nlocal.set 107\nlocal.get 106\nlocal.get 107\ni32.add\nlocal.set 108\ni32.const 3\nlocal.set 109\nlocal.get 108\nlocal.get 109\ni32.shl\nlocal.set 110\nlocal.get 105\nlocal.get 110\ni32.add\nlocal.set 111\nlocal.get 111\nf64.load\nlocal.set 307\nlocal.get 11\ni32.load offset=76\nlocal.set 112\nlocal.get 11\ni32.load offset=12\nlocal.set 113\ni32.const 3\nlocal.set 114\nlocal.get 113\nlocal.get 114\ni32.shl\nlocal.set 115\nlocal.get 112\nlocal.get 115\ni32.add\nlocal.set 116\nlocal.get 116\nf64.load\nlocal.set 308\nlocal.get 11\ni32.load offset=60\nlocal.set 117\nlocal.get 11\ni32.load offset=20\nlocal.set 118\ni32.const 1\nlocal.set 119\nlocal.get 118\nlocal.get 119\ni32.add\nlocal.set 120\ni32.const 3\nlocal.set 121\nlocal.get 120\nlocal.get 121\ni32.shl\nlocal.set 122\nlocal.get 117\nlocal.get 122\ni32.add\nlocal.set 123\nlocal.get 123\nf64.load\nlocal.set 309\nlocal.get 11\ni32.load offset=68\nlocal.set 124\nlocal.get 11\ni32.load offset=12\nlocal.set 125\ni32.const 3\nlocal.set 126\nlocal.get 125\nlocal.get 126\ni32.shl\nlocal.set 127\nlocal.get 124\nlocal.get 127\ni32.add\nlocal.set 128\nlocal.get 128\nf64.load\nlocal.set 310\nlocal.get 309\nlocal.get 310\nf64.mul\nlocal.set 311\nlocal.get 307\nlocal.get 308\nf64.mul\nlocal.set 312\nlocal.get 312\nlocal.get 311\nf64.add\nlocal.set 313\nlocal.get 11\ni32.load offset=52\nlocal.set 129\nlocal.get 11\ni32.load offset=4\nlocal.set 130\ni32.const 3\nlocal.set 131\nlocal.get 130\nlocal.get 131\ni32.shl\nlocal.set 132\nlocal.get 129\nlocal.get 132\ni32.add\nlocal.set 133\nlocal.get 133\nf64.load\nlocal.set 314\nlocal.get 314\nlocal.get 313\nf64.add\nlocal.set 315\nlocal.get 133\nlocal.get 315\nf64.store\nbr 1 (;@5;)\nend\nlocal.get 11\ni32.load offset=36\nlocal.set 134\nlocal.get 11\ni32.load offset=32\nlocal.set 135\nlocal.get 134\nlocal.get 135\ni32.sub\nlocal.set 136\nlocal.get 11\ni32.load offset=72\nlocal.set 137\nlocal.get 136\nlocal.get 137\ni32.ge_s\nlocal.set 138\ni32.const 1\nlocal.set 139\nlocal.get 138\nlocal.get 139\ni32.and\nlocal.set 140\nblock  ;; label = @6\nblock  ;; label = @7\nlocal.get 140\ni32.eqz\nbr_if 0 (;@7;)\nlocal.get 11\ni32.load offset=36\nlocal.set 141\nlocal.get 11\ni32.load offset=32\nlocal.set 142\nlocal.get 141\nlocal.get 142\ni32.sub\nlocal.set 143\nlocal.get 11\ni32.load offset=72\nlocal.set 144\nlocal.get 11\ni32.load offset=40\nlocal.set 145\nlocal.get 144\nlocal.get 145\ni32.add\nlocal.set 146\ni32.const 1\nlocal.set 147\nlocal.get 146\nlocal.get 147\ni32.sub\nlocal.set 148\nlocal.get 143\nlocal.get 148\ni32.lt_s\nlocal.set 149\ni32.const 1\nlocal.set 150\nlocal.get 149\nlocal.get 150\ni32.and\nlocal.set 151\nlocal.get 151\ni32.eqz\nbr_if 0 (;@7;)\nlocal.get 11\ni32.load offset=36\nlocal.set 152\nlocal.get 11\ni32.load offset=32\nlocal.set 153\nlocal.get 152\nlocal.get 153\ni32.sub\nlocal.set 154\nlocal.get 11\ni32.load offset=72\nlocal.set 155\nlocal.get 154\nlocal.get 155\ni32.sub\nlocal.set 156\nlocal.get 11\ni32.load offset=48\nlocal.set 157\nlocal.get 156\nlocal.get 157\ni32.mul\nlocal.set 158\nlocal.get 11\nlocal.get 158\ni32.store offset=12\nlocal.get 11\ni32.load offset=64\nlocal.set 159\nlocal.get 11\ni32.load offset=20\nlocal.set 160\ni32.const 3\nlocal.set 161\nlocal.get 160\nlocal.get 161\ni32.shl\nlocal.set 162\nlocal.get 159\nlocal.get 162\ni32.add\nlocal.set 163\nlocal.get 163\nf64.load\nlocal.set 316\nlocal.get 11\ni32.load offset=76\nlocal.set 164\nlocal.get 11\ni32.load offset=12\nlocal.set 165\ni32.const 3\nlocal.set 166\nlocal.get 165\nlocal.get 166\ni32.shl\nlocal.set 167\nlocal.get 164\nlocal.get 167\ni32.add\nlocal.set 168\nlocal.get 168\nf64.load\nlocal.set 317\nlocal.get 11\ni32.load offset=60\nlocal.set 169\nlocal.get 11\ni32.load offset=20\nlocal.set 170\ni32.const 3\nlocal.set 171\nlocal.get 170\nlocal.get 171\ni32.shl\nlocal.set 172\nlocal.get 169\nlocal.get 172\ni32.add\nlocal.set 173\nlocal.get 173\nf64.load\nlocal.set 318\nlocal.get 11\ni32.load offset=68\nlocal.set 174\nlocal.get 11\ni32.load offset=12\nlocal.set 175\ni32.const 3\nlocal.set 176\nlocal.get 175\nlocal.get 176\ni32.shl\nlocal.set 177\nlocal.get 174\nlocal.get 177\ni32.add\nlocal.set 178\nlocal.get 178\nf64.load\nlocal.set 319\nlocal.get 318\nlocal.get 319\nf64.mul\nlocal.set 320\nlocal.get 316\nlocal.get 317\nf64.mul\nlocal.set 321\nlocal.get 321\nlocal.get 320\nf64.add\nlocal.set 322\nlocal.get 11\ni32.load offset=52\nlocal.set 179\nlocal.get 11\ni32.load offset=8\nlocal.set 180\ni32.const 3\nlocal.set 181\nlocal.get 180\nlocal.get 181\ni32.shl\nlocal.set 182\nlocal.get 179\nlocal.get 182\ni32.add\nlocal.set 183\nlocal.get 183\nf64.load\nlocal.set 323\nlocal.get 323\nlocal.get 322\nf64.add\nlocal.set 324\nlocal.get 183\nlocal.get 324\nf64.store\nlocal.get 11\ni32.load offset=64\nlocal.set 184\nlocal.get 11\ni32.load offset=20\nlocal.set 185\ni32.const 1\nlocal.set 186\nlocal.get 185\nlocal.get 186\ni32.add\nlocal.set 187\ni32.const 3\nlocal.set 188\nlocal.get 187\nlocal.get 188\ni32.shl\nlocal.set 189\nlocal.get 184\nlocal.get 189\ni32.add\nlocal.set 190\nlocal.get 190\nf64.load\nlocal.set 325\nlocal.get 11\ni32.load offset=76\nlocal.set 191\nlocal.get 11\ni32.load offset=12\nlocal.set 192\ni32.const 3\nlocal.set 193\nlocal.get 192\nlocal.get 193\ni32.shl\nlocal.set 194\nlocal.get 191\nlocal.get 194\ni32.add\nlocal.set 195\nlocal.get 195\nf64.load\nlocal.set 326\nlocal.get 11\ni32.load offset=60\nlocal.set 196\nlocal.get 11\ni32.load offset=20\nlocal.set 197\ni32.const 1\nlocal.set 198\nlocal.get 197\nlocal.get 198\ni32.add\nlocal.set 199\ni32.const 3\nlocal.set 200\nlocal.get 199\nlocal.get 200\ni32.shl\nlocal.set 201\nlocal.get 196\nlocal.get 201\ni32.add\nlocal.set 202\nlocal.get 202\nf64.load\nlocal.set 327\nlocal.get 11\ni32.load offset=68\nlocal.set 203\nlocal.get 11\ni32.load offset=12\nlocal.set 204\ni32.const 3\nlocal.set 205\nlocal.get 204\nlocal.get 205\ni32.shl\nlocal.set 206\nlocal.get 203\nlocal.get 206\ni32.add\nlocal.set 207\nlocal.get 207\nf64.load\nlocal.set 328\nlocal.get 327\nlocal.get 328\nf64.mul\nlocal.set 329\nlocal.get 325\nlocal.get 326\nf64.mul\nlocal.set 330\nlocal.get 330\nlocal.get 329\nf64.add\nlocal.set 331\nlocal.get 11\ni32.load offset=52\nlocal.set 208\nlocal.get 11\ni32.load offset=4\nlocal.set 209\ni32.const 3\nlocal.set 210\nlocal.get 209\nlocal.get 210\ni32.shl\nlocal.set 211\nlocal.get 208\nlocal.get 211\ni32.add\nlocal.set 212\nlocal.get 212\nf64.load\nlocal.set 332\nlocal.get 332\nlocal.get 331\nf64.add\nlocal.set 333\nlocal.get 212\nlocal.get 333\nf64.store\nbr 1 (;@6;)\nend\nlocal.get 11\ni32.load offset=36\nlocal.set 213\nlocal.get 11\ni32.load offset=32\nlocal.set 214\nlocal.get 213\nlocal.get 214\ni32.sub\nlocal.set 215\ni32.const 0\nlocal.set 216\nlocal.get 215\nlocal.get 216\ni32.lt_s\nlocal.set 217\ni32.const 1\nlocal.set 218\nlocal.get 217\nlocal.get 218\ni32.and\nlocal.set 219\nblock  ;; label = @7\nlocal.get 219\ni32.eqz\nbr_if 0 (;@7;)\nlocal.get 11\ni32.load offset=36\nlocal.set 220\nlocal.get 11\ni32.load offset=32\nlocal.set 221\nlocal.get 220\nlocal.get 221\ni32.sub\nlocal.set 222\nlocal.get 11\ni32.load offset=16\nlocal.set 223\ni32.const 0\nlocal.set 224\nlocal.get 224\nlocal.get 223\ni32.sub\nlocal.set 225\nlocal.get 222\nlocal.get 225\ni32.gt_s\nlocal.set 226\ni32.const 1\nlocal.set 227\nlocal.get 226\nlocal.get 227\ni32.and\nlocal.set 228\nlocal.get 228\ni32.eqz\nbr_if 0 (;@7;)\nlocal.get 11\ni32.load offset=72\nlocal.set 229\nlocal.get 11\ni32.load offset=36\nlocal.set 230\nlocal.get 229\nlocal.get 230\ni32.add\nlocal.set 231\nlocal.get 11\ni32.load offset=32\nlocal.set 232\nlocal.get 231\nlocal.get 232\ni32.sub\nlocal.set 233\nlocal.get 11\ni32.load offset=48\nlocal.set 234\nlocal.get 233\nlocal.get 234\ni32.mul\nlocal.set 235\nlocal.get 11\nlocal.get 235\ni32.store offset=12\nlocal.get 11\ni32.load offset=64\nlocal.set 236\nlocal.get 11\ni32.load offset=20\nlocal.set 237\ni32.const 3\nlocal.set 238\nlocal.get 237\nlocal.get 238\ni32.shl\nlocal.set 239\nlocal.get 236\nlocal.get 239\ni32.add\nlocal.set 240\nlocal.get 240\nf64.load\nlocal.set 334\nlocal.get 11\ni32.load offset=76\nlocal.set 241\nlocal.get 11\ni32.load offset=12\nlocal.set 242\ni32.const 3\nlocal.set 243\nlocal.get 242\nlocal.get 243\ni32.shl\nlocal.set 244\nlocal.get 241\nlocal.get 244\ni32.add\nlocal.set 245\nlocal.get 245\nf64.load\nlocal.set 335\nlocal.get 11\ni32.load offset=60\nlocal.set 246\nlocal.get 11\ni32.load offset=20\nlocal.set 247\ni32.const 3\nlocal.set 248\nlocal.get 247\nlocal.get 248\ni32.shl\nlocal.set 249\nlocal.get 246\nlocal.get 249\ni32.add\nlocal.set 250\nlocal.get 250\nf64.load\nlocal.set 336\nlocal.get 11\ni32.load offset=68\nlocal.set 251\nlocal.get 11\ni32.load offset=12\nlocal.set 252\ni32.const 3\nlocal.set 253\nlocal.get 252\nlocal.get 253\ni32.shl\nlocal.set 254\nlocal.get 251\nlocal.get 254\ni32.add\nlocal.set 255\nlocal.get 255\nf64.load\nlocal.set 337\nlocal.get 336\nlocal.get 337\nf64.mul\nlocal.set 338\nlocal.get 334\nlocal.get 335\nf64.mul\nlocal.set 339\nlocal.get 339\nlocal.get 338\nf64.add\nlocal.set 340\nlocal.get 11\ni32.load offset=52\nlocal.set 256\nlocal.get 11\ni32.load offset=8\nlocal.set 257\ni32.const 3\nlocal.set 258\nlocal.get 257\nlocal.get 258\ni32.shl\nlocal.set 259\nlocal.get 256\nlocal.get 259\ni32.add\nlocal.set 260\nlocal.get 260\nf64.load\nlocal.set 341\nlocal.get 341\nlocal.get 340\nf64.add\nlocal.set 342\nlocal.get 260\nlocal.get 342\nf64.store\nlocal.get 11\ni32.load offset=64\nlocal.set 261\nlocal.get 11\ni32.load offset=20\nlocal.set 262\ni32.const 1\nlocal.set 263\nlocal.get 262\nlocal.get 263\ni32.add\nlocal.set 264\ni32.const 3\nlocal.set 265\nlocal.get 264\nlocal.get 265\ni32.shl\nlocal.set 266\nlocal.get 261\nlocal.get 266\ni32.add\nlocal.set 267\nlocal.get 267\nf64.load\nlocal.set 343\nlocal.get 11\ni32.load offset=76\nlocal.set 268\nlocal.get 11\ni32.load offset=12\nlocal.set 269\ni32.const 3\nlocal.set 270\nlocal.get 269\nlocal.get 270\ni32.shl\nlocal.set 271\nlocal.get 268\nlocal.get 271\ni32.add\nlocal.set 272\nlocal.get 272\nf64.load\nlocal.set 344\nlocal.get 11\ni32.load offset=60\nlocal.set 273\nlocal.get 11\ni32.load offset=20\nlocal.set 274\ni32.const 1\nlocal.set 275\nlocal.get 274\nlocal.get 275\ni32.add\nlocal.set 276\ni32.const 3\nlocal.set 277\nlocal.get 276\nlocal.get 277\ni32.shl\nlocal.set 278\nlocal.get 273\nlocal.get 278\ni32.add\nlocal.set 279\nlocal.get 279\nf64.load\nlocal.set 345\nlocal.get 11\ni32.load offset=68\nlocal.set 280\nlocal.get 11\ni32.load offset=12\nlocal.set 281\ni32.const 3\nlocal.set 282\nlocal.get 281\nlocal.get 282\ni32.shl\nlocal.set 283\nlocal.get 280\nlocal.get 283\ni32.add\nlocal.set 284\nlocal.get 284\nf64.load\nlocal.set 346\nlocal.get 345\nlocal.get 346\nf64.mul\nlocal.set 347\nlocal.get 343\nlocal.get 344\nf64.mul\nlocal.set 348\nlocal.get 348\nlocal.get 347\nf64.add\nlocal.set 349\nlocal.get 11\ni32.load offset=52\nlocal.set 285\nlocal.get 11\ni32.load offset=4\nlocal.set 286\ni32.const 3\nlocal.set 287\nlocal.get 286\nlocal.get 287\ni32.shl\nlocal.set 288\nlocal.get 285\nlocal.get 288\ni32.add\nlocal.set 289\nlocal.get 289\nf64.load\nlocal.set 350\nlocal.get 350\nlocal.get 349\nf64.add\nlocal.set 351\nlocal.get 289\nlocal.get 351\nf64.store\nend\nend\nend\nlocal.get 11\ni32.load offset=32\nlocal.set 290\ni32.const 1\nlocal.set 291\nlocal.get 290\nlocal.get 291\ni32.add\nlocal.set 292\nlocal.get 11\nlocal.get 292\ni32.store offset=32\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 11\ni32.load offset=36\nlocal.set 293\ni32.const 1\nlocal.set 294\nlocal.get 293\nlocal.get 294\ni32.add\nlocal.set 295\nlocal.get 11\nlocal.get 295\ni32.store offset=36\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_67",
        "query_text": "The function takes three inputs: a pointer to a double array, an integer indicating the length of that array, and an additional integer that controls processing behavior. If the integer is negative, the function returns an error code (-1). When the integer is zero, the function directly copies the input array into an output double array and returns the original length. For a positive integer, the function performs an upsampling process on the input array by inserting zeros between its elements\u2014the number of inserted zeros is determined by the integer parameter. The function then returns the length of the newly constructed, upsampled output array. The inputs are a double pointer and two integers, and the output consists of a double array along with an integer representing its length (or an error code).",
        "code_id": "c_group_1_id_67",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64)\nglobal.get 0\nlocal.set 4\ni32.const 48\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nlocal.get 0\ni32.store offset=40\nlocal.get 6\nlocal.get 1\ni32.store offset=36\nlocal.get 6\nlocal.get 2\ni32.store offset=32\nlocal.get 6\nlocal.get 3\ni32.store offset=28\nlocal.get 6\ni32.load offset=32\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.lt_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 11\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 12\nlocal.get 6\nlocal.get 12\ni32.store offset=44\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=32\nlocal.set 13\nblock  ;; label = @2\nlocal.get 13\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 14\nlocal.get 6\nlocal.get 14\ni32.store offset=20\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 6\ni32.load offset=20\nlocal.set 15\nlocal.get 6\ni32.load offset=36\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.lt_s\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 19\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 6\ni32.load offset=40\nlocal.set 20\nlocal.get 6\ni32.load offset=20\nlocal.set 21\ni32.const 3\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.shl\nlocal.set 23\nlocal.get 20\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nf64.load\nlocal.set 78\nlocal.get 6\ni32.load offset=28\nlocal.set 25\nlocal.get 6\ni32.load offset=20\nlocal.set 26\ni32.const 3\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.shl\nlocal.set 28\nlocal.get 25\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 29\nlocal.get 78\nf64.store\nlocal.get 6\ni32.load offset=20\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 6\nlocal.get 32\ni32.store offset=20\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=36\nlocal.set 33\nlocal.get 6\nlocal.get 33\ni32.store offset=44\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=32\nlocal.set 34\nlocal.get 6\ni32.load offset=36\nlocal.set 35\ni32.const 1\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.sub\nlocal.set 37\nlocal.get 34\nlocal.get 37\ni32.mul\nlocal.set 38\ni32.const 1\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.add\nlocal.set 40\nlocal.get 6\nlocal.get 40\ni32.store offset=24\ni32.const 1\nlocal.set 41\nlocal.get 6\nlocal.get 41\ni32.store offset=16\ni32.const 0\nlocal.set 42\nlocal.get 6\nlocal.get 42\ni32.store offset=12\ni32.const 0\nlocal.set 43\nlocal.get 6\nlocal.get 43\ni32.store offset=20\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 6\ni32.load offset=20\nlocal.set 44\nlocal.get 6\ni32.load offset=24\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.lt_s\nlocal.set 46\ni32.const 1\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.and\nlocal.set 48\nlocal.get 48\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 6\ni32.load offset=16\nlocal.set 49\ni32.const -1\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.add\nlocal.set 51\nlocal.get 6\nlocal.get 51\ni32.store offset=16\nlocal.get 6\ni32.load offset=28\nlocal.set 52\nlocal.get 6\ni32.load offset=20\nlocal.set 53\ni32.const 3\nlocal.set 54\nlocal.get 53\nlocal.get 54\ni32.shl\nlocal.set 55\nlocal.get 52\nlocal.get 55\ni32.add\nlocal.set 56\ni32.const 0\nlocal.set 57\nlocal.get 57\nf64.convert_i32_s\nlocal.set 79\nlocal.get 56\nlocal.get 79\nf64.store\nlocal.get 6\ni32.load offset=16\nlocal.set 58\nblock  ;; label = @4\nlocal.get 58\nbr_if 0 (;@4;)\nlocal.get 6\ni32.load offset=40\nlocal.set 59\nlocal.get 6\ni32.load offset=12\nlocal.set 60\ni32.const 3\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.shl\nlocal.set 62\nlocal.get 59\nlocal.get 62\ni32.add\nlocal.set 63\nlocal.get 63\nf64.load\nlocal.set 80\nlocal.get 6\ni32.load offset=28\nlocal.set 64\nlocal.get 6\ni32.load offset=20\nlocal.set 65\ni32.const 3\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.shl\nlocal.set 67\nlocal.get 64\nlocal.get 67\ni32.add\nlocal.set 68\nlocal.get 68\nlocal.get 80\nf64.store\nlocal.get 6\ni32.load offset=12\nlocal.set 69\ni32.const 1\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.add\nlocal.set 71\nlocal.get 6\nlocal.get 71\ni32.store offset=12\nlocal.get 6\ni32.load offset=32\nlocal.set 72\nlocal.get 6\nlocal.get 72\ni32.store offset=16\nend\nlocal.get 6\ni32.load offset=20\nlocal.set 73\ni32.const 1\nlocal.set 74\nlocal.get 73\nlocal.get 74\ni32.add\nlocal.set 75\nlocal.get 6\nlocal.get 75\ni32.store offset=20\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=24\nlocal.set 76\nlocal.get 6\nlocal.get 76\ni32.store offset=44\nend\nlocal.get 6\ni32.load offset=44\nlocal.set 77\nlocal.get 77\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_68",
        "query_text": "The function takes a string as input and iterates through each character to determine if it is not a UTF-8 continuation byte. For each character that is not a continuation byte, the function increments a counter. Once all characters are processed, it returns the total count, which represents the number of glyphs (logical characters) in the string. The input is of type std::string, and the output is of type std::string::size_type.",
        "code_id": "c_group_1_id_68",
        "code_text": "(func (;1;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 32\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=28\ni32.const 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=24\nlocal.get 3\ni32.load offset=28\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.store offset=20\nlocal.get 3\ni32.load offset=20\nlocal.set 6\nlocal.get 6\ncall 2\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.store offset=16\nlocal.get 3\ni32.load offset=20\nlocal.set 8\nlocal.get 8\ncall 3\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=12\nblock  ;; label = @1\nloop  ;; label = @2\ni32.const 16\nlocal.set 10\nlocal.get 3\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 11\nlocal.set 12\ni32.const 12\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\nlocal.set 15\nlocal.get 12\nlocal.get 15\ncall 4\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 18\ni32.eqz\nbr_if 1 (;@1;)\ni32.const 16\nlocal.set 19\nlocal.get 3\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\nlocal.set 21\nlocal.get 21\ncall 5\nlocal.set 22\nlocal.get 22\ni32.load8_u\nlocal.set 23\nlocal.get 3\nlocal.get 23\ni32.store8 offset=11\nlocal.get 3\ni32.load8_u offset=11\nlocal.set 24\ni32.const 24\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.shl\nlocal.set 26\nlocal.get 26\nlocal.get 25\ni32.shr_s\nlocal.set 27\ni32.const 192\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.and\nlocal.set 29\ni32.const 128\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.ne\nlocal.set 31\ni32.const 1\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.and\nlocal.set 33\nblock  ;; label = @3\nlocal.get 33\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load offset=24\nlocal.set 34\ni32.const 1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 3\nlocal.get 36\ni32.store offset=24\nend\ni32.const 16\nlocal.set 37\nlocal.get 3\nlocal.get 37\ni32.add\nlocal.set 38\nlocal.get 38\nlocal.set 39\nlocal.get 39\ncall 6\ndrop\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 3\ni32.load offset=24\nlocal.set 40\ni32.const 32\nlocal.set 41\nlocal.get 3\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 42\nglobal.set 0\nlocal.get 40\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_69",
        "query_text": "The function takes two unsigned integers as input and returns an unsigned integer. It extracts the lower 4 bits from the first input, shifts them left by 6 positions, and combines them with the lower 6 bits of the second input using a bitwise OR operation. This process produces a single unsigned integer that merges the relevant bits from both inputs.",
        "code_id": "c_group_1_id_69",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\ni32.const 15\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\ni32.const 6\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shl\nlocal.set 9\nlocal.get 4\ni32.load offset=8\nlocal.set 10\ni32.const 63\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 9\nlocal.get 12\ni32.or\nlocal.set 13\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_70",
        "query_text": "The function accepts an integer as its input and determines whether the provided value is greater than or equal to zero. It returns a boolean value: if the input is non-negative, the function produces true; otherwise, it produces false. This behavior can be evaluated at compile time due to its constexpr designation. The input is of type int, and the output is of type bool.",
        "code_id": "c_group_1_id_70",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.ge_s\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nlocal.get 8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_71",
        "query_text": "The function takes no input arguments and performs a compile-time check to determine whether two specific preprocessor macros are defined. If both macros are present, the function returns an integer value indicating success; otherwise, it returns an integer value indicating that the test was skipped.",
        "code_id": "c_group_1_id_71",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_72",
        "query_text": "The function takes no explicit input. It is a test routine that validates the proper initialization, configuration, and cleanup of a cryptographic algorithm implementation. It first verifies that the algorithm\u2019s context initialization properly handles invalid parameters by expecting specific error codes, and then confirms a successful initialization under valid conditions. If encryption modes (such as ECB, CBC, CTR, or CCM) are enabled, the function proceeds to test key configuration by invoking the key-setting routine with both valid data and a variety of invalid scenarios\u2014including null pointers, incorrect key sizes, and other improper parameters\u2014to ensure robust error handling. For modes that require an initialization vector, the function similarly tests setting the IV, checking for proper error responses on invalid inputs and success when given valid data. Finally, the routine cleans up any allocated resources and returns an integer value that indicates the overall success or failure of these tests.",
        "code_id": "c_group_1_id_72",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_73",
        "query_text": "The function is designed to perform a series of tests on an encryption algorithm operating in Electronic Codebook mode. It begins by initializing an encryption context and setting a key, then proceeds to evaluate correct responses when invalid arguments (such as null pointers) are supplied. The function also performs encryption and decryption on provided data buffers, including in-place operations, and compares resulting outputs to verify consistency across multiple calls. It covers various edge cases, including operations with differing data lengths, to ensure that both encryption and decryption behave as expected. Finally, the function returns a value indicating whether the tests passed, failed, or were skipped.",
        "code_id": "c_group_1_id_73",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_74",
        "query_text": "The function performs a series of tests to validate a block cipher\u2019s encryption and decryption routines using Galois/Counter Mode (GCM). It starts by initializing an encryption context and setting up necessary buffers for keys, nonces, plaintext/ciphertext, additional authenticated data (AAD), and authentication tags. The test sequence first checks for proper error handling by calling the encryption and decryption routines with various invalid arguments (such as null pointers, incorrect key sizes, unsuitable nonce lengths, and improperly sized authentication tags). It then proceeds to verify that valid inputs produce consistent outcomes by encrypting a data block and subsequently decrypting it to recover the original data. The function also examines edge cases including empty inputs, single and multiple data blocks, and large buffers. Throughout the tests, comparisons are made between expected and actual outputs to ensure that both encryption and decryption behave correctly under different scenarios. Finally, a status result is returned to indicate whether the tests passed, failed, or were skipped.",
        "code_id": "c_group_1_id_74",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_75",
        "query_text": "The function takes no input parameters and returns an integer representing the outcome of a test. It verifies the correctness of an elliptic curve digital signature verification process using SM2. The function performs the following steps:\n\n1. It initializes a key structure for an elliptic curve and two multi-precision integers that represent the signature components.\n2. It sets up fixed test data, including data for a public key, a message hash, and two signature components (one valid and one modified to simulate a failure scenario).\n3. It runs multiple verification tests:\n   - It first attempts to verify the signature using valid inputs.\n   - It then tests error handling by calling the verification routine with various combinations of invalid or missing parameters.\n   - Finally, it verifies that a signature check fails when a signature component is altered.\n4. It cleans up all allocated resources, freeing the multi-precision integers and the key structure.\n\nThe input is nonexistent, and the output is an integer indicating success, failure, or a skipped test result.",
        "code_id": "c_group_1_id_75",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_76",
        "query_text": "The function is a test routine that validates the process of signing a hash using an elliptic curve cryptography algorithm based on the SM2 specification. It begins by initializing and configuring essential cryptographic components such as a random number generator, an elliptic curve key structure, and multi-precision integers to hold signature elements. Initially, it generates a random hash and attempts to invoke the signing operation with various deliberately faulty or null parameters to ensure that the signing routine properly returns error codes when provided with invalid inputs. The test also involves setting up the elliptic curve parameters and, in certain cases, intentionally supplying incorrectly sized mathematical structures to trigger error conditions. After these edge-case verifications, the function performs a valid signing operation and subsequently verifies the correctness of the resulting signature against the original hash using a separate verification routine. Throughout the process, it manages resource allocation and cleanup appropriately. The function ultimately returns an integer test result indicating success, failure, or if the test was skipped.",
        "code_id": "c_group_1_id_76",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_77",
        "query_text": "The function performs a self-contained test of an encryption algorithm operating in ECB mode using a cryptography library. It follows these steps:\n\n1. Initialization: The function creates and configures a context for both encryption and decryption. A key is set up (initialized to zero) and a fixed-size block of plaintext is defined.\n2. Encryption: It encrypts the plaintext using the specified algorithm and key, storing the resulting ciphertext in a dedicated buffer.\n3. Decryption: The function then decrypts the ciphertext using the same key, placing the resultant plaintext in another buffer.\n4. Validation: It compares the decrypted data against the original plaintext to ensure that the encryption and decryption processes function correctly.\n5. Cleanup: The function releases the allocated resources associated with the encryption/decryption context.\n\nThe output is an integer that indicates the test result\u2014success, failure, or skipped (in case necessary features are not enabled). No external inputs are required as the function operates on fixed-size byte arrays for the key, plaintext, ciphertext, and decrypted text.",
        "code_id": "c_group_1_id_77",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_78",
        "query_text": "The function tests the encryption and decryption processes for a symmetric algorithm when provided with an empty plaintext. It sets up separate encryption and decryption contexts using predefined byte arrays for a key and an initialization vector. The process unfolds as follows:\n\n1. It initializes the encryption context, setting the IV length and then attempts to encrypt an empty plaintext. During encryption, it produces a ciphertext (which is expected to be empty) and an authentication tag.\n2. The decryption context is then initialized using the same key and IV. It attempts to decrypt the empty ciphertext while verifying the authentication tag, expecting to recover an empty plaintext.\n3. Finally, the function cleans up by freeing the resources used by both contexts and returns an integer status that indicates whether the test passed, failed, or was skipped.",
        "code_id": "c_group_1_id_78",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_79",
        "query_text": "The function takes no input arguments. It immediately returns a boolean value of true without performing any calculation or condition checks. This constant behavior ensures that the output is always true, regardless of any external factors. The return type of the function is bool.",
        "code_id": "c_group_1_id_79",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32)\ni32.const 1\nlocal.set 0\ni32.const 1\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.and\nlocal.set 2\nlocal.get 2\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_80",
        "query_text": "The function accepts a pointer to a constant void type as input and returns a boolean value. Internally, it casts the input pointer to an integer pointer and retrieves the integer value it points to. The function then checks if this integer value is zero; if so, it returns true, otherwise false.",
        "code_id": "c_group_1_id_80",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ni32.load\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.eq\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_81",
        "query_text": "This function takes an unsigned integer, a string, and a pair of double values as inputs. It computes the average time per operation by dividing the first double value by the unsigned integer, and calculates the relative error percentage using the difference between the two doubles. These computed values, along with the string (displayed left-aligned), are formatted and printed in a human-readable summary. The function does not return any value (void).",
        "code_id": "c_group_1_id_81",
        "code_text": "(func (;2;) (type 5) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 1\ncall 3\nlocal.set 6\nlocal.get 2\nf64.load\nlocal.set 13\nlocal.get 5\ni32.load offset=28\nlocal.set 7\nlocal.get 7\nf64.convert_i32_u\nlocal.set 14\nlocal.get 13\nlocal.get 14\nf64.div\nlocal.set 15\nlocal.get 2\nf64.load offset=8\nlocal.set 16\nlocal.get 2\nf64.load\nlocal.set 17\nlocal.get 16\nlocal.get 17\nf64.sub\nlocal.set 18\nf64.const 0x1.9p+6 (;=100;)\nlocal.set 19\nlocal.get 18\nlocal.get 19\nf64.mul\nlocal.set 20\nlocal.get 2\nf64.load offset=8\nlocal.set 21\nlocal.get 20\nlocal.get 21\nf64.div\nlocal.set 22\ni32.const 16\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nlocal.get 22\nf64.store\nlocal.get 5\nlocal.get 15\nf64.store offset=8\nlocal.get 5\nlocal.get 6\ni32.store\ni32.const 65590\nlocal.set 10\nlocal.get 10\nlocal.get 5\ncall 15\ndrop\ni32.const 32\nlocal.set 11\nlocal.get 5\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_82",
        "query_text": "The function takes five inputs: a double-precision floating-point number, an integer representing the desired precision, a boolean flag to determine if scientific notation is permitted, a character buffer to hold the formatted string, and the size of that buffer. It formats the floating-point number into the buffer using a fixed-point or scientific format based on the boolean flag. If the formatted string includes scientific notation (for instance, \"1.23e-4\"), the function terminates further processing. Otherwise, it checks for the presence of a decimal point and, if missing, appends \".0\" to the string. If a decimal point is present, the function removes any unnecessary trailing zeros following it, thereby simplifying the representation. The final formatted string is stored directly in the provided buffer, and no value is returned.",
        "code_id": "c_group_1_id_82",
        "code_text": "(func (;1;) (type 11) (param f64 i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64)\nglobal.get 0\nlocal.set 5\ni32.const 64\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.sub\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 7\nlocal.get 0\nf64.store offset=56\nlocal.get 7\nlocal.get 1\ni32.store offset=52\nlocal.get 7\nlocal.get 2\ni32.store offset=48\nlocal.get 7\nlocal.get 3\ni32.store offset=44\nlocal.get 7\nlocal.get 4\ni32.store offset=40\nlocal.get 7\ni32.load offset=48\nlocal.set 8\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 8\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 65569\nlocal.set 9\nlocal.get 9\nlocal.set 10\nbr 1 (;@1;)\nend\ni32.const 65578\nlocal.set 11\nlocal.get 11\nlocal.set 10\nend\nlocal.get 10\nlocal.set 12\nlocal.get 7\nlocal.get 12\ni32.store offset=36\nlocal.get 7\ni32.load offset=44\nlocal.set 13\nlocal.get 7\ni32.load offset=40\nlocal.set 14\ni32.const 3\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.sub\nlocal.set 16\nlocal.get 7\ni32.load offset=36\nlocal.set 17\nlocal.get 7\ni32.load offset=52\nlocal.set 18\nlocal.get 7\nf64.load offset=56\nlocal.set 66\nlocal.get 7\nlocal.get 66\nf64.store offset=8\nlocal.get 7\nlocal.get 18\ni32.store\nlocal.get 13\nlocal.get 16\nlocal.get 17\nlocal.get 7\ncall 4\ndrop\nlocal.get 7\ni32.load offset=44\nlocal.set 19\ni32.const 101\nlocal.set 20\nlocal.get 19\nlocal.get 20\ncall 2\nlocal.set 21\nlocal.get 7\nlocal.get 21\ni32.store offset=32\nlocal.get 7\ni32.load offset=32\nlocal.set 22\ni32.const 0\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.ne\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 26\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\nlocal.get 7\ni32.load offset=44\nlocal.set 27\ni32.const 46\nlocal.set 28\nlocal.get 27\nlocal.get 28\ncall 2\nlocal.set 29\nlocal.get 7\nlocal.get 29\ni32.store offset=32\nlocal.get 7\ni32.load offset=32\nlocal.set 30\ni32.const 0\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.ne\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.and\nlocal.set 34\nblock  ;; label = @2\nlocal.get 34\nbr_if 0 (;@2;)\nlocal.get 7\ni32.load offset=44\nlocal.set 35\ni32.const 65591\nlocal.set 36\nlocal.get 35\nlocal.get 36\ncall 5\ndrop\nbr 1 (;@1;)\nend\nlocal.get 7\ni32.load offset=44\nlocal.set 37\nlocal.get 7\ni32.load offset=44\nlocal.set 38\nlocal.get 38\ncall 10\nlocal.set 39\nlocal.get 37\nlocal.get 39\ni32.add\nlocal.set 40\ni32.const -1\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 7\nlocal.get 42\ni32.store offset=28\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 7\ni32.load offset=28\nlocal.set 43\nlocal.get 7\ni32.load offset=32\nlocal.set 44\ni32.const 1\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.add\nlocal.set 46\nlocal.get 43\nlocal.get 46\ni32.gt_u\nlocal.set 47\ni32.const 1\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.and\nlocal.set 49\nlocal.get 49\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 7\ni32.load offset=28\nlocal.set 50\nlocal.get 50\ni32.load8_u\nlocal.set 51\ni32.const 24\nlocal.set 52\nlocal.get 51\nlocal.get 52\ni32.shl\nlocal.set 53\nlocal.get 53\nlocal.get 52\ni32.shr_s\nlocal.set 54\ni32.const 48\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.eq\nlocal.set 56\ni32.const 1\nlocal.set 57\nlocal.get 56\nlocal.get 57\ni32.and\nlocal.set 58\nblock  ;; label = @4\nblock  ;; label = @5\nlocal.get 58\ni32.eqz\nbr_if 0 (;@5;)\nlocal.get 7\ni32.load offset=28\nlocal.set 59\ni32.const 0\nlocal.set 60\nlocal.get 59\nlocal.get 60\ni32.store8\nbr 1 (;@4;)\nend\nbr 2 (;@2;)\nend\nlocal.get 7\ni32.load offset=28\nlocal.set 61\ni32.const -1\nlocal.set 62\nlocal.get 61\nlocal.get 62\ni32.add\nlocal.set 63\nlocal.get 7\nlocal.get 63\ni32.store offset=28\nbr 0 (;@3;)\nend\nunreachable\nend\nend\ni32.const 64\nlocal.set 64\nlocal.get 7\nlocal.get 64\ni32.add\nlocal.set 65\nlocal.get 65\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_83",
        "query_text": "The function accepts a single integer input that represents a type identifier. It evaluates whether this identifier falls within an inclusive range defined by two predetermined constants. If the identifier lies within this range, the function returns a non-zero integer (indicating a true value); if not, it returns zero (indicating false). Its primary purpose is to determine if the provided type identifier corresponds to a scalar type.",
        "code_id": "c_group_1_id_83",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 2\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.ge_s\nlocal.set 6\ni32.const 0\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 7\nlocal.set 10\nblock  ;; label = @1\nlocal.get 9\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 11\ni32.const 6\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.le_s\nlocal.set 13\nlocal.get 13\nlocal.set 10\nend\nlocal.get 10\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 16\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_85",
        "query_text": "The function accepts a single string as input and returns a boolean value. It checks whether the input string is equal to one of three specific literal values \u2013 \".nan\", \".NaN\", or \".NAN\". If the input matches any of these values, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_85",
        "code_text": "(func (;2;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 65536\nlocal.set 5\nlocal.get 4\nlocal.get 5\ncall 3\nlocal.set 6\ni32.const 1\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 7\nlocal.set 10\nblock  ;; label = @1\nlocal.get 9\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 11\ni32.const 65554\nlocal.set 12\nlocal.get 11\nlocal.get 12\ncall 3\nlocal.set 13\ni32.const 1\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 13\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 14\nlocal.set 10\nlocal.get 16\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 17\ni32.const 65559\nlocal.set 18\nlocal.get 17\nlocal.get 18\ncall 3\nlocal.set 19\nlocal.get 19\nlocal.set 10\nend\nlocal.get 10\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\ni32.const 16\nlocal.set 23\nlocal.get 3\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nglobal.set 0\nlocal.get 22\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_86",
        "query_text": "The function takes a single character as input and returns an integer representing the number of bytes needed to encode that character using UTF-8 encoding. It evaluates the high-order bits of the unsigned version of the input character to determine the appropriate byte sequence. Specifically, it returns 1 for characters fitting the one-byte pattern, 2 for those matching the two-byte sequence, 3 for the three-byte pattern, and 4 for the four-byte sequence. If the character does not conform to any valid UTF-8 leading byte pattern, the function returns -1 to signal an invalid or unsupported character.",
        "code_id": "c_group_1_id_86",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=11\nlocal.get 3\ni32.load8_u offset=11\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=4\nlocal.get 3\ni32.load offset=4\nlocal.set 5\ni32.const 4\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.shr_s\nlocal.set 7\ni32.const 15\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.gt_u\ndrop\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nblock  ;; label = @4\nblock  ;; label = @5\nblock  ;; label = @6\nlocal.get 7\nbr_table 0 (;@6;) 0 (;@6;) 0 (;@6;) 0 (;@6;) 0 (;@6;) 0 (;@6;) 0 (;@6;) 0 (;@6;) 4 (;@2;) 4 (;@2;) 4 (;@2;) 4 (;@2;) 1 (;@5;) 1 (;@5;) 2 (;@4;) 3 (;@3;) 4 (;@2;)\nend\ni32.const 1\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=12\nbr 4 (;@1;)\nend\ni32.const 2\nlocal.set 10\nlocal.get 3\nlocal.get 10\ni32.store offset=12\nbr 3 (;@1;)\nend\ni32.const 3\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.store offset=12\nbr 2 (;@1;)\nend\ni32.const 4\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const -1\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 14\nlocal.get 14\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_87",
        "query_text": "The function accepts three parameters: a pointer to a character array representing a string, an unsigned integer indicating the string's size, and a boolean flag that determines whether non-ASCII characters should trigger a validation failure. It iterates over each character in the string checking two conditions: if the boolean flag is set, it verifies that no character has a value equal to or exceeding 0x80 (thus ensuring all characters are ASCII), and it confirms that the string does not contain any newline characters. The function returns a boolean value\u2014true if all characters meet the specified criteria, or false otherwise.",
        "code_id": "c_group_1_id_87",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 2\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store8 offset=7\nlocal.get 5\ni32.load offset=12\nlocal.set 7\nlocal.get 5\ni32.load offset=12\nlocal.set 8\nlocal.get 5\ni32.load offset=8\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 5\ni32.load8_u offset=7\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 5\nlocal.get 13\ni32.store8 offset=6\nlocal.get 5\ni32.load8_u offset=6\nlocal.set 14\nlocal.get 7\nlocal.get 10\nlocal.get 14\ncall 2\nlocal.set 15\ni32.const 1\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.and\nlocal.set 17\ni32.const 16\nlocal.set 18\nlocal.get 5\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 19\nglobal.set 0\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_88",
        "query_text": "The function accepts two pointers to constant memory areas representing a source string and a set of accepted characters. It processes the source as a UTF-8 encoded string, reading each character (or multi-byte sequence) and verifying if it exists within the accepted set. The function counts, in sequence, the number of characters from the source that are also found in the accepted set. It terminates the count when encountering the first character that does not match any in the accepted set or when the end of the source string is reached. The result, a count of type size_t, is returned as output.",
        "code_id": "c_group_1_id_88",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=16\ni32.const 0\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=12\nblock  ;; label = @1\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 4\ni32.load offset=16\nlocal.set 7\nlocal.get 7\ni32.load8_u\nlocal.set 8\ni32.const 24\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.shl\nlocal.set 10\nlocal.get 10\nlocal.get 9\ni32.shr_s\nlocal.set 11\ni32.const 0\nlocal.set 12\nlocal.get 12\nlocal.get 11\ni32.ne\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 4\ni32.load offset=20\nlocal.set 16\nlocal.get 4\nlocal.get 16\ni32.store offset=8\ni32.const 0\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.store offset=4\nblock  ;; label = @4\nloop  ;; label = @5\nlocal.get 4\ni32.load offset=8\nlocal.set 18\nlocal.get 18\ni32.load8_u\nlocal.set 19\ni32.const 24\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 21\nlocal.get 20\ni32.shr_s\nlocal.set 22\ni32.const 0\nlocal.set 23\nlocal.get 23\nlocal.get 22\ni32.ne\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nlocal.get 26\ni32.eqz\nbr_if 1 (;@4;)\nlocal.get 4\ni32.load offset=8\nlocal.set 27\nlocal.get 27\ni32.load8_u\nlocal.set 28\ni32.const 24\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.shl\nlocal.set 30\nlocal.get 30\nlocal.get 29\ni32.shr_s\nlocal.set 31\ni32.const 192\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.and\nlocal.set 33\ni32.const 128\nlocal.set 34\nlocal.get 34\nlocal.get 33\ni32.ne\nlocal.set 35\ni32.const 1\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.and\nlocal.set 37\nblock  ;; label = @6\nlocal.get 37\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 4\ni32.load offset=4\nlocal.set 38\ni32.const 0\nlocal.set 39\nlocal.get 39\nlocal.get 38\ni32.lt_u\nlocal.set 40\ni32.const 1\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.and\nlocal.set 42\nlocal.get 42\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 4\ni32.load offset=12\nlocal.set 43\ni32.const 1\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.add\nlocal.set 45\nlocal.get 4\nlocal.get 45\ni32.store offset=12\nlocal.get 4\ni32.load offset=4\nlocal.set 46\nlocal.get 4\ni32.load offset=16\nlocal.set 47\nlocal.get 47\nlocal.get 46\ni32.add\nlocal.set 48\nlocal.get 4\nlocal.get 48\ni32.store offset=16\nbr 2 (;@4;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 49\nlocal.get 49\ni32.load8_u\nlocal.set 50\ni32.const 24\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.shl\nlocal.set 52\nlocal.get 52\nlocal.get 51\ni32.shr_s\nlocal.set 53\nlocal.get 4\ni32.load offset=16\nlocal.set 54\nlocal.get 4\ni32.load offset=4\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.add\nlocal.set 56\nlocal.get 56\ni32.load8_u\nlocal.set 57\ni32.const 24\nlocal.set 58\nlocal.get 57\nlocal.get 58\ni32.shl\nlocal.set 59\nlocal.get 59\nlocal.get 58\ni32.shr_s\nlocal.set 60\nlocal.get 53\nlocal.get 60\ni32.eq\nlocal.set 61\ni32.const 1\nlocal.set 62\nlocal.get 61\nlocal.get 62\ni32.and\nlocal.set 63\nblock  ;; label = @6\nblock  ;; label = @7\nlocal.get 63\ni32.eqz\nbr_if 0 (;@7;)\nlocal.get 4\ni32.load offset=4\nlocal.set 64\ni32.const 1\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.add\nlocal.set 66\nlocal.get 4\nlocal.get 66\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 67\ni32.const 1\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.add\nlocal.set 69\nlocal.get 4\nlocal.get 69\ni32.store offset=8\nbr 1 (;@6;)\nend\nloop  ;; label = @7\nlocal.get 4\ni32.load offset=8\nlocal.set 70\ni32.const 1\nlocal.set 71\nlocal.get 70\nlocal.get 71\ni32.add\nlocal.set 72\nlocal.get 4\nlocal.get 72\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 73\nlocal.get 73\ni32.load8_u\nlocal.set 74\ni32.const 24\nlocal.set 75\nlocal.get 74\nlocal.get 75\ni32.shl\nlocal.set 76\nlocal.get 76\nlocal.get 75\ni32.shr_s\nlocal.set 77\ni32.const 192\nlocal.set 78\nlocal.get 77\nlocal.get 78\ni32.and\nlocal.set 79\ni32.const 128\nlocal.set 80\nlocal.get 80\nlocal.get 79\ni32.eq\nlocal.set 81\ni32.const 1\nlocal.set 82\nlocal.get 81\nlocal.get 82\ni32.and\nlocal.set 83\nlocal.get 83\nbr_if 0 (;@7;)\nend\ni32.const 0\nlocal.set 84\nlocal.get 4\nlocal.get 84\ni32.store offset=4\nend\nbr 0 (;@5;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 85\nlocal.get 85\ni32.load8_u\nlocal.set 86\ni32.const 24\nlocal.set 87\nlocal.get 86\nlocal.get 87\ni32.shl\nlocal.set 88\nlocal.get 88\nlocal.get 87\ni32.shr_s\nlocal.set 89\ni32.const 0\nlocal.set 90\nlocal.get 90\nlocal.get 89\ni32.eq\nlocal.set 91\ni32.const 1\nlocal.set 92\nlocal.get 91\nlocal.get 92\ni32.and\nlocal.set 93\nblock  ;; label = @4\nlocal.get 93\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 4\ni32.load offset=12\nlocal.set 94\nlocal.get 4\nlocal.get 94\ni32.store offset=28\nbr 3 (;@1;)\nend\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 95\nlocal.get 4\nlocal.get 95\ni32.store offset=28\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 96\nlocal.get 96\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_89",
        "query_text": "The function accepts three inputs: a constant string, a separator character, and a non-negative integer. It searches the string for the nth occurrence of the separator character and returns a pointer to the beginning of the substring immediately following that occurrence. If the string is null, the separator character does not appear, or the nth occurrence is not found, the function returns a null pointer. The output is of type pointer to constant character.",
        "code_id": "c_group_1_id_89",
        "code_text": "(func (;1;) (type 3) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=8\nlocal.get 5\nlocal.get 1\ni32.store8 offset=7\nlocal.get 5\nlocal.get 2\ni32.store\nlocal.get 5\ni32.load offset=8\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.eq\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 10\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 11\nlocal.get 5\nlocal.get 11\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 5\ni32.load\nlocal.set 12\nblock  ;; label = @2\nlocal.get 12\nbr_if 0 (;@2;)\nlocal.get 5\ni32.load offset=8\nlocal.set 13\nlocal.get 5\nlocal.get 13\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 5\ni32.load offset=8\nlocal.set 14\nlocal.get 5\ni32.load8_u offset=7\nlocal.set 15\ni32.const 24\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.shl\nlocal.set 17\nlocal.get 17\nlocal.get 16\ni32.shr_s\nlocal.set 18\nlocal.get 14\nlocal.get 18\ncall 2\nlocal.set 19\nlocal.get 5\nlocal.get 19\ni32.store offset=8\nlocal.get 5\ni32.load\nlocal.set 20\ni32.const -1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 5\nlocal.get 22\ni32.store\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 5\ni32.load\nlocal.set 23\ni32.const 0\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.gt_u\nlocal.set 25\ni32.const 1\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.and\nlocal.set 27\nlocal.get 27\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 5\ni32.load offset=8\nlocal.set 28\ni32.const 0\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.eq\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nblock  ;; label = @4\nlocal.get 32\ni32.eqz\nbr_if 0 (;@4;)\ni32.const 0\nlocal.set 33\nlocal.get 5\nlocal.get 33\ni32.store offset=12\nbr 3 (;@1;)\nend\nlocal.get 5\ni32.load\nlocal.set 34\ni32.const -1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 5\nlocal.get 36\ni32.store\nlocal.get 5\ni32.load offset=8\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 5\nlocal.get 39\ni32.store offset=8\nlocal.get 5\ni32.load offset=8\nlocal.set 40\nlocal.get 5\ni32.load8_u offset=7\nlocal.set 41\ni32.const 24\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.shl\nlocal.set 43\nlocal.get 43\nlocal.get 42\ni32.shr_s\nlocal.set 44\nlocal.get 40\nlocal.get 44\ncall 2\nlocal.set 45\nlocal.get 5\nlocal.get 45\ni32.store offset=8\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 5\ni32.load offset=8\nlocal.set 46\ni32.const 0\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.ne\nlocal.set 48\ni32.const 1\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.and\nlocal.set 50\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 50\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load offset=8\nlocal.set 51\ni32.const 1\nlocal.set 52\nlocal.get 51\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\nlocal.set 54\nbr 1 (;@2;)\nend\ni32.const 0\nlocal.set 55\nlocal.get 55\nlocal.set 54\nend\nlocal.get 54\nlocal.set 56\nlocal.get 5\nlocal.get 56\ni32.store offset=12\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 57\ni32.const 16\nlocal.set 58\nlocal.get 5\nlocal.get 58\ni32.add\nlocal.set 59\nlocal.get 59\nglobal.set 0\nlocal.get 57\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_90",
        "query_text": "This function returns a string representing the version of a library. It constructs the version string by concatenating the major, minor, and patch version numbers using the format \"X.Y.Z\". The function does not accept any input parameters and outputs a pointer to a constant character string that reflects the library's version.\n\n",
        "code_id": "c_group_1_id_90",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 65536\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_91",
        "query_text": "The function takes no input arguments and returns a pointer to a constant character string. It simply provides the Unicode version information supported by the library\u2014specifically \"16.0.0\"\u2014without performing any additional processing.",
        "code_id": "c_group_1_id_91",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 65536\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_92",
        "query_text": "The function takes an integer as input and returns an unsigned integer representing the floor of the base-2 logarithm of the input value. It calculates this by repeatedly right-shifting the input (effectively dividing it by 2) until the value becomes zero, incrementing a counter with each shift. The number of shifts performed corresponds to the floor of the logarithm to base 2. The input is of type int, and the output is of type unsigned int.",
        "code_id": "c_group_1_id_92",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=12\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.shr_s\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.store offset=12\nlocal.get 7\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 3\nlocal.get 10\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_93",
        "query_text": "The function accepts two integers as input and returns a boolean value. It evaluates whether the first integer qualifies as a valid digit within a numeral system defined by the second input (radix). The function checks three possible conditions: first, it verifies if the input falls within the numeric digit range ('0' to '9') and is valid for the given radix; second, for radices greater than 10, it checks if the input is a lowercase alphabetic digit (from 'a' onward) that represents a valid digit; and third, under the same condition (radix > 10), it verifies if the input is an uppercase alphabetic digit (from 'A' onward) corresponding to a valid digit. If any of these checks succeed, the function returns true, otherwise false.",
        "code_id": "c_group_1_id_93",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\ni32.const 48\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.ge_s\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 10\ni32.const 57\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.le_s\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nlocal.get 14\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 15\nlocal.get 4\ni32.load offset=8\nlocal.set 16\ni32.const 48\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 15\nlocal.get 18\ni32.lt_s\nlocal.set 19\ni32.const 1\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 19\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 20\nlocal.set 23\nlocal.get 22\nbr_if 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 24\ni32.const 10\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.gt_s\nlocal.set 26\ni32.const 1\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.and\nlocal.set 28\nblock  ;; label = @2\nlocal.get 28\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 29\ni32.const 97\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.ge_s\nlocal.set 31\ni32.const 1\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.and\nlocal.set 33\nlocal.get 33\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 34\nlocal.get 4\ni32.load offset=8\nlocal.set 35\ni32.const 97\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.add\nlocal.set 37\ni32.const 10\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.sub\nlocal.set 39\nlocal.get 34\nlocal.get 39\ni32.lt_s\nlocal.set 40\ni32.const 1\nlocal.set 41\ni32.const 1\nlocal.set 42\nlocal.get 40\nlocal.get 42\ni32.and\nlocal.set 43\nlocal.get 41\nlocal.set 23\nlocal.get 43\nbr_if 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 44\ni32.const 10\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.gt_s\nlocal.set 46\ni32.const 0\nlocal.set 47\ni32.const 1\nlocal.set 48\nlocal.get 46\nlocal.get 48\ni32.and\nlocal.set 49\nlocal.get 47\nlocal.set 50\nblock  ;; label = @2\nlocal.get 49\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 51\ni32.const 65\nlocal.set 52\nlocal.get 51\nlocal.get 52\ni32.ge_s\nlocal.set 53\ni32.const 0\nlocal.set 54\ni32.const 1\nlocal.set 55\nlocal.get 53\nlocal.get 55\ni32.and\nlocal.set 56\nlocal.get 54\nlocal.set 50\nlocal.get 56\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 57\nlocal.get 4\ni32.load offset=8\nlocal.set 58\ni32.const 65\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.add\nlocal.set 60\ni32.const 10\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.sub\nlocal.set 62\nlocal.get 57\nlocal.get 62\ni32.lt_s\nlocal.set 63\nlocal.get 63\nlocal.set 50\nend\nlocal.get 50\nlocal.set 64\nlocal.get 64\nlocal.set 23\nend\nlocal.get 23\nlocal.set 65\ni32.const 1\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.and\nlocal.set 67\nlocal.get 67\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_94",
        "query_text": "The function accepts three parameters: an integer value representing a character or digit, an integer representing the radix (base) of a numeral system, and a character that serves as the starting point for additional alphabetic digits (for numeral systems with bases higher than 10). It first checks if the radix is greater than 10. If so, the function verifies whether the integer falls within a continuous range beginning at the provided character and extending for (radix \u2013 10) positions. The function returns a boolean value: true if the integer represents a valid digit character for the given radix; otherwise, it returns false.",
        "code_id": "c_group_1_id_94",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store8 offset=7\nlocal.get 5\ni32.load offset=8\nlocal.set 6\ni32.const 10\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.gt_s\nlocal.set 8\ni32.const 0\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 8\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 9\nlocal.set 12\nblock  ;; label = @1\nlocal.get 11\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 5\ni32.load offset=12\nlocal.set 13\nlocal.get 5\ni32.load8_u offset=7\nlocal.set 14\ni32.const 24\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 16\nlocal.get 15\ni32.shr_s\nlocal.set 17\nlocal.get 13\nlocal.get 17\ni32.ge_s\nlocal.set 18\ni32.const 0\nlocal.set 19\ni32.const 1\nlocal.set 20\nlocal.get 18\nlocal.get 20\ni32.and\nlocal.set 21\nlocal.get 19\nlocal.set 12\nlocal.get 21\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 5\ni32.load offset=12\nlocal.set 22\nlocal.get 5\ni32.load8_u offset=7\nlocal.set 23\ni32.const 24\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.shl\nlocal.set 25\nlocal.get 25\nlocal.get 24\ni32.shr_s\nlocal.set 26\nlocal.get 5\ni32.load offset=8\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.add\nlocal.set 28\ni32.const 10\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.sub\nlocal.set 30\nlocal.get 22\nlocal.get 30\ni32.lt_s\nlocal.set 31\nlocal.get 31\nlocal.set 12\nend\nlocal.get 12\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.and\nlocal.set 34\nlocal.get 34\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_95",
        "query_text": "The function takes a single input of type char. It verifies whether the input character is a numeric digit by checking if it lies between '0' and '9' (inclusive). If the input character meets this condition, the function returns true; otherwise, it returns false. The output of the function is of type bool.",
        "code_id": "c_group_1_id_95",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.shr_s\nlocal.set 7\ni32.const 48\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.le_s\nlocal.set 9\ni32.const 0\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 9\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 10\nlocal.set 13\nblock  ;; label = @1\nlocal.get 12\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 14\ni32.const 24\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 16\nlocal.get 15\ni32.shr_s\nlocal.set 17\ni32.const 57\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.le_s\nlocal.set 19\nlocal.get 19\nlocal.set 13\nend\nlocal.get 13\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 22\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_96",
        "query_text": "The function accepts a pointer to a UTF-8 encoded character array as its input. It decodes the first UTF-8 sequence found in the string and outputs two values: a 32-bit unsigned integer representing the resulting Unicode code point and an integer error code that indicates whether the sequence was valid. The function returns a pointer to the character immediately following the decoded sequence, enabling sequential processing of subsequent UTF-8 characters. The input is a pointer to a UTF-8 encoded string, while the outputs are the decoded Unicode code point and an error status indicator.",
        "code_id": "c_group_1_id_96",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 3\ni32.const 144\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=140\nlocal.get 5\nlocal.get 1\ni32.store offset=136\nlocal.get 5\nlocal.get 2\ni32.store offset=132\ni32.const 0\nlocal.set 6\nlocal.get 6\ni32.load offset=65552\nlocal.set 7\ni32.const 128\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nlocal.get 7\ni32.store\nlocal.get 6\ni64.load offset=65544\nlocal.set 192\nlocal.get 5\nlocal.get 192\ni64.store offset=120\nlocal.get 6\ni64.load offset=65536\nlocal.set 193\nlocal.get 5\nlocal.get 193\ni64.store offset=112\ni32.const 0\nlocal.set 10\nlocal.get 10\ni32.load offset=65584\nlocal.set 11\ni32.const 96\nlocal.set 12\nlocal.get 5\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nlocal.get 11\ni32.store\nlocal.get 10\ni64.load offset=65576\nlocal.set 194\nlocal.get 5\nlocal.get 194\ni64.store offset=88\nlocal.get 10\ni64.load offset=65568\nlocal.set 195\nlocal.get 5\nlocal.get 195\ni64.store offset=80\ni32.const 0\nlocal.set 14\nlocal.get 14\ni32.load offset=65616\nlocal.set 15\ni32.const 64\nlocal.set 16\nlocal.get 5\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nlocal.get 15\ni32.store\nlocal.get 14\ni64.load offset=65608\nlocal.set 196\nlocal.get 5\nlocal.get 196\ni64.store offset=56\nlocal.get 14\ni64.load offset=65600\nlocal.set 197\nlocal.get 5\nlocal.get 197\ni64.store offset=48\ni32.const 0\nlocal.set 18\nlocal.get 18\ni32.load offset=65648\nlocal.set 19\ni32.const 32\nlocal.set 20\nlocal.get 5\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nlocal.get 19\ni32.store\nlocal.get 18\ni64.load offset=65640\nlocal.set 198\nlocal.get 5\nlocal.get 198\ni64.store offset=24\nlocal.get 18\ni64.load offset=65632\nlocal.set 199\nlocal.get 5\nlocal.get 199\ni64.store offset=16\nlocal.get 5\ni32.load offset=140\nlocal.set 22\nlocal.get 22\ni32.load8_u\nlocal.set 23\ni32.const 255\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\ni32.const 3\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.shr_s\nlocal.set 27\nlocal.get 27\ni32.load8_u offset=65652\nlocal.set 28\ni32.const 24\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.shl\nlocal.set 30\nlocal.get 30\nlocal.get 29\ni32.shr_s\nlocal.set 31\nlocal.get 5\nlocal.get 31\ni32.store offset=12\nlocal.get 5\ni32.load offset=140\nlocal.set 32\nlocal.get 5\ni32.load offset=12\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.add\nlocal.set 34\nlocal.get 5\ni32.load offset=12\nlocal.set 35\ni32.const 0\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.ne\nlocal.set 37\ni32.const -1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.xor\nlocal.set 39\ni32.const 1\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.and\nlocal.set 41\nlocal.get 34\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 5\nlocal.get 42\ni32.store offset=8\nlocal.get 5\ni32.load offset=140\nlocal.set 43\nlocal.get 43\ni32.load8_u\nlocal.set 44\ni32.const 255\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.and\nlocal.set 46\nlocal.get 5\ni32.load offset=12\nlocal.set 47\ni32.const 112\nlocal.set 48\nlocal.get 5\nlocal.get 48\ni32.add\nlocal.set 49\nlocal.get 49\nlocal.set 50\ni32.const 2\nlocal.set 51\nlocal.get 47\nlocal.get 51\ni32.shl\nlocal.set 52\nlocal.get 50\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\ni32.load\nlocal.set 54\nlocal.get 46\nlocal.get 54\ni32.and\nlocal.set 55\ni32.const 18\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.shl\nlocal.set 57\nlocal.get 5\ni32.load offset=136\nlocal.set 58\nlocal.get 58\nlocal.get 57\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 59\nlocal.get 59\ni32.load8_u offset=1\nlocal.set 60\ni32.const 255\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.and\nlocal.set 62\ni32.const 63\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.and\nlocal.set 64\ni32.const 12\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.shl\nlocal.set 66\nlocal.get 5\ni32.load offset=136\nlocal.set 67\nlocal.get 67\ni32.load\nlocal.set 68\nlocal.get 68\nlocal.get 66\ni32.or\nlocal.set 69\nlocal.get 67\nlocal.get 69\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 70\nlocal.get 70\ni32.load8_u offset=2\nlocal.set 71\ni32.const 255\nlocal.set 72\nlocal.get 71\nlocal.get 72\ni32.and\nlocal.set 73\ni32.const 63\nlocal.set 74\nlocal.get 73\nlocal.get 74\ni32.and\nlocal.set 75\ni32.const 6\nlocal.set 76\nlocal.get 75\nlocal.get 76\ni32.shl\nlocal.set 77\nlocal.get 5\ni32.load offset=136\nlocal.set 78\nlocal.get 78\ni32.load\nlocal.set 79\nlocal.get 79\nlocal.get 77\ni32.or\nlocal.set 80\nlocal.get 78\nlocal.get 80\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 81\nlocal.get 81\ni32.load8_u offset=3\nlocal.set 82\ni32.const 255\nlocal.set 83\nlocal.get 82\nlocal.get 83\ni32.and\nlocal.set 84\ni32.const 63\nlocal.set 85\nlocal.get 84\nlocal.get 85\ni32.and\nlocal.set 86\ni32.const 0\nlocal.set 87\nlocal.get 86\nlocal.get 87\ni32.shl\nlocal.set 88\nlocal.get 5\ni32.load offset=136\nlocal.set 89\nlocal.get 89\ni32.load\nlocal.set 90\nlocal.get 90\nlocal.get 88\ni32.or\nlocal.set 91\nlocal.get 89\nlocal.get 91\ni32.store\nlocal.get 5\ni32.load offset=12\nlocal.set 92\ni32.const 48\nlocal.set 93\nlocal.get 5\nlocal.get 93\ni32.add\nlocal.set 94\nlocal.get 94\nlocal.set 95\ni32.const 2\nlocal.set 96\nlocal.get 92\nlocal.get 96\ni32.shl\nlocal.set 97\nlocal.get 95\nlocal.get 97\ni32.add\nlocal.set 98\nlocal.get 98\ni32.load\nlocal.set 99\nlocal.get 5\ni32.load offset=136\nlocal.set 100\nlocal.get 100\ni32.load\nlocal.set 101\nlocal.get 101\nlocal.get 99\ni32.shr_u\nlocal.set 102\nlocal.get 100\nlocal.get 102\ni32.store\nlocal.get 5\ni32.load offset=136\nlocal.set 103\nlocal.get 103\ni32.load\nlocal.set 104\nlocal.get 5\ni32.load offset=12\nlocal.set 105\ni32.const 80\nlocal.set 106\nlocal.get 5\nlocal.get 106\ni32.add\nlocal.set 107\nlocal.get 107\nlocal.set 108\ni32.const 2\nlocal.set 109\nlocal.get 105\nlocal.get 109\ni32.shl\nlocal.set 110\nlocal.get 108\nlocal.get 110\ni32.add\nlocal.set 111\nlocal.get 111\ni32.load\nlocal.set 112\nlocal.get 104\nlocal.get 112\ni32.lt_u\nlocal.set 113\ni32.const 1\nlocal.set 114\nlocal.get 113\nlocal.get 114\ni32.and\nlocal.set 115\ni32.const 6\nlocal.set 116\nlocal.get 115\nlocal.get 116\ni32.shl\nlocal.set 117\nlocal.get 5\ni32.load offset=132\nlocal.set 118\nlocal.get 118\nlocal.get 117\ni32.store\nlocal.get 5\ni32.load offset=136\nlocal.set 119\nlocal.get 119\ni32.load\nlocal.set 120\ni32.const 11\nlocal.set 121\nlocal.get 120\nlocal.get 121\ni32.shr_u\nlocal.set 122\ni32.const 27\nlocal.set 123\nlocal.get 122\nlocal.get 123\ni32.eq\nlocal.set 124\ni32.const 1\nlocal.set 125\nlocal.get 124\nlocal.get 125\ni32.and\nlocal.set 126\ni32.const 7\nlocal.set 127\nlocal.get 126\nlocal.get 127\ni32.shl\nlocal.set 128\nlocal.get 5\ni32.load offset=132\nlocal.set 129\nlocal.get 129\ni32.load\nlocal.set 130\nlocal.get 130\nlocal.get 128\ni32.or\nlocal.set 131\nlocal.get 129\nlocal.get 131\ni32.store\nlocal.get 5\ni32.load offset=136\nlocal.set 132\nlocal.get 132\ni32.load\nlocal.set 133\ni32.const 1114111\nlocal.set 134\nlocal.get 133\nlocal.get 134\ni32.gt_u\nlocal.set 135\ni32.const 1\nlocal.set 136\nlocal.get 135\nlocal.get 136\ni32.and\nlocal.set 137\ni32.const 8\nlocal.set 138\nlocal.get 137\nlocal.get 138\ni32.shl\nlocal.set 139\nlocal.get 5\ni32.load offset=132\nlocal.set 140\nlocal.get 140\ni32.load\nlocal.set 141\nlocal.get 141\nlocal.get 139\ni32.or\nlocal.set 142\nlocal.get 140\nlocal.get 142\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 143\nlocal.get 143\ni32.load8_u offset=1\nlocal.set 144\ni32.const 255\nlocal.set 145\nlocal.get 144\nlocal.get 145\ni32.and\nlocal.set 146\ni32.const 192\nlocal.set 147\nlocal.get 146\nlocal.get 147\ni32.and\nlocal.set 148\ni32.const 2\nlocal.set 149\nlocal.get 148\nlocal.get 149\ni32.shr_s\nlocal.set 150\nlocal.get 5\ni32.load offset=132\nlocal.set 151\nlocal.get 151\ni32.load\nlocal.set 152\nlocal.get 152\nlocal.get 150\ni32.or\nlocal.set 153\nlocal.get 151\nlocal.get 153\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 154\nlocal.get 154\ni32.load8_u offset=2\nlocal.set 155\ni32.const 255\nlocal.set 156\nlocal.get 155\nlocal.get 156\ni32.and\nlocal.set 157\ni32.const 192\nlocal.set 158\nlocal.get 157\nlocal.get 158\ni32.and\nlocal.set 159\ni32.const 4\nlocal.set 160\nlocal.get 159\nlocal.get 160\ni32.shr_s\nlocal.set 161\nlocal.get 5\ni32.load offset=132\nlocal.set 162\nlocal.get 162\ni32.load\nlocal.set 163\nlocal.get 163\nlocal.get 161\ni32.or\nlocal.set 164\nlocal.get 162\nlocal.get 164\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 165\nlocal.get 165\ni32.load8_u offset=3\nlocal.set 166\ni32.const 255\nlocal.set 167\nlocal.get 166\nlocal.get 167\ni32.and\nlocal.set 168\ni32.const 6\nlocal.set 169\nlocal.get 168\nlocal.get 169\ni32.shr_s\nlocal.set 170\nlocal.get 5\ni32.load offset=132\nlocal.set 171\nlocal.get 171\ni32.load\nlocal.set 172\nlocal.get 172\nlocal.get 170\ni32.or\nlocal.set 173\nlocal.get 171\nlocal.get 173\ni32.store\nlocal.get 5\ni32.load offset=132\nlocal.set 174\nlocal.get 174\ni32.load\nlocal.set 175\ni32.const 42\nlocal.set 176\nlocal.get 175\nlocal.get 176\ni32.xor\nlocal.set 177\nlocal.get 174\nlocal.get 177\ni32.store\nlocal.get 5\ni32.load offset=12\nlocal.set 178\ni32.const 16\nlocal.set 179\nlocal.get 5\nlocal.get 179\ni32.add\nlocal.set 180\nlocal.get 180\nlocal.set 181\ni32.const 2\nlocal.set 182\nlocal.get 178\nlocal.get 182\ni32.shl\nlocal.set 183\nlocal.get 181\nlocal.get 183\ni32.add\nlocal.set 184\nlocal.get 184\ni32.load\nlocal.set 185\nlocal.get 5\ni32.load offset=132\nlocal.set 186\nlocal.get 186\ni32.load\nlocal.set 187\nlocal.get 187\nlocal.get 185\ni32.shr_s\nlocal.set 188\nlocal.get 186\nlocal.get 188\ni32.store\nlocal.get 5\ni32.load offset=8\nlocal.set 189\ni32.const 144\nlocal.set 190\nlocal.get 5\nlocal.get 190\ni32.add\nlocal.set 191\nlocal.get 191\nglobal.set 0\nlocal.get 189\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_97",
        "query_text": "The function takes a single character as input and determines whether it is alphanumeric\u2014that is, whether it is a letter (uppercase or lowercase) or a digit (0\u20139). If the character is alphanumeric, the function returns true; otherwise, it returns false. The input type is char, and the output is a boolean value.",
        "code_id": "c_group_1_id_97",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.ne\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\ni32.const 16\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_98",
        "query_text": "The function takes a single character as input and determines whether it represents a numeric digit (0-9). Internally, it casts the input to an unsigned character and uses a standard library routine to perform the check. Based on this evaluation, the function returns a boolean value: true if the character is a decimal digit, and false otherwise. The input is of type char, while the output is of type bool.",
        "code_id": "c_group_1_id_98",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.ne\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\ni32.const 16\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_99",
        "query_text": "The function receives a single character of type char and returns a boolean value. It first casts the input to an unsigned char to ensure compatibility with a standard library function that checks for lowercase characters. It then evaluates the input using this function and produces a boolean result: true if the character is lowercase, or false otherwise.",
        "code_id": "c_group_1_id_99",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.ne\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\ni32.const 16\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_100",
        "query_text": "The function accepts a single input of type char and returns an output of the same type. It first converts the input character to an unsigned char to safely handle potential negative values. Then, it applies the standard library function for case conversion to transform the character into its lowercase equivalent. Finally, the result is cast back to a char before being returned.",
        "code_id": "c_group_1_id_100",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shl\nlocal.set 9\nlocal.get 9\nlocal.get 8\ni32.shr_s\nlocal.set 10\ni32.const 16\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nglobal.set 0\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_101",
        "query_text": "The function takes a char as input and returns a char as output. It converts the provided character to its uppercase equivalent by first casting it to an unsigned type to prevent issues with negative values, then applying a standard uppercase conversion operation, and finally casting the result back to a char before returning it.",
        "code_id": "c_group_1_id_101",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shl\nlocal.set 9\nlocal.get 9\nlocal.get 8\ni32.shr_s\nlocal.set 10\ni32.const 16\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nglobal.set 0\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_102",
        "query_text": "The function takes two string inputs: one specifying a file path and the other specifying a file-mode indicator (such as \"r\" for read or \"w\" for write). On Windows systems (when not using a specific alternative compiler), it first converts these strings into wide-character format before attempting to open the file. On other systems, it directly opens the file using the provided strings. It returns a pointer to the opened file for later use.",
        "code_id": "c_group_1_id_102",
        "code_text": "(func (;5;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 21\nlocal.set 7\ni32.const 16\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nglobal.set 0\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_103",
        "query_text": "The function takes a Unicode character (of type char32_t) as input and writes its hexadecimal Unicode code point representation to an output stream (of type ::std::ostream*). It formats the output as \"U+XXXX\"\u2014where \"XXXX\" is the character's 4-digit uppercase hexadecimal value, padded with leading zeros if necessary\u2014and writes this formatted string to the provided stream.",
        "code_id": "c_group_1_id_103",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 4\nlocal.set 7\ni32.const 65565\nlocal.set 8\nlocal.get 7\nlocal.get 8\ncall 5\nlocal.set 9\ni32.const 2\nlocal.set 10\nlocal.get 9\nlocal.get 10\ncall 4\nlocal.set 11\ni32.const 48\nlocal.set 12\ni32.const 24\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.shl\nlocal.set 14\nlocal.get 14\nlocal.get 13\ni32.shr_s\nlocal.set 15\nlocal.get 15\ncall 7\nlocal.set 16\nlocal.get 4\nlocal.get 16\ni32.store8 offset=7\ni32.const 7\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 18\nlocal.set 19\nlocal.get 11\nlocal.get 19\ncall 8\nlocal.set 20\ni32.const 4\nlocal.set 21\nlocal.get 21\ncall 9\nlocal.set 22\nlocal.get 4\nlocal.get 22\ni32.store\nlocal.get 4\nlocal.set 23\nlocal.get 20\nlocal.get 23\ncall 10\nlocal.set 24\nlocal.get 4\ni32.load offset=12\nlocal.set 25\nlocal.get 24\nlocal.get 25\ncall 97\ndrop\ni32.const 16\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_104",
        "query_text": "The function accepts a volatile constant pointer to a void type as input. It converts this pointer by removing the volatile qualifier while preserving the constant qualifier, and then returns the resulting constant pointer. This enables use of the pointer in scenarios where a non-volatile pointer is required without modifying the underlying data.",
        "code_id": "c_group_1_id_104",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_105",
        "query_text": "The function takes three parameters: a string-like container, a pointer to a character array representing a pattern, and a pointer marking the end of the pattern. It checks whether the string conforms to the pattern using wildcard matching. The pattern may include two wildcards: one that matches any single character and another that matches zero or more characters. The function iterates through both the string and the pattern, comparing characters and applying the wildcard rules. If the entire string successfully matches the pattern, it returns a boolean true; if not, it returns false.",
        "code_id": "c_group_1_id_105",
        "code_text": "(func (;1;) (type 3) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 48\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=40\nlocal.get 5\nlocal.get 1\ni32.store offset=36\nlocal.get 5\nlocal.get 2\ni32.store offset=32\nlocal.get 5\ni32.load offset=40\nlocal.set 6\nlocal.get 6\ncall 2\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store offset=28\nlocal.get 5\ni32.load offset=28\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.store offset=24\nlocal.get 5\ni32.load offset=28\nlocal.set 9\nlocal.get 5\ni32.load offset=40\nlocal.set 10\nlocal.get 10\ncall 3\nlocal.set 11\nlocal.get 9\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 5\nlocal.get 12\ni32.store offset=20\nlocal.get 5\ni32.load offset=36\nlocal.set 13\nlocal.get 5\nlocal.get 13\ni32.store offset=16\nlocal.get 5\ni32.load offset=28\nlocal.set 14\nlocal.get 5\nlocal.get 14\ni32.store offset=12\nblock  ;; label = @1\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 5\ni32.load offset=36\nlocal.set 15\nlocal.get 5\ni32.load offset=32\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.lt_u\nlocal.set 17\ni32.const 1\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 17\nlocal.get 19\ni32.and\nlocal.set 20\nlocal.get 18\nlocal.set 21\nblock  ;; label = @4\nlocal.get 20\nbr_if 0 (;@4;)\nlocal.get 5\ni32.load offset=28\nlocal.set 22\nlocal.get 5\ni32.load offset=20\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.lt_u\nlocal.set 24\nlocal.get 24\nlocal.set 21\nend\nlocal.get 21\nlocal.set 25\ni32.const 1\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.and\nlocal.set 27\nlocal.get 27\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 5\ni32.load offset=36\nlocal.set 28\nlocal.get 5\ni32.load offset=32\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.lt_u\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nblock  ;; label = @4\nlocal.get 32\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 5\ni32.load offset=36\nlocal.set 33\nlocal.get 33\ni32.load8_s\nlocal.set 34\ni32.const 42\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.eq\nlocal.set 36\nblock  ;; label = @5\nblock  ;; label = @6\nlocal.get 36\nbr_if 0 (;@6;)\ni32.const 63\nlocal.set 37\nlocal.get 34\nlocal.get 37\ni32.eq\nlocal.set 38\nblock  ;; label = @7\nlocal.get 38\nbr_if 0 (;@7;)\nlocal.get 5\ni32.load offset=28\nlocal.set 39\nlocal.get 5\ni32.load offset=20\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.lt_u\nlocal.set 41\ni32.const 1\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.and\nlocal.set 43\nblock  ;; label = @8\nlocal.get 43\ni32.eqz\nbr_if 0 (;@8;)\nlocal.get 5\ni32.load offset=28\nlocal.set 44\nlocal.get 44\ni32.load8_u\nlocal.set 45\ni32.const 24\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.shl\nlocal.set 47\nlocal.get 47\nlocal.get 46\ni32.shr_s\nlocal.set 48\nlocal.get 5\ni32.load offset=36\nlocal.set 49\nlocal.get 49\ni32.load8_u\nlocal.set 50\ni32.const 24\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.shl\nlocal.set 52\nlocal.get 52\nlocal.get 51\ni32.shr_s\nlocal.set 53\nlocal.get 48\nlocal.get 53\ni32.eq\nlocal.set 54\ni32.const 1\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.and\nlocal.set 56\nlocal.get 56\ni32.eqz\nbr_if 0 (;@8;)\nlocal.get 5\ni32.load offset=36\nlocal.set 57\ni32.const 1\nlocal.set 58\nlocal.get 57\nlocal.get 58\ni32.add\nlocal.set 59\nlocal.get 5\nlocal.get 59\ni32.store offset=36\nlocal.get 5\ni32.load offset=28\nlocal.set 60\ni32.const 1\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.add\nlocal.set 62\nlocal.get 5\nlocal.get 62\ni32.store offset=28\nbr 5 (;@3;)\nend\nbr 2 (;@5;)\nend\nlocal.get 5\ni32.load offset=28\nlocal.set 63\nlocal.get 5\ni32.load offset=20\nlocal.set 64\nlocal.get 63\nlocal.get 64\ni32.lt_u\nlocal.set 65\ni32.const 1\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.and\nlocal.set 67\nblock  ;; label = @7\nlocal.get 67\ni32.eqz\nbr_if 0 (;@7;)\nlocal.get 5\ni32.load offset=36\nlocal.set 68\ni32.const 1\nlocal.set 69\nlocal.get 68\nlocal.get 69\ni32.add\nlocal.set 70\nlocal.get 5\nlocal.get 70\ni32.store offset=36\nlocal.get 5\ni32.load offset=28\nlocal.set 71\ni32.const 1\nlocal.set 72\nlocal.get 71\nlocal.get 72\ni32.add\nlocal.set 73\nlocal.get 5\nlocal.get 73\ni32.store offset=28\nbr 4 (;@3;)\nend\nbr 1 (;@5;)\nend\nlocal.get 5\ni32.load offset=36\nlocal.set 74\nlocal.get 5\nlocal.get 74\ni32.store offset=16\nlocal.get 5\ni32.load offset=28\nlocal.set 75\ni32.const 1\nlocal.set 76\nlocal.get 75\nlocal.get 76\ni32.add\nlocal.set 77\nlocal.get 5\nlocal.get 77\ni32.store offset=12\nlocal.get 5\ni32.load offset=36\nlocal.set 78\ni32.const 1\nlocal.set 79\nlocal.get 78\nlocal.get 79\ni32.add\nlocal.set 80\nlocal.get 5\nlocal.get 80\ni32.store offset=36\nbr 2 (;@3;)\nend\nend\nlocal.get 5\ni32.load offset=24\nlocal.set 81\nlocal.get 5\ni32.load offset=12\nlocal.set 82\nlocal.get 81\nlocal.get 82\ni32.lt_u\nlocal.set 83\ni32.const 1\nlocal.set 84\nlocal.get 83\nlocal.get 84\ni32.and\nlocal.set 85\nblock  ;; label = @4\nlocal.get 85\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 5\ni32.load offset=12\nlocal.set 86\nlocal.get 5\ni32.load offset=20\nlocal.set 87\nlocal.get 86\nlocal.get 87\ni32.le_u\nlocal.set 88\ni32.const 1\nlocal.set 89\nlocal.get 88\nlocal.get 89\ni32.and\nlocal.set 90\nlocal.get 90\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 5\ni32.load offset=16\nlocal.set 91\nlocal.get 5\nlocal.get 91\ni32.store offset=36\nlocal.get 5\ni32.load offset=12\nlocal.set 92\nlocal.get 5\nlocal.get 92\ni32.store offset=28\nbr 1 (;@3;)\nend\nend\ni32.const 0\nlocal.set 93\ni32.const 1\nlocal.set 94\nlocal.get 93\nlocal.get 94\ni32.and\nlocal.set 95\nlocal.get 5\nlocal.get 95\ni32.store8 offset=47\nbr 1 (;@1;)\nend\ni32.const 1\nlocal.set 96\ni32.const 1\nlocal.set 97\nlocal.get 96\nlocal.get 97\ni32.and\nlocal.set 98\nlocal.get 5\nlocal.get 98\ni32.store8 offset=47\nend\nlocal.get 5\ni32.load8_u offset=47\nlocal.set 99\ni32.const 1\nlocal.set 100\nlocal.get 99\nlocal.get 100\ni32.and\nlocal.set 101\ni32.const 48\nlocal.set 102\nlocal.get 5\nlocal.get 102\ni32.add\nlocal.set 103\nlocal.get 103\nglobal.set 0\nlocal.get 101\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_106",
        "query_text": "The function accepts two parameters: one is a pointer to a constant character array, and the other is also a pointer to a constant character array. It first checks whether either pointer is NULL; if so, it returns true only if both pointers are NULL. Otherwise, it employs a string search function to determine if the first string exists within the second string. If the specified substring is found, it returns true; if not, it returns false.",
        "code_id": "c_group_1_id_106",
        "code_text": "(func (;1;) (type 0) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.eq\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 9\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=4\nlocal.set 10\ni32.const 0\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.eq\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nlocal.get 14\ni32.eqz\nbr_if 1 (;@2;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 15\nlocal.get 4\ni32.load offset=4\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.eq\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.store8 offset=15\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=4\nlocal.set 20\nlocal.get 4\ni32.load offset=8\nlocal.set 21\nlocal.get 20\nlocal.get 21\ncall 2\nlocal.set 22\ni32.const 0\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.ne\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.store8 offset=15\nend\nlocal.get 4\ni32.load8_u offset=15\nlocal.set 27\ni32.const 1\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.and\nlocal.set 29\ni32.const 16\nlocal.set 30\nlocal.get 4\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 31\nglobal.set 0\nlocal.get 29\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_107",
        "query_text": "The function accepts a pointer to an unsigned 32-bit integer and an integer specifying the number of bits to operate on. It extracts the lower bits from the unsigned 32-bit integer by applying a bit mask defined by the number of bits, then shifts the original integer right by that many bits to remove the extracted portion. Finally, it returns the extracted bits as an unsigned 32-bit integer. The input types are a pointer to an unsigned 32-bit integer and an integer, and the output type is an unsigned 32-bit integer.",
        "code_id": "c_group_1_id_107",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nlocal.get 4\ni32.load offset=8\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.shl\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.sub\nlocal.set 11\nlocal.get 6\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 4\nlocal.get 12\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 13\nlocal.get 4\ni32.load offset=12\nlocal.set 14\nlocal.get 14\ni32.load\nlocal.set 15\nlocal.get 15\nlocal.get 13\ni32.shr_u\nlocal.set 16\nlocal.get 14\nlocal.get 16\ni32.store\nlocal.get 4\ni32.load offset=4\nlocal.set 17\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_108",
        "query_text": "The function accepts three parameters: a pointer to a constant character array representing a string, a pointer to a constant character array representing a flag name, and a boolean value indicating whether an associated value with the flag is optional. It first constructs a flag pattern by concatenating a predefined prefix with the provided flag name, then checks if the input string starts with this pattern. If the string does not begin with the expected flag pattern, the function returns a null pointer. Once the pattern is matched, the function examines the character immediately following the flag pattern. If the flag value is optional and the flag pattern is immediately followed by the end of the string, it returns a pointer to that position. Otherwise, it checks whether the character following the flag pattern is an equals sign; if it is, the pointer is advanced past the equals sign and returned as the position where the flag value starts, and if not, a null pointer is returned.",
        "code_id": "c_group_1_id_108",
        "code_text": "(func (;2;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 64\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=56\nlocal.get 5\nlocal.get 1\ni32.store offset=52\nlocal.get 2\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store8 offset=51\nlocal.get 5\ni32.load offset=56\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.eq\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 11\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load offset=52\nlocal.set 12\ni32.const 0\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.eq\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 16\ni32.eqz\nbr_if 1 (;@2;)\nend\ni32.const 0\nlocal.set 17\nlocal.get 5\nlocal.get 17\ni32.store offset=60\nbr 1 (;@1;)\nend\ni32.const 12\nlocal.set 18\nlocal.get 5\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 19\nlocal.set 20\ni32.const 65556\nlocal.set 21\nlocal.get 20\nlocal.get 21\ncall 3\ndrop\ni32.const 24\nlocal.set 22\nlocal.get 5\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 23\nlocal.set 24\ni32.const 12\nlocal.set 25\nlocal.get 5\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 26\nlocal.set 27\ni32.const 65549\nlocal.set 28\nlocal.get 24\nlocal.get 27\nlocal.get 28\ncall 4\nlocal.get 5\ni32.load offset=52\nlocal.set 29\ni32.const 36\nlocal.set 30\nlocal.get 5\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 31\nlocal.set 32\ni32.const 24\nlocal.set 33\nlocal.get 5\nlocal.get 33\ni32.add\nlocal.set 34\nlocal.get 34\nlocal.set 35\nlocal.get 32\nlocal.get 35\nlocal.get 29\ncall 4\ni32.const 24\nlocal.set 36\nlocal.get 5\nlocal.get 36\ni32.add\nlocal.set 37\nlocal.get 37\nlocal.set 38\nlocal.get 38\ncall 95\ndrop\ni32.const 12\nlocal.set 39\nlocal.get 5\nlocal.get 39\ni32.add\nlocal.set 40\nlocal.get 40\nlocal.set 41\nlocal.get 41\ncall 95\ndrop\ni32.const 36\nlocal.set 42\nlocal.get 5\nlocal.get 42\ni32.add\nlocal.set 43\nlocal.get 43\nlocal.set 44\nlocal.get 44\ncall 5\nlocal.set 45\nlocal.get 5\nlocal.get 45\ni32.store offset=8\nlocal.get 5\ni32.load offset=56\nlocal.set 46\ni32.const 36\nlocal.set 47\nlocal.get 5\nlocal.get 47\ni32.add\nlocal.set 48\nlocal.get 48\nlocal.set 49\nlocal.get 49\ncall 6\nlocal.set 50\nlocal.get 5\ni32.load offset=8\nlocal.set 51\nlocal.get 46\nlocal.get 50\nlocal.get 51\ncall 32\nlocal.set 52\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 52\ni32.eqz\nbr_if 0 (;@3;)\ni32.const 0\nlocal.set 53\nlocal.get 5\nlocal.get 53\ni32.store offset=60\ni32.const 1\nlocal.set 54\nlocal.get 5\nlocal.get 54\ni32.store offset=4\nbr 1 (;@2;)\nend\nlocal.get 5\ni32.load offset=56\nlocal.set 55\nlocal.get 5\ni32.load offset=8\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.add\nlocal.set 57\nlocal.get 5\nlocal.get 57\ni32.store\nlocal.get 5\ni32.load8_u offset=51\nlocal.set 58\ni32.const 1\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.and\nlocal.set 60\nblock  ;; label = @3\nlocal.get 60\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load\nlocal.set 61\nlocal.get 61\ni32.load8_u\nlocal.set 62\ni32.const 24\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.shl\nlocal.set 64\nlocal.get 64\nlocal.get 63\ni32.shr_s\nlocal.set 65\nlocal.get 65\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load\nlocal.set 66\nlocal.get 5\nlocal.get 66\ni32.store offset=60\ni32.const 1\nlocal.set 67\nlocal.get 5\nlocal.get 67\ni32.store offset=4\nbr 1 (;@2;)\nend\nlocal.get 5\ni32.load\nlocal.set 68\nlocal.get 68\ni32.load8_u\nlocal.set 69\ni32.const 24\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.shl\nlocal.set 71\nlocal.get 71\nlocal.get 70\ni32.shr_s\nlocal.set 72\ni32.const 61\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.ne\nlocal.set 74\ni32.const 1\nlocal.set 75\nlocal.get 74\nlocal.get 75\ni32.and\nlocal.set 76\nblock  ;; label = @3\nlocal.get 76\ni32.eqz\nbr_if 0 (;@3;)\ni32.const 0\nlocal.set 77\nlocal.get 5\nlocal.get 77\ni32.store offset=60\ni32.const 1\nlocal.set 78\nlocal.get 5\nlocal.get 78\ni32.store offset=4\nbr 1 (;@2;)\nend\nlocal.get 5\ni32.load\nlocal.set 79\ni32.const 1\nlocal.set 80\nlocal.get 79\nlocal.get 80\ni32.add\nlocal.set 81\nlocal.get 5\nlocal.get 81\ni32.store offset=60\ni32.const 1\nlocal.set 82\nlocal.get 5\nlocal.get 82\ni32.store offset=4\nend\ni32.const 36\nlocal.set 83\nlocal.get 5\nlocal.get 83\ni32.add\nlocal.set 84\nlocal.get 84\nlocal.set 85\nlocal.get 85\ncall 95\ndrop\nend\nlocal.get 5\ni32.load offset=60\nlocal.set 86\ni32.const 64\nlocal.set 87\nlocal.get 5\nlocal.get 87\ni32.add\nlocal.set 88\nlocal.get 88\nglobal.set 0\nlocal.get 86\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_109",
        "query_text": "The function takes two inputs: a string (passed by constant reference) and a pointer to an output stream. It checks that the string is non-empty and that the output stream pointer is not null. If both conditions are met, the function appends the string to the output stream, preceded by a comma and a space. The function returns no value.",
        "code_id": "c_group_1_id_109",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\ni32.const 65567\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nlocal.get 9\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=8\nlocal.set 10\ni32.const 0\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.ne\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nlocal.get 14\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=8\nlocal.set 15\ni32.const 65565\nlocal.set 16\nlocal.get 15\nlocal.get 16\ncall 4\nlocal.set 17\nlocal.get 4\ni32.load offset=12\nlocal.set 18\nlocal.get 17\nlocal.get 18\ncall 5\ndrop\nend\ni32.const 16\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_110",
        "query_text": "The function accepts a single integer input and returns a string that represents the frequency of an occurrence. When the input is 1, the function returns the string \"once\"; when the input is 2, it returns \"twice\". For any other integer value, the function constructs a string by concatenating the input value with the literal \" times\". The input parameter is of type int, and the output is of type std::string.",
        "code_id": "c_group_1_id_110",
        "code_text": "(func (;7;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 160\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=156\nlocal.get 4\nlocal.get 1\ni32.store offset=152\nlocal.get 4\ni32.load offset=152\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.eq\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 65928\nlocal.set 10\nlocal.get 0\nlocal.get 10\ncall 8\ndrop\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=152\nlocal.set 11\ni32.const 2\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.eq\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nblock  ;; label = @2\nlocal.get 15\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 65933\nlocal.set 16\nlocal.get 0\nlocal.get 16\ncall 8\ndrop\nbr 1 (;@1;)\nend\ni32.const 8\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 18\nlocal.set 19\nlocal.get 19\ncall 9\ndrop\ni32.const 8\nlocal.set 20\nlocal.get 4\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nlocal.set 22\ni32.const 8\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 4\ni32.load offset=152\nlocal.set 25\nlocal.get 24\nlocal.get 25\ncall 185\nlocal.set 26\ni32.const 65701\nlocal.set 27\nlocal.get 26\nlocal.get 27\ncall 10\ndrop\ni32.const 8\nlocal.set 28\nlocal.get 4\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 29\nlocal.set 30\nlocal.get 0\nlocal.get 30\ncall 11\ni32.const 8\nlocal.set 31\nlocal.get 4\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 32\nlocal.set 33\nlocal.get 33\ncall 12\ndrop\nend\ni32.const 160\nlocal.set 34\nlocal.get 4\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 35\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_111",
        "query_text": "The function accepts two parameters: a pointer to an array of unsigned characters (representing a series of bytes) and a corresponding non-negative integer indicating the number of bytes to process. It sets up platform-specific constant values based on whether it is running on a 32-bit or 64-bit system. The function iterates over each byte in the sequence, performing bitwise XOR operations followed by multiplications with a predefined constant. The outcome is an integer value (of type size_t) that represents the computed hash for the input sequence.",
        "code_id": "c_group_1_id_111",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const -2078137563\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=20\ni32.const 435\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=16\ni32.const -2078137563\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store offset=12\ni32.const 0\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=8\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=8\nlocal.set 9\nlocal.get 4\ni32.load offset=24\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.lt_u\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 13\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=28\nlocal.set 14\nlocal.get 4\ni32.load offset=8\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\ni32.load8_u\nlocal.set 17\ni32.const 255\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 4\ni32.load offset=12\nlocal.set 20\nlocal.get 20\nlocal.get 19\ni32.xor\nlocal.set 21\nlocal.get 4\nlocal.get 21\ni32.store offset=12\nlocal.get 4\ni32.load offset=12\nlocal.set 22\ni32.const 435\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.mul\nlocal.set 24\nlocal.get 4\nlocal.get 24\ni32.store offset=12\nlocal.get 4\ni32.load offset=8\nlocal.set 25\ni32.const 1\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 4\nlocal.get 27\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 28\nlocal.get 28\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_112",
        "query_text": "The function takes no input arguments and returns a reference to a constant pointer to a stream buffer object. Internally, the function utilizes a static variable to ensure that the pointer, which is initially set to point to the stream buffer of the standard logging stream, remains consistent across multiple invocations. This design guarantees that the same stream buffer is reused whenever the function is called.",
        "code_id": "c_group_1_id_112",
        "code_text": "(func (;8;) (type 9) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ni32.const 0\nlocal.set 3\nlocal.get 3\ni32.load offset=83144\nlocal.set 4\ni32.const -12\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\ni32.load\nlocal.set 7\ni32.const 83144\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.add\nlocal.set 9\nlocal.get 9\ncall 9\nlocal.set 10\nlocal.get 2\nlocal.get 10\ni32.store offset=12\ni32.const 12\nlocal.set 11\nlocal.get 2\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nlocal.set 13\ni32.const 16\nlocal.set 14\nlocal.get 2\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nglobal.set 0\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_113",
        "query_text": "The function returns a unique integer value that serves as an index for an input/output stream. It accepts no arguments and produces an integer output. Internally, it uses a static variable to store the index, ensuring that the same value is returned on every call. Its inline definition contributes to minimal overhead and efficient performance.",
        "code_id": "c_group_1_id_113",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ncall 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\ni32.const 16\nlocal.set 5\nlocal.get 2\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\nglobal.set 0\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_114",
        "query_text": "This function computes the population count of an unsigned 32-bit integer by determining the number of binary ones in its representation. It takes an unsigned 32-bit integer as input, applies a built-in compiler helper to efficiently count the ones, and returns the resulting count as an unsigned 32-bit integer. The input is an unsigned 32-bit integer, and the output represents the number of ones present in the binary form of the input.",
        "code_id": "c_group_1_id_114",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ni32.popcnt\nlocal.set 5\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_115",
        "query_text": "This function operates on a mutable C-style string provided as a null-terminated character array. It processes the string in place to remove extraneous spaces. Specifically, during its iteration, it skips any space character that immediately follows a specific marker (the '@' character) or that is immediately succeeded by another space, the marker, or the end of the string. The function ensures that the modified string remains null-terminated and does not return any value.",
        "code_id": "c_group_1_id_115",
        "code_text": "(func (;1;) (type 2) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\nlocal.get 3\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ni32.load8_u\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.store8 offset=7\ni32.const 0\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.store8 offset=6\nlocal.get 3\ni32.load offset=12\nlocal.set 8\ni32.const 0\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.store8\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load8_u offset=7\nlocal.set 10\ni32.const 0\nlocal.set 11\ni32.const 255\nlocal.set 12\nlocal.get 10\nlocal.get 12\ni32.and\nlocal.set 13\ni32.const 255\nlocal.set 14\nlocal.get 11\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 13\nlocal.get 15\ni32.ne\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nblock  ;; label = @3\nlocal.get 18\nbr_if 0 (;@3;)\nbr 2 (;@1;)\nend\nlocal.get 3\ni32.load8_u offset=7\nlocal.set 19\ni32.const 24\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 21\nlocal.get 20\ni32.shr_s\nlocal.set 22\ni32.const 32\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.eq\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 26\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 3\ni32.load8_u offset=6\nlocal.set 27\ni32.const 24\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.shl\nlocal.set 29\nlocal.get 29\nlocal.get 28\ni32.shr_s\nlocal.set 30\ni32.const 64\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.eq\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.and\nlocal.set 34\nlocal.get 34\nbr_if 1 (;@3;)\nlocal.get 3\ni32.load offset=12\nlocal.set 35\nlocal.get 35\ni32.load8_u offset=1\nlocal.set 36\ni32.const 24\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.shl\nlocal.set 38\nlocal.get 38\nlocal.get 37\ni32.shr_s\nlocal.set 39\ni32.const 32\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.eq\nlocal.set 41\ni32.const 1\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.and\nlocal.set 43\nlocal.get 43\nbr_if 1 (;@3;)\nlocal.get 3\ni32.load offset=12\nlocal.set 44\nlocal.get 44\ni32.load8_u offset=1\nlocal.set 45\ni32.const 24\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.shl\nlocal.set 47\nlocal.get 47\nlocal.get 46\ni32.shr_s\nlocal.set 48\ni32.const 64\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.eq\nlocal.set 50\ni32.const 1\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.and\nlocal.set 52\nlocal.get 52\nbr_if 1 (;@3;)\nlocal.get 3\ni32.load offset=12\nlocal.set 53\nlocal.get 53\ni32.load8_u offset=1\nlocal.set 54\ni32.const 24\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.shl\nlocal.set 56\nlocal.get 56\nlocal.get 55\ni32.shr_s\nlocal.set 57\nlocal.get 57\ni32.eqz\nbr_if 1 (;@3;)\nend\nlocal.get 3\ni32.load8_u offset=7\nlocal.set 58\nlocal.get 3\ni32.load offset=8\nlocal.set 59\ni32.const 1\nlocal.set 60\nlocal.get 59\nlocal.get 60\ni32.add\nlocal.set 61\nlocal.get 3\nlocal.get 61\ni32.store offset=8\nlocal.get 59\nlocal.get 58\ni32.store8\nlocal.get 3\ni32.load8_u offset=7\nlocal.set 62\nlocal.get 3\nlocal.get 62\ni32.store8 offset=6\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 63\ni32.const 1\nlocal.set 64\nlocal.get 63\nlocal.get 64\ni32.add\nlocal.set 65\nlocal.get 3\nlocal.get 65\ni32.store offset=12\nlocal.get 63\ni32.load8_u offset=1\nlocal.set 66\nlocal.get 3\nlocal.get 66\ni32.store8 offset=7\nlocal.get 3\ni32.load offset=12\nlocal.set 67\ni32.const 0\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.store8\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 69\ni32.const 0\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.store8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_116",
        "query_text": "The function takes no input arguments and returns a boolean value. It first checks if the code is running on a specific operating system and architecture (macOS with ARM64), in which case it immediately returns true. On other platforms, it attempts to allocate a memory page with read, write, and execute permissions. If the allocation fails, the function concludes that a hardened security feature is enabled and returns true; if the allocation succeeds, it returns false. The result of this check is cached for future calls using atomic operations to ensure thread safety.",
        "code_id": "c_group_1_id_116",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ni32.const 12\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.add\nlocal.set 4\nlocal.get 4\nlocal.set 5\ni32.const 5\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 2\nlocal.set 7\nlocal.get 2\nlocal.get 7\ni32.store offset=8\nlocal.get 2\ni32.load offset=8\nlocal.set 8\nblock  ;; label = @1\nlocal.get 8\nbr_if 0 (;@1;)\ncall 7\nlocal.set 9\nlocal.get 2\nlocal.get 9\ni32.store offset=4\nlocal.get 2\ni32.load offset=4\nlocal.set 10\ni32.const 0\nlocal.set 11\ni32.const 7\nlocal.set 12\ni32.const 34\nlocal.set 13\ni32.const -1\nlocal.set 14\ni64.const 0\nlocal.set 37\nlocal.get 11\nlocal.get 10\nlocal.get 12\nlocal.get 13\nlocal.get 14\nlocal.get 37\ncall 20\nlocal.set 15\nlocal.get 2\nlocal.get 15\ni32.store\nlocal.get 2\ni32.load\nlocal.set 16\ni32.const -1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.eq\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 20\ni32.eqz\nbr_if 0 (;@3;)\ni32.const 2\nlocal.set 21\nlocal.get 2\nlocal.get 21\ni32.store offset=8\nbr 1 (;@2;)\nend\ni32.const 1\nlocal.set 22\nlocal.get 2\nlocal.get 22\ni32.store offset=8\nlocal.get 2\ni32.load\nlocal.set 23\nlocal.get 2\ni32.load offset=4\nlocal.set 24\nlocal.get 23\nlocal.get 24\ncall 21\ndrop\nend\nlocal.get 2\ni32.load offset=8\nlocal.set 25\ni32.const 12\nlocal.set 26\nlocal.get 2\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\nlocal.set 28\ni32.const 5\nlocal.set 29\nlocal.get 28\nlocal.get 25\nlocal.get 29\ncall 3\nend\nlocal.get 2\ni32.load offset=8\nlocal.set 30\ni32.const 2\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.eq\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.and\nlocal.set 34\ni32.const 16\nlocal.set 35\nlocal.get 2\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 36\nglobal.set 0\nlocal.get 34\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_117",
        "query_text": "The function takes no input arguments and returns a boolean value indicating whether a particular system feature is supported. On one operating system with a non-standard architecture, it immediately returns true. On the same operating system but with a different architecture, it checks the system's kernel version; if the kernel version meets a specified minimum, it returns true, otherwise false, with the result cached for subsequent calls. On all other systems, it returns false. The output is of type bool.",
        "code_id": "c_group_1_id_117",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32)\ni32.const 0\nlocal.set 0\ni32.const 1\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.and\nlocal.set 2\nlocal.get 2\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_118",
        "query_text": "The function takes a floating-point value as its input and evaluates its sign. It determines whether the input is positive, negative, or zero by comparing the value to zero. If the input is greater than zero, the function returns a positive floating-point value; if less than zero, it returns a negative floating-point value; and if equal to zero, it returns zero. The primary purpose of the function is to indicate the sign of the input float using these comparisons.",
        "code_id": "c_group_1_id_118",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 13\ni32.const 0\nlocal.set 4\nlocal.get 4\nf32.convert_i32_s\nlocal.set 14\nlocal.get 13\nlocal.get 14\nf32.gt\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 3\nf32.load offset=12\nlocal.set 15\ni32.const 0\nlocal.set 8\nlocal.get 8\nf32.convert_i32_s\nlocal.set 16\nlocal.get 15\nlocal.get 16\nf32.lt\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 7\nlocal.get 11\ni32.sub\nlocal.set 12\nlocal.get 12\nf32.convert_i32_s\nlocal.set 17\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_119",
        "query_text": "The function takes a single floating-point input representing a numerical value and computes its square. It does this by multiplying the input by itself, returning the result as a floating-point value. The operation effectively calculates the square of the given number.",
        "code_id": "c_group_1_id_119",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nlocal.get 3\nf32.load offset=12\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf32.mul\nlocal.set 6\nlocal.get 6\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_120",
        "query_text": "The function takes three inputs, all of type float. The first two floats represent the starting and ending values for interpolation, while the third float specifies the interpolation factor. The function computes the result by adding the product of the interpolation factor and the difference between the ending and starting values to the starting value. If the interpolation factor is 0, the output is the starting value; if it is 1, the output is the ending value; intermediate values yield a proportional blend of the two. The function returns a float representing the interpolated value.",
        "code_id": "c_group_1_id_120",
        "code_text": "(func (;1;) (type 2) (param f32 f32 f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\nf32.store offset=12\nlocal.get 5\nlocal.get 1\nf32.store offset=8\nlocal.get 5\nlocal.get 2\nf32.store offset=4\nlocal.get 5\nf32.load offset=12\nlocal.set 6\nlocal.get 5\nf32.load offset=4\nlocal.set 7\nlocal.get 5\nf32.load offset=8\nlocal.set 8\nlocal.get 5\nf32.load offset=12\nlocal.set 9\nlocal.get 8\nlocal.get 9\nf32.sub\nlocal.set 10\nlocal.get 7\nlocal.get 10\nf32.mul\nlocal.set 11\nlocal.get 11\nlocal.get 6\nf32.add\nlocal.set 12\nlocal.get 12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_121",
        "query_text": "The function takes a floating-point input and returns a floating-point output. It computes a smooth interpolation by applying a cubic easing transformation based on the input, specifically through a quadratic combination that clamps the output between 0 and 1 when the input is within that range. This behavior is ideal for generating smooth transitions or easing effects in animations and interpolations.",
        "code_id": "c_group_1_id_121",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nlocal.get 3\nf32.load offset=12\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf32.mul\nlocal.set 6\nlocal.get 3\nf32.load offset=12\nlocal.set 7\nlocal.get 7\nlocal.get 7\nf32.add\nlocal.set 8\nf32.const 0x1.8p+1 (;=3;)\nlocal.set 9\nlocal.get 9\nlocal.get 8\nf32.sub\nlocal.set 10\nlocal.get 6\nlocal.get 10\nf32.mul\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_122",
        "query_text": "The function takes two pointers to floating-point numbers as input and swaps the values stored at those memory locations. It operates by temporarily storing the value from the first pointer, replacing that slot with the value from the second pointer, and finally assigning the stored value to the second pointer. The function does not return any value; it modifies the floating-point numbers in place.",
        "code_id": "c_group_1_id_122",
        "code_text": "(func (;1;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 f32 f32 f32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\nf32.load\nlocal.set 9\nlocal.get 4\nlocal.get 9\nf32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 6\nf32.load\nlocal.set 10\nlocal.get 4\ni32.load offset=12\nlocal.set 7\nlocal.get 7\nlocal.get 10\nf32.store\nlocal.get 4\nf32.load offset=4\nlocal.set 11\nlocal.get 4\ni32.load offset=8\nlocal.set 8\nlocal.get 8\nlocal.get 11\nf32.store\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_123",
        "query_text": "The function accepts a single floating-point parameter. It applies a linear transformation by simply returning the input value unchanged, thereby preserving a direct one-to-one relationship between input and output. Both the input and output are of type float, and the function does not modify or scale the value in any way.",
        "code_id": "c_group_1_id_123",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_124",
        "query_text": "The function accepts two inputs: a pointer to an unsigned character array and a size value representing the length of the memory region. It then releases the allocated memory block by invoking the system's memory unmapping operation. This effectively frees up the memory for future use. The function does not produce any output.",
        "code_id": "c_group_1_id_124",
        "code_text": "(func (;1;) (type 4) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 10\ndrop\ni32.const 16\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_125",
        "query_text": "The function is a static void procedure that takes no inputs and does not return any value. Its purpose is to display a comprehensive help message on the standard output, guiding the user on how to use a string sorting program. The message outlines various command-line options such as validating output, controlling performance monitoring through file descriptors, enabling specific profiling tools, listing available algorithms both in descriptive and script-friendly formats, and directing the sorted output to a specified file. It also illustrates the use of suffix sorting and supports alternative output formats like XML or human-readable statistics. Additionally, the help message provides several usage examples to assist the user in correctly invoking different functionalities of the program.",
        "code_id": "c_group_1_id_125",
        "code_text": "(func (;2;) (type 3)\n(local i32)\ni32.const 65536\nlocal.set 0\nlocal.get 0\ncall 13\ndrop\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_126",
        "query_text": "The function accepts three parameters: an integer representing the count of command-line arguments, an array of character pointers holding the arguments, and a pointer to a file stream where output should be directed. It first checks if the file stream pointer is valid; if it is not, the function terminates without performing any output. If the stream is valid, the function writes a fixed prefix (\"Command line:\") to the stream, then iterates over the array of arguments\u2014writing each argument preceded by a space\u2014and finally outputs a newline character. The function does not return any value.",
        "code_id": "c_group_1_id_126",
        "code_text": "(func (;1;) (type 4) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\nlocal.get 5\ni32.load offset=20\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 10\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\nlocal.get 5\ni32.load offset=20\nlocal.set 11\ni32.const 65585\nlocal.set 12\ni32.const 0\nlocal.set 13\nlocal.get 11\nlocal.get 12\nlocal.get 13\ncall 3\ndrop\ni32.const 0\nlocal.set 14\nlocal.get 5\nlocal.get 14\ni32.store offset=16\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 5\ni32.load offset=16\nlocal.set 15\nlocal.get 5\ni32.load offset=28\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.lt_s\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 19\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 5\ni32.load offset=20\nlocal.set 20\nlocal.get 5\ni32.load offset=24\nlocal.set 21\nlocal.get 5\ni32.load offset=16\nlocal.set 22\ni32.const 2\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.shl\nlocal.set 24\nlocal.get 21\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\ni32.load\nlocal.set 26\nlocal.get 5\nlocal.get 26\ni32.store\ni32.const 65565\nlocal.set 27\nlocal.get 20\nlocal.get 27\nlocal.get 5\ncall 3\ndrop\nlocal.get 5\ni32.load offset=16\nlocal.set 28\ni32.const 1\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.add\nlocal.set 30\nlocal.get 5\nlocal.get 30\ni32.store offset=16\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 5\ni32.load offset=20\nlocal.set 31\ni32.const 65608\nlocal.set 32\ni32.const 0\nlocal.set 33\nlocal.get 31\nlocal.get 32\nlocal.get 33\ncall 3\ndrop\nend\ni32.const 32\nlocal.set 34\nlocal.get 5\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 35\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_127",
        "query_text": "This function performs a lexicographical comparison between two null-terminated arrays of bytes. It takes two inputs, each being a pointer to an unsigned character array, and uses assertions to ensure neither pointer is null. It then converts the input arrays to C-style strings and calls the standard string comparison function to determine their relative ordering, returning an integer result that indicates whether the first array is less than, equal to, or greater than the second array.",
        "code_id": "c_group_1_id_127",
        "code_text": "(func (;5;) (type 5) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.ne\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 65666\nlocal.set 10\ni32.const 65565\nlocal.set 11\ni32.const 20\nlocal.set 12\ni32.const 65682\nlocal.set 13\nlocal.get 10\nlocal.get 11\nlocal.get 12\nlocal.get 13\ncall 7\nunreachable\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 14\ni32.const 0\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.ne\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 18\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 65659\nlocal.set 19\ni32.const 65565\nlocal.set 20\ni32.const 21\nlocal.set 21\ni32.const 65682\nlocal.set 22\nlocal.get 19\nlocal.get 20\nlocal.get 21\nlocal.get 22\ncall 7\nunreachable\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 23\nlocal.get 4\ni32.load offset=8\nlocal.set 24\nlocal.get 23\nlocal.get 24\ncall 17\nlocal.set 25\ni32.const 16\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\nglobal.set 0\nlocal.get 25\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_128",
        "query_text": "The function takes an unsigned 8-bit integer representing a character as input and returns a string representing that character. If the input is a displayable character, it is directly converted to its string equivalent; otherwise, the function produces a string in which the integer value of the non-printable character is enclosed in angle brackets. The resulting string is returned as the output.",
        "code_id": "c_group_1_id_128",
        "code_text": "(func (;7;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 144\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=140\nlocal.get 4\nlocal.get 1\ni32.store8 offset=139\nlocal.get 4\nlocal.set 5\nlocal.get 5\ncall 8\ndrop\nlocal.get 4\ni32.load8_u offset=139\nlocal.set 6\ni32.const 255\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nlocal.get 8\ncall 60\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load8_u offset=139\nlocal.set 10\nlocal.get 4\nlocal.set 11\ni32.const 255\nlocal.set 12\nlocal.get 10\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 11\nlocal.get 13\ncall 9\ndrop\nbr 1 (;@1;)\nend\nlocal.get 4\nlocal.set 14\ni32.const 60\nlocal.set 15\ni32.const 24\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.shl\nlocal.set 17\nlocal.get 17\nlocal.get 16\ni32.shr_s\nlocal.set 18\nlocal.get 14\nlocal.get 18\ncall 10\nlocal.set 19\nlocal.get 4\ni32.load8_u offset=139\nlocal.set 20\ni32.const 255\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 19\nlocal.get 22\ncall 176\nlocal.set 23\ni32.const 62\nlocal.set 24\ni32.const 24\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.shl\nlocal.set 26\nlocal.get 26\nlocal.get 25\ni32.shr_s\nlocal.set 27\nlocal.get 23\nlocal.get 27\ncall 10\ndrop\nend\nlocal.get 4\nlocal.set 28\nlocal.get 0\nlocal.get 28\ncall 11\nlocal.get 4\nlocal.set 29\nlocal.get 29\ncall 12\ndrop\ni32.const 144\nlocal.set 30\nlocal.get 4\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 31\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_129",
        "query_text": "This function accepts a 16-bit unsigned integer as its parameter and returns a string representation of the input. It operates by dividing the input into two 8-bit segments: one corresponding to the upper half and the other to the lower half of the original value. Each segment is individually converted to a string via a helper conversion method, after which the two strings are concatenated. The final result is the combined string that reflects the original 16-bit integer.",
        "code_id": "c_group_1_id_129",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store16 offset=26\nlocal.get 4\ni32.load16_u offset=26\nlocal.set 5\ni32.const 65535\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\ni32.const 65280\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\ni32.const 8\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.shr_s\nlocal.set 11\ni32.const 255\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\ni32.const 12\nlocal.set 14\nlocal.get 4\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nlocal.set 16\ni32.const 65535\nlocal.set 17\nlocal.get 13\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 16\nlocal.get 18\ncall 2\nlocal.get 4\ni32.load16_u offset=26\nlocal.set 19\ni32.const 255\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.and\nlocal.set 21\nlocal.get 4\nlocal.set 22\ni32.const 65535\nlocal.set 23\nlocal.get 21\nlocal.get 23\ni32.and\nlocal.set 24\nlocal.get 22\nlocal.get 24\ncall 2\ni32.const 12\nlocal.set 25\nlocal.get 4\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 26\nlocal.set 27\nlocal.get 4\nlocal.set 28\nlocal.get 0\nlocal.get 27\nlocal.get 28\ncall 3\nlocal.get 4\nlocal.set 29\nlocal.get 29\ncall 81\ndrop\ni32.const 12\nlocal.set 30\nlocal.get 4\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 31\nlocal.set 32\nlocal.get 32\ncall 81\ndrop\ni32.const 32\nlocal.set 33\nlocal.get 4\nlocal.get 33\ni32.add\nlocal.set 34\nlocal.get 34\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_130",
        "query_text": "This function accepts a single character input. It then checks if the input represents a valid hexadecimal digit by determining whether it falls within the range of numeric digits or lowercase alphabetical characters corresponding to hexadecimal values. The output is an integer value, where 1 indicates a valid hexadecimal digit and 0 indicates an invalid one.",
        "code_id": "c_group_1_id_130",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.shr_s\nlocal.set 7\ni32.const 48\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.ge_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 11\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 12\ni32.const 24\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.shl\nlocal.set 14\nlocal.get 14\nlocal.get 13\ni32.shr_s\nlocal.set 15\ni32.const 57\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.le_s\nlocal.set 17\ni32.const 1\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 17\nlocal.get 19\ni32.and\nlocal.set 20\nlocal.get 18\nlocal.set 21\nlocal.get 20\nbr_if 1 (;@1;)\nend\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 22\ni32.const 24\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.shl\nlocal.set 24\nlocal.get 24\nlocal.get 23\ni32.shr_s\nlocal.set 25\ni32.const 97\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.ge_s\nlocal.set 27\ni32.const 0\nlocal.set 28\ni32.const 1\nlocal.set 29\nlocal.get 27\nlocal.get 29\ni32.and\nlocal.set 30\nlocal.get 28\nlocal.set 31\nblock  ;; label = @2\nlocal.get 30\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 32\ni32.const 24\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.shl\nlocal.set 34\nlocal.get 34\nlocal.get 33\ni32.shr_s\nlocal.set 35\ni32.const 102\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.le_s\nlocal.set 37\nlocal.get 37\nlocal.set 31\nend\nlocal.get 31\nlocal.set 38\nlocal.get 38\nlocal.set 21\nend\nlocal.get 21\nlocal.set 39\ni32.const 1\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.and\nlocal.set 41\nlocal.get 41\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_131",
        "query_text": "The function takes three inputs: a pointer to an array of null-terminated strings (each string represented as an array of unsigned characters), an integer indicating the total number of strings, and an integer specifying the starting index for character comparison. It implements an insertion sort algorithm to reorder the strings in ascending order based on their characters starting from the given index. During the sorting process, each string is compared to the ones preceding it, and inserted in its appropriate position within the array. The function does not produce a return value, as it directly modifies the order of the strings in the input array.",
        "code_id": "c_group_1_id_131",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\nlocal.get 5\ni32.load offset=28\nlocal.set 6\ni32.const 4\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.store offset=16\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=24\nlocal.set 9\ni32.const -1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 5\nlocal.get 11\ni32.store offset=24\ni32.const 0\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.gt_s\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=16\nlocal.set 16\nlocal.get 16\ni32.load\nlocal.set 17\nlocal.get 5\nlocal.get 17\ni32.store\nlocal.get 5\ni32.load offset=16\nlocal.set 18\nlocal.get 5\nlocal.get 18\ni32.store offset=12\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 5\ni32.load offset=12\nlocal.set 19\nlocal.get 5\ni32.load offset=28\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.gt_u\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.and\nlocal.set 23\nlocal.get 23\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 5\ni32.load offset=12\nlocal.set 24\ni32.const -4\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 26\ni32.load\nlocal.set 27\nlocal.get 5\ni32.load offset=20\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 5\nlocal.get 29\ni32.store offset=8\nlocal.get 5\ni32.load\nlocal.set 30\nlocal.get 5\ni32.load offset=20\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 5\nlocal.get 32\ni32.store offset=4\nloop  ;; label = @5\nlocal.get 5\ni32.load offset=8\nlocal.set 33\nlocal.get 33\ni32.load8_u\nlocal.set 34\ni32.const 255\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.and\nlocal.set 36\nlocal.get 5\ni32.load offset=4\nlocal.set 37\nlocal.get 37\ni32.load8_u\nlocal.set 38\ni32.const 255\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.and\nlocal.set 40\nlocal.get 36\nlocal.get 40\ni32.eq\nlocal.set 41\ni32.const 0\nlocal.set 42\ni32.const 1\nlocal.set 43\nlocal.get 41\nlocal.get 43\ni32.and\nlocal.set 44\nlocal.get 42\nlocal.set 45\nblock  ;; label = @6\nlocal.get 44\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 5\ni32.load offset=8\nlocal.set 46\nlocal.get 46\ni32.load8_u\nlocal.set 47\ni32.const 255\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.and\nlocal.set 49\ni32.const 0\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.ne\nlocal.set 51\nlocal.get 51\nlocal.set 45\nend\nlocal.get 45\nlocal.set 52\ni32.const 1\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.and\nlocal.set 54\nblock  ;; label = @6\nlocal.get 54\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 5\ni32.load offset=8\nlocal.set 55\ni32.const 1\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.add\nlocal.set 57\nlocal.get 5\nlocal.get 57\ni32.store offset=8\nlocal.get 5\ni32.load offset=4\nlocal.set 58\ni32.const 1\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.add\nlocal.set 60\nlocal.get 5\nlocal.get 60\ni32.store offset=4\nbr 1 (;@5;)\nend\nend\nlocal.get 5\ni32.load offset=8\nlocal.set 61\nlocal.get 61\ni32.load8_u\nlocal.set 62\ni32.const 255\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.and\nlocal.set 64\nlocal.get 5\ni32.load offset=4\nlocal.set 65\nlocal.get 65\ni32.load8_u\nlocal.set 66\ni32.const 255\nlocal.set 67\nlocal.get 66\nlocal.get 67\ni32.and\nlocal.set 68\nlocal.get 64\nlocal.get 68\ni32.le_s\nlocal.set 69\ni32.const 1\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.and\nlocal.set 71\nblock  ;; label = @5\nlocal.get 71\ni32.eqz\nbr_if 0 (;@5;)\nbr 2 (;@3;)\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 72\ni32.const -4\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.add\nlocal.set 74\nlocal.get 74\ni32.load\nlocal.set 75\nlocal.get 5\ni32.load offset=12\nlocal.set 76\nlocal.get 76\nlocal.get 75\ni32.store\nlocal.get 5\ni32.load offset=12\nlocal.set 77\ni32.const -4\nlocal.set 78\nlocal.get 77\nlocal.get 78\ni32.add\nlocal.set 79\nlocal.get 5\nlocal.get 79\ni32.store offset=12\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 5\ni32.load\nlocal.set 80\nlocal.get 5\ni32.load offset=12\nlocal.set 81\nlocal.get 81\nlocal.get 80\ni32.store\nlocal.get 5\ni32.load offset=16\nlocal.set 82\ni32.const 4\nlocal.set 83\nlocal.get 82\nlocal.get 83\ni32.add\nlocal.set 84\nlocal.get 5\nlocal.get 84\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_132",
        "query_text": "The function accepts two inputs: pointers to unsigned characters (commonly representing strings). It compares the characters of the two strings sequentially until it encounters a mismatched character or reaches the terminating null character in either string. The function then returns an integer that represents the difference between the ASCII values of the first pair of characters that do not match. If the strings are identical, it returns 0.",
        "code_id": "c_group_1_id_132",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nloop  ;; label = @1\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ni32.load8_u\nlocal.set 6\ni32.const 255\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\ni32.const 0\nlocal.set 9\nlocal.get 9\nlocal.set 10\nblock  ;; label = @2\nlocal.get 8\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 11\nlocal.get 11\ni32.load8_u\nlocal.set 12\ni32.const 255\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nlocal.get 4\ni32.load offset=8\nlocal.set 15\nlocal.get 15\ni32.load8_u\nlocal.set 16\ni32.const 255\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 14\nlocal.get 18\ni32.eq\nlocal.set 19\nlocal.get 19\nlocal.set 10\nend\nlocal.get 10\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nblock  ;; label = @2\nlocal.get 22\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 4\nlocal.get 25\ni32.store offset=12\nlocal.get 4\ni32.load offset=8\nlocal.set 26\ni32.const 1\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 4\nlocal.get 28\ni32.store offset=8\nbr 1 (;@1;)\nend\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 29\nlocal.get 29\ni32.load8_u\nlocal.set 30\ni32.const 255\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nlocal.get 4\ni32.load offset=8\nlocal.set 33\nlocal.get 33\ni32.load8_u\nlocal.set 34\ni32.const 255\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.and\nlocal.set 36\nlocal.get 32\nlocal.get 36\ni32.sub\nlocal.set 37\nlocal.get 37\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_133",
        "query_text": "The function takes two pointer-to-pointer parameters that reference memory blocks of unsigned characters and an integer specifying the number of iterations. In each iteration, it swaps the memory locations pointed to by the two pointer parameters and then increments both pointers. This process is repeated until the specified number of swaps is completed. The function performs the operations in place and does not return any value (void).",
        "code_id": "c_group_1_id_133",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=4\nlocal.set 6\ni32.const -1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.store offset=4\ni32.const 0\nlocal.set 9\nlocal.get 6\nlocal.get 9\ni32.gt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=12\nlocal.set 13\nlocal.get 13\ni32.load\nlocal.set 14\nlocal.get 5\nlocal.get 14\ni32.store\nlocal.get 5\ni32.load offset=8\nlocal.set 15\nlocal.get 15\ni32.load\nlocal.set 16\nlocal.get 5\ni32.load offset=12\nlocal.set 17\ni32.const 4\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 5\nlocal.get 19\ni32.store offset=12\nlocal.get 17\nlocal.get 16\ni32.store\nlocal.get 5\ni32.load\nlocal.set 20\nlocal.get 5\ni32.load offset=8\nlocal.set 21\ni32.const 4\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 5\nlocal.get 23\ni32.store offset=8\nlocal.get 21\nlocal.get 20\ni32.store\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_134",
        "query_text": "The function accepts four parameters: three pointers to pointers of an unsigned byte and an integer representing the depth for comparison. It first extracts an integer value from each of the three pointer targets using an external helper function (assumed to retrieve the corresponding value at the specified depth). If the two values from the first and second pointers are equal, it immediately returns the first pointer. Otherwise, if the value from the third pointer matches either of the first two values, it returns the third pointer. If no matches are found, it returns the pointer corresponding to the median value among the three. The result is a pointer to a pointer of unsigned byte.",
        "code_id": "c_group_1_id_134",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 4\ni32.const 32\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nlocal.get 0\ni32.store offset=24\nlocal.get 6\nlocal.get 1\ni32.store offset=20\nlocal.get 6\nlocal.get 2\ni32.store offset=16\nlocal.get 6\nlocal.get 3\ni32.store offset=12\nlocal.get 6\ni32.load offset=24\nlocal.set 7\nlocal.get 7\ni32.load\nlocal.set 8\nlocal.get 6\ni32.load offset=12\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\ni32.load8_u\nlocal.set 11\ni32.const 255\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 6\nlocal.get 13\ni32.store offset=8\nlocal.get 6\ni32.load offset=20\nlocal.set 14\nlocal.get 14\ni32.load\nlocal.set 15\nlocal.get 6\ni32.load offset=12\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\ni32.load8_u\nlocal.set 18\ni32.const 255\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\nlocal.get 6\nlocal.get 20\ni32.store offset=4\nlocal.get 13\nlocal.get 20\ni32.eq\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.and\nlocal.set 23\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 23\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 6\ni32.load offset=24\nlocal.set 24\nlocal.get 6\nlocal.get 24\ni32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=16\nlocal.set 25\nlocal.get 25\ni32.load\nlocal.set 26\nlocal.get 6\ni32.load offset=12\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 28\ni32.load8_u\nlocal.set 29\ni32.const 255\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.and\nlocal.set 31\nlocal.get 6\nlocal.get 31\ni32.store\nlocal.get 6\ni32.load offset=8\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.eq\nlocal.set 33\ni32.const 1\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.and\nlocal.set 35\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 35\nbr_if 0 (;@3;)\nlocal.get 6\ni32.load\nlocal.set 36\nlocal.get 6\ni32.load offset=4\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.eq\nlocal.set 38\ni32.const 1\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.and\nlocal.set 40\nlocal.get 40\ni32.eqz\nbr_if 1 (;@2;)\nend\nlocal.get 6\ni32.load offset=16\nlocal.set 41\nlocal.get 6\nlocal.get 41\ni32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=8\nlocal.set 42\nlocal.get 6\ni32.load offset=4\nlocal.set 43\nlocal.get 42\nlocal.get 43\ni32.lt_s\nlocal.set 44\ni32.const 1\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.and\nlocal.set 46\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 46\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 6\ni32.load offset=4\nlocal.set 47\nlocal.get 6\ni32.load\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.lt_s\nlocal.set 49\ni32.const 1\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.and\nlocal.set 51\nblock  ;; label = @4\nblock  ;; label = @5\nlocal.get 51\ni32.eqz\nbr_if 0 (;@5;)\nlocal.get 6\ni32.load offset=20\nlocal.set 52\nlocal.get 52\nlocal.set 53\nbr 1 (;@4;)\nend\nlocal.get 6\ni32.load offset=8\nlocal.set 54\nlocal.get 6\ni32.load\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.lt_s\nlocal.set 56\ni32.const 1\nlocal.set 57\nlocal.get 56\nlocal.get 57\ni32.and\nlocal.set 58\nblock  ;; label = @5\nblock  ;; label = @6\nlocal.get 58\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 6\ni32.load offset=16\nlocal.set 59\nlocal.get 59\nlocal.set 60\nbr 1 (;@5;)\nend\nlocal.get 6\ni32.load offset=24\nlocal.set 61\nlocal.get 61\nlocal.set 60\nend\nlocal.get 60\nlocal.set 62\nlocal.get 62\nlocal.set 53\nend\nlocal.get 53\nlocal.set 63\nlocal.get 63\nlocal.set 64\nbr 1 (;@2;)\nend\nlocal.get 6\ni32.load offset=4\nlocal.set 65\nlocal.get 6\ni32.load\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.gt_s\nlocal.set 67\ni32.const 1\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.and\nlocal.set 69\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 69\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 6\ni32.load offset=20\nlocal.set 70\nlocal.get 70\nlocal.set 71\nbr 1 (;@3;)\nend\nlocal.get 6\ni32.load offset=8\nlocal.set 72\nlocal.get 6\ni32.load\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.lt_s\nlocal.set 74\ni32.const 1\nlocal.set 75\nlocal.get 74\nlocal.get 75\ni32.and\nlocal.set 76\nblock  ;; label = @4\nblock  ;; label = @5\nlocal.get 76\ni32.eqz\nbr_if 0 (;@5;)\nlocal.get 6\ni32.load offset=24\nlocal.set 77\nlocal.get 77\nlocal.set 78\nbr 1 (;@4;)\nend\nlocal.get 6\ni32.load offset=16\nlocal.set 79\nlocal.get 79\nlocal.set 78\nend\nlocal.get 78\nlocal.set 80\nlocal.get 80\nlocal.set 71\nend\nlocal.get 71\nlocal.set 81\nlocal.get 81\nlocal.set 64\nend\nlocal.get 64\nlocal.set 82\nlocal.get 6\nlocal.get 82\ni32.store offset=28\nend\nlocal.get 6\ni32.load offset=28\nlocal.set 83\nlocal.get 83\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_135",
        "query_text": "The function sorts an array of strings in place using the insertion sort algorithm. It takes as input an array of strings (pointers to unsigned characters), an integer representing the number of strings in the array, and a size_t value specifying the depth from which to begin comparing the strings lexicographically. The function modifies the input array directly and does not return any value.",
        "code_id": "c_group_1_id_135",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\nlocal.get 5\ni32.load offset=28\nlocal.set 6\ni32.const 4\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.store offset=16\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=24\nlocal.set 9\ni32.const -1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 5\nlocal.get 11\ni32.store offset=24\ni32.const 0\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.gt_s\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=16\nlocal.set 16\nlocal.get 5\nlocal.get 16\ni32.store offset=12\nlocal.get 5\ni32.load offset=16\nlocal.set 17\nlocal.get 17\ni32.load\nlocal.set 18\nlocal.get 5\nlocal.get 18\ni32.store offset=8\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 5\ni32.load offset=12\nlocal.set 19\nlocal.get 5\ni32.load offset=28\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.gt_u\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.and\nlocal.set 23\nlocal.get 23\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 5\ni32.load offset=12\nlocal.set 24\ni32.const -4\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 26\ni32.load\nlocal.set 27\nlocal.get 5\ni32.load offset=20\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 5\nlocal.get 29\ni32.store offset=4\nlocal.get 5\ni32.load offset=8\nlocal.set 30\nlocal.get 5\ni32.load offset=20\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 5\nlocal.get 32\ni32.store\nloop  ;; label = @5\nlocal.get 5\ni32.load offset=4\nlocal.set 33\nlocal.get 33\ni32.load8_u\nlocal.set 34\ni32.const 255\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.and\nlocal.set 36\nlocal.get 5\ni32.load\nlocal.set 37\nlocal.get 37\ni32.load8_u\nlocal.set 38\ni32.const 255\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.and\nlocal.set 40\nlocal.get 36\nlocal.get 40\ni32.eq\nlocal.set 41\ni32.const 0\nlocal.set 42\ni32.const 1\nlocal.set 43\nlocal.get 41\nlocal.get 43\ni32.and\nlocal.set 44\nlocal.get 42\nlocal.set 45\nblock  ;; label = @6\nlocal.get 44\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 5\ni32.load offset=4\nlocal.set 46\nlocal.get 46\ni32.load8_u\nlocal.set 47\ni32.const 0\nlocal.set 48\ni32.const 255\nlocal.set 49\nlocal.get 47\nlocal.get 49\ni32.and\nlocal.set 50\ni32.const 255\nlocal.set 51\nlocal.get 48\nlocal.get 51\ni32.and\nlocal.set 52\nlocal.get 50\nlocal.get 52\ni32.ne\nlocal.set 53\nlocal.get 53\nlocal.set 45\nend\nlocal.get 45\nlocal.set 54\ni32.const 1\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.and\nlocal.set 56\nblock  ;; label = @6\nlocal.get 56\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 5\ni32.load offset=4\nlocal.set 57\ni32.const 1\nlocal.set 58\nlocal.get 57\nlocal.get 58\ni32.add\nlocal.set 59\nlocal.get 5\nlocal.get 59\ni32.store offset=4\nlocal.get 5\ni32.load\nlocal.set 60\ni32.const 1\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.add\nlocal.set 62\nlocal.get 5\nlocal.get 62\ni32.store\nbr 1 (;@5;)\nend\nend\nlocal.get 5\ni32.load offset=4\nlocal.set 63\nlocal.get 63\ni32.load8_u\nlocal.set 64\ni32.const 255\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.and\nlocal.set 66\nlocal.get 5\ni32.load\nlocal.set 67\nlocal.get 67\ni32.load8_u\nlocal.set 68\ni32.const 255\nlocal.set 69\nlocal.get 68\nlocal.get 69\ni32.and\nlocal.set 70\nlocal.get 66\nlocal.get 70\ni32.le_s\nlocal.set 71\ni32.const 1\nlocal.set 72\nlocal.get 71\nlocal.get 72\ni32.and\nlocal.set 73\nblock  ;; label = @5\nlocal.get 73\ni32.eqz\nbr_if 0 (;@5;)\nbr 2 (;@3;)\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 74\ni32.const -4\nlocal.set 75\nlocal.get 74\nlocal.get 75\ni32.add\nlocal.set 76\nlocal.get 76\ni32.load\nlocal.set 77\nlocal.get 5\ni32.load offset=12\nlocal.set 78\nlocal.get 78\nlocal.get 77\ni32.store\nlocal.get 5\ni32.load offset=12\nlocal.set 79\ni32.const -4\nlocal.set 80\nlocal.get 79\nlocal.get 80\ni32.add\nlocal.set 81\nlocal.get 5\nlocal.get 81\ni32.store offset=12\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 5\ni32.load offset=8\nlocal.set 82\nlocal.get 5\ni32.load offset=12\nlocal.set 83\nlocal.get 83\nlocal.get 82\ni32.store\nlocal.get 5\ni32.load offset=16\nlocal.set 84\ni32.const 4\nlocal.set 85\nlocal.get 84\nlocal.get 85\ni32.add\nlocal.set 86\nlocal.get 5\nlocal.get 86\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_136",
        "query_text": "The function accepts two integer inputs and returns an integer that indicates their relative ordering. Specifically, it returns \u20131 if the first input is less than the second, 1 if the first input is greater than the second, and 0 if the two inputs are equal. The function uses simple conditional checks to determine the relationship between the two integers.",
        "code_id": "c_group_1_id_136",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 5\nlocal.get 4\ni32.load offset=4\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.lt_s\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 11\nlocal.get 4\ni32.load offset=4\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.gt_s\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nblock  ;; label = @2\nlocal.get 15\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 1\nlocal.set 16\nlocal.get 4\nlocal.get 16\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.store offset=12\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 18\nlocal.get 18\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_137",
        "query_text": "The function receives four inputs: a pointer to a character array representing a file path, a pointer to an unsigned character array serving as a byte buffer, a size value indicating the number of bytes in the buffer, and an integer representing a count. Initially, it checks whether the integer is non-negative and, if so, prints a failure message along with the corresponding document number. The function then opens the file specified by the path in binary read mode and proceeds to read its contents in fixed-size chunks. As each chunk is read, it is written to the standard output while simultaneously accumulating the total number of bytes processed. Once the entire file is read, the file is closed, and the function prints the total size of the file data followed by the contents of the provided byte buffer along with its size. Finally, the function returns a value of 0, indicating successful completion.",
        "code_id": "c_group_1_id_137",
        "code_text": "(func (;6;) (type 5) (param i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 4\ni32.const 65616\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nglobal.set 0\nlocal.get 6\nlocal.get 0\ni32.store offset=65612\nlocal.get 6\nlocal.get 1\ni32.store offset=65608\nlocal.get 6\nlocal.get 2\ni32.store offset=65604\nlocal.get 6\nlocal.get 3\ni32.store offset=65600\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.store offset=44\ni32.const 0\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.store offset=40\nlocal.get 6\ni32.load offset=65600\nlocal.set 9\ni32.const 0\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.ge_s\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @1\nlocal.get 13\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 6\ni32.load offset=65600\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 6\nlocal.get 16\ni32.store offset=32\ni32.const 65832\nlocal.set 17\ni32.const 32\nlocal.set 18\nlocal.get 6\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 17\nlocal.get 19\ncall 46\ndrop\nend\nlocal.get 6\ni32.load offset=65612\nlocal.set 20\ni32.const 65739\nlocal.set 21\nlocal.get 20\nlocal.get 21\ncall 32\nlocal.set 22\nlocal.get 6\nlocal.get 22\ni32.store offset=65596\nlocal.get 6\ni32.load offset=65596\nlocal.set 23\ni32.const 0\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.ne\nlocal.set 25\ni32.const 1\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.and\nlocal.set 27\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 27\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 65734\nlocal.set 28\ni32.const 65589\nlocal.set 29\ni32.const 27\nlocal.set 30\ni32.const 65756\nlocal.set 31\nlocal.get 28\nlocal.get 29\nlocal.get 30\nlocal.get 31\ncall 8\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 6\ni32.load offset=44\nlocal.set 32\ni32.const 0\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.gt_u\nlocal.set 34\ni32.const 1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.and\nlocal.set 36\nlocal.get 36\ni32.eqz\nbr_if 1 (;@1;)\ni32.const 48\nlocal.set 37\nlocal.get 6\nlocal.get 37\ni32.add\nlocal.set 38\nlocal.get 38\nlocal.set 39\nlocal.get 6\ni32.load offset=65596\nlocal.set 40\ni32.const 1\nlocal.set 41\ni32.const 65536\nlocal.set 42\nlocal.get 39\nlocal.get 41\nlocal.get 42\nlocal.get 40\ncall 36\nlocal.set 43\nlocal.get 6\nlocal.get 43\ni32.store offset=44\nlocal.get 6\ni32.load offset=65596\nlocal.set 44\nlocal.get 44\ncall 22\nlocal.set 45\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 45\nbr_if 0 (;@4;)\nbr 1 (;@3;)\nend\ni32.const 65818\nlocal.set 46\ni32.const 65589\nlocal.set 47\ni32.const 30\nlocal.set 48\ni32.const 65756\nlocal.set 49\nlocal.get 46\nlocal.get 47\nlocal.get 48\nlocal.get 49\ncall 8\nunreachable\nend\nlocal.get 6\ni32.load offset=44\nlocal.set 50\nblock  ;; label = @3\nlocal.get 50\nbr_if 0 (;@3;)\nbr 2 (;@1;)\nend\ni32.const 48\nlocal.set 51\nlocal.get 6\nlocal.get 51\ni32.add\nlocal.set 52\nlocal.get 52\nlocal.set 53\nlocal.get 6\ni32.load offset=44\nlocal.set 54\ni32.const 0\nlocal.set 55\nlocal.get 55\ni32.load offset=65936\nlocal.set 56\ni32.const 1\nlocal.set 57\nlocal.get 53\nlocal.get 57\nlocal.get 54\nlocal.get 56\ncall 39\nlocal.set 58\nlocal.get 6\ni32.load offset=44\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.eq\nlocal.set 60\ni32.const 1\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.and\nlocal.set 62\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 62\ni32.eqz\nbr_if 0 (;@4;)\nbr 1 (;@3;)\nend\ni32.const 65686\nlocal.set 63\ni32.const 65589\nlocal.set 64\ni32.const 32\nlocal.set 65\ni32.const 65756\nlocal.set 66\nlocal.get 63\nlocal.get 64\nlocal.get 65\nlocal.get 66\ncall 8\nunreachable\nend\nlocal.get 6\ni32.load offset=44\nlocal.set 67\nlocal.get 6\ni32.load offset=40\nlocal.set 68\nlocal.get 68\nlocal.get 67\ni32.add\nlocal.set 69\nlocal.get 6\nlocal.get 69\ni32.store offset=40\nlocal.get 6\ni32.load offset=65596\nlocal.set 70\nlocal.get 70\ncall 21\nlocal.set 71\nblock  ;; label = @3\nlocal.get 71\ni32.eqz\nbr_if 0 (;@3;)\nbr 2 (;@1;)\nend\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=65596\nlocal.set 72\nlocal.get 72\ncall 20\ndrop\nlocal.get 6\ni32.load offset=40\nlocal.set 73\nlocal.get 6\nlocal.get 73\ni32.store\ni32.const 65880\nlocal.set 74\nlocal.get 74\nlocal.get 6\ncall 46\ndrop\nlocal.get 6\ni32.load offset=65608\nlocal.set 75\nlocal.get 6\ni32.load offset=65604\nlocal.set 76\nlocal.get 6\nlocal.get 76\ni32.store offset=20\nlocal.get 6\nlocal.get 75\ni32.store offset=16\ni32.const 65870\nlocal.set 77\ni32.const 16\nlocal.set 78\nlocal.get 6\nlocal.get 78\ni32.add\nlocal.set 79\nlocal.get 77\nlocal.get 79\ncall 46\ndrop\ni32.const 0\nlocal.set 80\ni32.const 65616\nlocal.set 81\nlocal.get 6\nlocal.get 81\ni32.add\nlocal.set 82\nlocal.get 82\nglobal.set 0\nlocal.get 80\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_138",
        "query_text": "The function takes an integer as input and returns an integer. It prints a usage message to the standard error stream, which provides guidance on how to execute a program. The message details optional arguments, including options for specific directives and control over execution flow, as well as the possibility of specifying an input file. After displaying the message, the function returns the provided integer value. The input is of type int, and the output is of type int.",
        "code_id": "c_group_1_id_138",
        "code_text": "(func (;4;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 0\nlocal.set 4\nlocal.get 4\ni32.load offset=65684\nlocal.set 5\ni32.const 65590\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 5\nlocal.get 6\nlocal.get 7\ncall 6\ndrop\nlocal.get 3\ni32.load offset=12\nlocal.set 8\ni32.const 16\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nglobal.set 0\nlocal.get 8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_139",
        "query_text": "The function accepts a single integer input representing a value N and returns an integer. It computes the result by first calculating the logarithm of N divided by 2 with a base of 2, then dividing this value by a fixed constant factor (0.4875). The intermediate result is then cast to an integer to obtain the final output. The primary purpose of the function is to perform a scaled logarithmic transformation of the input value.",
        "code_id": "c_group_1_id_139",
        "code_text": "(func (;1;) (type 3) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 1\ni32.const 32\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=28\nf64.const 0x1.f333333333333p-2 (;=0.4875;)\nlocal.set 14\nlocal.get 3\nlocal.get 14\nf64.store offset=8\nlocal.get 3\ni32.load offset=28\nlocal.set 4\nlocal.get 4\nf64.convert_i32_s\nlocal.set 15\nf64.const 0x1p+1 (;=2;)\nlocal.set 16\nlocal.get 15\nlocal.get 16\nf64.div\nlocal.set 17\nlocal.get 17\ncall 6\nlocal.set 18\nf64.const 0x1p+1 (;=2;)\nlocal.set 19\nlocal.get 19\ncall 6\nlocal.set 20\nlocal.get 18\nlocal.get 20\nf64.div\nlocal.set 21\nlocal.get 3\nf64.load offset=8\nlocal.set 22\nlocal.get 21\nlocal.get 22\nf64.div\nlocal.set 23\nlocal.get 3\nlocal.get 23\nf64.store offset=16\nlocal.get 3\nf64.load offset=16\nlocal.set 24\nlocal.get 24\nf64.abs\nlocal.set 25\nf64.const 0x1p+31 (;=2.14748e+09;)\nlocal.set 26\nlocal.get 25\nlocal.get 26\nf64.lt\nlocal.set 5\nlocal.get 5\ni32.eqz\nlocal.set 6\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 6\nbr_if 0 (;@2;)\nlocal.get 24\ni32.trunc_f64_s\nlocal.set 7\nlocal.get 7\nlocal.set 8\nbr 1 (;@1;)\nend\ni32.const -2147483648\nlocal.set 9\nlocal.get 9\nlocal.set 8\nend\nlocal.get 8\nlocal.set 10\nlocal.get 3\nlocal.get 10\ni32.store offset=24\nlocal.get 3\ni32.load offset=24\nlocal.set 11\ni32.const 32\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_140",
        "query_text": "The function takes three inputs: a pointer to an array of doubles, an integer indicating the total number of elements in the array, and another integer used as a control parameter. It iterates over the array starting at the index computed by doubling the control parameter, and for every element from that starting point, it multiplies the element with the one located a fixed offset earlier in the array (offset equal to twice the control parameter). These products are added together to form a cumulative sum, which is returned as a double-precision value representing the overall computed result.",
        "code_id": "c_group_1_id_140",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\ni32.const 0\nlocal.set 6\nlocal.get 6\nf64.convert_i32_s\nlocal.set 32\nlocal.get 5\nlocal.get 32\nf64.store offset=8\nlocal.get 5\ni32.load offset=20\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shl\nlocal.set 9\nlocal.get 5\nlocal.get 9\ni32.store offset=4\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=4\nlocal.set 10\nlocal.get 5\ni32.load offset=24\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.lt_s\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nlocal.get 14\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=28\nlocal.set 15\nlocal.get 5\ni32.load offset=4\nlocal.set 16\ni32.const 3\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.shl\nlocal.set 18\nlocal.get 15\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 19\nf64.load\nlocal.set 33\nlocal.get 5\ni32.load offset=28\nlocal.set 20\nlocal.get 5\ni32.load offset=4\nlocal.set 21\nlocal.get 5\ni32.load offset=20\nlocal.set 22\ni32.const 1\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.shl\nlocal.set 24\nlocal.get 21\nlocal.get 24\ni32.sub\nlocal.set 25\ni32.const 3\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.shl\nlocal.set 27\nlocal.get 20\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 28\nf64.load\nlocal.set 34\nlocal.get 5\nf64.load offset=8\nlocal.set 35\nlocal.get 33\nlocal.get 34\nf64.mul\nlocal.set 36\nlocal.get 36\nlocal.get 35\nf64.add\nlocal.set 37\nlocal.get 5\nlocal.get 37\nf64.store offset=8\nlocal.get 5\ni32.load offset=4\nlocal.set 29\ni32.const 1\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 5\nlocal.get 31\ni32.store offset=4\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 5\nf64.load offset=8\nlocal.set 38\nlocal.get 38\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_141",
        "query_text": "The function accepts two integer inputs. It repeatedly performs integer division of the first input by the second input as long as the division results in a zero remainder. If the first input reduces to 1 after these successive divisions, the function returns 1, indicating that the original value is a complete power of the second input. Otherwise, it returns 0, signifying that such repeated division did not yield 1.",
        "code_id": "c_group_1_id_141",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=8\nlocal.set 5\nlocal.get 4\ni32.load offset=4\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.rem_s\nlocal.set 7\nlocal.get 7\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=8\nlocal.set 8\nlocal.get 4\ni32.load offset=4\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.div_s\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.eq\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 15\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 1\nlocal.set 16\nlocal.get 4\nlocal.get 16\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.store offset=12\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 18\nlocal.get 18\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_142",
        "query_text": "The function accepts two input arrays along with their respective lengths and an output array intended to hold the convolution result, which has a length equal to the sum of the input lengths minus one. It computes a direct convolution by iterating through one array and, for each element, multiplying it by corresponding elements from the other array while accumulating the products. The function accounts for two scenarios: one where the first input array is at least as long as the second, and another where the second input array is longer. In each case, it processes the elements appropriately and stores the final accumulated sums directly into the output array. No value is returned, as the computation modifies the supplied output array in place.",
        "code_id": "c_group_1_id_142",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 5\ni32.const 64\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.sub\nlocal.set 7\nlocal.get 7\nlocal.get 0\ni32.store offset=60\nlocal.get 7\nlocal.get 1\ni32.store offset=56\nlocal.get 7\nlocal.get 2\ni32.store offset=52\nlocal.get 7\nlocal.get 3\ni32.store offset=48\nlocal.get 7\nlocal.get 4\ni32.store offset=44\nlocal.get 7\ni32.load offset=56\nlocal.set 8\nlocal.get 7\ni32.load offset=48\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.add\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.sub\nlocal.set 12\nlocal.get 7\nlocal.get 12\ni32.store offset=40\ni32.const 0\nlocal.set 13\nlocal.get 7\nlocal.get 13\ni32.store offset=28\nlocal.get 7\ni32.load offset=56\nlocal.set 14\nlocal.get 7\ni32.load offset=48\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.ge_s\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 18\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 19\nlocal.get 7\nlocal.get 19\ni32.store offset=36\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 7\ni32.load offset=36\nlocal.set 20\nlocal.get 7\ni32.load offset=48\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.lt_s\nlocal.set 22\ni32.const 1\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.and\nlocal.set 24\nlocal.get 24\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 7\ni32.load offset=44\nlocal.set 25\nlocal.get 7\ni32.load offset=36\nlocal.set 26\ni32.const 3\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.shl\nlocal.set 28\nlocal.get 25\nlocal.get 28\ni32.add\nlocal.set 29\ni32.const 0\nlocal.set 30\nlocal.get 30\nf64.convert_i32_s\nlocal.set 203\nlocal.get 29\nlocal.get 203\nf64.store\ni32.const 0\nlocal.set 31\nlocal.get 7\nlocal.get 31\ni32.store offset=32\nblock  ;; label = @5\nloop  ;; label = @6\nlocal.get 7\ni32.load offset=32\nlocal.set 32\nlocal.get 7\ni32.load offset=36\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.le_s\nlocal.set 34\ni32.const 1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.and\nlocal.set 36\nlocal.get 36\ni32.eqz\nbr_if 1 (;@5;)\nlocal.get 7\ni32.load offset=60\nlocal.set 37\nlocal.get 7\ni32.load offset=32\nlocal.set 38\ni32.const 3\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.shl\nlocal.set 40\nlocal.get 37\nlocal.get 40\ni32.add\nlocal.set 41\nlocal.get 41\nf64.load\nlocal.set 204\nlocal.get 7\ni32.load offset=52\nlocal.set 42\nlocal.get 7\ni32.load offset=36\nlocal.set 43\nlocal.get 7\ni32.load offset=32\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.sub\nlocal.set 45\ni32.const 3\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.shl\nlocal.set 47\nlocal.get 42\nlocal.get 47\ni32.add\nlocal.set 48\nlocal.get 48\nf64.load\nlocal.set 205\nlocal.get 7\ni32.load offset=44\nlocal.set 49\nlocal.get 7\ni32.load offset=36\nlocal.set 50\ni32.const 3\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.shl\nlocal.set 52\nlocal.get 49\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\nf64.load\nlocal.set 206\nlocal.get 204\nlocal.get 205\nf64.mul\nlocal.set 207\nlocal.get 207\nlocal.get 206\nf64.add\nlocal.set 208\nlocal.get 53\nlocal.get 208\nf64.store\nlocal.get 7\ni32.load offset=32\nlocal.set 54\ni32.const 1\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.add\nlocal.set 56\nlocal.get 7\nlocal.get 56\ni32.store offset=32\nbr 0 (;@6;)\nend\nunreachable\nend\nlocal.get 7\ni32.load offset=36\nlocal.set 57\ni32.const 1\nlocal.set 58\nlocal.get 57\nlocal.get 58\ni32.add\nlocal.set 59\nlocal.get 7\nlocal.get 59\ni32.store offset=36\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 7\ni32.load offset=48\nlocal.set 60\nlocal.get 7\nlocal.get 60\ni32.store offset=36\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 7\ni32.load offset=36\nlocal.set 61\nlocal.get 7\ni32.load offset=40\nlocal.set 62\nlocal.get 61\nlocal.get 62\ni32.lt_s\nlocal.set 63\ni32.const 1\nlocal.set 64\nlocal.get 63\nlocal.get 64\ni32.and\nlocal.set 65\nlocal.get 65\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 7\ni32.load offset=44\nlocal.set 66\nlocal.get 7\ni32.load offset=36\nlocal.set 67\ni32.const 3\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.shl\nlocal.set 69\nlocal.get 66\nlocal.get 69\ni32.add\nlocal.set 70\ni32.const 0\nlocal.set 71\nlocal.get 71\nf64.convert_i32_s\nlocal.set 209\nlocal.get 70\nlocal.get 209\nf64.store\nlocal.get 7\ni32.load offset=28\nlocal.set 72\ni32.const 1\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.add\nlocal.set 74\nlocal.get 7\nlocal.get 74\ni32.store offset=28\nlocal.get 7\ni32.load offset=48\nlocal.set 75\nlocal.get 7\ni32.load offset=28\nlocal.set 76\nlocal.get 75\nlocal.get 76\ni32.add\nlocal.set 77\nlocal.get 77\nf64.convert_i32_s\nlocal.set 210\nlocal.get 7\nlocal.get 210\nf64.store offset=16\nlocal.get 7\nf64.load offset=16\nlocal.set 211\nlocal.get 7\ni32.load offset=56\nlocal.set 78\nlocal.get 78\nf64.convert_i32_s\nlocal.set 212\nlocal.get 211\nlocal.get 212\nf64.lt\nlocal.set 79\ni32.const 1\nlocal.set 80\nlocal.get 79\nlocal.get 80\ni32.and\nlocal.set 81\nblock  ;; label = @5\nblock  ;; label = @6\nlocal.get 81\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 7\nf64.load offset=16\nlocal.set 213\nlocal.get 213\nlocal.set 214\nbr 1 (;@5;)\nend\nlocal.get 7\ni32.load offset=56\nlocal.set 82\nlocal.get 82\nf64.convert_i32_s\nlocal.set 215\nlocal.get 215\nlocal.set 214\nend\nlocal.get 214\nlocal.set 216\nlocal.get 7\nlocal.get 216\nf64.store offset=8\nlocal.get 7\ni32.load offset=28\nlocal.set 83\nlocal.get 7\nlocal.get 83\ni32.store offset=32\nblock  ;; label = @5\nloop  ;; label = @6\nlocal.get 7\ni32.load offset=32\nlocal.set 84\nlocal.get 84\nf64.convert_i32_s\nlocal.set 217\nlocal.get 7\nf64.load offset=8\nlocal.set 218\nlocal.get 217\nlocal.get 218\nf64.lt\nlocal.set 85\ni32.const 1\nlocal.set 86\nlocal.get 85\nlocal.get 86\ni32.and\nlocal.set 87\nlocal.get 87\ni32.eqz\nbr_if 1 (;@5;)\nlocal.get 7\ni32.load offset=60\nlocal.set 88\nlocal.get 7\ni32.load offset=32\nlocal.set 89\ni32.const 3\nlocal.set 90\nlocal.get 89\nlocal.get 90\ni32.shl\nlocal.set 91\nlocal.get 88\nlocal.get 91\ni32.add\nlocal.set 92\nlocal.get 92\nf64.load\nlocal.set 219\nlocal.get 7\ni32.load offset=52\nlocal.set 93\nlocal.get 7\ni32.load offset=36\nlocal.set 94\nlocal.get 7\ni32.load offset=32\nlocal.set 95\nlocal.get 94\nlocal.get 95\ni32.sub\nlocal.set 96\ni32.const 3\nlocal.set 97\nlocal.get 96\nlocal.get 97\ni32.shl\nlocal.set 98\nlocal.get 93\nlocal.get 98\ni32.add\nlocal.set 99\nlocal.get 99\nf64.load\nlocal.set 220\nlocal.get 7\ni32.load offset=44\nlocal.set 100\nlocal.get 7\ni32.load offset=36\nlocal.set 101\ni32.const 3\nlocal.set 102\nlocal.get 101\nlocal.get 102\ni32.shl\nlocal.set 103\nlocal.get 100\nlocal.get 103\ni32.add\nlocal.set 104\nlocal.get 104\nf64.load\nlocal.set 221\nlocal.get 219\nlocal.get 220\nf64.mul\nlocal.set 222\nlocal.get 222\nlocal.get 221\nf64.add\nlocal.set 223\nlocal.get 104\nlocal.get 223\nf64.store\nlocal.get 7\ni32.load offset=32\nlocal.set 105\ni32.const 1\nlocal.set 106\nlocal.get 105\nlocal.get 106\ni32.add\nlocal.set 107\nlocal.get 7\nlocal.get 107\ni32.store offset=32\nbr 0 (;@6;)\nend\nunreachable\nend\nlocal.get 7\ni32.load offset=36\nlocal.set 108\ni32.const 1\nlocal.set 109\nlocal.get 108\nlocal.get 109\ni32.add\nlocal.set 110\nlocal.get 7\nlocal.get 110\ni32.store offset=36\nbr 0 (;@4;)\nend\nunreachable\nend\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 111\nlocal.get 7\nlocal.get 111\ni32.store offset=36\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 7\ni32.load offset=36\nlocal.set 112\nlocal.get 7\ni32.load offset=56\nlocal.set 113\nlocal.get 112\nlocal.get 113\ni32.lt_s\nlocal.set 114\ni32.const 1\nlocal.set 115\nlocal.get 114\nlocal.get 115\ni32.and\nlocal.set 116\nlocal.get 116\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 7\ni32.load offset=44\nlocal.set 117\nlocal.get 7\ni32.load offset=36\nlocal.set 118\ni32.const 3\nlocal.set 119\nlocal.get 118\nlocal.get 119\ni32.shl\nlocal.set 120\nlocal.get 117\nlocal.get 120\ni32.add\nlocal.set 121\ni32.const 0\nlocal.set 122\nlocal.get 122\nf64.convert_i32_s\nlocal.set 224\nlocal.get 121\nlocal.get 224\nf64.store\ni32.const 0\nlocal.set 123\nlocal.get 7\nlocal.get 123\ni32.store offset=32\nblock  ;; label = @4\nloop  ;; label = @5\nlocal.get 7\ni32.load offset=32\nlocal.set 124\nlocal.get 7\ni32.load offset=36\nlocal.set 125\nlocal.get 124\nlocal.get 125\ni32.le_s\nlocal.set 126\ni32.const 1\nlocal.set 127\nlocal.get 126\nlocal.get 127\ni32.and\nlocal.set 128\nlocal.get 128\ni32.eqz\nbr_if 1 (;@4;)\nlocal.get 7\ni32.load offset=52\nlocal.set 129\nlocal.get 7\ni32.load offset=32\nlocal.set 130\ni32.const 3\nlocal.set 131\nlocal.get 130\nlocal.get 131\ni32.shl\nlocal.set 132\nlocal.get 129\nlocal.get 132\ni32.add\nlocal.set 133\nlocal.get 133\nf64.load\nlocal.set 225\nlocal.get 7\ni32.load offset=60\nlocal.set 134\nlocal.get 7\ni32.load offset=36\nlocal.set 135\nlocal.get 7\ni32.load offset=32\nlocal.set 136\nlocal.get 135\nlocal.get 136\ni32.sub\nlocal.set 137\ni32.const 3\nlocal.set 138\nlocal.get 137\nlocal.get 138\ni32.shl\nlocal.set 139\nlocal.get 134\nlocal.get 139\ni32.add\nlocal.set 140\nlocal.get 140\nf64.load\nlocal.set 226\nlocal.get 7\ni32.load offset=44\nlocal.set 141\nlocal.get 7\ni32.load offset=36\nlocal.set 142\ni32.const 3\nlocal.set 143\nlocal.get 142\nlocal.get 143\ni32.shl\nlocal.set 144\nlocal.get 141\nlocal.get 144\ni32.add\nlocal.set 145\nlocal.get 145\nf64.load\nlocal.set 227\nlocal.get 225\nlocal.get 226\nf64.mul\nlocal.set 228\nlocal.get 228\nlocal.get 227\nf64.add\nlocal.set 229\nlocal.get 145\nlocal.get 229\nf64.store\nlocal.get 7\ni32.load offset=32\nlocal.set 146\ni32.const 1\nlocal.set 147\nlocal.get 146\nlocal.get 147\ni32.add\nlocal.set 148\nlocal.get 7\nlocal.get 148\ni32.store offset=32\nbr 0 (;@5;)\nend\nunreachable\nend\nlocal.get 7\ni32.load offset=36\nlocal.set 149\ni32.const 1\nlocal.set 150\nlocal.get 149\nlocal.get 150\ni32.add\nlocal.set 151\nlocal.get 7\nlocal.get 151\ni32.store offset=36\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 7\ni32.load offset=56\nlocal.set 152\nlocal.get 7\nlocal.get 152\ni32.store offset=36\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 7\ni32.load offset=36\nlocal.set 153\nlocal.get 7\ni32.load offset=40\nlocal.set 154\nlocal.get 153\nlocal.get 154\ni32.lt_s\nlocal.set 155\ni32.const 1\nlocal.set 156\nlocal.get 155\nlocal.get 156\ni32.and\nlocal.set 157\nlocal.get 157\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 7\ni32.load offset=44\nlocal.set 158\nlocal.get 7\ni32.load offset=36\nlocal.set 159\ni32.const 3\nlocal.set 160\nlocal.get 159\nlocal.get 160\ni32.shl\nlocal.set 161\nlocal.get 158\nlocal.get 161\ni32.add\nlocal.set 162\ni32.const 0\nlocal.set 163\nlocal.get 163\nf64.convert_i32_s\nlocal.set 230\nlocal.get 162\nlocal.get 230\nf64.store\nlocal.get 7\ni32.load offset=28\nlocal.set 164\ni32.const 1\nlocal.set 165\nlocal.get 164\nlocal.get 165\ni32.add\nlocal.set 166\nlocal.get 7\nlocal.get 166\ni32.store offset=28\nlocal.get 7\ni32.load offset=56\nlocal.set 167\nlocal.get 7\ni32.load offset=28\nlocal.set 168\nlocal.get 167\nlocal.get 168\ni32.add\nlocal.set 169\nlocal.get 169\nf64.convert_i32_s\nlocal.set 231\nlocal.get 7\nlocal.get 231\nf64.store offset=16\nlocal.get 7\nf64.load offset=16\nlocal.set 232\nlocal.get 7\ni32.load offset=48\nlocal.set 170\nlocal.get 170\nf64.convert_i32_s\nlocal.set 233\nlocal.get 232\nlocal.get 233\nf64.lt\nlocal.set 171\ni32.const 1\nlocal.set 172\nlocal.get 171\nlocal.get 172\ni32.and\nlocal.set 173\nblock  ;; label = @4\nblock  ;; label = @5\nlocal.get 173\ni32.eqz\nbr_if 0 (;@5;)\nlocal.get 7\nf64.load offset=16\nlocal.set 234\nlocal.get 234\nlocal.set 235\nbr 1 (;@4;)\nend\nlocal.get 7\ni32.load offset=48\nlocal.set 174\nlocal.get 174\nf64.convert_i32_s\nlocal.set 236\nlocal.get 236\nlocal.set 235\nend\nlocal.get 235\nlocal.set 237\nlocal.get 7\nlocal.get 237\nf64.store offset=8\nlocal.get 7\ni32.load offset=28\nlocal.set 175\nlocal.get 7\nlocal.get 175\ni32.store offset=32\nblock  ;; label = @4\nloop  ;; label = @5\nlocal.get 7\ni32.load offset=32\nlocal.set 176\nlocal.get 176\nf64.convert_i32_s\nlocal.set 238\nlocal.get 7\nf64.load offset=8\nlocal.set 239\nlocal.get 238\nlocal.get 239\nf64.lt\nlocal.set 177\ni32.const 1\nlocal.set 178\nlocal.get 177\nlocal.get 178\ni32.and\nlocal.set 179\nlocal.get 179\ni32.eqz\nbr_if 1 (;@4;)\nlocal.get 7\ni32.load offset=52\nlocal.set 180\nlocal.get 7\ni32.load offset=32\nlocal.set 181\ni32.const 3\nlocal.set 182\nlocal.get 181\nlocal.get 182\ni32.shl\nlocal.set 183\nlocal.get 180\nlocal.get 183\ni32.add\nlocal.set 184\nlocal.get 184\nf64.load\nlocal.set 240\nlocal.get 7\ni32.load offset=60\nlocal.set 185\nlocal.get 7\ni32.load offset=36\nlocal.set 186\nlocal.get 7\ni32.load offset=32\nlocal.set 187\nlocal.get 186\nlocal.get 187\ni32.sub\nlocal.set 188\ni32.const 3\nlocal.set 189\nlocal.get 188\nlocal.get 189\ni32.shl\nlocal.set 190\nlocal.get 185\nlocal.get 190\ni32.add\nlocal.set 191\nlocal.get 191\nf64.load\nlocal.set 241\nlocal.get 7\ni32.load offset=44\nlocal.set 192\nlocal.get 7\ni32.load offset=36\nlocal.set 193\ni32.const 3\nlocal.set 194\nlocal.get 193\nlocal.get 194\ni32.shl\nlocal.set 195\nlocal.get 192\nlocal.get 195\ni32.add\nlocal.set 196\nlocal.get 196\nf64.load\nlocal.set 242\nlocal.get 240\nlocal.get 241\nf64.mul\nlocal.set 243\nlocal.get 243\nlocal.get 242\nf64.add\nlocal.set 244\nlocal.get 196\nlocal.get 244\nf64.store\nlocal.get 7\ni32.load offset=32\nlocal.set 197\ni32.const 1\nlocal.set 198\nlocal.get 197\nlocal.get 198\ni32.add\nlocal.set 199\nlocal.get 7\nlocal.get 199\ni32.store offset=32\nbr 0 (;@5;)\nend\nunreachable\nend\nlocal.get 7\ni32.load offset=36\nlocal.set 200\ni32.const 1\nlocal.set 201\nlocal.get 200\nlocal.get 201\ni32.add\nlocal.set 202\nlocal.get 7\nlocal.get 202\ni32.store offset=36\nbr 0 (;@3;)\nend\nunreachable\nend\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_143",
        "query_text": "The function accepts five parameters: two pointers to numeric arrays (one for each input array) along with two integers that specify the sizes of these arrays, as well as a pointer to a numeric array intended to store the convolution result. It first calculates the size of the output array as the sum of the two input sizes minus one, and then initializes each element of this output array to zero. The function proceeds to iterate over the range of the output array, and for each position, it sums the products of appropriate elements from the two input arrays\u2014ensuring that the indices used strictly fall within the limits of the second input array. The function does not return a value; instead, it directly modifies the output array in place.",
        "code_id": "c_group_1_id_143",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 5\ni32.const 32\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.sub\nlocal.set 7\nlocal.get 7\nlocal.get 0\ni32.store offset=28\nlocal.get 7\nlocal.get 1\ni32.store offset=24\nlocal.get 7\nlocal.get 2\ni32.store offset=20\nlocal.get 7\nlocal.get 3\ni32.store offset=16\nlocal.get 7\nlocal.get 4\ni32.store offset=12\nlocal.get 7\ni32.load offset=24\nlocal.set 8\nlocal.get 7\ni32.load offset=16\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.add\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.sub\nlocal.set 12\nlocal.get 7\nlocal.get 12\ni32.store offset=8\ni32.const 0\nlocal.set 13\nlocal.get 7\nlocal.get 13\ni32.store offset=4\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 7\ni32.load offset=4\nlocal.set 14\nlocal.get 7\ni32.load offset=8\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.lt_s\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 18\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 7\ni32.load offset=12\nlocal.set 19\nlocal.get 7\ni32.load offset=4\nlocal.set 20\ni32.const 3\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.shl\nlocal.set 22\nlocal.get 19\nlocal.get 22\ni32.add\nlocal.set 23\ni32.const 0\nlocal.set 24\nlocal.get 24\nf64.convert_i32_s\nlocal.set 68\nlocal.get 23\nlocal.get 68\nf64.store\ni32.const 0\nlocal.set 25\nlocal.get 7\nlocal.get 25\ni32.store\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 7\ni32.load\nlocal.set 26\nlocal.get 7\ni32.load offset=24\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.lt_s\nlocal.set 28\ni32.const 1\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.and\nlocal.set 30\nlocal.get 30\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 7\ni32.load offset=4\nlocal.set 31\nlocal.get 7\ni32.load\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.sub\nlocal.set 33\ni32.const 0\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.ge_s\nlocal.set 35\ni32.const 1\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.and\nlocal.set 37\nblock  ;; label = @5\nlocal.get 37\ni32.eqz\nbr_if 0 (;@5;)\nlocal.get 7\ni32.load offset=4\nlocal.set 38\nlocal.get 7\ni32.load\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.sub\nlocal.set 40\nlocal.get 7\ni32.load offset=16\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.lt_s\nlocal.set 42\ni32.const 1\nlocal.set 43\nlocal.get 42\nlocal.get 43\ni32.and\nlocal.set 44\nlocal.get 44\ni32.eqz\nbr_if 0 (;@5;)\nlocal.get 7\ni32.load offset=28\nlocal.set 45\nlocal.get 7\ni32.load\nlocal.set 46\ni32.const 3\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.shl\nlocal.set 48\nlocal.get 45\nlocal.get 48\ni32.add\nlocal.set 49\nlocal.get 49\nf64.load\nlocal.set 69\nlocal.get 7\ni32.load offset=20\nlocal.set 50\nlocal.get 7\ni32.load offset=4\nlocal.set 51\nlocal.get 7\ni32.load\nlocal.set 52\nlocal.get 51\nlocal.get 52\ni32.sub\nlocal.set 53\ni32.const 3\nlocal.set 54\nlocal.get 53\nlocal.get 54\ni32.shl\nlocal.set 55\nlocal.get 50\nlocal.get 55\ni32.add\nlocal.set 56\nlocal.get 56\nf64.load\nlocal.set 70\nlocal.get 7\ni32.load offset=12\nlocal.set 57\nlocal.get 7\ni32.load offset=4\nlocal.set 58\ni32.const 3\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.shl\nlocal.set 60\nlocal.get 57\nlocal.get 60\ni32.add\nlocal.set 61\nlocal.get 61\nf64.load\nlocal.set 71\nlocal.get 69\nlocal.get 70\nf64.mul\nlocal.set 72\nlocal.get 72\nlocal.get 71\nf64.add\nlocal.set 73\nlocal.get 61\nlocal.get 73\nf64.store\nend\nlocal.get 7\ni32.load\nlocal.set 62\ni32.const 1\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.add\nlocal.set 64\nlocal.get 7\nlocal.get 64\ni32.store\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 7\ni32.load offset=4\nlocal.set 65\ni32.const 1\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.add\nlocal.set 67\nlocal.get 7\nlocal.get 67\ni32.store offset=4\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_144",
        "query_text": "The function takes three parameters: a pointer to an array of double-precision floating-point numbers, an integer specifying the number of elements in the array, and another pointer to an array of doubles where the result will be stored. It reverses the order of the elements from the input array such that the first element in the output array is the last element from the input array, the second element is the second-to-last, and so on. The function processes exactly the number of elements specified by the integer parameter and returns no value.",
        "code_id": "c_group_1_id_144",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store\ni32.const 0\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load\nlocal.set 8\nlocal.get 5\ni32.load offset=8\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=12\nlocal.set 13\nlocal.get 5\ni32.load offset=8\nlocal.set 14\nlocal.get 5\ni32.load\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.sub\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.sub\nlocal.set 18\ni32.const 3\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.shl\nlocal.set 20\nlocal.get 13\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nf64.load\nlocal.set 30\nlocal.get 5\ni32.load offset=4\nlocal.set 22\nlocal.get 5\ni32.load\nlocal.set 23\ni32.const 3\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.shl\nlocal.set 25\nlocal.get 22\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 26\nlocal.get 30\nf64.store\nlocal.get 5\ni32.load\nlocal.set 27\ni32.const 1\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 5\nlocal.get 29\ni32.store\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_145",
        "query_text": "This function accepts three parameters: an input array of type double, an integer representing the number of elements to process, and an output array of type double. The function iterates through the input array up to the specified count, copying each element into the output array so that its contents exactly mirror the input array for that range. It does not return a value.",
        "code_id": "c_group_1_id_145",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store\ni32.const 0\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load\nlocal.set 8\nlocal.get 5\ni32.load offset=8\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=12\nlocal.set 13\nlocal.get 5\ni32.load\nlocal.set 14\ni32.const 3\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 13\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nf64.load\nlocal.set 26\nlocal.get 5\ni32.load offset=4\nlocal.set 18\nlocal.get 5\ni32.load\nlocal.set 19\ni32.const 3\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 18\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 22\nlocal.get 26\nf64.store\nlocal.get 5\ni32.load\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 5\nlocal.get 25\ni32.store\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_147",
        "query_text": "This function processes an array of double-precision floating-point numbers to produce a downsampled version of the array. It takes as inputs a pointer to a floating-point array, the length of that array, an integer specifying the sampling interval, and a pointer to an output array. If the sampling interval is negative, the function immediately returns an error code (-1). When the interval is zero, the function copies each element from the input array to the output array and returns the original array length. For a positive interval, it calculates the length of the resulting downsampled array, then selects elements from the input array at positions determined by the interval, storing them in the output array. Finally, it returns the length of the downsampled array.",
        "code_id": "c_group_1_id_147",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64)\nglobal.get 0\nlocal.set 4\ni32.const 32\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nlocal.get 0\ni32.store offset=24\nlocal.get 6\nlocal.get 1\ni32.store offset=20\nlocal.get 6\nlocal.get 2\ni32.store offset=16\nlocal.get 6\nlocal.get 3\ni32.store offset=12\nlocal.get 6\ni32.load offset=16\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.lt_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 11\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 12\nlocal.get 6\nlocal.get 12\ni32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=16\nlocal.set 13\nblock  ;; label = @2\nlocal.get 13\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 14\nlocal.get 6\nlocal.get 14\ni32.store offset=4\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 6\ni32.load offset=4\nlocal.set 15\nlocal.get 6\ni32.load offset=20\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.lt_s\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 19\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 6\ni32.load offset=24\nlocal.set 20\nlocal.get 6\ni32.load offset=4\nlocal.set 21\ni32.const 3\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.shl\nlocal.set 23\nlocal.get 20\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nf64.load\nlocal.set 64\nlocal.get 6\ni32.load offset=12\nlocal.set 25\nlocal.get 6\ni32.load offset=4\nlocal.set 26\ni32.const 3\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.shl\nlocal.set 28\nlocal.get 25\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 29\nlocal.get 64\nf64.store\nlocal.get 6\ni32.load offset=4\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 6\nlocal.get 32\ni32.store offset=4\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=20\nlocal.set 33\nlocal.get 6\nlocal.get 33\ni32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=20\nlocal.set 34\ni32.const 1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.sub\nlocal.set 36\nlocal.get 6\ni32.load offset=16\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.div_s\nlocal.set 38\ni32.const 1\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.add\nlocal.set 40\nlocal.get 6\nlocal.get 40\ni32.store offset=8\ni32.const 0\nlocal.set 41\nlocal.get 6\nlocal.get 41\ni32.store offset=4\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 6\ni32.load offset=4\nlocal.set 42\nlocal.get 6\ni32.load offset=8\nlocal.set 43\nlocal.get 42\nlocal.get 43\ni32.lt_s\nlocal.set 44\ni32.const 1\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.and\nlocal.set 46\nlocal.get 46\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 6\ni32.load offset=24\nlocal.set 47\nlocal.get 6\ni32.load offset=4\nlocal.set 48\nlocal.get 6\ni32.load offset=16\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.mul\nlocal.set 50\ni32.const 3\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.shl\nlocal.set 52\nlocal.get 47\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\nf64.load\nlocal.set 65\nlocal.get 6\ni32.load offset=12\nlocal.set 54\nlocal.get 6\ni32.load offset=4\nlocal.set 55\ni32.const 3\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.shl\nlocal.set 57\nlocal.get 54\nlocal.get 57\ni32.add\nlocal.set 58\nlocal.get 58\nlocal.get 65\nf64.store\nlocal.get 6\ni32.load offset=4\nlocal.set 59\ni32.const 1\nlocal.set 60\nlocal.get 59\nlocal.get 60\ni32.add\nlocal.set 61\nlocal.get 6\nlocal.get 61\ni32.store offset=4\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=8\nlocal.set 62\nlocal.get 6\nlocal.get 62\ni32.store offset=28\nend\nlocal.get 6\ni32.load offset=28\nlocal.set 63\nlocal.get 63\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_148",
        "query_text": "The function takes an input array of double values and an integer indicating its length, along with an integer offset and an output array for storing results. It first copies the input array into the output array starting at the specified offset. If the length of the input array is odd, it duplicates the last element to ensure an even count. The function then extends the section of the output array by mirroring the copied values to both the beginning (before the offset) and the end (after the extended segment), thereby creating a symmetric, periodic repetition of the signal. Finally, the function returns an integer representing the length of the extended signal, which is either equal to the original length or incremented by one if the input length was odd.",
        "code_id": "c_group_1_id_148",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 4\ni32.const 48\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nlocal.get 0\ni32.store offset=44\nlocal.get 6\nlocal.get 1\ni32.store offset=40\nlocal.get 6\nlocal.get 2\ni32.store offset=36\nlocal.get 6\nlocal.get 3\ni32.store offset=32\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.store offset=28\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 6\ni32.load offset=28\nlocal.set 8\nlocal.get 6\ni32.load offset=40\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 6\ni32.load offset=44\nlocal.set 13\nlocal.get 6\ni32.load offset=28\nlocal.set 14\ni32.const 3\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 13\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nf64.load\nlocal.set 95\nlocal.get 6\ni32.load offset=32\nlocal.set 18\nlocal.get 6\ni32.load offset=36\nlocal.set 19\nlocal.get 6\ni32.load offset=28\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.add\nlocal.set 21\ni32.const 3\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.shl\nlocal.set 23\nlocal.get 18\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nlocal.get 95\nf64.store\nlocal.get 6\ni32.load offset=28\nlocal.set 25\ni32.const 1\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 6\nlocal.get 27\ni32.store offset=28\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=40\nlocal.set 28\nlocal.get 6\nlocal.get 28\ni32.store offset=24\nlocal.get 6\ni32.load offset=40\nlocal.set 29\ni32.const 2\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.rem_s\nlocal.set 31\nblock  ;; label = @1\nlocal.get 31\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 6\ni32.load offset=40\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.add\nlocal.set 34\nlocal.get 6\nlocal.get 34\ni32.store offset=24\nlocal.get 6\ni32.load offset=44\nlocal.set 35\nlocal.get 6\ni32.load offset=40\nlocal.set 36\ni32.const 1\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.sub\nlocal.set 38\ni32.const 3\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.shl\nlocal.set 40\nlocal.get 35\nlocal.get 40\ni32.add\nlocal.set 41\nlocal.get 41\nf64.load\nlocal.set 96\nlocal.get 6\ni32.load offset=32\nlocal.set 42\nlocal.get 6\ni32.load offset=36\nlocal.set 43\nlocal.get 6\ni32.load offset=40\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.add\nlocal.set 45\ni32.const 3\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.shl\nlocal.set 47\nlocal.get 42\nlocal.get 47\ni32.add\nlocal.set 48\nlocal.get 48\nlocal.get 96\nf64.store\nend\ni32.const 0\nlocal.set 49\nlocal.get 6\nlocal.get 49\ni32.store offset=28\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 6\ni32.load offset=28\nlocal.set 50\nlocal.get 6\ni32.load offset=36\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.lt_s\nlocal.set 52\ni32.const 1\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.and\nlocal.set 54\nlocal.get 54\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 6\ni32.load offset=32\nlocal.set 55\nlocal.get 6\ni32.load offset=36\nlocal.set 56\nlocal.get 6\ni32.load offset=28\nlocal.set 57\nlocal.get 56\nlocal.get 57\ni32.add\nlocal.set 58\ni32.const 3\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.shl\nlocal.set 60\nlocal.get 55\nlocal.get 60\ni32.add\nlocal.set 61\nlocal.get 61\nf64.load\nlocal.set 97\nlocal.get 6\nlocal.get 97\nf64.store offset=16\nlocal.get 6\ni32.load offset=32\nlocal.set 62\nlocal.get 6\ni32.load offset=36\nlocal.set 63\nlocal.get 6\ni32.load offset=24\nlocal.set 64\nlocal.get 63\nlocal.get 64\ni32.add\nlocal.set 65\ni32.const 1\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.sub\nlocal.set 67\nlocal.get 6\ni32.load offset=28\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.sub\nlocal.set 69\ni32.const 3\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.shl\nlocal.set 71\nlocal.get 62\nlocal.get 71\ni32.add\nlocal.set 72\nlocal.get 72\nf64.load\nlocal.set 98\nlocal.get 6\nlocal.get 98\nf64.store offset=8\nlocal.get 6\nf64.load offset=8\nlocal.set 99\nlocal.get 6\ni32.load offset=32\nlocal.set 73\nlocal.get 6\ni32.load offset=36\nlocal.set 74\ni32.const 1\nlocal.set 75\nlocal.get 74\nlocal.get 75\ni32.sub\nlocal.set 76\nlocal.get 6\ni32.load offset=28\nlocal.set 77\nlocal.get 76\nlocal.get 77\ni32.sub\nlocal.set 78\ni32.const 3\nlocal.set 79\nlocal.get 78\nlocal.get 79\ni32.shl\nlocal.set 80\nlocal.get 73\nlocal.get 80\ni32.add\nlocal.set 81\nlocal.get 81\nlocal.get 99\nf64.store\nlocal.get 6\nf64.load offset=16\nlocal.set 100\nlocal.get 6\ni32.load offset=32\nlocal.set 82\nlocal.get 6\ni32.load offset=24\nlocal.set 83\nlocal.get 6\ni32.load offset=36\nlocal.set 84\nlocal.get 83\nlocal.get 84\ni32.add\nlocal.set 85\nlocal.get 6\ni32.load offset=28\nlocal.set 86\nlocal.get 85\nlocal.get 86\ni32.add\nlocal.set 87\ni32.const 3\nlocal.set 88\nlocal.get 87\nlocal.get 88\ni32.shl\nlocal.set 89\nlocal.get 82\nlocal.get 89\ni32.add\nlocal.set 90\nlocal.get 90\nlocal.get 100\nf64.store\nlocal.get 6\ni32.load offset=28\nlocal.set 91\ni32.const 1\nlocal.set 92\nlocal.get 91\nlocal.get 92\ni32.add\nlocal.set 93\nlocal.get 6\nlocal.get 93\ni32.store offset=28\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=24\nlocal.set 94\nlocal.get 94\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_149",
        "query_text": "The function takes four inputs: a double-precision floating-point array containing the original data, an integer denoting the number of elements in this array, an integer that specifies a position index used for the symmetric extension, and another double-precision floating-point array designated for the output. The function first copies the elements of the original array into a specific segment of the output array starting at the given index. It then mirrors these copied elements around this segment to achieve a symmetric extension of the input data. Finally, the function returns an integer corresponding to the length of the original input array.",
        "code_id": "c_group_1_id_149",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 4\ni32.const 48\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nlocal.get 0\ni32.store offset=44\nlocal.get 6\nlocal.get 1\ni32.store offset=40\nlocal.get 6\nlocal.get 2\ni32.store offset=36\nlocal.get 6\nlocal.get 3\ni32.store offset=32\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.store offset=28\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 6\ni32.load offset=28\nlocal.set 8\nlocal.get 6\ni32.load offset=40\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 6\ni32.load offset=44\nlocal.set 13\nlocal.get 6\ni32.load offset=28\nlocal.set 14\ni32.const 3\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 13\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nf64.load\nlocal.set 75\nlocal.get 6\ni32.load offset=32\nlocal.set 18\nlocal.get 6\ni32.load offset=36\nlocal.set 19\nlocal.get 6\ni32.load offset=28\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.add\nlocal.set 21\ni32.const 3\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.shl\nlocal.set 23\nlocal.get 18\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nlocal.get 75\nf64.store\nlocal.get 6\ni32.load offset=28\nlocal.set 25\ni32.const 1\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 6\nlocal.get 27\ni32.store offset=28\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=40\nlocal.set 28\nlocal.get 6\nlocal.get 28\ni32.store offset=24\ni32.const 0\nlocal.set 29\nlocal.get 6\nlocal.get 29\ni32.store offset=28\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 6\ni32.load offset=28\nlocal.set 30\nlocal.get 6\ni32.load offset=36\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.lt_s\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.and\nlocal.set 34\nlocal.get 34\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 6\ni32.load offset=32\nlocal.set 35\nlocal.get 6\ni32.load offset=36\nlocal.set 36\nlocal.get 6\ni32.load offset=28\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.add\nlocal.set 38\ni32.const 3\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.shl\nlocal.set 40\nlocal.get 35\nlocal.get 40\ni32.add\nlocal.set 41\nlocal.get 41\nf64.load\nlocal.set 76\nlocal.get 6\nlocal.get 76\nf64.store offset=16\nlocal.get 6\ni32.load offset=32\nlocal.set 42\nlocal.get 6\ni32.load offset=36\nlocal.set 43\nlocal.get 6\ni32.load offset=24\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.add\nlocal.set 45\ni32.const 1\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.sub\nlocal.set 47\nlocal.get 6\ni32.load offset=28\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.sub\nlocal.set 49\ni32.const 3\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.shl\nlocal.set 51\nlocal.get 42\nlocal.get 51\ni32.add\nlocal.set 52\nlocal.get 52\nf64.load\nlocal.set 77\nlocal.get 6\nlocal.get 77\nf64.store offset=8\nlocal.get 6\nf64.load offset=16\nlocal.set 78\nlocal.get 6\ni32.load offset=32\nlocal.set 53\nlocal.get 6\ni32.load offset=36\nlocal.set 54\ni32.const 1\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.sub\nlocal.set 56\nlocal.get 6\ni32.load offset=28\nlocal.set 57\nlocal.get 56\nlocal.get 57\ni32.sub\nlocal.set 58\ni32.const 3\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.shl\nlocal.set 60\nlocal.get 53\nlocal.get 60\ni32.add\nlocal.set 61\nlocal.get 61\nlocal.get 78\nf64.store\nlocal.get 6\nf64.load offset=8\nlocal.set 79\nlocal.get 6\ni32.load offset=32\nlocal.set 62\nlocal.get 6\ni32.load offset=24\nlocal.set 63\nlocal.get 6\ni32.load offset=36\nlocal.set 64\nlocal.get 63\nlocal.get 64\ni32.add\nlocal.set 65\nlocal.get 6\ni32.load offset=28\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.add\nlocal.set 67\ni32.const 3\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.shl\nlocal.set 69\nlocal.get 62\nlocal.get 69\ni32.add\nlocal.set 70\nlocal.get 70\nlocal.get 79\nf64.store\nlocal.get 6\ni32.load offset=28\nlocal.set 71\ni32.const 1\nlocal.set 72\nlocal.get 71\nlocal.get 72\ni32.add\nlocal.set 73\nlocal.get 6\nlocal.get 73\ni32.store offset=28\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=24\nlocal.set 74\nlocal.get 74\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_151",
        "query_text": "The function takes an integer as its input and produces an integer as its output. It computes 2 raised to the power specified by the input by initializing a base value to 1 and then multiplying it by 2 iteratively for a number of times equal to the input value. The final computed value is eventually returned as the output.",
        "code_id": "c_group_1_id_151",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 1\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\ni32.const 0\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.store offset=4\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=4\nlocal.set 6\nlocal.get 3\ni32.load offset=12\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.lt_s\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 10\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.shl\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.store offset=8\nlocal.get 3\ni32.load offset=4\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 3\nlocal.get 16\ni32.store offset=4\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 17\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_153",
        "query_text": "The function takes an unsigned 64-bit integer as input and returns an integer representing the number of contiguous zero bits at the least significant end of its binary representation. It is marked as noexcept, ensuring that no exceptions are thrown during execution. Internally, the function leverages a compiler-specific intrinsic to efficiently perform the bit-counting operation. It is important to note that if the input is zero, the behavior is undefined.",
        "code_id": "c_group_1_id_153",
        "code_text": "(func (;1;) (type 2) (param i64) (result i32)\n(local i32 i32 i32 i32 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 5\nlocal.get 5\ni64.ctz\nlocal.set 6\nlocal.get 6\ni32.wrap_i64\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_155",
        "query_text": "The function takes three unsigned integers as input. It shifts the first input left by 12 bits, shifts the lower 6 bits of the second integer left by 6 bits, and then combines these results with the lower 6 bits of the third input using bitwise OR operations. The function returns a single unsigned integer encapsulating the combined bit pattern from the three inputs.",
        "code_id": "c_group_1_id_155",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nlocal.get 5\ni32.load offset=12\nlocal.set 6\ni32.const 12\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.shl\nlocal.set 8\nlocal.get 5\ni32.load offset=8\nlocal.set 9\ni32.const 63\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\ni32.const 6\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.shl\nlocal.set 13\nlocal.get 8\nlocal.get 13\ni32.or\nlocal.set 14\nlocal.get 5\ni32.load offset=4\nlocal.set 15\ni32.const 63\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.and\nlocal.set 17\nlocal.get 14\nlocal.get 17\ni32.or\nlocal.set 18\nlocal.get 18\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_156",
        "query_text": "The function takes no input arguments and returns a pointer to a statically allocated constant character array. This array holds a concatenated sequence of two-digit numbers in ascending order from \"00\" to \"99\". The function is declared as inline and guarantees no exceptions, with the return type being const char*. Its purpose is to provide quick access to a precomputed lookup table that can be utilized for efficient string formatting or similar operations.",
        "code_id": "c_group_1_id_156",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 208\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ni32.const 65536\nlocal.set 3\ni32.const 201\nlocal.set 4\nlocal.get 2\nlocal.get 3\nlocal.get 4\ncall 3\ndrop\nlocal.get 2\nlocal.set 5\ni32.const 208\nlocal.set 6\nlocal.get 2\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_157",
        "query_text": "This function takes a single character input and determines whether it represents a numerical digit. The input, of type char, is examined to see if it lies between the characters '0' and '9' inclusive. If the character is within this range, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_157",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.shr_s\nlocal.set 7\ni32.const 48\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.ge_s\nlocal.set 9\ni32.const 0\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 9\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 10\nlocal.set 13\nblock  ;; label = @1\nlocal.get 12\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 14\ni32.const 24\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 16\nlocal.get 15\ni32.shr_s\nlocal.set 17\ni32.const 57\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.le_s\nlocal.set 19\nlocal.get 19\nlocal.set 13\nend\nlocal.get 13\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 22\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_158",
        "query_text": "The function accepts two inputs: a constant character pointer representing the input string, and a pointer to a double where the parsed floating-point value will be stored. It converts the numeric portion of the input string to a double-precision floating-point number, employing platform-specific variants that utilize appropriate locale settings for accurate parsing. If the conversion succeeds and the resulting value is finite (i.e., not infinity or NaN), the function returns a pointer to the character immediately following the parsed number in the input string; otherwise, it returns a null pointer.",
        "code_id": "c_group_1_id_158",
        "code_text": "(func (;3;) (type 4) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\ni32.const 8127\nlocal.set 5\ni32.const 65567\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 5\nlocal.get 6\nlocal.get 7\ncall 17\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=12\nlocal.get 4\ni32.load offset=24\nlocal.set 9\nlocal.get 4\ni32.load offset=12\nlocal.set 10\ni32.const 16\nlocal.set 11\nlocal.get 4\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nlocal.set 13\nlocal.get 9\nlocal.get 13\nlocal.get 10\ncall 40\nlocal.set 24\nlocal.get 4\ni32.load offset=20\nlocal.set 14\nlocal.get 14\nlocal.get 24\nf64.store\nlocal.get 4\ni32.load offset=20\nlocal.set 15\nlocal.get 15\nf64.load\nlocal.set 25\nlocal.get 25\ncall 4\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 18\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=16\nlocal.set 20\nlocal.get 4\nlocal.get 20\ni32.store offset=28\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 21\ni32.const 32\nlocal.set 22\nlocal.get 4\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 23\nglobal.set 0\nlocal.get 21\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_159",
        "query_text": "The function accepts a 64-bit unsigned integer as input and returns a 64-bit unsigned integer as output. It processes the input through multiple stages of transformation. Initially, the function applies a bitwise XOR combined with a right-shift operation. It then multiplies the intermediate value by a predefined constant. This sequence is repeated: after a second XOR shift, another multiplication with a different constant is performed, followed by a final XOR shift. The resulting value from these operations is returned as the function's output.",
        "code_id": "c_group_1_id_159",
        "code_text": "(func (;1;) (type 2) (param i64) (result i64)\n(local i32 i32 i32 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 4\ni64.const 33\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni64.shr_u\nlocal.set 6\nlocal.get 3\ni64.load offset=8\nlocal.set 7\nlocal.get 7\nlocal.get 6\ni64.xor\nlocal.set 8\nlocal.get 3\nlocal.get 8\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 9\ni64.const -49064778989728563\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni64.mul\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 12\ni64.const 33\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni64.shr_u\nlocal.set 14\nlocal.get 3\ni64.load offset=8\nlocal.set 15\nlocal.get 15\nlocal.get 14\ni64.xor\nlocal.set 16\nlocal.get 3\nlocal.get 16\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 17\ni64.const -4265267296055464877\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni64.mul\nlocal.set 19\nlocal.get 3\nlocal.get 19\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 20\ni64.const 33\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni64.shr_u\nlocal.set 22\nlocal.get 3\ni64.load offset=8\nlocal.set 23\nlocal.get 23\nlocal.get 22\ni64.xor\nlocal.set 24\nlocal.get 3\nlocal.get 24\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 25\nlocal.get 25\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_162",
        "query_text": "The function takes a double-precision floating-point number as input and returns an integer. It verifies whether the input lies within a valid range defined by a predetermined constant. Specifically, the function checks if the input is less than the reciprocal of this constant or greater than the constant itself. If the input falls outside this range, the function returns a non-zero value to indicate an invalid condition; otherwise, it returns zero, signifying that the input is within the acceptable bounds.",
        "code_id": "c_group_1_id_162",
        "code_text": "(func (;1;) (type 2) (param f64) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf64.store offset=8\nlocal.get 3\nf64.load offset=8\nlocal.set 13\nf64.const 0x1p-8 (;=0.00390625;)\nlocal.set 14\nlocal.get 13\nlocal.get 14\nf64.lt\nlocal.set 4\ni32.const 1\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 5\nlocal.set 8\nblock  ;; label = @1\nlocal.get 7\nbr_if 0 (;@1;)\nlocal.get 3\nf64.load offset=8\nlocal.set 15\nf64.const 0x1p+8 (;=256;)\nlocal.set 16\nlocal.get 15\nlocal.get 16\nf64.gt\nlocal.set 9\nlocal.get 9\nlocal.set 8\nend\nlocal.get 8\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_163",
        "query_text": "The function accepts two integer parameters: the first is a non-negative integer, and the second is a positive integer. It calculates the ceiling of the division of the first parameter by the second, ensuring that any fractional result is rounded up to the next whole number. The function returns the computed result as an integer.",
        "code_id": "c_group_1_id_163",
        "code_text": "(func (;5;) (type 5) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.ge_s\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=8\nlocal.set 10\ni32.const 0\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.gt_s\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nlocal.get 14\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 65659\nlocal.set 15\ni32.const 65565\nlocal.set 16\ni32.const 19\nlocal.set 17\ni32.const 65690\nlocal.set 18\nlocal.get 15\nlocal.get 16\nlocal.get 17\nlocal.get 18\ncall 7\nunreachable\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 19\nlocal.get 4\ni32.load offset=8\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.sub\nlocal.set 22\nlocal.get 19\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 4\ni32.load offset=8\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.div_s\nlocal.set 25\ni32.const 16\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\nglobal.set 0\nlocal.get 25\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_164",
        "query_text": "The function takes a single integer input that acts as a reset flag and returns an integer output corresponding to a block length. It maintains an internal state representing a fixed sequence of block lengths. When the reset flag is non-zero, the internal state is reinitialized so that the next output comes from the start of the sequence. When the reset flag is zero, the function outputs the subsequent block length in the sequence, wrapping around to the beginning once the end is reached.",
        "code_id": "c_group_1_id_164",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 64\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=60\ni32.const 0\nlocal.set 4\nlocal.get 4\ni32.load offset=65568\nlocal.set 5\ni32.const 48\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.get 5\ni32.store\nlocal.get 4\ni64.load offset=65560\nlocal.set 28\ni32.const 40\nlocal.set 8\nlocal.get 3\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nlocal.get 28\ni64.store\nlocal.get 4\ni64.load offset=65552\nlocal.set 29\ni32.const 32\nlocal.set 10\nlocal.get 3\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 11\nlocal.get 29\ni64.store\nlocal.get 4\ni64.load offset=65544\nlocal.set 30\nlocal.get 3\nlocal.get 30\ni64.store offset=24\nlocal.get 4\ni64.load offset=65536\nlocal.set 31\nlocal.get 3\nlocal.get 31\ni64.store offset=16\ni32.const 0\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.store offset=12\nlocal.get 3\ni32.load offset=60\nlocal.set 13\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 13\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 14\nlocal.get 3\nlocal.get 14\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 15\ni32.const 1\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.add\nlocal.set 17\ni32.const 9\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.rem_s\nlocal.set 19\nlocal.get 3\nlocal.get 19\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 20\ni32.const 16\nlocal.set 21\nlocal.get 3\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 22\nlocal.set 23\ni32.const 2\nlocal.set 24\nlocal.get 20\nlocal.get 24\ni32.shl\nlocal.set 25\nlocal.get 23\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 26\ni32.load\nlocal.set 27\nlocal.get 27\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_165",
        "query_text": "This function provides a static buffer of floats and its size to the caller. It takes two inputs: a generic pointer (unused) and a pointer to a pointer to a float. The function assigns the static float buffer to the provided pointer-to-pointer, enabling external access to the buffer. Finally, it returns the number of elements in the buffer as a long integer.",
        "code_id": "c_group_1_id_165",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 96\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=92\nlocal.get 4\nlocal.get 1\ni32.store offset=88\nlocal.get 4\nlocal.set 5\nlocal.get 4\ni32.load offset=88\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.store\ni32.const 20\nlocal.set 7\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_168",
        "query_text": "The function accepts one input: a character. It outputs a signed 8-bit integer, representing the corresponding numeric value of the input if it is a valid hexadecimal digit (i.e. '0'-'9', 'A'-'F', or 'a'-'f'). If the character is not a valid hexadecimal digit, the function returns -1. The input type is char, while the output type is a signed char.",
        "code_id": "c_group_1_id_168",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store8 offset=14\nlocal.get 3\ni32.load8_u offset=14\nlocal.set 5\ni32.const 24\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.shl\nlocal.set 7\nlocal.get 7\nlocal.get 6\ni32.shr_s\nlocal.set 8\ni32.const 48\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.ge_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 12\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load8_u offset=14\nlocal.set 13\ni32.const 24\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 15\nlocal.get 14\ni32.shr_s\nlocal.set 16\ni32.const 57\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.le_s\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\nlocal.get 20\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load8_u offset=14\nlocal.set 21\ni32.const 24\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.shl\nlocal.set 23\nlocal.get 23\nlocal.get 22\ni32.shr_s\nlocal.set 24\ni32.const 48\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.sub\nlocal.set 26\nlocal.get 3\nlocal.get 26\ni32.store8 offset=14\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load8_u offset=14\nlocal.set 27\ni32.const 24\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.shl\nlocal.set 29\nlocal.get 29\nlocal.get 28\ni32.shr_s\nlocal.set 30\ni32.const 65\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.ge_s\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.and\nlocal.set 34\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 34\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load8_u offset=14\nlocal.set 35\ni32.const 24\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.shl\nlocal.set 37\nlocal.get 37\nlocal.get 36\ni32.shr_s\nlocal.set 38\ni32.const 70\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.le_s\nlocal.set 40\ni32.const 1\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.and\nlocal.set 42\nlocal.get 42\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load8_u offset=14\nlocal.set 43\ni32.const 24\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.shl\nlocal.set 45\nlocal.get 45\nlocal.get 44\ni32.shr_s\nlocal.set 46\ni32.const 55\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.sub\nlocal.set 48\nlocal.get 3\nlocal.get 48\ni32.store8 offset=14\nbr 1 (;@2;)\nend\nlocal.get 3\ni32.load8_u offset=14\nlocal.set 49\ni32.const 24\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.shl\nlocal.set 51\nlocal.get 51\nlocal.get 50\ni32.shr_s\nlocal.set 52\ni32.const 97\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.ge_s\nlocal.set 54\ni32.const 1\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.and\nlocal.set 56\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 56\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 3\ni32.load8_u offset=14\nlocal.set 57\ni32.const 24\nlocal.set 58\nlocal.get 57\nlocal.get 58\ni32.shl\nlocal.set 59\nlocal.get 59\nlocal.get 58\ni32.shr_s\nlocal.set 60\ni32.const 102\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.le_s\nlocal.set 62\ni32.const 1\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.and\nlocal.set 64\nlocal.get 64\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 3\ni32.load8_u offset=14\nlocal.set 65\ni32.const 24\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.shl\nlocal.set 67\nlocal.get 67\nlocal.get 66\ni32.shr_s\nlocal.set 68\ni32.const 87\nlocal.set 69\nlocal.get 68\nlocal.get 69\ni32.sub\nlocal.set 70\nlocal.get 3\nlocal.get 70\ni32.store8 offset=14\nbr 1 (;@3;)\nend\ni32.const 255\nlocal.set 71\nlocal.get 3\nlocal.get 71\ni32.store8 offset=14\nend\nend\nend\nlocal.get 3\ni32.load8_u offset=14\nlocal.set 72\ni32.const 24\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.shl\nlocal.set 74\nlocal.get 74\nlocal.get 73\ni32.shr_s\nlocal.set 75\nlocal.get 75\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_169",
        "query_text": "This function examines an input character to determine if it qualifies as a whitespace character. It accepts a character (of type char) and checks if it is either a space, a tab, or a newline. If the character matches any of these, the function returns an integer value of 1; otherwise, it returns 0. The output is of type int, signifying a boolean-like indicator for whitespace detection.",
        "code_id": "c_group_1_id_169",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=11\nlocal.get 3\ni32.load8_s offset=11\nlocal.set 4\ni32.const -9\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.add\nlocal.set 6\ni32.const 2\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.lt_u\nlocal.set 8\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 8\nbr_if 0 (;@3;)\ni32.const 32\nlocal.set 9\nlocal.get 4\nlocal.get 9\ni32.ne\nlocal.set 10\nlocal.get 10\nbr_if 1 (;@2;)\nend\ni32.const 1\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 13\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_170",
        "query_text": "The function accepts an array of unsigned characters, represented by a pointer, along with an integer that specifies the length of this array. It checks whether the provided pointer is NULL; if it is, the function immediately terminates without making any modifications. Otherwise, it reverses the elements in the array in place by swapping the first element with the last, the second element with the second-to-last, and continuing this process until the entire array is reversed. The function does not return any value.",
        "code_id": "c_group_1_id_170",
        "code_text": "(func (;1;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\nlocal.get 4\ni32.load offset=28\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.eq\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.sub\nlocal.set 13\nlocal.get 4\nlocal.get 13\ni32.store offset=16\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=20\nlocal.set 14\nlocal.get 4\ni32.load offset=16\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.lt_s\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 18\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=28\nlocal.set 19\nlocal.get 4\ni32.load offset=20\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\ni32.load8_u\nlocal.set 22\nlocal.get 4\nlocal.get 22\ni32.store8 offset=15\nlocal.get 4\ni32.load offset=28\nlocal.set 23\nlocal.get 4\ni32.load offset=16\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\ni32.load8_u\nlocal.set 26\nlocal.get 4\ni32.load offset=28\nlocal.set 27\nlocal.get 4\ni32.load offset=20\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 29\nlocal.get 26\ni32.store8\nlocal.get 4\ni32.load8_u offset=15\nlocal.set 30\nlocal.get 4\ni32.load offset=28\nlocal.set 31\nlocal.get 4\ni32.load offset=16\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.add\nlocal.set 33\nlocal.get 33\nlocal.get 30\ni32.store8\nlocal.get 4\ni32.load offset=20\nlocal.set 34\ni32.const 1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 4\nlocal.get 36\ni32.store offset=20\nlocal.get 4\ni32.load offset=16\nlocal.set 37\ni32.const -1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 4\nlocal.get 39\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_171",
        "query_text": "The function is a void function that accepts no input parameters and returns no value. It initializes the error handling mechanism of the library by loading a set of predefined error strings. These error messages allow for error codes generated during execution to be translated into meaningful, human-readable descriptions.",
        "code_id": "c_group_1_id_171",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_172",
        "query_text": "The function accepts a single unsigned long integer that represents an error code and returns a pointer to a constant character string. It is designed to generate a human-readable description of the library associated with the provided error code. When a specific compile-time flag is enabled, the function extracts a library identifier from the error code and then checks this identifier against known values. If it matches one of the predefined identifiers (such as those corresponding to routines for handling specific file formats or cryptographic operations), it returns a descriptive string for that library routine. If the identifier is unrecognized or the compile-time flag is not enabled, the function simply returns an empty string. This mechanism is primarily utilized for error logging and debugging purposes.",
        "code_id": "c_group_1_id_172",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\ni32.const 65536\nlocal.set 5\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_173",
        "query_text": "The function accepts two pointer inputs: one pointing to the start of a character array and the other pointing to its end. It sequentially examines each character from the beginning, skipping any occurrence of carriage return ('\\r') or newline ('\\n'). The function returns the pointer to the first character that is not a line-ending character.",
        "code_id": "c_group_1_id_173",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nloop  ;; label = @1\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.lt_u\nlocal.set 7\ni32.const 0\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 7\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 8\nlocal.set 11\nblock  ;; label = @2\nlocal.get 10\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 12\nlocal.get 12\ni32.load8_u\nlocal.set 13\ni32.const 24\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 15\nlocal.get 14\ni32.shr_s\nlocal.set 16\ni32.const 13\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.eq\nlocal.set 18\ni32.const 1\nlocal.set 19\ni32.const 1\nlocal.set 20\nlocal.get 18\nlocal.get 20\ni32.and\nlocal.set 21\nlocal.get 19\nlocal.set 22\nblock  ;; label = @3\nlocal.get 21\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=12\nlocal.set 23\nlocal.get 23\ni32.load8_u\nlocal.set 24\ni32.const 24\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.shl\nlocal.set 26\nlocal.get 26\nlocal.get 25\ni32.shr_s\nlocal.set 27\ni32.const 10\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.eq\nlocal.set 29\nlocal.get 29\nlocal.set 22\nend\nlocal.get 22\nlocal.set 30\nlocal.get 30\nlocal.set 11\nend\nlocal.get 11\nlocal.set 31\ni32.const 1\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.and\nlocal.set 33\nblock  ;; label = @2\nlocal.get 33\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 34\ni32.const 1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 4\nlocal.get 36\ni32.store offset=12\nbr 1 (;@1;)\nend\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 37\nlocal.get 37\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_174",
        "query_text": "The function takes an integer input representing an alert type and logs a formatted alert message if debug mode is enabled. It first converts the integer to a string using a helper routine; if the conversion is successful, it incorporates the string into a predefined message format and logs the result. When debug mode is not enabled, the input is disregarded and no logging occurs. The function does not produce a return value.",
        "code_id": "c_group_1_id_174",
        "code_text": "(func (;1;) (type 2) (param i32)\n(local i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_175",
        "query_text": "The function takes two inputs: an integer representing an error value and a socket descriptor (which is often unused). It returns an integer that represents the last error code for a socket operation, following the platform-specific error retrieval mechanism. If the input error value is positive, the function returns 0 to indicate the absence of an error. Otherwise, it determines and returns the appropriate error code based on the current platform's implementation (such as for Windows, Linux kernel mode, or various embedded systems).",
        "code_id": "c_group_1_id_175",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.gt_s\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.store offset=12\nbr 1 (;@1;)\nend\ncall 3\nlocal.set 11\nlocal.get 11\ni32.load\nlocal.set 12\nlocal.get 4\nlocal.get 12\ni32.store offset=12\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 13\ni32.const 16\nlocal.set 14\nlocal.get 4\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nglobal.set 0\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_176",
        "query_text": "The function takes an input\u2014a constant C-string pointer that represents a directory path\u2014and attempts to remove the directory. It uses a platform-specific system call: on Windows (compiled with MSVC), it invokes one removal function; on other platforms, it uses a different standard removal function. If the removal is successful, the function returns 0; if it fails, the function returns -1. The input type is a const char pointer and the output type is an int.",
        "code_id": "c_group_1_id_176",
        "code_text": "(func (;2;) (type 1) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 4\nlocal.get 4\ncall 4\nlocal.set 5\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 5\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 8\ni32.const 16\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nglobal.set 0\nlocal.get 8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_177",
        "query_text": "This function removes a file from the file system based on a provided string that specifies the file's name. It utilizes platform-specific system calls: on certain Windows compilers, it employs one call, whereas on other systems it uses an alternative call. If the deletion operation completes successfully, the function returns 0; if it fails, the function returns -1 to signal an error.",
        "code_id": "c_group_1_id_177",
        "code_text": "(func (;2;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 4\nlocal.get 4\ncall 6\nlocal.set 5\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 5\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 8\ni32.const 16\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nglobal.set 0\nlocal.get 8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_178",
        "query_text": "The function generates a formatted string that lists supported protocol versions and optional feature flags, and then prints this string to the console. It begins by initializing a fixed-size character array with zeros and then conditionally appends version identifiers (such as \"0:\", \"1:\", \"2:\", etc.) based on preprocessor definitions. Depending on the compilation configuration, it may also append additional markers like a downgrade flag or an either-side flag. The function does not accept any input parameters and does not return any value.",
        "code_id": "c_group_1_id_178",
        "code_text": "(func (;2;) (type 3)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 128\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.add\nlocal.set 4\nlocal.get 4\nlocal.set 5\ni32.const 100\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 5\nlocal.get 7\nlocal.get 6\ncall 4\ndrop\ni32.const 16\nlocal.set 8\nlocal.get 2\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nlocal.set 10\ni32.const 65587\nlocal.set 11\ni32.const 3\nlocal.set 12\nlocal.get 10\nlocal.get 11\nlocal.get 12\ncall 19\ndrop\ni32.const 16\nlocal.set 13\nlocal.get 2\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\nlocal.set 15\ni32.const 65584\nlocal.set 16\ni32.const 3\nlocal.set 17\nlocal.get 15\nlocal.get 16\nlocal.get 17\ncall 19\ndrop\ni32.const 16\nlocal.set 18\nlocal.get 2\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 19\nlocal.set 20\ni32.const 65581\nlocal.set 21\ni32.const 3\nlocal.set 22\nlocal.get 20\nlocal.get 21\nlocal.get 22\ncall 19\ndrop\ni32.const 16\nlocal.set 23\nlocal.get 2\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nlocal.set 25\ni32.const 65590\nlocal.set 26\ni32.const 14\nlocal.set 27\nlocal.get 25\nlocal.get 26\nlocal.get 27\ncall 19\ndrop\ni32.const 16\nlocal.set 28\nlocal.get 2\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 29\nlocal.set 30\nlocal.get 2\nlocal.get 30\ni32.store\ni32.const 65613\nlocal.set 31\nlocal.get 31\nlocal.get 2\ncall 13\ndrop\ni32.const 0\nlocal.set 32\nlocal.get 32\ni32.load offset=65620\nlocal.set 33\nlocal.get 33\ncall 7\ndrop\ni32.const 128\nlocal.set 34\nlocal.get 2\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 35\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_179",
        "query_text": "The function takes a pointer to an integer, representing a socket file descriptor, as its input. It first checks whether the socket is open by examining if the integer is not equal to -1. If the socket is open, the function proceeds to close the socket and then sets the file descriptor to -1 to mark it as invalid. Additionally, under a specific compilation condition, it resets a global status flag to 0. The function does not return any value; its main purpose is to safely close and clean up the socket.",
        "code_id": "c_group_1_id_179",
        "code_text": "(func (;2;) (type 3) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ni32.load\nlocal.set 5\ni32.const -1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.ne\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nlocal.get 9\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 10\nlocal.get 10\ni32.load\nlocal.set 11\nlocal.get 11\ncall 5\ndrop\nlocal.get 3\ni32.load offset=12\nlocal.set 12\ni32.const -1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.store\nend\ni32.const 16\nlocal.set 14\nlocal.get 3\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_180",
        "query_text": "The function takes a pointer to an integer as input. It begins by checking if the integer value is not equal to -1. If this condition is met, the function closes the resource associated with this value (such as a file descriptor or socket) and then resets the value to -1 to indicate the resource is no longer active. The function does not return a value.",
        "code_id": "c_group_1_id_180",
        "code_text": "(func (;2;) (type 3) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ni32.load\nlocal.set 5\ni32.const -1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.ne\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nlocal.get 9\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 10\nlocal.get 10\ni32.load\nlocal.set 11\nlocal.get 11\ncall 5\ndrop\nlocal.get 3\ni32.load offset=12\nlocal.set 12\ni32.const -1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.store\nend\ni32.const 16\nlocal.set 14\nlocal.get 3\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_181",
        "query_text": "The function accepts a pointer to a double value representing a numerical quantity, and returns a constant C-string indicating a unit of measurement. It first evaluates compile-time flags to determine if a fixed unit should be used\u2014dividing the value accordingly by factors of 1,000,000,000, 1,000,000, or 1,000 for gigabytes, megabytes, or kilobytes respectively, or leaving the value unchanged for bytes. If no fixed unit is specified at compile time, the function adjusts the input value at runtime based on its magnitude: values larger than one million are scaled to megabytes, values larger than one thousand to kilobytes, and values below this threshold remain in bytes. Finally, a constant string denoting the unit (\"GB\", \"MB\", \"KB\", or \"bytes\") is returned.",
        "code_id": "c_group_1_id_181",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nf64.load\nlocal.set 18\nf64.const 0x1.e848p+19 (;=1e+06;)\nlocal.set 19\nlocal.get 18\nlocal.get 19\nf64.gt\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 7\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=12\nlocal.set 8\nlocal.get 8\nf64.load\nlocal.set 20\nf64.const 0x1.e848p+19 (;=1e+06;)\nlocal.set 21\nlocal.get 20\nlocal.get 21\nf64.div\nlocal.set 22\nlocal.get 8\nlocal.get 22\nf64.store\ni32.const 65542\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=8\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 10\nlocal.get 10\nf64.load\nlocal.set 23\nf64.const 0x1.f4p+9 (;=1000;)\nlocal.set 24\nlocal.get 23\nlocal.get 24\nf64.gt\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 13\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load offset=12\nlocal.set 14\nlocal.get 14\nf64.load\nlocal.set 25\nf64.const 0x1.f4p+9 (;=1000;)\nlocal.set 26\nlocal.get 25\nlocal.get 26\nf64.div\nlocal.set 27\nlocal.get 14\nlocal.get 27\nf64.store\ni32.const 65545\nlocal.set 15\nlocal.get 3\nlocal.get 15\ni32.store offset=8\nbr 1 (;@2;)\nend\ni32.const 65536\nlocal.set 16\nlocal.get 3\nlocal.get 16\ni32.store offset=8\nend\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 17\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_182",
        "query_text": "This function conditionally deallocates memory for a linked list of statistics data structures when a specific compilation flag is active. It iterates over the list starting from the head, freeing each node by invoking a custom memory deallocation routine. After traversing and freeing all nodes, the function resets both the head and tail pointers to null, thereby reinitializing the list. The function takes no inputs and returns no output (void), serving solely to clean up dynamically allocated memory associated with the statistics tracking system.",
        "code_id": "c_group_1_id_182",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_183",
        "query_text": "The function accepts as input a pointer to a constant character array (string) and a pointer to an integer representing the current line length. It outputs the string with proper indentation and line wrapping: initially adding an indentation when starting a new line, then printing the string while updating the line length counter. If the current line length exceeds a predefined maximum value, the function outputs a newline and resets the counter. The function returns no value (void); its purpose is to format and print text so that it adheres to a specified line width.",
        "code_id": "c_group_1_id_183",
        "code_text": "(func (;2;) (type 5) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 65594\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 6\nlocal.get 6\ni32.load\nlocal.set 7\nblock  ;; label = @1\nlocal.get 7\nbr_if 0 (;@1;)\ni32.const 65594\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=16\ni32.const 65566\nlocal.set 9\ni32.const 16\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 9\nlocal.get 11\ncall 12\ndrop\ni32.const 0\nlocal.set 12\nlocal.get 12\ni32.load offset=65612\nlocal.set 13\nlocal.get 13\ncall 6\ndrop\nlocal.get 4\ni32.load offset=24\nlocal.set 14\ni32.const 13\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.store\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 16\nlocal.get 4\nlocal.get 16\ni32.store\ni32.const 65565\nlocal.set 17\nlocal.get 17\nlocal.get 4\ncall 12\ndrop\ni32.const 0\nlocal.set 18\nlocal.get 18\ni32.load offset=65612\nlocal.set 19\nlocal.get 19\ncall 6\ndrop\nlocal.get 4\ni32.load offset=28\nlocal.set 20\nlocal.get 20\ncall 17\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 4\ni32.load offset=24\nlocal.set 24\nlocal.get 24\ni32.load\nlocal.set 25\nlocal.get 25\nlocal.get 23\ni32.add\nlocal.set 26\nlocal.get 24\nlocal.get 26\ni32.store\nlocal.get 4\ni32.load offset=24\nlocal.set 27\nlocal.get 27\ni32.load\nlocal.set 28\ni32.const 80\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.gt_s\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nblock  ;; label = @1\nlocal.get 32\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 65608\nlocal.set 33\ni32.const 0\nlocal.set 34\nlocal.get 33\nlocal.get 34\ncall 12\ndrop\ni32.const 0\nlocal.set 35\nlocal.get 35\ni32.load offset=65612\nlocal.set 36\nlocal.get 36\ncall 6\ndrop\nlocal.get 4\ni32.load offset=24\nlocal.set 37\ni32.const 0\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.store\nend\ni32.const 32\nlocal.set 39\nlocal.get 4\nlocal.get 39\ni32.add\nlocal.set 40\nlocal.get 40\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_184",
        "query_text": "The function accepts two constant character arrays (strings) as inputs. It performs a case-sensitive exact string comparison and returns an integer value: it returns 1 if the strings are identical and 0 if they are not.",
        "code_id": "c_group_1_id_184",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.eq\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\ni32.const 16\nlocal.set 12\nlocal.get 4\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_185",
        "query_text": "The function takes no input and returns a boolean value. It verifies whether the system or compiler correctly encodes a particular Unicode character in UTF-8 format. To do so, the function first checks if the byte-length of a string literal representing the character is three, which is the expected length for its UTF-8 encoding. It then confirms that the first two bytes of the string match the predetermined values required for the proper UTF-8 representation of the character. Based on these checks, the function returns true if both conditions are met, indicating that UTF-8 encoding is supported; otherwise, it returns false.",
        "code_id": "c_group_1_id_185",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\ni32.const 0\nlocal.set 0\nlocal.get 0\ni32.load8_u offset=65537\nlocal.set 1\ni32.const 255\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.and\nlocal.set 3\ni32.const 167\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.eq\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_186",
        "query_text": "The function takes three pointer parameters. The first parameter is a pointer to a UTF-8 encoded character array, the second is a pointer to an unsigned 32-bit integer that will hold the decoded Unicode code point, and the third is a pointer to an integer used to store error flags. The function begins by determining the byte-length of the current UTF-8 character, then decodes the character by applying bit masks and shifts to combine up to four bytes into a single Unicode code point. As it decodes, it also checks for several error conditions\u2014such as values below a minimum threshold, excessively large values, or improperly encoded continuation bytes\u2014by setting corresponding error flags. Finally, it returns a pointer to the next character in the input string, while updating the provided outputs with the decoded code point and any detected encoding errors.",
        "code_id": "c_group_1_id_186",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 3\ni32.const 144\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=140\nlocal.get 5\nlocal.get 1\ni32.store offset=136\nlocal.get 5\nlocal.get 2\ni32.store offset=132\ni32.const 0\nlocal.set 6\nlocal.get 6\ni32.load offset=65552\nlocal.set 7\ni32.const 128\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nlocal.get 7\ni32.store\nlocal.get 6\ni64.load offset=65544\nlocal.set 192\nlocal.get 5\nlocal.get 192\ni64.store offset=120\nlocal.get 6\ni64.load offset=65536\nlocal.set 193\nlocal.get 5\nlocal.get 193\ni64.store offset=112\ni32.const 0\nlocal.set 10\nlocal.get 10\ni32.load offset=65584\nlocal.set 11\ni32.const 96\nlocal.set 12\nlocal.get 5\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nlocal.get 11\ni32.store\nlocal.get 10\ni64.load offset=65576\nlocal.set 194\nlocal.get 5\nlocal.get 194\ni64.store offset=88\nlocal.get 10\ni64.load offset=65568\nlocal.set 195\nlocal.get 5\nlocal.get 195\ni64.store offset=80\ni32.const 0\nlocal.set 14\nlocal.get 14\ni32.load offset=65616\nlocal.set 15\ni32.const 64\nlocal.set 16\nlocal.get 5\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nlocal.get 15\ni32.store\nlocal.get 14\ni64.load offset=65608\nlocal.set 196\nlocal.get 5\nlocal.get 196\ni64.store offset=56\nlocal.get 14\ni64.load offset=65600\nlocal.set 197\nlocal.get 5\nlocal.get 197\ni64.store offset=48\ni32.const 0\nlocal.set 18\nlocal.get 18\ni32.load offset=65648\nlocal.set 19\ni32.const 32\nlocal.set 20\nlocal.get 5\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nlocal.get 19\ni32.store\nlocal.get 18\ni64.load offset=65640\nlocal.set 198\nlocal.get 5\nlocal.get 198\ni64.store offset=24\nlocal.get 18\ni64.load offset=65632\nlocal.set 199\nlocal.get 5\nlocal.get 199\ni64.store offset=16\nlocal.get 5\ni32.load offset=140\nlocal.set 22\nlocal.get 22\ni32.load8_u\nlocal.set 23\ni32.const 255\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\ni32.const 3\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.shr_s\nlocal.set 27\nlocal.get 27\ni32.load8_u offset=65652\nlocal.set 28\ni32.const 24\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.shl\nlocal.set 30\nlocal.get 30\nlocal.get 29\ni32.shr_s\nlocal.set 31\nlocal.get 5\nlocal.get 31\ni32.store offset=12\nlocal.get 5\ni32.load offset=140\nlocal.set 32\nlocal.get 5\ni32.load offset=12\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.add\nlocal.set 34\nlocal.get 5\ni32.load offset=12\nlocal.set 35\ni32.const 0\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.ne\nlocal.set 37\ni32.const -1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.xor\nlocal.set 39\ni32.const 1\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.and\nlocal.set 41\nlocal.get 34\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 5\nlocal.get 42\ni32.store offset=8\nlocal.get 5\ni32.load offset=140\nlocal.set 43\nlocal.get 43\ni32.load8_u\nlocal.set 44\ni32.const 255\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.and\nlocal.set 46\nlocal.get 5\ni32.load offset=12\nlocal.set 47\ni32.const 112\nlocal.set 48\nlocal.get 5\nlocal.get 48\ni32.add\nlocal.set 49\nlocal.get 49\nlocal.set 50\ni32.const 2\nlocal.set 51\nlocal.get 47\nlocal.get 51\ni32.shl\nlocal.set 52\nlocal.get 50\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\ni32.load\nlocal.set 54\nlocal.get 46\nlocal.get 54\ni32.and\nlocal.set 55\ni32.const 18\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.shl\nlocal.set 57\nlocal.get 5\ni32.load offset=136\nlocal.set 58\nlocal.get 58\nlocal.get 57\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 59\nlocal.get 59\ni32.load8_u offset=1\nlocal.set 60\ni32.const 255\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.and\nlocal.set 62\ni32.const 63\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.and\nlocal.set 64\ni32.const 12\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.shl\nlocal.set 66\nlocal.get 5\ni32.load offset=136\nlocal.set 67\nlocal.get 67\ni32.load\nlocal.set 68\nlocal.get 68\nlocal.get 66\ni32.or\nlocal.set 69\nlocal.get 67\nlocal.get 69\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 70\nlocal.get 70\ni32.load8_u offset=2\nlocal.set 71\ni32.const 255\nlocal.set 72\nlocal.get 71\nlocal.get 72\ni32.and\nlocal.set 73\ni32.const 63\nlocal.set 74\nlocal.get 73\nlocal.get 74\ni32.and\nlocal.set 75\ni32.const 6\nlocal.set 76\nlocal.get 75\nlocal.get 76\ni32.shl\nlocal.set 77\nlocal.get 5\ni32.load offset=136\nlocal.set 78\nlocal.get 78\ni32.load\nlocal.set 79\nlocal.get 79\nlocal.get 77\ni32.or\nlocal.set 80\nlocal.get 78\nlocal.get 80\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 81\nlocal.get 81\ni32.load8_u offset=3\nlocal.set 82\ni32.const 255\nlocal.set 83\nlocal.get 82\nlocal.get 83\ni32.and\nlocal.set 84\ni32.const 63\nlocal.set 85\nlocal.get 84\nlocal.get 85\ni32.and\nlocal.set 86\ni32.const 0\nlocal.set 87\nlocal.get 86\nlocal.get 87\ni32.shl\nlocal.set 88\nlocal.get 5\ni32.load offset=136\nlocal.set 89\nlocal.get 89\ni32.load\nlocal.set 90\nlocal.get 90\nlocal.get 88\ni32.or\nlocal.set 91\nlocal.get 89\nlocal.get 91\ni32.store\nlocal.get 5\ni32.load offset=12\nlocal.set 92\ni32.const 48\nlocal.set 93\nlocal.get 5\nlocal.get 93\ni32.add\nlocal.set 94\nlocal.get 94\nlocal.set 95\ni32.const 2\nlocal.set 96\nlocal.get 92\nlocal.get 96\ni32.shl\nlocal.set 97\nlocal.get 95\nlocal.get 97\ni32.add\nlocal.set 98\nlocal.get 98\ni32.load\nlocal.set 99\nlocal.get 5\ni32.load offset=136\nlocal.set 100\nlocal.get 100\ni32.load\nlocal.set 101\nlocal.get 101\nlocal.get 99\ni32.shr_u\nlocal.set 102\nlocal.get 100\nlocal.get 102\ni32.store\nlocal.get 5\ni32.load offset=136\nlocal.set 103\nlocal.get 103\ni32.load\nlocal.set 104\nlocal.get 5\ni32.load offset=12\nlocal.set 105\ni32.const 80\nlocal.set 106\nlocal.get 5\nlocal.get 106\ni32.add\nlocal.set 107\nlocal.get 107\nlocal.set 108\ni32.const 2\nlocal.set 109\nlocal.get 105\nlocal.get 109\ni32.shl\nlocal.set 110\nlocal.get 108\nlocal.get 110\ni32.add\nlocal.set 111\nlocal.get 111\ni32.load\nlocal.set 112\nlocal.get 104\nlocal.get 112\ni32.lt_u\nlocal.set 113\ni32.const 1\nlocal.set 114\nlocal.get 113\nlocal.get 114\ni32.and\nlocal.set 115\ni32.const 6\nlocal.set 116\nlocal.get 115\nlocal.get 116\ni32.shl\nlocal.set 117\nlocal.get 5\ni32.load offset=132\nlocal.set 118\nlocal.get 118\nlocal.get 117\ni32.store\nlocal.get 5\ni32.load offset=136\nlocal.set 119\nlocal.get 119\ni32.load\nlocal.set 120\ni32.const 11\nlocal.set 121\nlocal.get 120\nlocal.get 121\ni32.shr_u\nlocal.set 122\ni32.const 27\nlocal.set 123\nlocal.get 122\nlocal.get 123\ni32.eq\nlocal.set 124\ni32.const 1\nlocal.set 125\nlocal.get 124\nlocal.get 125\ni32.and\nlocal.set 126\ni32.const 7\nlocal.set 127\nlocal.get 126\nlocal.get 127\ni32.shl\nlocal.set 128\nlocal.get 5\ni32.load offset=132\nlocal.set 129\nlocal.get 129\ni32.load\nlocal.set 130\nlocal.get 130\nlocal.get 128\ni32.or\nlocal.set 131\nlocal.get 129\nlocal.get 131\ni32.store\nlocal.get 5\ni32.load offset=136\nlocal.set 132\nlocal.get 132\ni32.load\nlocal.set 133\ni32.const 1114111\nlocal.set 134\nlocal.get 133\nlocal.get 134\ni32.gt_u\nlocal.set 135\ni32.const 1\nlocal.set 136\nlocal.get 135\nlocal.get 136\ni32.and\nlocal.set 137\ni32.const 8\nlocal.set 138\nlocal.get 137\nlocal.get 138\ni32.shl\nlocal.set 139\nlocal.get 5\ni32.load offset=132\nlocal.set 140\nlocal.get 140\ni32.load\nlocal.set 141\nlocal.get 141\nlocal.get 139\ni32.or\nlocal.set 142\nlocal.get 140\nlocal.get 142\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 143\nlocal.get 143\ni32.load8_u offset=1\nlocal.set 144\ni32.const 255\nlocal.set 145\nlocal.get 144\nlocal.get 145\ni32.and\nlocal.set 146\ni32.const 192\nlocal.set 147\nlocal.get 146\nlocal.get 147\ni32.and\nlocal.set 148\ni32.const 2\nlocal.set 149\nlocal.get 148\nlocal.get 149\ni32.shr_s\nlocal.set 150\nlocal.get 5\ni32.load offset=132\nlocal.set 151\nlocal.get 151\ni32.load\nlocal.set 152\nlocal.get 152\nlocal.get 150\ni32.or\nlocal.set 153\nlocal.get 151\nlocal.get 153\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 154\nlocal.get 154\ni32.load8_u offset=2\nlocal.set 155\ni32.const 255\nlocal.set 156\nlocal.get 155\nlocal.get 156\ni32.and\nlocal.set 157\ni32.const 192\nlocal.set 158\nlocal.get 157\nlocal.get 158\ni32.and\nlocal.set 159\ni32.const 4\nlocal.set 160\nlocal.get 159\nlocal.get 160\ni32.shr_s\nlocal.set 161\nlocal.get 5\ni32.load offset=132\nlocal.set 162\nlocal.get 162\ni32.load\nlocal.set 163\nlocal.get 163\nlocal.get 161\ni32.or\nlocal.set 164\nlocal.get 162\nlocal.get 164\ni32.store\nlocal.get 5\ni32.load offset=140\nlocal.set 165\nlocal.get 165\ni32.load8_u offset=3\nlocal.set 166\ni32.const 255\nlocal.set 167\nlocal.get 166\nlocal.get 167\ni32.and\nlocal.set 168\ni32.const 6\nlocal.set 169\nlocal.get 168\nlocal.get 169\ni32.shr_s\nlocal.set 170\nlocal.get 5\ni32.load offset=132\nlocal.set 171\nlocal.get 171\ni32.load\nlocal.set 172\nlocal.get 172\nlocal.get 170\ni32.or\nlocal.set 173\nlocal.get 171\nlocal.get 173\ni32.store\nlocal.get 5\ni32.load offset=132\nlocal.set 174\nlocal.get 174\ni32.load\nlocal.set 175\ni32.const 42\nlocal.set 176\nlocal.get 175\nlocal.get 176\ni32.xor\nlocal.set 177\nlocal.get 174\nlocal.get 177\ni32.store\nlocal.get 5\ni32.load offset=12\nlocal.set 178\ni32.const 16\nlocal.set 179\nlocal.get 5\nlocal.get 179\ni32.add\nlocal.set 180\nlocal.get 180\nlocal.set 181\ni32.const 2\nlocal.set 182\nlocal.get 178\nlocal.get 182\ni32.shl\nlocal.set 183\nlocal.get 181\nlocal.get 183\ni32.add\nlocal.set 184\nlocal.get 184\ni32.load\nlocal.set 185\nlocal.get 5\ni32.load offset=132\nlocal.set 186\nlocal.get 186\ni32.load\nlocal.set 187\nlocal.get 187\nlocal.get 185\ni32.shr_s\nlocal.set 188\nlocal.get 186\nlocal.get 188\ni32.store\nlocal.get 5\ni32.load offset=8\nlocal.set 189\ni32.const 144\nlocal.set 190\nlocal.get 5\nlocal.get 190\ni32.add\nlocal.set 191\nlocal.get 191\nglobal.set 0\nlocal.get 189\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_187",
        "query_text": "The function receives three inputs: a pointer to a memory location, a size indicating the number of bytes to write, and a file pointer. It writes the specified number of bytes from the memory location to the file using a file-writing mechanism determined by the platform and configuration. The function then returns a boolean (true or false) indicating whether the exact number of bytes were successfully written. Internally, it utilizes a platform-specific or standard file writing routine depending on the compilation environment.",
        "code_id": "c_group_1_id_187",
        "code_text": "(func (;1;) (type 0) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nlocal.get 5\ni32.load offset=12\nlocal.set 6\nlocal.get 5\ni32.load offset=8\nlocal.set 7\nlocal.get 5\ni32.load offset=4\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 6\nlocal.get 9\nlocal.get 7\nlocal.get 8\ncall 8\nlocal.set 10\nlocal.get 5\ni32.load offset=8\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.eq\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\ni32.const 16\nlocal.set 15\nlocal.get 5\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\nglobal.set 0\nlocal.get 14\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_188",
        "query_text": "The function takes a modifiable string as input and removes any leading and trailing whitespace characters, including spaces, newline characters, carriage returns, and tabs. The operation alters the input string directly and returns the modified string. Both the input and output are of type std::string.",
        "code_id": "c_group_1_id_188",
        "code_text": "(func (;2;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 65564\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\nlocal.get 3\ni32.load offset=12\nlocal.set 5\nlocal.get 3\ni32.load offset=12\nlocal.set 6\nlocal.get 3\ni32.load offset=8\nlocal.set 7\ni32.const -1\nlocal.set 8\nlocal.get 6\nlocal.get 7\nlocal.get 8\ncall 3\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.add\nlocal.set 11\ni32.const -1\nlocal.set 12\nlocal.get 5\nlocal.get 11\nlocal.get 12\ncall 4\ndrop\nlocal.get 3\ni32.load offset=12\nlocal.set 13\nlocal.get 3\ni32.load offset=12\nlocal.set 14\nlocal.get 3\ni32.load offset=8\nlocal.set 15\ni32.const 0\nlocal.set 16\nlocal.get 14\nlocal.get 15\nlocal.get 16\ncall 5\nlocal.set 17\ni32.const 0\nlocal.set 18\nlocal.get 13\nlocal.get 18\nlocal.get 17\ncall 4\ndrop\nlocal.get 3\ni32.load offset=12\nlocal.set 19\ni32.const 16\nlocal.set 20\nlocal.get 3\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nglobal.set 0\nlocal.get 19\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_189",
        "query_text": "The function takes a C-style string and a size limit (of type std::size_t) as inputs. It computes the string's length up to the given limit, stopping if a null terminator is encountered. If the null terminator is found before reaching the limit, the function returns the number of characters before it; otherwise, it returns the specified size limit. The output is of type std::size_t, representing the computed length.",
        "code_id": "c_group_1_id_189",
        "code_text": "(func (;1;) (type 3) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 4\ni32.load offset=20\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store8 offset=15\ni32.const 15\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nlocal.set 10\nlocal.get 5\nlocal.get 6\nlocal.get 10\ncall 2\nlocal.set 11\nlocal.get 4\nlocal.get 11\ni32.store offset=16\nlocal.get 4\ni32.load offset=16\nlocal.set 12\ni32.const 0\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.ne\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 16\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=16\nlocal.set 17\nlocal.get 4\ni32.load offset=24\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.sub\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=20\nlocal.set 20\nlocal.get 4\nlocal.get 20\ni32.store offset=28\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 21\ni32.const 32\nlocal.set 22\nlocal.get 4\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 23\nglobal.set 0\nlocal.get 21\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_190",
        "query_text": "The function is an inline function that takes no input arguments and returns no output values. It embeds an inline assembly instruction that serves as a compiler memory barrier, informing the compiler that the memory state may have changed. The embedded assembly code prevents the compiler from optimizing or reordering memory operations across the barrier. Its primary purpose is to enforce memory consistency and ensure that memory accesses are performed in the intended order.",
        "code_id": "c_group_1_id_190",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_191",
        "query_text": "The function takes a floating-point number as input and computes the cumulative probability for a standard normal distribution. It utilizes the complementary error function to determine the probability that a standard normally distributed random variable is less than or equal to the input value, then scales the result to yield the correct CDF value, which is returned as a floating-point number.",
        "code_id": "c_group_1_id_191",
        "code_text": "(func (;1;) (type 0) (param f64) (result f64)\n(local i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\nf64.store offset=8\nlocal.get 3\nf64.load offset=8\nlocal.set 6\nlocal.get 6\nf64.neg\nlocal.set 7\nf64.const 0x1p+1 (;=2;)\nlocal.set 8\nlocal.get 8\nf64.sqrt\nlocal.set 9\nlocal.get 7\nlocal.get 9\nf64.div\nlocal.set 10\nlocal.get 10\ncall 5\nlocal.set 11\nf64.const 0x1p+1 (;=2;)\nlocal.set 12\nlocal.get 11\nlocal.get 12\nf64.div\nlocal.set 13\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.add\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_193",
        "query_text": "The function takes a single input character and returns a transformed character that is its lowercase equivalent. It first casts the input to an unsigned character to ensure proper processing by the standard library's lowercase conversion function, then converts the result back to a character before returning it.",
        "code_id": "c_group_1_id_193",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shl\nlocal.set 9\nlocal.get 9\nlocal.get 8\ni32.shr_s\nlocal.set 10\ni32.const 16\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nglobal.set 0\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_194",
        "query_text": "The function checks whether a string begins with a specified prefix. It accepts two strings as input and returns a boolean value. First, it verifies that the length of the input string is at least as long as the prefix. If this condition is met, the function extracts the beginning segment of the string\u2014matching the length of the prefix\u2014and compares it with the prefix. If these two values are identical, it returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_194",
        "code_text": "(func (;2;) (type 1) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 5\ncall 3\nlocal.set 6\nlocal.get 4\ni32.load offset=20\nlocal.set 7\nlocal.get 7\ncall 3\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.ge_u\nlocal.set 9\ni32.const 0\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 4\nlocal.get 12\ni32.store8 offset=7\ni32.const 0\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 9\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 13\nlocal.set 16\nblock  ;; label = @1\nlocal.get 15\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=24\nlocal.set 17\nlocal.get 4\ni32.load offset=20\nlocal.set 18\nlocal.get 18\ncall 3\nlocal.set 19\ni32.const 8\nlocal.set 20\nlocal.get 4\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nlocal.set 22\ni32.const 0\nlocal.set 23\nlocal.get 22\nlocal.get 17\nlocal.get 23\nlocal.get 19\ncall 4\ni32.const 1\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.store8 offset=7\nlocal.get 4\ni32.load offset=20\nlocal.set 27\ni32.const 8\nlocal.set 28\nlocal.get 4\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 29\nlocal.set 30\nlocal.get 30\nlocal.get 27\ncall 5\nlocal.set 31\nlocal.get 31\nlocal.set 16\nend\nlocal.get 16\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.and\nlocal.set 34\nlocal.get 4\nlocal.get 34\ni32.store8 offset=31\nlocal.get 4\ni32.load8_u offset=7\nlocal.set 35\ni32.const 1\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.and\nlocal.set 37\nblock  ;; label = @1\nlocal.get 37\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 8\nlocal.set 38\nlocal.get 4\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 39\nlocal.set 40\nlocal.get 40\ncall 83\ndrop\nend\nlocal.get 4\ni32.load8_u offset=31\nlocal.set 41\ni32.const 1\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.and\nlocal.set 43\ni32.const 32\nlocal.set 44\nlocal.get 4\nlocal.get 44\ni32.add\nlocal.set 45\nlocal.get 45\nglobal.set 0\nlocal.get 43\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_195",
        "query_text": "The function converts an array of C-style strings (typically used for command-line arguments) into a vector of strings. It accepts two parameters: an integer representing the number of elements and a pointer to an array of constant C-style strings. The function begins by initializing a vector of strings sized according to the provided integer. It then iterates over the C-style string array, copying each string into the corresponding index of the vector. Finally, the function returns the completed vector of strings.",
        "code_id": "c_group_1_id_195",
        "code_text": "(func (;2;) (type 5) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\ni32.const 0\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.store8 offset=19\nlocal.get 5\ni32.load offset=24\nlocal.set 9\nlocal.get 0\nlocal.get 9\ncall 3\ndrop\ni32.const 0\nlocal.set 10\nlocal.get 5\nlocal.get 10\ni32.store offset=12\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=12\nlocal.set 11\nlocal.get 5\ni32.load offset=24\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.lt_u\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=20\nlocal.set 16\nlocal.get 5\ni32.load offset=12\nlocal.set 17\ni32.const 2\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.shl\nlocal.set 19\nlocal.get 16\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\ni32.load\nlocal.set 21\nlocal.get 5\ni32.load offset=12\nlocal.set 22\nlocal.get 0\nlocal.get 22\ncall 4\nlocal.set 23\nlocal.get 23\nlocal.get 21\ncall 5\ndrop\nlocal.get 5\ni32.load offset=12\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 5\nlocal.get 26\ni32.store offset=12\nbr 0 (;@2;)\nend\nunreachable\nend\ni32.const 1\nlocal.set 27\ni32.const 1\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.and\nlocal.set 29\nlocal.get 5\nlocal.get 29\ni32.store8 offset=19\nlocal.get 5\ni32.load8_u offset=19\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nblock  ;; label = @1\nlocal.get 32\nbr_if 0 (;@1;)\nlocal.get 0\ncall 6\ndrop\nend\ni32.const 32\nlocal.set 33\nlocal.get 5\nlocal.get 33\ni32.add\nlocal.set 34\nlocal.get 34\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_196",
        "query_text": "This function accepts two string inputs and produces a string output. It first checks whether the second input is either empty or represents an empty string (i.e., a string containing two double quotes). When this condition is met, it simply returns the first input. Otherwise, it concatenates the first input with a comma and a space followed by the second input, and then returns this concatenated string.",
        "code_id": "c_group_1_id_196",
        "code_text": "(func (;2;) (type 4) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\nlocal.get 5\ni32.load offset=20\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 0\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 5\nlocal.get 10\ni32.store8 offset=7\ni32.const 1\nlocal.set 11\nlocal.get 7\nlocal.get 11\ni32.and\nlocal.set 12\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 12\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load offset=20\nlocal.set 13\ni32.const 65600\nlocal.set 14\nlocal.get 13\nlocal.get 14\ncall 4\nlocal.set 15\ni32.const 1\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.and\nlocal.set 17\nlocal.get 17\ni32.eqz\nbr_if 1 (;@2;)\nend\nlocal.get 5\ni32.load offset=24\nlocal.set 18\nlocal.get 0\nlocal.get 18\ncall 5\ndrop\nbr 1 (;@1;)\nend\nlocal.get 5\ni32.load offset=24\nlocal.set 19\ni32.const 8\nlocal.set 20\nlocal.get 5\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nlocal.set 22\ni32.const 65603\nlocal.set 23\nlocal.get 22\nlocal.get 19\nlocal.get 23\ncall 6\ni32.const 1\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nlocal.get 5\nlocal.get 26\ni32.store8 offset=7\nlocal.get 5\ni32.load offset=20\nlocal.set 27\ni32.const 8\nlocal.set 28\nlocal.get 5\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 29\nlocal.set 30\nlocal.get 0\nlocal.get 30\nlocal.get 27\ncall 7\nend\nlocal.get 5\ni32.load8_u offset=7\nlocal.set 31\ni32.const 1\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.and\nlocal.set 33\nblock  ;; label = @1\nlocal.get 33\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 8\nlocal.set 34\nlocal.get 5\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 35\nlocal.set 36\nlocal.get 36\ncall 180\ndrop\nend\ni32.const 32\nlocal.set 37\nlocal.get 5\nlocal.get 37\ni32.add\nlocal.set 38\nlocal.get 38\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_197",
        "query_text": "The function takes a pointer to a null-terminated character array (string) as input. It iterates over the characters in the string, searching for the first occurrence of either a newline or a carriage return character. Once one of these characters is found, it is replaced with a null terminator, thereby truncating the string at that point. If no newline or carriage return is encountered, the string remains unmodified. The function does not return any value.",
        "code_id": "c_group_1_id_197",
        "code_text": "(func (;1;) (type 2) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nloop  ;; label = @1\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.ne\nlocal.set 6\ni32.const 0\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 7\nlocal.set 10\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=12\nlocal.set 11\nlocal.get 11\ni32.load8_u\nlocal.set 12\ni32.const 0\nlocal.set 13\ni32.const 255\nlocal.set 14\nlocal.get 12\nlocal.get 14\ni32.and\nlocal.set 15\ni32.const 255\nlocal.set 16\nlocal.get 13\nlocal.get 16\ni32.and\nlocal.set 17\nlocal.get 15\nlocal.get 17\ni32.ne\nlocal.set 18\nlocal.get 18\nlocal.set 10\nend\nlocal.get 10\nlocal.set 19\ni32.const 1\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.and\nlocal.set 21\nblock  ;; label = @2\nlocal.get 21\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=12\nlocal.set 22\nlocal.get 22\ni32.load8_u\nlocal.set 23\ni32.const 24\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.shl\nlocal.set 25\nlocal.get 25\nlocal.get 24\ni32.shr_s\nlocal.set 26\ni32.const 10\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.eq\nlocal.set 28\ni32.const 1\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.and\nlocal.set 30\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 30\nbr_if 0 (;@4;)\nlocal.get 3\ni32.load offset=12\nlocal.set 31\nlocal.get 31\ni32.load8_u\nlocal.set 32\ni32.const 24\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.shl\nlocal.set 34\nlocal.get 34\nlocal.get 33\ni32.shr_s\nlocal.set 35\ni32.const 13\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.eq\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.and\nlocal.set 39\nlocal.get 39\ni32.eqz\nbr_if 1 (;@3;)\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 40\ni32.const 0\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.store8\nbr 1 (;@2;)\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 42\ni32.const 1\nlocal.set 43\nlocal.get 42\nlocal.get 43\ni32.add\nlocal.set 44\nlocal.get 3\nlocal.get 44\ni32.store offset=12\nbr 1 (;@1;)\nend\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_198",
        "query_text": "This function accepts a single input of type FILE*, representing a file stream. It begins by verifying that the input is valid (i.e., non-null). If the file pointer is valid, the function duplicates the current standard error file descriptor to preserve its original state. It then retrieves the file descriptor associated with the provided file stream and uses it to replace the standard error output via a redirection call. If the file descriptor retrieval fails (for example, if the file descriptor is -1), the function terminates the process immediately. Finally, it returns the saved original file descriptor for standard error. Conversely, if the input file pointer is null, the function returns -1, indicating an error condition.",
        "code_id": "c_group_1_id_198",
        "code_text": "(func (;4;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.ne\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 8\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 2\nlocal.set 9\nlocal.get 9\ncall 12\nlocal.set 10\nlocal.get 3\nlocal.get 10\ni32.store offset=4\nlocal.get 3\ni32.load offset=8\nlocal.set 11\nlocal.get 11\ncall 16\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.store\nlocal.get 3\ni32.load\nlocal.set 13\ni32.const -1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.eq\nlocal.set 15\ni32.const 1\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.and\nlocal.set 17\nblock  ;; label = @3\nlocal.get 17\ni32.eqz\nbr_if 0 (;@3;)\ni32.const 1\nlocal.set 18\nlocal.get 18\ncall 8\nunreachable\nend\nlocal.get 3\ni32.load\nlocal.set 19\ni32.const 2\nlocal.set 20\nlocal.get 19\nlocal.get 20\ncall 13\ndrop\nlocal.get 3\ni32.load offset=4\nlocal.set 21\nlocal.get 3\nlocal.get 21\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const -1\nlocal.set 22\nlocal.get 3\nlocal.get 22\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 23\ni32.const 16\nlocal.set 24\nlocal.get 3\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\nglobal.set 0\nlocal.get 23\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_199",
        "query_text": "The function takes an integer input that represents a file descriptor. If this input is valid (i.e., not -1), the function directs the standard error stream back to its original destination by duplicating this descriptor to the standard error output and subsequently closing the original descriptor. It returns no value, as its primary purpose is to restore the standard error stream to its prior state.",
        "code_id": "c_group_1_id_199",
        "code_text": "(func (;4;) (type 4) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const -1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.ne\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nblock  ;; label = @1\nlocal.get 8\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 9\ni32.const 2\nlocal.set 10\nlocal.get 9\nlocal.get 10\ncall 8\ndrop\nlocal.get 3\ni32.load offset=12\nlocal.set 11\nlocal.get 11\ncall 7\ndrop\nend\ni32.const 16\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_200",
        "query_text": "The function takes a pointer (of generic type, expected to reference an integer) as input and returns a pointer to a newly allocated integer. It first allocates dynamic memory for an integer and then, if both the allocation succeeds and the input pointer is not null, it copies the value from the referenced integer to the allocated location. Finally, it returns the pointer to this newly created integer.",
        "code_id": "c_group_1_id_200",
        "code_text": "(func (;1;) (type 1) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 4\nlocal.set 4\nlocal.get 4\ncall 7\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nblock  ;; label = @1\nlocal.get 10\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 11\ni32.const 0\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.ne\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 16\nlocal.get 16\ni32.load\nlocal.set 17\nlocal.get 3\ni32.load offset=8\nlocal.set 18\nlocal.get 18\nlocal.get 17\ni32.store\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 19\ni32.const 16\nlocal.set 20\nlocal.get 3\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nglobal.set 0\nlocal.get 19\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_201",
        "query_text": "The function accepts two inputs of type constant void pointer, each expected to reference an integer value. It retrieves the integer values and compares them. It returns an integer: -1 if the first value is less than the second, 0 if they are equal, and 1 if the first value is greater than the second. This comparator function is commonly used in sorting and searching algorithms to determine the order between elements.",
        "code_id": "c_group_1_id_201",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=16\nlocal.get 4\ni32.load offset=20\nlocal.set 7\nlocal.get 7\ni32.load\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=12\nlocal.get 4\ni32.load offset=16\nlocal.set 9\nlocal.get 4\ni32.load offset=12\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.lt_s\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 13\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 14\nlocal.get 4\nlocal.get 14\ni32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=16\nlocal.set 15\nlocal.get 4\ni32.load offset=12\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.eq\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nblock  ;; label = @2\nlocal.get 19\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 20\nlocal.get 4\nlocal.get 20\ni32.store offset=28\nbr 1 (;@1;)\nend\ni32.const 1\nlocal.set 21\nlocal.get 4\nlocal.get 21\ni32.store offset=28\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 22\nlocal.get 22\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_202",
        "query_text": "The function accepts two constant void pointers as input. It first compares the two pointers to determine whether they refer to the same memory location. If the pointers are equal, it returns 0; if not, it returns 1. The return value is of type int.",
        "code_id": "c_group_1_id_202",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.eq\nlocal.set 7\ni32.const -1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.xor\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_203",
        "query_text": "The function accepts three pointer parameters. Two of these pointers reference boolean values, and the third points to a memory location where the result is to be stored. It performs a logical AND operation on the two boolean values and writes the resulting boolean value to the output memory location. The function does not return any value.",
        "code_id": "c_group_1_id_203",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nlocal.get 5\ni32.load offset=12\nlocal.set 6\nlocal.get 6\ni32.load8_u\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 5\nlocal.get 9\ni32.store8 offset=3\nlocal.get 5\ni32.load offset=8\nlocal.set 10\nlocal.get 10\ni32.load8_u\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 5\nlocal.get 13\ni32.store8 offset=2\nlocal.get 5\ni32.load8_u offset=3\nlocal.set 14\ni32.const 0\nlocal.set 15\ni32.const 1\nlocal.set 16\nlocal.get 14\nlocal.get 16\ni32.and\nlocal.set 17\nlocal.get 15\nlocal.set 18\nblock  ;; label = @1\nlocal.get 17\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 5\ni32.load8_u offset=2\nlocal.set 19\nlocal.get 19\nlocal.set 18\nend\nlocal.get 18\nlocal.set 20\nlocal.get 5\ni32.load offset=4\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 20\nlocal.get 22\ni32.and\nlocal.set 23\nlocal.get 21\nlocal.get 23\ni32.store8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_204",
        "query_text": "The function takes two generic pointer inputs and compares the integer values they reference by subtracting the second from the first. It returns an int that is negative if the referenced value of the first pointer is smaller, zero if they are equal, and positive if the first value is larger. This design makes it suitable for use as a comparator in standard sorting routines.",
        "code_id": "c_group_1_id_204",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nlocal.get 4\ni32.load offset=8\nlocal.set 7\nlocal.get 7\ni32.load\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.sub\nlocal.set 9\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_205",
        "query_text": "This function receives a pointer to a character string as its input and processes the string by sequentially scanning numeric characters. It converts the sequence of digit characters into an integer value while advancing the pointer to the first non-digit character. The input is a pointer to a character string assumed to have valid numeric digits starting at the current position, and the output is an integer representing the parsed number.",
        "code_id": "c_group_1_id_205",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\nloop  ;; label = @1\nlocal.get 3\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nlocal.get 6\ni32.load8_u\nlocal.set 7\ni32.const 24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shl\nlocal.set 9\nlocal.get 9\nlocal.get 8\ni32.shr_s\nlocal.set 10\ni32.const 48\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.ge_s\nlocal.set 12\ni32.const 0\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 12\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 13\nlocal.set 16\nblock  ;; label = @2\nlocal.get 15\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=12\nlocal.set 17\nlocal.get 17\ni32.load\nlocal.set 18\nlocal.get 18\ni32.load8_u\nlocal.set 19\ni32.const 24\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 21\nlocal.get 20\ni32.shr_s\nlocal.set 22\ni32.const 57\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.le_s\nlocal.set 24\nlocal.get 24\nlocal.set 16\nend\nlocal.get 16\nlocal.set 25\ni32.const 1\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.and\nlocal.set 27\nblock  ;; label = @2\nlocal.get 27\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=8\nlocal.set 28\ni32.const 10\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.mul\nlocal.set 30\nlocal.get 3\ni32.load offset=12\nlocal.set 31\nlocal.get 31\ni32.load\nlocal.set 32\nlocal.get 32\ni32.load8_u\nlocal.set 33\ni32.const 24\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.shl\nlocal.set 35\nlocal.get 35\nlocal.get 34\ni32.shr_s\nlocal.set 36\ni32.const 48\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.sub\nlocal.set 38\nlocal.get 30\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 3\nlocal.get 39\ni32.store offset=8\nlocal.get 3\ni32.load offset=12\nlocal.set 40\nlocal.get 40\ni32.load\nlocal.set 41\ni32.const 1\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.add\nlocal.set 43\nlocal.get 40\nlocal.get 43\ni32.store\nbr 1 (;@1;)\nend\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 44\nlocal.get 44\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_206",
        "query_text": "The function accepts an output stream reference and a pointer to a format string as its inputs. It iterates through the string character by character, writing the processed segment to the output stream. When the function encounters the null terminator (which marks the end of the string), it writes out the accumulated portion and returns a pointer to the end of the string. Alternatively, if it encounters a '%' character that is not immediately followed by another '%', it writes the processed portion up to that point and returns a pointer to the '%' character. In cases where the '%' is immediately followed by another '%', the function treats this as an escape sequence and continues processing the remaining characters.",
        "code_id": "c_group_1_id_206",
        "code_text": "(func (;2;) (type 6) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nlocal.get 4\ni32.load offset=4\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load\nlocal.set 6\nlocal.get 6\ni32.load8_u\nlocal.set 7\ni32.const 24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shl\nlocal.set 9\nlocal.get 9\nlocal.get 8\ni32.shr_s\nlocal.set 10\nblock  ;; label = @3\nlocal.get 10\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=8\nlocal.set 11\nlocal.get 4\ni32.load offset=4\nlocal.set 12\nlocal.get 4\ni32.load\nlocal.set 13\nlocal.get 4\ni32.load offset=4\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.sub\nlocal.set 15\nlocal.get 11\nlocal.get 12\nlocal.get 15\ncall 21\ndrop\nlocal.get 4\ni32.load\nlocal.set 16\nlocal.get 4\nlocal.get 16\ni32.store offset=12\nbr 2 (;@1;)\nend\nlocal.get 4\ni32.load\nlocal.set 17\nlocal.get 17\ni32.load8_u\nlocal.set 18\ni32.const 24\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.shl\nlocal.set 20\nlocal.get 20\nlocal.get 19\ni32.shr_s\nlocal.set 21\ni32.const 37\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.eq\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\nblock  ;; label = @3\nlocal.get 25\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=8\nlocal.set 26\nlocal.get 4\ni32.load offset=4\nlocal.set 27\nlocal.get 4\ni32.load\nlocal.set 28\nlocal.get 4\ni32.load offset=4\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.sub\nlocal.set 30\nlocal.get 26\nlocal.get 27\nlocal.get 30\ncall 21\ndrop\nlocal.get 4\ni32.load\nlocal.set 31\nlocal.get 31\ni32.load8_u offset=1\nlocal.set 32\ni32.const 24\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.shl\nlocal.set 34\nlocal.get 34\nlocal.get 33\ni32.shr_s\nlocal.set 35\ni32.const 37\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.ne\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.and\nlocal.set 39\nblock  ;; label = @4\nlocal.get 39\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 4\ni32.load\nlocal.set 40\nlocal.get 4\nlocal.get 40\ni32.store offset=12\nbr 3 (;@1;)\nend\nlocal.get 4\ni32.load\nlocal.set 41\ni32.const 1\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.add\nlocal.set 43\nlocal.get 4\nlocal.get 43\ni32.store\nlocal.get 4\nlocal.get 43\ni32.store offset=4\nend\nlocal.get 4\ni32.load\nlocal.set 44\ni32.const 1\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.add\nlocal.set 46\nlocal.get 4\nlocal.get 46\ni32.store\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 47\ni32.const 16\nlocal.set 48\nlocal.get 4\nlocal.get 48\ni32.add\nlocal.set 49\nlocal.get 49\nglobal.set 0\nlocal.get 47\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_207",
        "query_text": "The function accepts a single input, a non-negative integer representing the size of a memory block to be allocated. It allocates a memory block of the given size using a standard memory allocation mechanism, and returns a pointer referencing the beginning of the allocated block. If the allocation is unsuccessful, the function returns a null pointer.",
        "code_id": "c_group_1_id_207",
        "code_text": "(func (;1;) (type 1) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 7\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_208",
        "query_text": "The function accepts a pointer to a memory block (expressed as a void pointer) and frees the allocated memory so that it can be reused in the future. It does not return any value.",
        "code_id": "c_group_1_id_208",
        "code_text": "(func (;1;) (type 2) (param i32)\n(local i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 3\ni32.const 16\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_209",
        "query_text": "The function takes a 16-bit unsigned integer as input and returns a 16-bit unsigned integer with its byte order reversed. It swaps the two constituent bytes so that the least significant byte becomes the most significant and vice versa, which is useful for converting between big-endian and little-endian data formats.",
        "code_id": "c_group_1_id_209",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store16 offset=14\nlocal.get 3\ni32.load16_u offset=14\nlocal.set 4\ni32.const 65535\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\ni32.const 255\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\ni32.const 8\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.shl\nlocal.set 10\nlocal.get 3\ni32.load16_u offset=14\nlocal.set 11\ni32.const 65535\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\ni32.const 8\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shr_s\nlocal.set 15\nlocal.get 10\nlocal.get 15\ni32.or\nlocal.set 16\ni32.const 65535\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 18\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_210",
        "query_text": "The function takes no input parameters and determines the system's byte order. It initializes an integer with the value 1, then inspects the first byte of its memory representation. If that byte equals 1, the function concludes that the system is using little-endian byte ordering and returns true; otherwise, it returns false. The output is a boolean value.",
        "code_id": "c_group_1_id_210",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 1\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load8_u offset=12\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.eq\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_211",
        "query_text": "The function accepts a pointer to a file stream object as input and calls the standard routine to close the associated file. It ensures that any buffered data is flushed to the file and that the file is no longer available for further operations. The function does not return any value.",
        "code_id": "c_group_1_id_211",
        "code_text": "(func (;1;) (type 0) (param i32)\n(local i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 6\ndrop\ni32.const 16\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_212",
        "query_text": "The function takes two string inputs: one representing the file path and the other indicating the file open mode (for example, \"r\" for read or \"w\" for write). It returns a pointer to a file object, which signifies that the file has been successfully opened. The function employs a platform-specific implementation: on certain platforms that support a secure file-opening method, it uses that for additional safety; on other platforms, it uses the standard file-opening routine. If the file cannot be opened, the function returns NULL.",
        "code_id": "c_group_1_id_212",
        "code_text": "(func (;5;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 21\nlocal.set 7\ni32.const 16\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nglobal.set 0\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_213",
        "query_text": "The function takes three inputs: a pointer to an array of pointers representing a hash table, an integer indicating the number of elements in the table, and a pointer representing a key. It computes a hash value from the key using bitwise operations and arithmetic, then uses this value to determine an initial index in the table. By employing a linear probing strategy, the function searches for an available slot to insert the key. If an empty position is found, the key is inserted and the function returns true. If the key is already present or the table is full, it returns false (with an assertion triggered in the event the table is full). The input consists of a pointer to a hash table, a non-negative integer, and a pointer, while the output is of type bool.",
        "code_id": "c_group_1_id_213",
        "code_text": "(func (;5;) (type 0) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=24\nlocal.get 5\nlocal.get 1\ni32.store offset=20\nlocal.get 5\nlocal.get 2\ni32.store offset=16\nlocal.get 5\ni32.load offset=16\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 10\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 65536\nlocal.set 11\ni32.const 65569\nlocal.set 12\ni32.const 19\nlocal.set 13\ni32.const 65672\nlocal.set 14\nlocal.get 11\nlocal.get 12\nlocal.get 13\nlocal.get 14\ncall 7\nunreachable\nend\nlocal.get 5\ni32.load offset=16\nlocal.set 15\nlocal.get 5\nlocal.get 15\ni32.store offset=12\nlocal.get 5\ni32.load offset=12\nlocal.set 16\ni32.const 16\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.shr_u\nlocal.set 18\nlocal.get 5\ni32.load offset=12\nlocal.set 19\nlocal.get 19\nlocal.get 18\ni32.xor\nlocal.set 20\nlocal.get 5\nlocal.get 20\ni32.store offset=12\nlocal.get 5\ni32.load offset=12\nlocal.set 21\ni32.const -2048144789\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.mul\nlocal.set 23\nlocal.get 5\nlocal.get 23\ni32.store offset=12\nlocal.get 5\ni32.load offset=12\nlocal.set 24\ni32.const 13\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.shr_u\nlocal.set 26\nlocal.get 5\ni32.load offset=12\nlocal.set 27\nlocal.get 27\nlocal.get 26\ni32.xor\nlocal.set 28\nlocal.get 5\nlocal.get 28\ni32.store offset=12\nlocal.get 5\ni32.load offset=12\nlocal.set 29\ni32.const -1028477387\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.mul\nlocal.set 31\nlocal.get 5\nlocal.get 31\ni32.store offset=12\nlocal.get 5\ni32.load offset=12\nlocal.set 32\ni32.const 16\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.shr_u\nlocal.set 34\nlocal.get 5\ni32.load offset=12\nlocal.set 35\nlocal.get 35\nlocal.get 34\ni32.xor\nlocal.set 36\nlocal.get 5\nlocal.get 36\ni32.store offset=12\nlocal.get 5\ni32.load offset=20\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.sub\nlocal.set 39\nlocal.get 5\nlocal.get 39\ni32.store offset=8\nlocal.get 5\ni32.load offset=12\nlocal.set 40\nlocal.get 5\ni32.load offset=8\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.and\nlocal.set 42\nlocal.get 5\nlocal.get 42\ni32.store offset=4\ni32.const 0\nlocal.set 43\nlocal.get 5\nlocal.get 43\ni32.store\nblock  ;; label = @1\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 5\ni32.load\nlocal.set 44\nlocal.get 5\ni32.load offset=8\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.le_u\nlocal.set 46\ni32.const 1\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.and\nlocal.set 48\nlocal.get 48\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 5\ni32.load offset=24\nlocal.set 49\nlocal.get 5\ni32.load offset=4\nlocal.set 50\ni32.const 2\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.shl\nlocal.set 52\nlocal.get 49\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\ni32.load\nlocal.set 54\ni32.const 0\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.eq\nlocal.set 56\ni32.const 1\nlocal.set 57\nlocal.get 56\nlocal.get 57\ni32.and\nlocal.set 58\nblock  ;; label = @4\nlocal.get 58\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 5\ni32.load offset=16\nlocal.set 59\nlocal.get 5\ni32.load offset=24\nlocal.set 60\nlocal.get 5\ni32.load offset=4\nlocal.set 61\ni32.const 2\nlocal.set 62\nlocal.get 61\nlocal.get 62\ni32.shl\nlocal.set 63\nlocal.get 60\nlocal.get 63\ni32.add\nlocal.set 64\nlocal.get 64\nlocal.get 59\ni32.store\ni32.const 1\nlocal.set 65\ni32.const 1\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.and\nlocal.set 67\nlocal.get 5\nlocal.get 67\ni32.store8 offset=31\nbr 3 (;@1;)\nend\nlocal.get 5\ni32.load offset=24\nlocal.set 68\nlocal.get 5\ni32.load offset=4\nlocal.set 69\ni32.const 2\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.shl\nlocal.set 71\nlocal.get 68\nlocal.get 71\ni32.add\nlocal.set 72\nlocal.get 72\ni32.load\nlocal.set 73\nlocal.get 5\ni32.load offset=16\nlocal.set 74\nlocal.get 73\nlocal.get 74\ni32.eq\nlocal.set 75\ni32.const 1\nlocal.set 76\nlocal.get 75\nlocal.get 76\ni32.and\nlocal.set 77\nblock  ;; label = @4\nlocal.get 77\ni32.eqz\nbr_if 0 (;@4;)\ni32.const 0\nlocal.set 78\ni32.const 1\nlocal.set 79\nlocal.get 78\nlocal.get 79\ni32.and\nlocal.set 80\nlocal.get 5\nlocal.get 80\ni32.store8 offset=31\nbr 3 (;@1;)\nend\nlocal.get 5\ni32.load offset=4\nlocal.set 81\nlocal.get 5\ni32.load\nlocal.set 82\nlocal.get 81\nlocal.get 82\ni32.add\nlocal.set 83\ni32.const 1\nlocal.set 84\nlocal.get 83\nlocal.get 84\ni32.add\nlocal.set 85\nlocal.get 5\ni32.load offset=8\nlocal.set 86\nlocal.get 85\nlocal.get 86\ni32.and\nlocal.set 87\nlocal.get 5\nlocal.get 87\ni32.store offset=4\nlocal.get 5\ni32.load\nlocal.set 88\ni32.const 1\nlocal.set 89\nlocal.get 88\nlocal.get 89\ni32.add\nlocal.set 90\nlocal.get 5\nlocal.get 90\ni32.store\nbr 0 (;@3;)\nend\nunreachable\nend\ni32.const 65726\nlocal.set 91\ni32.const 65569\nlocal.set 92\ni32.const 48\nlocal.set 93\ni32.const 65672\nlocal.set 94\nlocal.get 91\nlocal.get 92\nlocal.get 93\nlocal.get 94\ncall 7\nunreachable\nend\nlocal.get 5\ni32.load8_u offset=31\nlocal.set 95\ni32.const 1\nlocal.set 96\nlocal.get 95\nlocal.get 96\ni32.and\nlocal.set 97\ni32.const 32\nlocal.set 98\nlocal.get 5\nlocal.get 98\ni32.add\nlocal.set 99\nlocal.get 99\nglobal.set 0\nlocal.get 97\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_214",
        "query_text": "The function accepts a floating-point input of type double and returns a boolean value. It determines whether the input is \u201cNot a Number\u201d (NaN) by using a platform-dependent strategy. Initially, the function checks for compiler-specific conditions: in certain environments (such as specific Microsoft or Borland compiler versions), it directly calls a built-in function to test for NaN. In other cases, it utilizes a classification method (comparing against a constant that denotes NaN) if such macros are available. As a final fallback, the function takes advantage of the fact that a NaN value does not compare equal to itself. If any of these methods confirm that the value is NaN, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_214",
        "code_text": "(func (;1;) (type 2) (param f64) (result i32)\n(local i32 i32 i32 i32 i32 i32 f64 f64 f64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf64.store offset=8\nlocal.get 3\nf64.load offset=8\nlocal.set 7\nlocal.get 3\nlocal.get 7\nf64.store\nlocal.get 3\nf64.load\nlocal.set 8\nlocal.get 3\nf64.load\nlocal.set 9\nlocal.get 8\nlocal.get 9\nf64.ne\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_215",
        "query_text": "The function takes two pointers that specify the bounds of a character array: one for the beginning and one for the end. It then iterates backwards from the end pointer, decrementing it as long as it has not reached the beginning and the character immediately before the end is a '0'. Once a character other than '0' is found (or the beginning is reached), the function writes a null character at the current end pointer position to mark the new end of the array. This process effectively removes any trailing '0' characters from the array.",
        "code_id": "c_group_1_id_215",
        "code_text": "(func (;1;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nloop  ;; label = @1\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.ne\nlocal.set 7\ni32.const 0\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 7\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 8\nlocal.set 11\nblock  ;; label = @2\nlocal.get 10\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=8\nlocal.set 12\ni32.const -1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\ni32.load8_u\nlocal.set 15\ni32.const 24\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.shl\nlocal.set 17\nlocal.get 17\nlocal.get 16\ni32.shr_s\nlocal.set 18\ni32.const 48\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.eq\nlocal.set 20\nlocal.get 20\nlocal.set 11\nend\nlocal.get 11\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.and\nlocal.set 23\nblock  ;; label = @2\nlocal.get 23\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=8\nlocal.set 24\ni32.const -1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.store offset=8\nbr 1 (;@1;)\nend\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 27\ni32.const 0\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.store8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_216",
        "query_text": "The function accepts a double-precision floating-point number as input and returns a double-precision floating-point number that represents the nearest integer value to the input. It computes this result by adding 0.5 to the given value and then applying the floor operation to round down to the nearest integer.",
        "code_id": "c_group_1_id_216",
        "code_text": "(func (;1;) (type 2) (param f64) (result f64)\n(local i32 i32 i32 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf64.store offset=8\nlocal.get 3\nf64.load offset=8\nlocal.set 4\nf64.const 0x1p-1 (;=0.5;)\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf64.add\nlocal.set 6\nlocal.get 6\nf64.floor\nlocal.set 7\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_217",
        "query_text": "The function receives a double-precision floating-point number as input and produces an output of type double. It evaluates the received value to determine if it falls between -0.5 and 0 (inclusive). If the value is within this range, the function rounds it towards zero using a ceiling operation; otherwise, it rounds the value to the nearest integer by applying a floor operation to the input value after adding an offset of 0.5. The final result, in double-precision, is then returned.",
        "code_id": "c_group_1_id_217",
        "code_text": "(func (;1;) (type 2) (param f64) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf64.store offset=8\nlocal.get 3\nf64.load offset=8\nlocal.set 11\nf64.const -0x1p-1 (;=-0.5;)\nlocal.set 12\nlocal.get 11\nlocal.get 12\nf64.ge\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 6\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\nf64.load offset=8\nlocal.set 13\ni32.const 0\nlocal.set 7\nlocal.get 7\nf64.convert_i32_s\nlocal.set 14\nlocal.get 13\nlocal.get 14\nf64.le\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 10\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\nf64.load offset=8\nlocal.set 15\nlocal.get 15\nf64.ceil\nlocal.set 16\nlocal.get 16\nlocal.set 17\nbr 1 (;@1;)\nend\nlocal.get 3\nf64.load offset=8\nlocal.set 18\nf64.const 0x1p-1 (;=0.5;)\nlocal.set 19\nlocal.get 18\nlocal.get 19\nf64.add\nlocal.set 20\nlocal.get 20\nf64.floor\nlocal.set 21\nlocal.get 21\nlocal.set 17\nend\nlocal.get 17\nlocal.set 22\nlocal.get 22\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_219",
        "query_text": "The function takes a constant reference to a std::string as input and checks if the string contains no characters. It returns a boolean value: true if the string is empty, and false otherwise.",
        "code_id": "c_group_1_id_219",
        "code_text": "(func (;1;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 2\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\ni32.const 16\nlocal.set 8\nlocal.get 3\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nglobal.set 0\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_220",
        "query_text": "The function accepts an integer as input, representing an error code, and checks it against a predefined set of error conditions that require additional parameters. It employs a switch mechanism: if the input error code matches any of these specific conditions, the function returns 1, indicating that further context is needed; if not, the function returns 0, signifying no additional parameters are required. The input is of type int, and the output is an int flag.",
        "code_id": "c_group_1_id_220",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 4\ni32.const -223\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.eq\nlocal.set 6\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 6\nbr_if 0 (;@3;)\ni32.const 220\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.add\nlocal.set 8\ni32.const 5\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.gt_u\nlocal.set 10\nlocal.get 10\nbr_if 1 (;@2;)\nend\ni32.const 1\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 13\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_221",
        "query_text": "The function accepts two integer inputs representing positive numbers, and it returns their product as an integer. Initially, if either input is zero, the function immediately returns zero. Otherwise, it checks whether multiplying the two inputs would result in a value no greater than the maximum integer value. If the product is within this limit, it returns the product; if not, it returns -1 to indicate that an overflow would occur.",
        "code_id": "c_group_1_id_221",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 5\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 5\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=4\nlocal.set 6\nlocal.get 6\nbr_if 1 (;@2;)\nend\ni32.const 0\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 8\nlocal.get 4\ni32.load offset=4\nlocal.set 9\ni32.const 2147483647\nlocal.set 10\nlocal.get 10\nlocal.get 9\ni32.div_s\nlocal.set 11\nlocal.get 8\nlocal.get 11\ni32.lt_s\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nblock  ;; label = @2\nlocal.get 14\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=8\nlocal.set 15\nlocal.get 4\ni32.load offset=4\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.mul\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const -1\nlocal.set 18\nlocal.get 4\nlocal.get 18\ni32.store offset=12\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 19\nlocal.get 19\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_222",
        "query_text": "The function takes three inputs: a pointer to an input character array, a pointer to an output character array (which is modified in place), and an integer representing the length of the input array. It processes the input array in pairs of characters. For each pair, the function first examines the initial character. If this character is null (0), it then considers the second character. If this second character is either a non-printable ASCII character, a backslash, or a double quote, it encodes the character as an octal escape sequence (for example, \"\\123\") into the output array; otherwise, it copies the character directly. If the first character in the pair is not null, both characters are encoded as octal escape sequences and written to the output array. After processing all character pairs, the function appends a null terminator to the output array. The primary purpose of the function is to convert characters from the input into either their direct representation or an octal escape sequence in the output, following specific encoding rules.",
        "code_id": "c_group_1_id_222",
        "code_text": "(func (;1;) (type 4) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 80\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=76\nlocal.get 5\nlocal.get 1\ni32.store offset=72\nlocal.get 5\nlocal.get 2\ni32.store offset=68\nlocal.get 5\ni32.load offset=72\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store offset=56\ni32.const 0\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store offset=64\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=64\nlocal.set 8\nlocal.get 5\ni32.load offset=68\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=76\nlocal.set 13\nlocal.get 5\ni32.load offset=64\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\ni32.load8_u\nlocal.set 16\nlocal.get 5\nlocal.get 16\ni32.store8 offset=63\nlocal.get 5\ni32.load8_u offset=63\nlocal.set 17\ni32.const 255\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 19\nbr_if 0 (;@4;)\nlocal.get 5\ni32.load offset=76\nlocal.set 20\nlocal.get 5\ni32.load offset=64\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 20\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\ni32.load8_u\nlocal.set 25\nlocal.get 5\nlocal.get 25\ni32.store8 offset=63\nlocal.get 5\ni32.load8_u offset=63\nlocal.set 26\ni32.const 255\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.and\nlocal.set 28\ni32.const 32\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.lt_s\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nblock  ;; label = @5\nblock  ;; label = @6\nblock  ;; label = @7\nlocal.get 32\nbr_if 0 (;@7;)\nlocal.get 5\ni32.load8_u offset=63\nlocal.set 33\ni32.const 255\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.and\nlocal.set 35\ni32.const 127\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.ge_s\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.and\nlocal.set 39\nlocal.get 39\nbr_if 0 (;@7;)\nlocal.get 5\ni32.load8_u offset=63\nlocal.set 40\ni32.const 255\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.and\nlocal.set 42\ni32.const 92\nlocal.set 43\nlocal.get 42\nlocal.get 43\ni32.eq\nlocal.set 44\ni32.const 1\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.and\nlocal.set 46\nlocal.get 46\nbr_if 0 (;@7;)\nlocal.get 5\ni32.load8_u offset=63\nlocal.set 47\ni32.const 255\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.and\nlocal.set 49\ni32.const 34\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.eq\nlocal.set 51\ni32.const 1\nlocal.set 52\nlocal.get 51\nlocal.get 52\ni32.and\nlocal.set 53\nlocal.get 53\ni32.eqz\nbr_if 1 (;@6;)\nend\nlocal.get 5\ni32.load offset=56\nlocal.set 54\nlocal.get 5\ni32.load8_u offset=63\nlocal.set 55\ni32.const 255\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.and\nlocal.set 57\nlocal.get 5\nlocal.get 57\ni32.store\ni32.const 65565\nlocal.set 58\nlocal.get 54\nlocal.get 58\nlocal.get 5\ncall 3\ndrop\nlocal.get 5\ni32.load offset=56\nlocal.set 59\ni32.const 4\nlocal.set 60\nlocal.get 59\nlocal.get 60\ni32.add\nlocal.set 61\nlocal.get 5\nlocal.get 61\ni32.store offset=56\nbr 1 (;@5;)\nend\nlocal.get 5\ni32.load offset=56\nlocal.set 62\nlocal.get 5\ni32.load8_u offset=63\nlocal.set 63\ni32.const 255\nlocal.set 64\nlocal.get 63\nlocal.get 64\ni32.and\nlocal.set 65\nlocal.get 5\nlocal.get 65\ni32.store offset=16\ni32.const 65579\nlocal.set 66\ni32.const 16\nlocal.set 67\nlocal.get 5\nlocal.get 67\ni32.add\nlocal.set 68\nlocal.get 62\nlocal.get 66\nlocal.get 68\ncall 3\ndrop\nlocal.get 5\ni32.load offset=56\nlocal.set 69\ni32.const 1\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.add\nlocal.set 71\nlocal.get 5\nlocal.get 71\ni32.store offset=56\nend\nbr 1 (;@3;)\nend\nlocal.get 5\ni32.load offset=56\nlocal.set 72\nlocal.get 5\ni32.load8_u offset=63\nlocal.set 73\ni32.const 255\nlocal.set 74\nlocal.get 73\nlocal.get 74\ni32.and\nlocal.set 75\nlocal.get 5\nlocal.get 75\ni32.store offset=32\ni32.const 65565\nlocal.set 76\ni32.const 32\nlocal.set 77\nlocal.get 5\nlocal.get 77\ni32.add\nlocal.set 78\nlocal.get 72\nlocal.get 76\nlocal.get 78\ncall 3\ndrop\nlocal.get 5\ni32.load offset=56\nlocal.set 79\ni32.const 4\nlocal.set 80\nlocal.get 79\nlocal.get 80\ni32.add\nlocal.set 81\nlocal.get 5\nlocal.get 81\ni32.store offset=56\nlocal.get 5\ni32.load offset=76\nlocal.set 82\nlocal.get 5\ni32.load offset=64\nlocal.set 83\ni32.const 1\nlocal.set 84\nlocal.get 83\nlocal.get 84\ni32.add\nlocal.set 85\nlocal.get 82\nlocal.get 85\ni32.add\nlocal.set 86\nlocal.get 86\ni32.load8_u\nlocal.set 87\nlocal.get 5\nlocal.get 87\ni32.store8 offset=63\nlocal.get 5\ni32.load offset=56\nlocal.set 88\nlocal.get 5\ni32.load8_u offset=63\nlocal.set 89\ni32.const 255\nlocal.set 90\nlocal.get 89\nlocal.get 90\ni32.and\nlocal.set 91\nlocal.get 5\nlocal.get 91\ni32.store offset=48\ni32.const 65565\nlocal.set 92\ni32.const 48\nlocal.set 93\nlocal.get 5\nlocal.get 93\ni32.add\nlocal.set 94\nlocal.get 88\nlocal.get 92\nlocal.get 94\ncall 3\ndrop\nlocal.get 5\ni32.load offset=56\nlocal.set 95\ni32.const 4\nlocal.set 96\nlocal.get 95\nlocal.get 96\ni32.add\nlocal.set 97\nlocal.get 5\nlocal.get 97\ni32.store offset=56\nend\nlocal.get 5\ni32.load offset=64\nlocal.set 98\ni32.const 2\nlocal.set 99\nlocal.get 98\nlocal.get 99\ni32.add\nlocal.set 100\nlocal.get 5\nlocal.get 100\ni32.store offset=64\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 5\ni32.load offset=56\nlocal.set 101\ni32.const 0\nlocal.set 102\nlocal.get 101\nlocal.get 102\ni32.store8\ni32.const 80\nlocal.set 103\nlocal.get 5\nlocal.get 103\ni32.add\nlocal.set 104\nlocal.get 104\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_224",
        "query_text": "The function takes three inputs: an integer representing the count of elements in an array, and two arrays of character pointers. It begins by copying each element from the first array into the corresponding position of the second array. Then, the function shuffles the elements of the second array using a random swapping mechanism: it iterates backwards from the last element, and for each position, it selects a random index within the unshuffled portion of the array and swaps the element at the current position with the one at the random index, ensuring that every position is equally likely to be occupied by any element. The function performs this shuffling operation in-place and does not return any value.",
        "code_id": "c_group_1_id_224",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store offset=16\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=16\nlocal.set 7\nlocal.get 5\ni32.load offset=28\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.lt_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=24\nlocal.set 12\nlocal.get 5\ni32.load offset=16\nlocal.set 13\ni32.const 2\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 12\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\ni32.load\nlocal.set 17\nlocal.get 5\ni32.load offset=20\nlocal.set 18\nlocal.get 5\ni32.load offset=16\nlocal.set 19\ni32.const 2\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 18\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 22\nlocal.get 17\ni32.store\nlocal.get 5\ni32.load offset=16\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 5\nlocal.get 25\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 5\ni32.load offset=28\nlocal.set 26\ni32.const 1\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.sub\nlocal.set 28\nlocal.get 5\nlocal.get 28\ni32.store offset=16\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=16\nlocal.set 29\ni32.const 0\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.gt_s\nlocal.set 31\ni32.const 1\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.and\nlocal.set 33\nlocal.get 33\ni32.eqz\nbr_if 1 (;@1;)\ncall 3\nlocal.set 34\nlocal.get 5\ni32.load offset=16\nlocal.set 35\ni32.const 1\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.add\nlocal.set 37\nlocal.get 34\nlocal.get 37\ni32.rem_s\nlocal.set 38\nlocal.get 5\nlocal.get 38\ni32.store offset=12\nlocal.get 5\ni32.load offset=20\nlocal.set 39\nlocal.get 5\ni32.load offset=16\nlocal.set 40\ni32.const 2\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.shl\nlocal.set 42\nlocal.get 39\nlocal.get 42\ni32.add\nlocal.set 43\nlocal.get 43\ni32.load\nlocal.set 44\nlocal.get 5\nlocal.get 44\ni32.store offset=8\nlocal.get 5\ni32.load offset=20\nlocal.set 45\nlocal.get 5\ni32.load offset=12\nlocal.set 46\ni32.const 2\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.shl\nlocal.set 48\nlocal.get 45\nlocal.get 48\ni32.add\nlocal.set 49\nlocal.get 49\ni32.load\nlocal.set 50\nlocal.get 5\ni32.load offset=20\nlocal.set 51\nlocal.get 5\ni32.load offset=16\nlocal.set 52\ni32.const 2\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.shl\nlocal.set 54\nlocal.get 51\nlocal.get 54\ni32.add\nlocal.set 55\nlocal.get 55\nlocal.get 50\ni32.store\nlocal.get 5\ni32.load offset=8\nlocal.set 56\nlocal.get 5\ni32.load offset=20\nlocal.set 57\nlocal.get 5\ni32.load offset=12\nlocal.set 58\ni32.const 2\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.shl\nlocal.set 60\nlocal.get 57\nlocal.get 60\ni32.add\nlocal.set 61\nlocal.get 61\nlocal.get 56\ni32.store\nlocal.get 5\ni32.load offset=16\nlocal.set 62\ni32.const -1\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.add\nlocal.set 64\nlocal.get 5\nlocal.get 64\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\ni32.const 32\nlocal.set 65\nlocal.get 5\nlocal.get 65\ni32.add\nlocal.set 66\nlocal.get 66\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_225",
        "query_text": "The function accepts two inputs: a floating-point number of type long double and a size_t value that specifies the desired precision for its conversion into a string. If the precision parameter is zero, the function automatically substitutes it with the maximum number of significant digits available for a long double. It then converts the value into a string representation using the C locale to ensure that the formatting remains consistent regardless of locale-specific differences. The output is a string that reflects the formatted floating-point number.",
        "code_id": "c_group_1_id_225",
        "code_text": "(func (;7;) (type 19) (param i32 i64 i64 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64)\nglobal.get 0\nlocal.set 4\ni32.const 192\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nglobal.set 0\nlocal.get 6\nlocal.get 0\ni32.store offset=188\nlocal.get 6\nlocal.get 2\ni64.store offset=176\nlocal.get 6\nlocal.get 1\ni64.store offset=168\nlocal.get 6\nlocal.get 3\ni32.store offset=164\ni32.const 20\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\nlocal.set 9\nlocal.get 9\ncall 8\ndrop\nlocal.get 6\ni32.load offset=20\nlocal.set 10\ni32.const -12\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\ni32.load\nlocal.set 13\ni32.const 20\nlocal.set 14\nlocal.get 6\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nlocal.set 16\nlocal.get 16\nlocal.get 13\ni32.add\nlocal.set 17\ni32.const 12\nlocal.set 18\nlocal.get 6\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 19\nlocal.set 20\ni32.const 66055\nlocal.set 21\nlocal.get 20\nlocal.get 21\ncall 1255\ndrop\ni32.const 16\nlocal.set 22\nlocal.get 6\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 23\nlocal.set 24\ni32.const 12\nlocal.set 25\nlocal.get 6\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 26\nlocal.set 27\nlocal.get 24\nlocal.get 17\nlocal.get 27\ncall 9\ni32.const 16\nlocal.set 28\nlocal.get 6\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 29\nlocal.set 30\nlocal.get 30\ncall 1253\ndrop\ni32.const 12\nlocal.set 31\nlocal.get 6\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 32\nlocal.set 33\nlocal.get 33\ncall 1253\ndrop\nlocal.get 6\ni32.load offset=164\nlocal.set 34\nblock  ;; label = @1\nlocal.get 34\nbr_if 0 (;@1;)\ni32.const 36\nlocal.set 35\nlocal.get 6\nlocal.get 35\ni32.store offset=164\nend\nlocal.get 6\ni32.load offset=20\nlocal.set 36\ni32.const -12\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.add\nlocal.set 38\nlocal.get 38\ni32.load\nlocal.set 39\ni32.const 20\nlocal.set 40\nlocal.get 6\nlocal.get 40\ni32.add\nlocal.set 41\nlocal.get 41\nlocal.get 39\ni32.add\nlocal.set 42\nlocal.get 6\ni32.load offset=164\nlocal.set 43\nlocal.get 42\nlocal.get 43\ncall 10\ndrop\ni32.const 8\nlocal.set 44\ni32.const 20\nlocal.set 45\nlocal.get 6\nlocal.get 45\ni32.add\nlocal.set 46\nlocal.get 46\nlocal.get 44\ni32.add\nlocal.set 47\ni32.const 168\nlocal.set 48\nlocal.get 6\nlocal.get 48\ni32.add\nlocal.set 49\nlocal.get 49\nlocal.get 44\ni32.add\nlocal.set 50\nlocal.get 50\ni64.load\nlocal.set 59\nlocal.get 6\ni64.load offset=168\nlocal.set 60\nlocal.get 47\nlocal.get 60\nlocal.get 59\ncall 157\ndrop\ni32.const 20\nlocal.set 51\nlocal.get 6\nlocal.get 51\ni32.add\nlocal.set 52\nlocal.get 52\nlocal.set 53\nlocal.get 0\nlocal.get 53\ncall 11\ni32.const 20\nlocal.set 54\nlocal.get 6\nlocal.get 54\ni32.add\nlocal.set 55\nlocal.get 55\nlocal.set 56\nlocal.get 56\ncall 12\ndrop\ni32.const 192\nlocal.set 57\nlocal.get 6\nlocal.get 57\ni32.add\nlocal.set 58\nlocal.get 58\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_226",
        "query_text": "The function takes a pointer to an unsigned character as input and returns a pointer to a character. It uses a reinterpret cast to convert the pointer to the unsigned character buffer into a pointer to a character buffer, effectively allowing the same underlying data to be accessed as a sequence of characters. The input type is unsigned char*, and the output type is char*.",
        "code_id": "c_group_1_id_226",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_227",
        "query_text": "The function accepts a single parameter: a reference to an input stream (of type std::istream&). It reads all characters from the stream\u2014from the current position to the end\u2014and constructs a string containing the complete set of data read. The function then returns this string (of type std::string) holding the stream's content.",
        "code_id": "c_group_1_id_227",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 4\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.set 8\nlocal.get 8\nlocal.get 5\ncall 3\ndrop\nlocal.get 4\nlocal.set 9\nlocal.get 9\ncall 4\ndrop\nlocal.get 4\ni32.load offset=4\nlocal.set 10\nlocal.get 4\ni32.load\nlocal.set 11\nlocal.get 0\nlocal.get 10\nlocal.get 11\ncall 5\ndrop\ni32.const 16\nlocal.set 12\nlocal.get 4\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_228",
        "query_text": "The function accepts a single character as input and returns a boolean value indicating whether the character represents a non-zero digit. It does so by verifying if the character falls within the ASCII range corresponding to the digits 1 through 9. If the character meets this criterion, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_228",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.shr_s\nlocal.set 7\ni32.const 49\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.le_s\nlocal.set 9\ni32.const 0\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 9\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 10\nlocal.set 13\nblock  ;; label = @1\nlocal.get 12\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 14\ni32.const 24\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 16\nlocal.get 15\ni32.shr_s\nlocal.set 17\ni32.const 57\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.le_s\nlocal.set 19\nlocal.get 19\nlocal.set 13\nend\nlocal.get 13\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 22\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_229",
        "query_text": "The function takes two C-style strings as inputs\u2014one for the filename and one for the mode\u2014and returns a pointer to a FILE object. It opens the specified file using platform-specific logic: on Windows platforms (excluding MinGW), it uses a secure method to open the file, while on other platforms it uses the standard approach. The function returns the file pointer if the file is successfully opened, or a null pointer if the operation fails.",
        "code_id": "c_group_1_id_229",
        "code_text": "(func (;5;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 21\nlocal.set 7\ni32.const 16\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nglobal.set 0\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_230",
        "query_text": "The function accepts a single parameter of type char. It converts the provided character to an unsigned char for compatibility with the standard library's character classification routine, which is then used to determine if the character is a whitespace character. Based on this evaluation, the function returns a boolean value: true if the character is whitespace, and false otherwise.",
        "code_id": "c_group_1_id_230",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.ne\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\ni32.const 16\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_231",
        "query_text": "The function accepts a single character as its input and returns a boolean value indicating whether the input character is an uppercase letter. It operates by utilizing a standard library function to evaluate if the character belongs to the uppercase category, ultimately converting the non-zero result into a boolean true or false outcome. The primary purpose of this function is to determine the uppercase status of the provided character.",
        "code_id": "c_group_1_id_231",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.ne\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\ni32.const 16\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_232",
        "query_text": "The function takes two inputs: a byte size of type size_t and an integer flag for huge page usage. It attempts to allocate a memory block using the mmap system call, creating an anonymous and private memory mapping. If the flag for huge pages is enabled, the function sets the appropriate mapping flag. Upon successful allocation, it returns a pointer to the allocated memory block of type void*. If the allocation fails, it prints an error message to the standard error stream and terminates the program.",
        "code_id": "c_group_1_id_232",
        "code_text": "(func (;5;) (type 5) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 34\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 6\nblock  ;; label = @1\nlocal.get 6\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=20\nlocal.set 7\ni32.const 262144\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.or\nlocal.set 9\nlocal.get 4\nlocal.get 9\ni32.store offset=20\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 10\nlocal.get 4\ni32.load offset=20\nlocal.set 11\ni32.const 0\nlocal.set 12\ni32.const 3\nlocal.set 13\ni32.const -1\nlocal.set 14\ni64.const 0\nlocal.set 31\nlocal.get 12\nlocal.get 10\nlocal.get 13\nlocal.get 11\nlocal.get 14\nlocal.get 31\ncall 21\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.store offset=16\nlocal.get 4\ni32.load offset=16\nlocal.set 16\ni32.const -1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.eq\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\nblock  ;; label = @1\nlocal.get 20\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 0\nlocal.set 21\nlocal.get 21\ni32.load offset=65636\nlocal.set 22\ncall 11\nlocal.set 23\nlocal.get 23\ni32.load\nlocal.set 24\nlocal.get 24\ncall 35\nlocal.set 25\nlocal.get 4\nlocal.get 25\ni32.store\ni32.const 65590\nlocal.set 26\nlocal.get 22\nlocal.get 26\nlocal.get 4\ncall 12\ndrop\ni32.const 1\nlocal.set 27\nlocal.get 27\ncall 9\nunreachable\nend\nlocal.get 4\ni32.load offset=16\nlocal.set 28\ni32.const 32\nlocal.set 29\nlocal.get 4\nlocal.get 29\ni32.add\nlocal.set 30\nlocal.get 30\nglobal.set 0\nlocal.get 28\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_233",
        "query_text": "The function accepts a single character input (of type char) representing a hexadecimal digit. It checks if the input is a decimal digit between '0' and '9'; if so, it converts it to its corresponding integer value (0\u20139) by subtracting the ASCII value for '0'. If the input is a lowercase letter between 'a' and 'f', it converts it to its equivalent hexadecimal value (10\u201315) by adjusting for the ASCII offset for 'a'. If the character does not fall within these valid ranges, the function terminates the program abruptly using abort(). The resulting output is an integer (of type int) corresponding to the numeric value of the hexadecimal digit if valid.",
        "code_id": "c_group_1_id_233",
        "code_text": "(func (;2;) (type 3) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=11\nlocal.get 3\ni32.load8_u offset=11\nlocal.set 4\ni32.const 24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.shr_s\nlocal.set 7\ni32.const 48\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.ge_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 11\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load8_u offset=11\nlocal.set 12\ni32.const 24\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.shl\nlocal.set 14\nlocal.get 14\nlocal.get 13\ni32.shr_s\nlocal.set 15\ni32.const 57\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.le_s\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 19\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load8_u offset=11\nlocal.set 20\ni32.const 24\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.shl\nlocal.set 22\nlocal.get 22\nlocal.get 21\ni32.shr_s\nlocal.set 23\ni32.const 48\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.sub\nlocal.set 25\nlocal.get 3\nlocal.get 25\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load8_u offset=11\nlocal.set 26\ni32.const 24\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.shl\nlocal.set 28\nlocal.get 28\nlocal.get 27\ni32.shr_s\nlocal.set 29\ni32.const 97\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.ge_s\nlocal.set 31\ni32.const 1\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.and\nlocal.set 33\nblock  ;; label = @2\nlocal.get 33\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load8_u offset=11\nlocal.set 34\ni32.const 24\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.shl\nlocal.set 36\nlocal.get 36\nlocal.get 35\ni32.shr_s\nlocal.set 37\ni32.const 102\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.le_s\nlocal.set 39\ni32.const 1\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.and\nlocal.set 41\nlocal.get 41\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load8_u offset=11\nlocal.set 42\ni32.const 24\nlocal.set 43\nlocal.get 42\nlocal.get 43\ni32.shl\nlocal.set 44\nlocal.get 44\nlocal.get 43\ni32.shr_s\nlocal.set 45\ni32.const 97\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.sub\nlocal.set 47\ni32.const 10\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.add\nlocal.set 49\nlocal.get 3\nlocal.get 49\ni32.store offset=12\nbr 1 (;@1;)\nend\ncall 4\nunreachable\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 50\ni32.const 16\nlocal.set 51\nlocal.get 3\nlocal.get 51\ni32.add\nlocal.set 52\nlocal.get 52\nglobal.set 0\nlocal.get 50\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_234",
        "query_text": "The function takes two inputs: a pointer to an array of character pointers and an unsigned integer representing the number of elements in that array. It iterates over the array, freeing each allocated sub-array of characters. After processing all elements, it frees the memory allocated for the array itself. The function returns no value, and its purpose is to deallocate all memory associated with a dynamically allocated two-dimensional array of strings.",
        "code_id": "c_group_1_id_234",
        "code_text": "(func (;1;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=4\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=4\nlocal.set 6\nlocal.get 4\ni32.load offset=8\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.lt_u\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 10\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=12\nlocal.set 11\nlocal.get 4\ni32.load offset=4\nlocal.set 12\ni32.const 2\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.shl\nlocal.set 14\nlocal.get 11\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\ni32.load\nlocal.set 16\nlocal.get 16\ncall 3\nlocal.get 4\ni32.load offset=4\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.store offset=4\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 20\nlocal.get 20\ncall 3\ni32.const 16\nlocal.set 21\nlocal.get 4\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 22\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_235",
        "query_text": "The function accepts three parameters: a pointer to a constant array of double-precision floating-point numbers, an integer representing the number of elements in the array, and a pointer to an array of doubles for the output. It iterates through the input array in reverse order, copying each element to the corresponding position in the output array; additionally, if the current index is odd, the function negates the copied value. The output array maintains the same size as the input array, and the function itself does not alter the original input array.",
        "code_id": "c_group_1_id_235",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store\ni32.const 0\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load\nlocal.set 8\nlocal.get 5\ni32.load offset=8\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=12\nlocal.set 13\nlocal.get 5\ni32.load offset=8\nlocal.set 14\nlocal.get 5\ni32.load\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.sub\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.sub\nlocal.set 18\ni32.const 3\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.shl\nlocal.set 20\nlocal.get 13\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nf64.load\nlocal.set 43\nlocal.get 5\ni32.load offset=4\nlocal.set 22\nlocal.get 5\ni32.load\nlocal.set 23\ni32.const 3\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.shl\nlocal.set 25\nlocal.get 22\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 26\nlocal.get 43\nf64.store\nlocal.get 5\ni32.load\nlocal.set 27\ni32.const 2\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.rem_s\nlocal.set 29\nblock  ;; label = @3\nlocal.get 29\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load offset=4\nlocal.set 30\nlocal.get 5\ni32.load\nlocal.set 31\ni32.const 3\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.shl\nlocal.set 33\nlocal.get 30\nlocal.get 33\ni32.add\nlocal.set 34\nlocal.get 34\nf64.load\nlocal.set 44\nf64.const -0x1p+0 (;=-1;)\nlocal.set 45\nlocal.get 45\nlocal.get 44\nf64.mul\nlocal.set 46\nlocal.get 5\ni32.load offset=4\nlocal.set 35\nlocal.get 5\ni32.load\nlocal.set 36\ni32.const 3\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.shl\nlocal.set 38\nlocal.get 35\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 39\nlocal.get 46\nf64.store\nend\nlocal.get 5\ni32.load\nlocal.set 40\ni32.const 1\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 5\nlocal.get 42\ni32.store\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_236",
        "query_text": "The function accepts an array of double precision numbers along with two filter arrays used for transformation, as well as stride values for indexing. It processes the input array in discrete steps, computing two output arrays: one that represents a smoothed (averaged) version of the input and another that captures finer, detailed variations. For each step, the function multiplies elements from the input by corresponding filter coefficients, summing the results into the respective outputs. To correctly handle the boundaries of the input array, it employs modular arithmetic, ensuring indices wrap around as needed. The overall inputs include the input array's length, the filter arrays partitioned appropriately, and stride parameters, while the outputs are the two resulting arrays of double precision numbers.",
        "code_id": "c_group_1_id_236",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 10\ni32.const 64\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.sub\nlocal.set 12\nlocal.get 12\nlocal.get 0\ni32.store offset=60\nlocal.get 12\nlocal.get 1\ni32.store offset=56\nlocal.get 12\nlocal.get 2\ni32.store offset=52\nlocal.get 12\nlocal.get 3\ni32.store offset=48\nlocal.get 12\nlocal.get 4\ni32.store offset=44\nlocal.get 12\nlocal.get 5\ni32.store offset=40\nlocal.get 12\nlocal.get 6\ni32.store offset=36\nlocal.get 12\nlocal.get 7\ni32.store offset=32\nlocal.get 12\nlocal.get 8\ni32.store offset=28\nlocal.get 12\nlocal.get 9\ni32.store offset=24\nlocal.get 12\ni32.load offset=44\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.store offset=8\ni32.const 0\nlocal.set 14\nlocal.get 12\nlocal.get 14\ni32.store offset=16\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 12\ni32.load offset=16\nlocal.set 15\nlocal.get 12\ni32.load offset=36\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.lt_s\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 19\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 12\ni32.load offset=16\nlocal.set 20\nlocal.get 12\nlocal.get 20\ni32.store offset=12\nlocal.get 12\ni32.load offset=16\nlocal.set 21\nlocal.get 12\ni32.load offset=24\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.mul\nlocal.set 23\nlocal.get 12\nlocal.get 23\ni32.store\nlocal.get 12\ni32.load offset=12\nlocal.set 24\nlocal.get 12\ni32.load offset=28\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.mul\nlocal.set 26\nlocal.get 12\nlocal.get 26\ni32.store offset=4\nlocal.get 12\ni32.load offset=48\nlocal.set 27\nlocal.get 27\nf64.load\nlocal.set 122\nlocal.get 12\ni32.load offset=56\nlocal.set 28\nlocal.get 12\ni32.load offset=4\nlocal.set 29\ni32.const 3\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.shl\nlocal.set 31\nlocal.get 28\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 32\nf64.load\nlocal.set 123\nlocal.get 122\nlocal.get 123\nf64.mul\nlocal.set 124\nlocal.get 12\ni32.load offset=40\nlocal.set 33\nlocal.get 12\ni32.load\nlocal.set 34\ni32.const 3\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.shl\nlocal.set 36\nlocal.get 33\nlocal.get 36\ni32.add\nlocal.set 37\nlocal.get 37\nlocal.get 124\nf64.store\nlocal.get 12\ni32.load offset=48\nlocal.set 38\nlocal.get 12\ni32.load offset=8\nlocal.set 39\ni32.const 3\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.shl\nlocal.set 41\nlocal.get 38\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 42\nf64.load\nlocal.set 125\nlocal.get 12\ni32.load offset=56\nlocal.set 43\nlocal.get 12\ni32.load offset=4\nlocal.set 44\ni32.const 3\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.shl\nlocal.set 46\nlocal.get 43\nlocal.get 46\ni32.add\nlocal.set 47\nlocal.get 47\nf64.load\nlocal.set 126\nlocal.get 125\nlocal.get 126\nf64.mul\nlocal.set 127\nlocal.get 12\ni32.load offset=32\nlocal.set 48\nlocal.get 12\ni32.load\nlocal.set 49\ni32.const 3\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.shl\nlocal.set 51\nlocal.get 48\nlocal.get 51\ni32.add\nlocal.set 52\nlocal.get 52\nlocal.get 127\nf64.store\ni32.const 1\nlocal.set 53\nlocal.get 12\nlocal.get 53\ni32.store offset=20\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 12\ni32.load offset=20\nlocal.set 54\nlocal.get 12\ni32.load offset=8\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.lt_s\nlocal.set 56\ni32.const 1\nlocal.set 57\nlocal.get 56\nlocal.get 57\ni32.and\nlocal.set 58\nlocal.get 58\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 12\ni32.load offset=60\nlocal.set 59\nlocal.get 12\ni32.load offset=12\nlocal.set 60\nlocal.get 60\nlocal.get 59\ni32.sub\nlocal.set 61\nlocal.get 12\nlocal.get 61\ni32.store offset=12\nblock  ;; label = @5\nloop  ;; label = @6\nlocal.get 12\ni32.load offset=12\nlocal.set 62\nlocal.get 12\ni32.load offset=36\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.ge_s\nlocal.set 64\ni32.const 1\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.and\nlocal.set 66\nlocal.get 66\ni32.eqz\nbr_if 1 (;@5;)\nlocal.get 12\ni32.load offset=36\nlocal.set 67\nlocal.get 12\ni32.load offset=12\nlocal.set 68\nlocal.get 68\nlocal.get 67\ni32.sub\nlocal.set 69\nlocal.get 12\nlocal.get 69\ni32.store offset=12\nbr 0 (;@6;)\nend\nunreachable\nend\nblock  ;; label = @5\nloop  ;; label = @6\nlocal.get 12\ni32.load offset=12\nlocal.set 70\ni32.const 0\nlocal.set 71\nlocal.get 70\nlocal.get 71\ni32.lt_s\nlocal.set 72\ni32.const 1\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.and\nlocal.set 74\nlocal.get 74\ni32.eqz\nbr_if 1 (;@5;)\nlocal.get 12\ni32.load offset=36\nlocal.set 75\nlocal.get 12\ni32.load offset=12\nlocal.set 76\nlocal.get 76\nlocal.get 75\ni32.add\nlocal.set 77\nlocal.get 12\nlocal.get 77\ni32.store offset=12\nbr 0 (;@6;)\nend\nunreachable\nend\nlocal.get 12\ni32.load offset=16\nlocal.set 78\nlocal.get 12\ni32.load offset=24\nlocal.set 79\nlocal.get 78\nlocal.get 79\ni32.mul\nlocal.set 80\nlocal.get 12\nlocal.get 80\ni32.store\nlocal.get 12\ni32.load offset=12\nlocal.set 81\nlocal.get 12\ni32.load offset=28\nlocal.set 82\nlocal.get 81\nlocal.get 82\ni32.mul\nlocal.set 83\nlocal.get 12\nlocal.get 83\ni32.store offset=4\nlocal.get 12\ni32.load offset=48\nlocal.set 84\nlocal.get 12\ni32.load offset=20\nlocal.set 85\ni32.const 3\nlocal.set 86\nlocal.get 85\nlocal.get 86\ni32.shl\nlocal.set 87\nlocal.get 84\nlocal.get 87\ni32.add\nlocal.set 88\nlocal.get 88\nf64.load\nlocal.set 128\nlocal.get 12\ni32.load offset=56\nlocal.set 89\nlocal.get 12\ni32.load offset=4\nlocal.set 90\ni32.const 3\nlocal.set 91\nlocal.get 90\nlocal.get 91\ni32.shl\nlocal.set 92\nlocal.get 89\nlocal.get 92\ni32.add\nlocal.set 93\nlocal.get 93\nf64.load\nlocal.set 129\nlocal.get 12\ni32.load offset=40\nlocal.set 94\nlocal.get 12\ni32.load\nlocal.set 95\ni32.const 3\nlocal.set 96\nlocal.get 95\nlocal.get 96\ni32.shl\nlocal.set 97\nlocal.get 94\nlocal.get 97\ni32.add\nlocal.set 98\nlocal.get 98\nf64.load\nlocal.set 130\nlocal.get 128\nlocal.get 129\nf64.mul\nlocal.set 131\nlocal.get 131\nlocal.get 130\nf64.add\nlocal.set 132\nlocal.get 98\nlocal.get 132\nf64.store\nlocal.get 12\ni32.load offset=48\nlocal.set 99\nlocal.get 12\ni32.load offset=8\nlocal.set 100\nlocal.get 12\ni32.load offset=20\nlocal.set 101\nlocal.get 100\nlocal.get 101\ni32.add\nlocal.set 102\ni32.const 3\nlocal.set 103\nlocal.get 102\nlocal.get 103\ni32.shl\nlocal.set 104\nlocal.get 99\nlocal.get 104\ni32.add\nlocal.set 105\nlocal.get 105\nf64.load\nlocal.set 133\nlocal.get 12\ni32.load offset=56\nlocal.set 106\nlocal.get 12\ni32.load offset=4\nlocal.set 107\ni32.const 3\nlocal.set 108\nlocal.get 107\nlocal.get 108\ni32.shl\nlocal.set 109\nlocal.get 106\nlocal.get 109\ni32.add\nlocal.set 110\nlocal.get 110\nf64.load\nlocal.set 134\nlocal.get 12\ni32.load offset=32\nlocal.set 111\nlocal.get 12\ni32.load\nlocal.set 112\ni32.const 3\nlocal.set 113\nlocal.get 112\nlocal.get 113\ni32.shl\nlocal.set 114\nlocal.get 111\nlocal.get 114\ni32.add\nlocal.set 115\nlocal.get 115\nf64.load\nlocal.set 135\nlocal.get 133\nlocal.get 134\nf64.mul\nlocal.set 136\nlocal.get 136\nlocal.get 135\nf64.add\nlocal.set 137\nlocal.get 115\nlocal.get 137\nf64.store\nlocal.get 12\ni32.load offset=20\nlocal.set 116\ni32.const 1\nlocal.set 117\nlocal.get 116\nlocal.get 117\ni32.add\nlocal.set 118\nlocal.get 12\nlocal.get 118\ni32.store offset=20\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 12\ni32.load offset=16\nlocal.set 119\ni32.const 1\nlocal.set 120\nlocal.get 119\nlocal.get 120\ni32.add\nlocal.set 121\nlocal.get 12\nlocal.get 121\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_238",
        "query_text": "The function takes several inputs that include two arrays of double-precision floating-point numbers and a filter array, along with various integer parameters to control stride and length. It processes the two input arrays by computing a weighted sum of their elements using the provided filter values, where the weights for the two arrays are taken from different segments of the filter array. The computation is performed using designated input and output strides, and the algorithm employs circular indexing to wrap around the input arrays as needed. The result of the transformation is stored in an output array of double-precision floating-point numbers. \n\nInputs:\n- An integer used as a multiplier for index transformation.\n- Two arrays of double-precision floating-point numbers for coefficients and details.\n- An integer representing the length of the first array.\n- An array of double-precision floating-point numbers representing filter weights.\n- An integer indicating the length of the filter array.\n- Two integers specifying the input and output strides.\n\nOutput:\n- An array of double-precision floating-point numbers containing the computed results.\n\nThe function serves as a black box to perform the transformation of the input arrays into an output array by applying the filter weights in a cyclic manner, without requiring knowledge of the underlying algorithm details.",
        "code_id": "c_group_1_id_238",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32 i32 i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 9\ni32.const 64\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.sub\nlocal.set 11\nlocal.get 11\nlocal.get 0\ni32.store offset=60\nlocal.get 11\nlocal.get 1\ni32.store offset=56\nlocal.get 11\nlocal.get 2\ni32.store offset=52\nlocal.get 11\nlocal.get 3\ni32.store offset=48\nlocal.get 11\nlocal.get 4\ni32.store offset=44\nlocal.get 11\nlocal.get 5\ni32.store offset=40\nlocal.get 11\nlocal.get 6\ni32.store offset=36\nlocal.get 11\nlocal.get 7\ni32.store offset=32\nlocal.get 11\nlocal.get 8\ni32.store offset=28\nlocal.get 11\ni32.load offset=40\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.store offset=24\ni32.const 0\nlocal.set 13\nlocal.get 11\nlocal.get 13\ni32.store offset=20\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 11\ni32.load offset=20\nlocal.set 14\nlocal.get 11\ni32.load offset=52\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.lt_s\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 18\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 11\ni32.load offset=20\nlocal.set 19\nlocal.get 11\nlocal.get 19\ni32.store offset=12\nlocal.get 11\ni32.load offset=20\nlocal.set 20\nlocal.get 11\ni32.load offset=28\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.mul\nlocal.set 22\nlocal.get 11\nlocal.get 22\ni32.store offset=4\nlocal.get 11\ni32.load offset=12\nlocal.set 23\nlocal.get 11\ni32.load offset=32\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.mul\nlocal.set 25\nlocal.get 11\nlocal.get 25\ni32.store offset=8\nlocal.get 11\ni32.load offset=44\nlocal.set 26\nlocal.get 26\nf64.load\nlocal.set 108\nlocal.get 11\ni32.load offset=56\nlocal.set 27\nlocal.get 11\ni32.load offset=8\nlocal.set 28\ni32.const 3\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.shl\nlocal.set 30\nlocal.get 27\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 31\nf64.load\nlocal.set 109\nlocal.get 11\ni32.load offset=44\nlocal.set 32\nlocal.get 11\ni32.load offset=24\nlocal.set 33\ni32.const 3\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.shl\nlocal.set 35\nlocal.get 32\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 36\nf64.load\nlocal.set 110\nlocal.get 11\ni32.load offset=48\nlocal.set 37\nlocal.get 11\ni32.load offset=8\nlocal.set 38\ni32.const 3\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.shl\nlocal.set 40\nlocal.get 37\nlocal.get 40\ni32.add\nlocal.set 41\nlocal.get 41\nf64.load\nlocal.set 111\nlocal.get 110\nlocal.get 111\nf64.mul\nlocal.set 112\nlocal.get 108\nlocal.get 109\nf64.mul\nlocal.set 113\nlocal.get 113\nlocal.get 112\nf64.add\nlocal.set 114\nlocal.get 11\ni32.load offset=36\nlocal.set 42\nlocal.get 11\ni32.load offset=4\nlocal.set 43\ni32.const 3\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.shl\nlocal.set 45\nlocal.get 42\nlocal.get 45\ni32.add\nlocal.set 46\nlocal.get 46\nlocal.get 114\nf64.store\ni32.const 1\nlocal.set 47\nlocal.get 11\nlocal.get 47\ni32.store offset=16\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 11\ni32.load offset=16\nlocal.set 48\nlocal.get 11\ni32.load offset=24\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.lt_s\nlocal.set 50\ni32.const 1\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.and\nlocal.set 52\nlocal.get 52\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 11\ni32.load offset=60\nlocal.set 53\nlocal.get 11\ni32.load offset=12\nlocal.set 54\nlocal.get 54\nlocal.get 53\ni32.add\nlocal.set 55\nlocal.get 11\nlocal.get 55\ni32.store offset=12\nblock  ;; label = @5\nloop  ;; label = @6\nlocal.get 11\ni32.load offset=12\nlocal.set 56\nlocal.get 11\ni32.load offset=52\nlocal.set 57\nlocal.get 56\nlocal.get 57\ni32.ge_s\nlocal.set 58\ni32.const 1\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.and\nlocal.set 60\nlocal.get 60\ni32.eqz\nbr_if 1 (;@5;)\nlocal.get 11\ni32.load offset=52\nlocal.set 61\nlocal.get 11\ni32.load offset=12\nlocal.set 62\nlocal.get 62\nlocal.get 61\ni32.sub\nlocal.set 63\nlocal.get 11\nlocal.get 63\ni32.store offset=12\nbr 0 (;@6;)\nend\nunreachable\nend\nblock  ;; label = @5\nloop  ;; label = @6\nlocal.get 11\ni32.load offset=12\nlocal.set 64\ni32.const 0\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.lt_s\nlocal.set 66\ni32.const 1\nlocal.set 67\nlocal.get 66\nlocal.get 67\ni32.and\nlocal.set 68\nlocal.get 68\ni32.eqz\nbr_if 1 (;@5;)\nlocal.get 11\ni32.load offset=52\nlocal.set 69\nlocal.get 11\ni32.load offset=12\nlocal.set 70\nlocal.get 70\nlocal.get 69\ni32.add\nlocal.set 71\nlocal.get 11\nlocal.get 71\ni32.store offset=12\nbr 0 (;@6;)\nend\nunreachable\nend\nlocal.get 11\ni32.load offset=12\nlocal.set 72\nlocal.get 11\ni32.load offset=32\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.mul\nlocal.set 74\nlocal.get 11\nlocal.get 74\ni32.store offset=8\nlocal.get 11\ni32.load offset=44\nlocal.set 75\nlocal.get 11\ni32.load offset=16\nlocal.set 76\ni32.const 3\nlocal.set 77\nlocal.get 76\nlocal.get 77\ni32.shl\nlocal.set 78\nlocal.get 75\nlocal.get 78\ni32.add\nlocal.set 79\nlocal.get 79\nf64.load\nlocal.set 115\nlocal.get 11\ni32.load offset=56\nlocal.set 80\nlocal.get 11\ni32.load offset=8\nlocal.set 81\ni32.const 3\nlocal.set 82\nlocal.get 81\nlocal.get 82\ni32.shl\nlocal.set 83\nlocal.get 80\nlocal.get 83\ni32.add\nlocal.set 84\nlocal.get 84\nf64.load\nlocal.set 116\nlocal.get 11\ni32.load offset=44\nlocal.set 85\nlocal.get 11\ni32.load offset=24\nlocal.set 86\nlocal.get 11\ni32.load offset=16\nlocal.set 87\nlocal.get 86\nlocal.get 87\ni32.add\nlocal.set 88\ni32.const 3\nlocal.set 89\nlocal.get 88\nlocal.get 89\ni32.shl\nlocal.set 90\nlocal.get 85\nlocal.get 90\ni32.add\nlocal.set 91\nlocal.get 91\nf64.load\nlocal.set 117\nlocal.get 11\ni32.load offset=48\nlocal.set 92\nlocal.get 11\ni32.load offset=8\nlocal.set 93\ni32.const 3\nlocal.set 94\nlocal.get 93\nlocal.get 94\ni32.shl\nlocal.set 95\nlocal.get 92\nlocal.get 95\ni32.add\nlocal.set 96\nlocal.get 96\nf64.load\nlocal.set 118\nlocal.get 117\nlocal.get 118\nf64.mul\nlocal.set 119\nlocal.get 115\nlocal.get 116\nf64.mul\nlocal.set 120\nlocal.get 120\nlocal.get 119\nf64.add\nlocal.set 121\nlocal.get 11\ni32.load offset=36\nlocal.set 97\nlocal.get 11\ni32.load offset=4\nlocal.set 98\ni32.const 3\nlocal.set 99\nlocal.get 98\nlocal.get 99\ni32.shl\nlocal.set 100\nlocal.get 97\nlocal.get 100\ni32.add\nlocal.set 101\nlocal.get 101\nf64.load\nlocal.set 122\nlocal.get 122\nlocal.get 121\nf64.add\nlocal.set 123\nlocal.get 101\nlocal.get 123\nf64.store\nlocal.get 11\ni32.load offset=16\nlocal.set 102\ni32.const 1\nlocal.set 103\nlocal.get 102\nlocal.get 103\ni32.add\nlocal.set 104\nlocal.get 11\nlocal.get 104\ni32.store offset=16\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 11\ni32.load offset=20\nlocal.set 105\ni32.const 1\nlocal.set 106\nlocal.get 105\nlocal.get 106\ni32.add\nlocal.set 107\nlocal.get 11\nlocal.get 107\ni32.store offset=20\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_239",
        "query_text": "The function accepts an integer as input and returns an integer as output. It evaluates whether the provided integer is non-negative or negative. If the input is non-negative, the function returns 1, and if negative, it returns -1. Its primary purpose is to determine and output the sign of the input integer.",
        "code_id": "c_group_1_id_239",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.ge_s\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 8\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 1\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=8\nbr 1 (;@1;)\nend\ni32.const -1\nlocal.set 10\nlocal.get 3\nlocal.get 10\ni32.store offset=8\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_240",
        "query_text": "The function takes an integer input and returns its absolute value as an integer. It first checks if the input is non-negative; if so, it returns the input directly. Otherwise, it returns the negated value, effectively converting any negative number into a positive one.",
        "code_id": "c_group_1_id_240",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.ge_s\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 8\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=8\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 10\ni32.const 0\nlocal.set 11\nlocal.get 11\nlocal.get 10\ni32.sub\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 13\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_241",
        "query_text": "The function accepts two inputs: pointers to double values provided via generic pointer types. It compares the underlying double values and returns an integer indicating their ordering. Specifically, it returns -1 if the first value is smaller than the second, 1 if the first value is larger, and 0 if the two values are equal. This comparator is typically used for sorting or searching operations.",
        "code_id": "c_group_1_id_241",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 5\nf64.load\nlocal.set 17\nlocal.get 4\nlocal.get 17\nf64.store offset=8\nlocal.get 4\ni32.load offset=20\nlocal.set 6\nlocal.get 6\nf64.load\nlocal.set 18\nlocal.get 4\nlocal.get 18\nf64.store\nlocal.get 4\nf64.load offset=8\nlocal.set 19\nlocal.get 4\nf64.load\nlocal.set 20\nlocal.get 19\nlocal.get 20\nf64.lt\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 4\nf64.load offset=8\nlocal.set 21\nlocal.get 4\nf64.load\nlocal.set 22\nlocal.get 21\nlocal.get 22\nf64.gt\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @2\nlocal.get 13\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 1\nlocal.set 14\nlocal.get 4\nlocal.get 14\ni32.store offset=28\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.store offset=28\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 16\nlocal.get 16\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_242",
        "query_text": "The function takes two inputs: a pointer to an array of double-precision floating-point values and an integer representing the count of elements in the array. It iterates over the array, summing all the values, and then divides the total by the number of elements, thereby computing the arithmetic mean. The result is returned as a double-precision floating-point number.",
        "code_id": "c_group_1_id_242",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 0\nlocal.set 5\nlocal.get 5\nf64.convert_i32_s\nlocal.set 21\nlocal.get 4\nlocal.get 21\nf64.store offset=8\ni32.const 0\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=20\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=20\nlocal.set 7\nlocal.get 4\ni32.load offset=24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.lt_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=28\nlocal.set 12\nlocal.get 4\ni32.load offset=20\nlocal.set 13\ni32.const 3\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 12\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\nf64.load\nlocal.set 22\nlocal.get 4\nf64.load offset=8\nlocal.set 23\nlocal.get 23\nlocal.get 22\nf64.add\nlocal.set 24\nlocal.get 4\nlocal.get 24\nf64.store offset=8\nlocal.get 4\ni32.load offset=20\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.store offset=20\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\nf64.load offset=8\nlocal.set 25\nlocal.get 4\ni32.load offset=24\nlocal.set 20\nlocal.get 20\nf64.convert_i32_s\nlocal.set 26\nlocal.get 25\nlocal.get 26\nf64.div\nlocal.set 27\nlocal.get 4\nlocal.get 27\nf64.store offset=8\nlocal.get 4\nf64.load offset=8\nlocal.set 28\nlocal.get 28\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_243",
        "query_text": "The function accepts an array of double-precision floating-point numbers along with an integer indicating the array's size. It iterates through the array to find the smallest element, tracking the first occurrence in case of duplicate minimal values. After the traversal, the function returns an integer representing the index of this smallest element.",
        "code_id": "c_group_1_id_243",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\nf64.const 0x1.fffffffffffffp+1023 (;=1.79769e+308;)\nlocal.set 30\nlocal.get 4\nlocal.get 30\nf64.store offset=16\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=12\ni32.const 0\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=8\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=8\nlocal.set 7\nlocal.get 4\ni32.load offset=24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.lt_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=28\nlocal.set 12\nlocal.get 4\ni32.load offset=8\nlocal.set 13\ni32.const 3\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 12\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\nf64.load\nlocal.set 31\nlocal.get 4\nf64.load offset=16\nlocal.set 32\nlocal.get 31\nlocal.get 32\nf64.lt\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nblock  ;; label = @3\nlocal.get 19\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=28\nlocal.set 20\nlocal.get 4\ni32.load offset=8\nlocal.set 21\ni32.const 3\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.shl\nlocal.set 23\nlocal.get 20\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nf64.load\nlocal.set 33\nlocal.get 4\nlocal.get 33\nf64.store offset=16\nlocal.get 4\ni32.load offset=8\nlocal.set 25\nlocal.get 4\nlocal.get 25\ni32.store offset=12\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 26\ni32.const 1\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 4\nlocal.get 28\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 29\nlocal.get 29\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_244",
        "query_text": "The function takes no input parameters and returns no value. It starts by checking if a specific compile-time flag is defined; when this flag is active, it resets two pointer variables used for tracking statistics, effectively clearing any previous benchmarking data. Afterward, it initializes a cycle counter via a predefined macro, setting up performance measurement. Its overall purpose is to prepare the system for collecting benchmarking statistics and measuring execution cycles.",
        "code_id": "c_group_1_id_244",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_245",
        "query_text": "SUMMARY:  \nThe function takes a modifiable string as its input and processes it in place. It iteratively scans the string for a specific two-character substring (composed of two colons) and, upon finding it, replaces that occurrence with a single dot character. The search continues from just after each replacement until no further occurrences are detected. The input is of type std::string, and the function modifies it directly without returning a new string.",
        "code_id": "c_group_1_id_245",
        "code_text": "(func (;2;) (type 3) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 65549\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 4\nlocal.get 5\nlocal.get 6\ncall 3\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.store offset=8\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 8\ni32.const -1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.ne\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 13\nlocal.get 3\ni32.load offset=8\nlocal.set 14\ni32.const 2\nlocal.set 15\ni32.const 65552\nlocal.set 16\nlocal.get 13\nlocal.get 14\nlocal.get 15\nlocal.get 16\ncall 95\ndrop\nlocal.get 3\ni32.load offset=8\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 3\nlocal.get 19\ni32.store offset=8\nlocal.get 3\ni32.load offset=12\nlocal.set 20\nlocal.get 3\ni32.load offset=8\nlocal.set 21\ni32.const 65549\nlocal.set 22\nlocal.get 20\nlocal.get 22\nlocal.get 21\ncall 3\nlocal.set 23\nlocal.get 3\nlocal.get 23\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\ni32.const 16\nlocal.set 24\nlocal.get 3\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_246",
        "query_text": "The function takes no input parameters and returns a 64-bit unsigned integer. It begins by retrieving the current system time using a high-resolution clock. This time point is then interpreted as the duration elapsed since the epoch (typically January 1, 1970) and converted into a nanosecond count, which is finally returned as the output.",
        "code_id": "c_group_1_id_246",
        "code_text": "(func (;3;) (type 5) (result i64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 0\ni32.const 32\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ncall 18\nlocal.set 14\nlocal.get 2\nlocal.get 14\ni64.store offset=8\ni32.const 8\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.add\nlocal.set 4\nlocal.get 4\nlocal.set 5\nlocal.get 5\ncall 4\nlocal.set 15\nlocal.get 2\nlocal.get 15\ni64.store offset=16\ni32.const 16\nlocal.set 6\nlocal.get 2\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.set 8\nlocal.get 8\ncall 5\nlocal.set 16\nlocal.get 2\nlocal.get 16\ni64.store offset=24\ni32.const 24\nlocal.set 9\nlocal.get 2\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nlocal.set 11\nlocal.get 11\ncall 6\nlocal.set 17\ni32.const 32\nlocal.set 12\nlocal.get 2\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_247",
        "query_text": "The function rotates a 32-bit unsigned integer to the right by a given number of bit positions. It accepts two 32-bit unsigned integer inputs: one representing the value to be rotated, and the other indicating how many positions to rotate. The function begins by constraining the rotation count to the range 0 through 31 using a bitmask. It then shifts the value right by the specified count, while simultaneously shifting the value left by the complement of the count to capture any bits that \"fall off\" the right end. The two shifted results are then combined using a bitwise OR, yielding a new 32-bit unsigned integer with the bits rotated as specified.",
        "code_id": "c_group_1_id_247",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\ni32.const 31\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 6\ni32.const 31\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 9\nlocal.get 4\ni32.load offset=8\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.shr_u\nlocal.set 11\nlocal.get 4\ni32.load offset=12\nlocal.set 12\nlocal.get 4\ni32.load offset=8\nlocal.set 13\ni32.const 0\nlocal.set 14\nlocal.get 14\nlocal.get 13\ni32.sub\nlocal.set 15\ni32.const 31\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.and\nlocal.set 17\nlocal.get 12\nlocal.get 17\ni32.shl\nlocal.set 18\nlocal.get 11\nlocal.get 18\ni32.or\nlocal.set 19\nlocal.get 19\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_248",
        "query_text": "The function takes a vector of pointers to unsigned characters and a pointer to a pointer to unsigned characters as inputs. It sequentially copies the elements from the vector into the memory location referenced by the second input using a standard library copy algorithm.",
        "code_id": "c_group_1_id_248",
        "code_text": "(func (;1;) (type 7) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ncall 2\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=4\nlocal.get 4\ni32.load offset=12\nlocal.set 7\nlocal.get 7\ncall 3\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store\nlocal.get 4\ni32.load offset=8\nlocal.set 9\nlocal.get 4\ni32.load offset=4\nlocal.set 10\nlocal.get 4\ni32.load\nlocal.set 11\nlocal.get 10\nlocal.get 11\nlocal.get 9\ncall 4\ndrop\ni32.const 16\nlocal.set 12\nlocal.get 4\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_249",
        "query_text": "This function converts an angle from radians to degrees. It takes a single input in the form of a pointer to a floating-point value representing the angle in radians. The function processes the value in-place by multiplying it by the conversion factor (180.0 divided by \u03c0), thereby updating the original value to reflect the equivalent measure in degrees. Both the input and output utilize the floating-point type.",
        "code_id": "c_group_1_id_249",
        "code_text": "(func (;1;) (type 2) (param i32)\n(local i32 i32 i32 i32 i32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nf32.load\nlocal.set 6\nf32.const 0x1.68p+7 (;=180;)\nlocal.set 7\nlocal.get 6\nlocal.get 7\nf32.mul\nlocal.set 8\nf32.const 0x1.921fb6p+1 (;=3.14159;)\nlocal.set 9\nlocal.get 8\nlocal.get 9\nf32.div\nlocal.set 10\nlocal.get 3\ni32.load offset=12\nlocal.set 5\nlocal.get 5\nlocal.get 10\nf32.store\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_250",
        "query_text": "The function resets the locale settings for the calling thread to a default or global state, adapting its approach based on the system capabilities. On Windows platforms (excluding certain environments like MinGW), it disables per-thread locale settings, thereby reverting to the global locale. On POSIX-compliant systems that support specific locale APIs, it switches the thread's locale to the global one and then releases the associated locale object. If neither mechanism is available, it outputs a warning that the thread's locale cannot be modified. The function neither accepts parameters nor returns a value.",
        "code_id": "c_group_1_id_250",
        "code_text": "(func (;1;) (type 1)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ni32.const -1\nlocal.set 3\nlocal.get 3\ncall 9\nlocal.set 4\nlocal.get 2\nlocal.get 4\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ncall 3\ni32.const 16\nlocal.set 6\nlocal.get 2\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_251",
        "query_text": "This function computes the number of leading zero bits in a 64-bit unsigned integer. It accepts a single unsigned integer input and returns an integer result reflecting the count of zeros preceding the first set bit. On Windows, the function branches into different implementations based on the system architecture, employing one intrinsic function for 64-bit builds and another for 32-bit builds. In contrast, on other platforms, it directly uses a compiler-provided intrinsic. The result is an integer in the range from 0 to 64, corresponding to the number of leading zeros in the input value.",
        "code_id": "c_group_1_id_251",
        "code_text": "(func (;1;) (type 2) (param i64) (result i32)\n(local i32 i32 i32 i32 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 5\nlocal.get 5\ni64.clz\nlocal.set 6\nlocal.get 6\ni32.wrap_i64\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_252",
        "query_text": "The function takes four inputs: a pointer to the beginning of a memory block, the size of that block, a pointer to a second memory block to search for, and the size of this second block. It examines the first memory block for the initial occurrence of the second memory block. If it finds an exact match, the function returns a pointer to its starting position within the first block; if no match is found or if the search block is larger than the first block, it returns NULL. The inputs are of types const void* and size_t, while the output is of type void*.",
        "code_id": "c_group_1_id_252",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 4\ni32.const 48\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nlocal.get 0\ni32.store offset=40\nlocal.get 6\nlocal.get 1\ni32.store offset=36\nlocal.get 6\nlocal.get 2\ni32.store offset=32\nlocal.get 6\nlocal.get 3\ni32.store offset=28\nlocal.get 6\ni32.load offset=40\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.store offset=16\nlocal.get 6\ni32.load offset=32\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.store offset=12\nlocal.get 6\ni32.load offset=28\nlocal.set 9\nlocal.get 6\ni32.load offset=36\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.gt_u\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 13\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 14\nlocal.get 6\nlocal.get 14\ni32.store offset=44\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 15\nlocal.get 6\nlocal.get 15\ni32.store offset=24\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 6\ni32.load offset=24\nlocal.set 16\nlocal.get 6\ni32.load offset=36\nlocal.set 17\nlocal.get 6\ni32.load offset=28\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.sub\nlocal.set 19\nlocal.get 16\nlocal.get 19\ni32.le_u\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 22\ni32.eqz\nbr_if 1 (;@2;)\ni32.const 0\nlocal.set 23\nlocal.get 6\nlocal.get 23\ni32.store offset=20\nblock  ;; label = @4\nloop  ;; label = @5\nlocal.get 6\ni32.load offset=20\nlocal.set 24\nlocal.get 6\ni32.load offset=28\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.lt_u\nlocal.set 26\ni32.const 1\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.and\nlocal.set 28\nlocal.get 28\ni32.eqz\nbr_if 1 (;@4;)\nlocal.get 6\ni32.load offset=16\nlocal.set 29\nlocal.get 6\ni32.load offset=24\nlocal.set 30\nlocal.get 6\ni32.load offset=20\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 29\nlocal.get 32\ni32.add\nlocal.set 33\nlocal.get 33\ni32.load8_u\nlocal.set 34\ni32.const 24\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.shl\nlocal.set 36\nlocal.get 36\nlocal.get 35\ni32.shr_s\nlocal.set 37\nlocal.get 6\ni32.load offset=12\nlocal.set 38\nlocal.get 6\ni32.load offset=20\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.add\nlocal.set 40\nlocal.get 40\ni32.load8_u\nlocal.set 41\ni32.const 24\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.shl\nlocal.set 43\nlocal.get 43\nlocal.get 42\ni32.shr_s\nlocal.set 44\nlocal.get 37\nlocal.get 44\ni32.ne\nlocal.set 45\ni32.const 1\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.and\nlocal.set 47\nblock  ;; label = @6\nlocal.get 47\ni32.eqz\nbr_if 0 (;@6;)\nbr 2 (;@4;)\nend\nlocal.get 6\ni32.load offset=20\nlocal.set 48\ni32.const 1\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.add\nlocal.set 50\nlocal.get 6\nlocal.get 50\ni32.store offset=20\nbr 0 (;@5;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=20\nlocal.set 51\nlocal.get 6\ni32.load offset=28\nlocal.set 52\nlocal.get 51\nlocal.get 52\ni32.eq\nlocal.set 53\ni32.const 1\nlocal.set 54\nlocal.get 53\nlocal.get 54\ni32.and\nlocal.set 55\nblock  ;; label = @4\nlocal.get 55\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 6\ni32.load offset=16\nlocal.set 56\nlocal.get 6\ni32.load offset=24\nlocal.set 57\nlocal.get 56\nlocal.get 57\ni32.add\nlocal.set 58\nlocal.get 6\nlocal.get 58\ni32.store offset=44\nbr 3 (;@1;)\nend\nlocal.get 6\ni32.load offset=24\nlocal.set 59\ni32.const 1\nlocal.set 60\nlocal.get 59\nlocal.get 60\ni32.add\nlocal.set 61\nlocal.get 6\nlocal.get 61\ni32.store offset=24\nbr 0 (;@3;)\nend\nunreachable\nend\ni32.const 0\nlocal.set 62\nlocal.get 6\nlocal.get 62\ni32.store offset=44\nend\nlocal.get 6\ni32.load offset=44\nlocal.set 63\nlocal.get 63\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_253",
        "query_text": "The function takes no inputs and returns an integer value representing the overall outcome of a series of tests. It starts by initializing a status variable used to monitor whether any test fails. Under a conditional compilation flag, the function displays a start message and then sequentially invokes several test routines\u2014each assessing a different aspect of QUIC functionality, such as cryptographic operations, handshake procedures, and session-related behaviors. If any test routine returns a non-zero value (indicating a failure), the function immediately halts further testing and proceeds to a final stage where it prints an error message highlighting the failure of one or more tests. A closing message is then printed, and the function returns the status variable; a return value of zero signifies that all tests have passed, while any non-zero value indicates that at least one test did not succeed. Additionally, some tests are conditionally executed based on preprocessor directives, allowing the function to adapt to different build configurations and feature sets.",
        "code_id": "c_group_1_id_253",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 0\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_254",
        "query_text": "The function writes indentation to a file stream based on the provided depth and width parameters. It takes three inputs: a file stream, an integer representing the indentation depth, and an unsigned short representing the indentation width. If the width is non-zero, the function prints spaces to the file stream, where the number of spaces is computed as (depth - 1) times the width. If the width is zero, it prints tab characters instead, outputting one tab for each level of indentation (depth - 1). The function does not return a value; it directly modifies the file stream by outputting the appropriate indentation.",
        "code_id": "c_group_1_id_254",
        "code_text": "(func (;1;) (type 6) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store16 offset=22\nlocal.get 5\ni32.load16_u offset=22\nlocal.set 6\ni32.const 0\nlocal.set 7\ni32.const 65535\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\ni32.const 65535\nlocal.set 10\nlocal.get 7\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 9\nlocal.get 11\ni32.ne\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 14\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 5\ni32.load offset=28\nlocal.set 15\nlocal.get 5\ni32.load offset=24\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.sub\nlocal.set 18\nlocal.get 5\ni32.load16_u offset=22\nlocal.set 19\ni32.const 65535\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.and\nlocal.set 21\nlocal.get 18\nlocal.get 21\ni32.mul\nlocal.set 22\ni32.const 65594\nlocal.set 23\nlocal.get 5\nlocal.get 23\ni32.store offset=4\nlocal.get 5\nlocal.get 22\ni32.store\ni32.const 65565\nlocal.set 24\nlocal.get 15\nlocal.get 24\nlocal.get 5\ncall 3\ndrop\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 25\nlocal.get 5\nlocal.get 25\ni32.store offset=16\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 5\ni32.load offset=16\nlocal.set 26\nlocal.get 5\ni32.load offset=24\nlocal.set 27\ni32.const 1\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.sub\nlocal.set 29\nlocal.get 26\nlocal.get 29\ni32.lt_s\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nlocal.get 32\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 5\ni32.load offset=28\nlocal.set 33\ni32.const 9\nlocal.set 34\nlocal.get 34\nlocal.get 33\ncall 8\ndrop\nlocal.get 5\ni32.load offset=16\nlocal.set 35\ni32.const 1\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.add\nlocal.set 37\nlocal.get 5\nlocal.get 37\ni32.store offset=16\nbr 0 (;@3;)\nend\nunreachable\nend\nend\ni32.const 32\nlocal.set 38\nlocal.get 5\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 39\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_255",
        "query_text": "The function takes two inputs. The first is a pointer to a block of memory, and the second is an integer value representing the size in bytes of that block. The function initializes the entire block by setting every byte to zero. It achieves this by either invoking a standard library function to fill the memory with zeros (if a certain macro is defined) or by manually iterating over each byte in the block to set it to zero. The function does not return any value.",
        "code_id": "c_group_1_id_255",
        "code_text": "(func (;1;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=4\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=8\nlocal.set 6\ni32.const -1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=8\ni32.const 0\nlocal.set 9\nlocal.get 6\nlocal.get 9\ni32.gt_u\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=4\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.store offset=4\ni32.const 0\nlocal.set 16\nlocal.get 13\nlocal.get 16\ni32.store8\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_256",
        "query_text": "The function accepts an array of character pointers and two integers marking a range within the array. It reverses the order of the elements in the specified subarray (starting at the first index and ending just before the second index), by swapping elements symmetrically from the ends toward the center. The operation is performed in place, modifying the original array without returning any value.",
        "code_id": "c_group_1_id_256",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=4\nlocal.set 6\nlocal.get 5\ni32.load offset=8\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.sub\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.gt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=12\nlocal.set 13\nlocal.get 5\ni32.load offset=8\nlocal.set 14\ni32.const 2\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 13\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\ni32.load\nlocal.set 18\nlocal.get 5\nlocal.get 18\ni32.store\nlocal.get 5\ni32.load offset=12\nlocal.set 19\nlocal.get 5\ni32.load offset=4\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.sub\nlocal.set 22\ni32.const 2\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.shl\nlocal.set 24\nlocal.get 19\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\ni32.load\nlocal.set 26\nlocal.get 5\ni32.load offset=12\nlocal.set 27\nlocal.get 5\ni32.load offset=8\nlocal.set 28\ni32.const 2\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.shl\nlocal.set 30\nlocal.get 27\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 31\nlocal.get 26\ni32.store\nlocal.get 5\ni32.load\nlocal.set 32\nlocal.get 5\ni32.load offset=12\nlocal.set 33\nlocal.get 5\ni32.load offset=4\nlocal.set 34\ni32.const 1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.sub\nlocal.set 36\ni32.const 2\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.shl\nlocal.set 38\nlocal.get 33\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 39\nlocal.get 32\ni32.store\nlocal.get 5\ni32.load offset=8\nlocal.set 40\ni32.const 1\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 5\nlocal.get 42\ni32.store offset=8\nlocal.get 5\ni32.load offset=4\nlocal.set 43\ni32.const -1\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.add\nlocal.set 45\nlocal.get 5\nlocal.get 45\ni32.store offset=4\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_257",
        "query_text": "The function compares two integers indirectly through pointer dereferencing. It takes two inputs of type const void*, each expected to point to an int pointer. After dereferencing, the function compares the integer values: it returns -1 if the first integer is less than the second, 1 if it is greater, and 0 if both are equal. This comparison mechanism is designed for use in sorting or searching algorithms that require a callback for comparing elements.",
        "code_id": "c_group_1_id_257",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=16\nlocal.get 4\ni32.load offset=20\nlocal.set 7\nlocal.get 7\ni32.load\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=12\nlocal.get 4\ni32.load offset=16\nlocal.set 9\nlocal.get 9\ni32.load\nlocal.set 10\nlocal.get 4\ni32.load offset=12\nlocal.set 11\nlocal.get 11\ni32.load\nlocal.set 12\nlocal.get 10\nlocal.get 12\ni32.lt_s\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 15\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 16\nlocal.get 4\nlocal.get 16\ni32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=16\nlocal.set 17\nlocal.get 17\ni32.load\nlocal.set 18\nlocal.get 4\ni32.load offset=12\nlocal.set 19\nlocal.get 19\ni32.load\nlocal.set 20\nlocal.get 18\nlocal.get 20\ni32.gt_s\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.and\nlocal.set 23\nblock  ;; label = @2\nlocal.get 23\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 1\nlocal.set 24\nlocal.get 4\nlocal.get 24\ni32.store offset=28\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 25\nlocal.get 4\nlocal.get 25\ni32.store offset=28\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 26\nlocal.get 26\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_258",
        "query_text": "This function retrieves version information by constructing a formatted constant string. It takes no input arguments and produces an output that concatenates predefined constants representing the package and version details with a static copyright message. The function returns a pointer to a constant character array containing this version-related information.",
        "code_id": "c_group_1_id_258",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 65536\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_259",
        "query_text": "The function takes a single character of type char as input and returns a boolean value indicating whether the character is a whitespace character. It does so by comparing the input character against a fixed set of characters representing space, tab, newline, and carriage return. If the character is found within this set, the function returns true; otherwise, it returns false. The input is of type char, while the output is of type bool.",
        "code_id": "c_group_1_id_259",
        "code_text": "(func (;2;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\nlocal.set 4\ni32.const 65549\nlocal.set 5\nlocal.get 4\nlocal.get 5\ncall 3\ndrop\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 6\nlocal.get 3\nlocal.set 7\ni32.const 0\nlocal.set 8\ni32.const 24\nlocal.set 9\nlocal.get 6\nlocal.get 9\ni32.shl\nlocal.set 10\nlocal.get 10\nlocal.get 9\ni32.shr_s\nlocal.set 11\nlocal.get 7\nlocal.get 11\nlocal.get 8\ncall 76\nlocal.set 12\ni32.const -1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.ne\nlocal.set 14\nlocal.get 3\nlocal.set 15\nlocal.get 15\ncall 72\ndrop\ni32.const 1\nlocal.set 16\nlocal.get 14\nlocal.get 16\ni32.and\nlocal.set 17\ni32.const 16\nlocal.set 18\nlocal.get 3\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 19\nglobal.set 0\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_260",
        "query_text": "The function takes a boolean value as input and returns no value (void). It checks if the provided boolean is false; if so, it throws a runtime exception with the message \"bug\". Otherwise, if the boolean is true, it performs no action and simply returns. This design serves primarily as a debugging or assertion tool during program execution.",
        "code_id": "c_group_1_id_260",
        "code_text": "(func (;2;) (type 1) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nblock  ;; label = @1\nlocal.get 7\nbr_if 0 (;@1;)\ni32.const 8\nlocal.set 8\nlocal.get 8\ncall 27\nlocal.set 9\ni32.const 65551\nlocal.set 10\nlocal.get 9\nlocal.get 10\ncall 24\ndrop\ni32.const 65864\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 9\nlocal.get 11\nlocal.get 12\ncall 6\nunreachable\nend\ni32.const 16\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_261",
        "query_text": "The function receives an unsigned integer and a boolean as inputs and returns a boolean value. It starts by checking if the boolean input is true; if so, it returns true immediately. If not, the function shifts the unsigned integer right by 5 bits and compares this result with the value 0x1B. If the shifted value is not equal to 0x1B, it returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_261",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store8 offset=11\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 6\ni32.const 1\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 7\nlocal.set 10\nblock  ;; label = @1\nlocal.get 9\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=12\nlocal.set 11\ni32.const 5\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.shr_u\nlocal.set 13\ni32.const 27\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.ne\nlocal.set 15\nlocal.get 15\nlocal.set 10\nend\nlocal.get 10\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 18\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_262",
        "query_text": "The function reads a set number of bytes from a file descriptor into a provided buffer. It takes three inputs: an integer (representing the file descriptor), a pointer (pointing to the buffer where data will be stored), and an unsigned integer (specifying the number of bytes to read). Internally, it wraps the standard system call to perform the read operation and returns an integer indicating the actual number of bytes read or -1 if an error is encountered.",
        "code_id": "c_group_1_id_262",
        "code_text": "(func (;2;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nlocal.get 5\ni32.load offset=12\nlocal.set 6\nlocal.get 5\ni32.load offset=8\nlocal.set 7\nlocal.get 5\ni32.load offset=4\nlocal.set 8\nlocal.get 6\nlocal.get 7\nlocal.get 8\ncall 4\nlocal.set 9\ni32.const 16\nlocal.set 10\nlocal.get 5\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 11\nglobal.set 0\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_264",
        "query_text": "The function takes two constant string inputs. It first checks if the length of the first string is at least as long as the length of the second string. If this condition is satisfied, the function compares the corresponding characters from the beginning of the first string with those from the second string. If all compared characters match, the function returns a boolean value of true; otherwise, it returns false. The primary functionality of the function is to determine whether the first string starts with the second string.",
        "code_id": "c_group_1_id_264",
        "code_text": "(func (;1;) (type 4) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\nlocal.get 4\ni32.load offset=28\nlocal.set 5\nlocal.get 5\ncall 2\nlocal.set 6\nlocal.get 4\ni32.load offset=24\nlocal.set 7\nlocal.get 7\ncall 2\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.ge_u\nlocal.set 9\ni32.const 0\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 9\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 10\nlocal.set 13\nblock  ;; label = @1\nlocal.get 12\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=24\nlocal.set 14\nlocal.get 14\ncall 3\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 16\nlocal.get 16\ncall 4\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.store offset=16\nlocal.get 4\ni32.load offset=28\nlocal.set 18\nlocal.get 18\ncall 3\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.store offset=12\nlocal.get 4\ni32.load offset=20\nlocal.set 20\nlocal.get 4\ni32.load offset=16\nlocal.set 21\nlocal.get 4\ni32.load offset=12\nlocal.set 22\nlocal.get 20\nlocal.get 21\nlocal.get 22\ncall 5\nlocal.set 23\nlocal.get 23\nlocal.set 13\nend\nlocal.get 13\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\ni32.const 32\nlocal.set 27\nlocal.get 4\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 28\nglobal.set 0\nlocal.get 26\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_265",
        "query_text": "The function takes a single character as input and returns a boolean value indicating whether the character is alphabetic (either uppercase or lowercase). Internally, it converts the input character to an unsigned representation and utilizes a standard library function to perform the alphabetic check. If the input character qualifies as a letter, the function returns true; otherwise, it returns false. The input is of type char and the output is of type bool.",
        "code_id": "c_group_1_id_265",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.ne\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\ni32.const 16\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_266",
        "query_text": "The function accepts two constant string references. It checks if the second string appears as a contiguous sequence of characters within the first string. The function returns a boolean value indicating the result, where \"true\" signifies that the second string is found and \"false\" indicates it is not.",
        "code_id": "c_group_1_id_266",
        "code_text": "(func (;1;) (type 4) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 5\nlocal.get 6\nlocal.get 7\ncall 2\nlocal.set 8\ni32.const -1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.ne\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\ni32.const 16\nlocal.set 13\nlocal.get 4\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\nglobal.set 0\nlocal.get 12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_268",
        "query_text": "The function accepts two integers: one representing an ASCII character and the other representing a radix (base). It begins by verifying that the provided character code corresponds to a decimal digit (i.e., between '0' and '9'). It then checks whether the numeric value of that digit (obtained by subtracting the ASCII value for '0') is less than the specified radix. Finally, the function returns a boolean value: it outputs true if both conditions are met, and false otherwise.",
        "code_id": "c_group_1_id_268",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\ni32.const 48\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.le_s\nlocal.set 7\ni32.const 0\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 7\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 8\nlocal.set 11\nblock  ;; label = @1\nlocal.get 10\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=12\nlocal.set 12\ni32.const 57\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.le_s\nlocal.set 14\ni32.const 0\nlocal.set 15\ni32.const 1\nlocal.set 16\nlocal.get 14\nlocal.get 16\ni32.and\nlocal.set 17\nlocal.get 15\nlocal.set 11\nlocal.get 17\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=12\nlocal.set 18\ni32.const 48\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.sub\nlocal.set 20\nlocal.get 4\ni32.load offset=8\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.lt_s\nlocal.set 22\nlocal.get 22\nlocal.set 11\nend\nlocal.get 11\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\nlocal.get 25\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_269",
        "query_text": "The function takes an integer input representing a Unicode code point and returns a boolean value. It first checks whether the character is one of a set of explicitly defined symbols (for instance, certain punctuation marks, whitespace characters, and specific control characters) and immediately returns false for them\u2014with one exception where a particular control value results in true. If the input does not match these cases, the function performs a series of range checks: it rejects characters that fall into control ranges (i.e., below a given low threshold), ignores characters in a narrow range following the standard printable set, and then further excludes characters within specific invalid Unicode ranges (such as surrogate pairs, non-characters, and code points exceeding the Unicode maximum). Generally, printable ASCII characters and valid Unicode characters that do not trigger any of these conditions are accepted as anchor characters. \n\nInput: int (representing a Unicode code point)  \nOutput: bool (true if the character qualifies as an anchor character, false otherwise)",
        "code_id": "c_group_1_id_269",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 4\ni32.const -9\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.add\nlocal.set 6\ni32.const 2\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.lt_u\nlocal.set 8\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 8\nbr_if 0 (;@4;)\ni32.const 13\nlocal.set 9\nlocal.get 4\nlocal.get 9\ni32.eq\nlocal.set 10\nlocal.get 10\nbr_if 0 (;@4;)\ni32.const 32\nlocal.set 11\nlocal.get 4\nlocal.get 11\ni32.eq\nlocal.set 12\nlocal.get 12\nbr_if 0 (;@4;)\ni32.const 44\nlocal.set 13\nlocal.get 4\nlocal.get 13\ni32.eq\nlocal.set 14\nlocal.get 14\nbr_if 0 (;@4;)\ni32.const 91\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.eq\nlocal.set 16\nlocal.get 16\nbr_if 0 (;@4;)\ni32.const 93\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.eq\nlocal.set 18\nlocal.get 18\nbr_if 0 (;@4;)\ni32.const 123\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.eq\nlocal.set 20\nlocal.get 20\nbr_if 0 (;@4;)\ni32.const 125\nlocal.set 21\nlocal.get 4\nlocal.get 21\ni32.eq\nlocal.set 22\nlocal.get 22\nbr_if 0 (;@4;)\ni32.const 133\nlocal.set 23\nlocal.get 4\nlocal.get 23\ni32.eq\nlocal.set 24\nlocal.get 24\nbr_if 1 (;@3;)\ni32.const 65279\nlocal.set 25\nlocal.get 4\nlocal.get 25\ni32.ne\nlocal.set 26\nlocal.get 26\nbr_if 2 (;@2;)\nend\ni32.const 0\nlocal.set 27\ni32.const 1\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.and\nlocal.set 29\nlocal.get 3\nlocal.get 29\ni32.store8 offset=15\nbr 2 (;@1;)\nend\ni32.const 1\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nlocal.get 3\nlocal.get 32\ni32.store8 offset=15\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 33\ni32.const 32\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.lt_s\nlocal.set 35\ni32.const 1\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.and\nlocal.set 37\nblock  ;; label = @2\nlocal.get 37\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 38\ni32.const 1\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.and\nlocal.set 40\nlocal.get 3\nlocal.get 40\ni32.store8 offset=15\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 41\ni32.const 126\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.lt_s\nlocal.set 43\ni32.const 1\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.and\nlocal.set 45\nblock  ;; label = @2\nlocal.get 45\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 1\nlocal.set 46\ni32.const 1\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.and\nlocal.set 48\nlocal.get 3\nlocal.get 48\ni32.store8 offset=15\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 49\ni32.const 160\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.lt_s\nlocal.set 51\ni32.const 1\nlocal.set 52\nlocal.get 51\nlocal.get 52\ni32.and\nlocal.set 53\nblock  ;; label = @2\nlocal.get 53\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 54\ni32.const 1\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.and\nlocal.set 56\nlocal.get 3\nlocal.get 56\ni32.store8 offset=15\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 57\ni32.const 55296\nlocal.set 58\nlocal.get 57\nlocal.get 58\ni32.ge_s\nlocal.set 59\ni32.const 1\nlocal.set 60\nlocal.get 59\nlocal.get 60\ni32.and\nlocal.set 61\nblock  ;; label = @2\nlocal.get 61\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=8\nlocal.set 62\ni32.const 57343\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.le_s\nlocal.set 64\ni32.const 1\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.and\nlocal.set 66\nlocal.get 66\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 67\ni32.const 1\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.and\nlocal.set 69\nlocal.get 3\nlocal.get 69\ni32.store8 offset=15\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 70\ni32.const 65534\nlocal.set 71\nlocal.get 70\nlocal.get 71\ni32.and\nlocal.set 72\ni32.const 65534\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.eq\nlocal.set 74\ni32.const 1\nlocal.set 75\nlocal.get 74\nlocal.get 75\ni32.and\nlocal.set 76\nblock  ;; label = @2\nlocal.get 76\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 77\ni32.const 1\nlocal.set 78\nlocal.get 77\nlocal.get 78\ni32.and\nlocal.set 79\nlocal.get 3\nlocal.get 79\ni32.store8 offset=15\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 80\ni32.const 64976\nlocal.set 81\nlocal.get 80\nlocal.get 81\ni32.ge_s\nlocal.set 82\ni32.const 1\nlocal.set 83\nlocal.get 82\nlocal.get 83\ni32.and\nlocal.set 84\nblock  ;; label = @2\nlocal.get 84\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=8\nlocal.set 85\ni32.const 65007\nlocal.set 86\nlocal.get 85\nlocal.get 86\ni32.le_s\nlocal.set 87\ni32.const 1\nlocal.set 88\nlocal.get 87\nlocal.get 88\ni32.and\nlocal.set 89\nlocal.get 89\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 90\ni32.const 1\nlocal.set 91\nlocal.get 90\nlocal.get 91\ni32.and\nlocal.set 92\nlocal.get 3\nlocal.get 92\ni32.store8 offset=15\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 93\ni32.const 1114111\nlocal.set 94\nlocal.get 93\nlocal.get 94\ni32.gt_s\nlocal.set 95\ni32.const 1\nlocal.set 96\nlocal.get 95\nlocal.get 96\ni32.and\nlocal.set 97\nblock  ;; label = @2\nlocal.get 97\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 98\ni32.const 1\nlocal.set 99\nlocal.get 98\nlocal.get 99\ni32.and\nlocal.set 100\nlocal.get 3\nlocal.get 100\ni32.store8 offset=15\nbr 1 (;@1;)\nend\ni32.const 1\nlocal.set 101\ni32.const 1\nlocal.set 102\nlocal.get 101\nlocal.get 102\ni32.and\nlocal.set 103\nlocal.get 3\nlocal.get 103\ni32.store8 offset=15\nend\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 104\ni32.const 1\nlocal.set 105\nlocal.get 104\nlocal.get 105\ni32.and\nlocal.set 106\nlocal.get 106\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_270",
        "query_text": "The function takes no input parameters and returns a boolean value indicating the support status of a specific mapping feature. It determines the availability based on whether a particular preprocessor directive is defined; if the directive is present, the function returns false, indicating that the mapping feature is disabled, otherwise, it returns true, signifying that the feature is enabled.",
        "code_id": "c_group_1_id_270",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32)\ni32.const 1\nlocal.set 0\ni32.const 1\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.and\nlocal.set 2\nlocal.get 2\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_271",
        "query_text": "The function takes two floating-point numbers as input. It compares the second input value with the first input value, treated as an edge threshold. If the second value is less than the edge, it returns 0.0; otherwise, it returns 1.0. Essentially, the function implements a step function that produces a binary output (0.0 or 1.0) based on whether the provided value is below or above the specified edge.",
        "code_id": "c_group_1_id_271",
        "code_text": "(func (;1;) (type 2) (param f32 f32) (result f32)\n(local i32 i32 i32 i32 i32 i32 i32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\nf32.store offset=12\nlocal.get 4\nlocal.get 1\nf32.store offset=8\nlocal.get 4\nf32.load offset=8\nlocal.set 9\nlocal.get 4\nf32.load offset=12\nlocal.set 10\nlocal.get 9\nlocal.get 10\nf32.lt\nlocal.set 5\ni32.const 0\nlocal.set 6\nlocal.get 6\nf32.convert_i32_s\nlocal.set 11\nf32.const 0x1p+0 (;=1;)\nlocal.set 12\ni32.const 1\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.and\nlocal.set 8\nlocal.get 11\nlocal.get 12\nlocal.get 8\nselect\nlocal.set 13\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_273",
        "query_text": "The function accepts five floating-point arguments: one representing a scalar interpolation parameter and four representing control values that influence the smooth curve's behavior. Inside, it uses basic arithmetic operations\u2014such as multiplication and addition\u2014to compute several intermediate values. These computed values are then combined using a specific mathematical formula to perform the interpolation. The final result is a single floating-point value that represents the interpolated output. The function performs all calculations internally without relying on external dependencies, and its operation is fully deterministic, ensuring that identical inputs will always produce the same result.",
        "code_id": "c_group_1_id_273",
        "code_text": "(func (;1;) (type 2) (param f32 f32 f32 f32 f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 5\ni32.const 48\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.sub\nlocal.set 7\nlocal.get 7\nlocal.get 0\nf32.store offset=44\nlocal.get 7\nlocal.get 1\nf32.store offset=40\nlocal.get 7\nlocal.get 2\nf32.store offset=36\nlocal.get 7\nlocal.get 3\nf32.store offset=32\nlocal.get 7\nlocal.get 4\nf32.store offset=28\nlocal.get 7\nf32.load offset=44\nlocal.set 8\nlocal.get 7\nf32.load offset=44\nlocal.set 9\nlocal.get 8\nlocal.get 9\nf32.mul\nlocal.set 10\nlocal.get 7\nlocal.get 10\nf32.store offset=24\nlocal.get 7\nf32.load offset=24\nlocal.set 11\nlocal.get 7\nf32.load offset=24\nlocal.set 12\nlocal.get 11\nlocal.get 12\nf32.add\nlocal.set 13\nlocal.get 7\nlocal.get 13\nf32.store offset=16\nlocal.get 7\nf32.load offset=16\nlocal.set 14\nlocal.get 7\nf32.load offset=24\nlocal.set 15\nlocal.get 14\nlocal.get 15\nf32.add\nlocal.set 16\nlocal.get 7\nlocal.get 16\nf32.store offset=8\nlocal.get 7\nf32.load offset=16\nlocal.set 17\nlocal.get 7\nf32.load offset=44\nlocal.set 18\nlocal.get 17\nlocal.get 18\nf32.mul\nlocal.set 19\nlocal.get 7\nlocal.get 19\nf32.store offset=12\nlocal.get 7\nf32.load offset=44\nlocal.set 20\nlocal.get 7\nf32.load offset=24\nlocal.set 21\nlocal.get 20\nlocal.get 21\nf32.mul\nlocal.set 22\nlocal.get 7\nlocal.get 22\nf32.store offset=20\nlocal.get 7\nf32.load offset=20\nlocal.set 23\nlocal.get 7\nf32.load offset=24\nlocal.set 24\nlocal.get 23\nlocal.get 24\nf32.sub\nlocal.set 25\nlocal.get 7\nlocal.get 25\nf32.store\nlocal.get 7\nf32.load offset=12\nlocal.set 26\nlocal.get 7\nf32.load offset=8\nlocal.set 27\nlocal.get 26\nlocal.get 27\nf32.sub\nlocal.set 28\nlocal.get 7\nlocal.get 28\nf32.store offset=4\nlocal.get 7\nf32.load offset=40\nlocal.set 29\nlocal.get 7\nf32.load offset=4\nlocal.set 30\nf32.const 0x1p+0 (;=1;)\nlocal.set 31\nlocal.get 30\nlocal.get 31\nf32.add\nlocal.set 32\nlocal.get 7\nf32.load offset=36\nlocal.set 33\nlocal.get 7\nf32.load\nlocal.set 34\nlocal.get 7\nf32.load offset=24\nlocal.set 35\nlocal.get 34\nlocal.get 35\nf32.sub\nlocal.set 36\nlocal.get 7\nf32.load offset=44\nlocal.set 37\nlocal.get 36\nlocal.get 37\nf32.add\nlocal.set 38\nlocal.get 33\nlocal.get 38\nf32.mul\nlocal.set 39\nlocal.get 29\nlocal.get 32\nf32.mul\nlocal.set 40\nlocal.get 40\nlocal.get 39\nf32.add\nlocal.set 41\nlocal.get 7\nf32.load offset=32\nlocal.set 42\nlocal.get 7\nf32.load\nlocal.set 43\nlocal.get 42\nlocal.get 43\nf32.mul\nlocal.set 44\nlocal.get 44\nlocal.get 41\nf32.add\nlocal.set 45\nlocal.get 7\nf32.load offset=28\nlocal.set 46\nlocal.get 7\nf32.load offset=4\nlocal.set 47\nlocal.get 46\nf32.neg\nlocal.set 48\nlocal.get 48\nlocal.get 47\nf32.mul\nlocal.set 49\nlocal.get 49\nlocal.get 45\nf32.add\nlocal.set 50\nlocal.get 50\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_274",
        "query_text": "The function takes three inputs: a pointer to a wide-character string, a wide-character separator, and a count of type size_t. It first verifies that the input string is not null and immediately returns the original string if the count is zero. If the count is non-zero, it searches for the first occurrence of the separator in the string. The function then iterates to locate the subsequent occurrences until it finds the nth occurrence. If the nth occurrence is found, it returns a pointer to the character immediately following that occurrence; otherwise, if any occurrence is missing or the string is empty, the function returns a null pointer.",
        "code_id": "c_group_1_id_274",
        "code_text": "(func (;1;) (type 3) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=8\nlocal.get 5\nlocal.get 1\ni32.store offset=4\nlocal.get 5\nlocal.get 2\ni32.store\nlocal.get 5\ni32.load offset=8\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.eq\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 10\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 11\nlocal.get 5\nlocal.get 11\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 5\ni32.load\nlocal.set 12\nblock  ;; label = @2\nlocal.get 12\nbr_if 0 (;@2;)\nlocal.get 5\ni32.load offset=8\nlocal.set 13\nlocal.get 5\nlocal.get 13\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 5\ni32.load offset=8\nlocal.set 14\nlocal.get 5\ni32.load offset=4\nlocal.set 15\nlocal.get 14\nlocal.get 15\ncall 2\nlocal.set 16\nlocal.get 5\nlocal.get 16\ni32.store offset=8\nlocal.get 5\ni32.load\nlocal.set 17\ni32.const -1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 5\nlocal.get 19\ni32.store\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 5\ni32.load\nlocal.set 20\ni32.const 0\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.gt_u\nlocal.set 22\ni32.const 1\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.and\nlocal.set 24\nlocal.get 24\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 5\ni32.load offset=8\nlocal.set 25\ni32.const 0\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.eq\nlocal.set 27\ni32.const 1\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.and\nlocal.set 29\nblock  ;; label = @4\nlocal.get 29\ni32.eqz\nbr_if 0 (;@4;)\ni32.const 0\nlocal.set 30\nlocal.get 5\nlocal.get 30\ni32.store offset=12\nbr 3 (;@1;)\nend\nlocal.get 5\ni32.load\nlocal.set 31\ni32.const -1\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.add\nlocal.set 33\nlocal.get 5\nlocal.get 33\ni32.store\nlocal.get 5\ni32.load offset=8\nlocal.set 34\ni32.const 4\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 5\nlocal.get 36\ni32.store offset=8\nlocal.get 5\ni32.load offset=8\nlocal.set 37\nlocal.get 5\ni32.load offset=4\nlocal.set 38\nlocal.get 37\nlocal.get 38\ncall 2\nlocal.set 39\nlocal.get 5\nlocal.get 39\ni32.store offset=8\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 5\ni32.load offset=8\nlocal.set 40\ni32.const 0\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.ne\nlocal.set 42\ni32.const 1\nlocal.set 43\nlocal.get 42\nlocal.get 43\ni32.and\nlocal.set 44\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 44\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load offset=8\nlocal.set 45\ni32.const 4\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.add\nlocal.set 47\nlocal.get 47\nlocal.set 48\nbr 1 (;@2;)\nend\ni32.const 0\nlocal.set 49\nlocal.get 49\nlocal.set 48\nend\nlocal.get 48\nlocal.set 50\nlocal.get 5\nlocal.get 50\ni32.store offset=12\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 51\ni32.const 16\nlocal.set 52\nlocal.get 5\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\nglobal.set 0\nlocal.get 51\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_275",
        "query_text": "The function takes a single input: a floating-point value that typically represents a normalized time or progress value between 0 and 1. It then computes and returns a floating-point output by evaluating the input against a series of four distinct intervals. For each interval, a different mathematical expression is applied\u2014beginning with the calculation of the input\u2019s square\u2014resulting in a smooth, non-linear transformation. This piecewise computation generates what is known as a \"bounce-out\" easing effect, which is commonly used in animations to simulate a deceleration with a bouncing motion as the transition nears completion.",
        "code_id": "c_group_1_id_275",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 13\nlocal.get 3\nf32.load offset=8\nlocal.set 14\nlocal.get 13\nlocal.get 14\nf32.mul\nlocal.set 15\nlocal.get 3\nlocal.get 15\nf32.store offset=4\nlocal.get 3\nf32.load offset=8\nlocal.set 16\nf32.const 0x1.745d18p-2 (;=0.363636;)\nlocal.set 17\nlocal.get 16\nlocal.get 17\nf32.lt\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 6\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\nf32.load offset=4\nlocal.set 18\nf32.const 0x1.e4p+6 (;=121;)\nlocal.set 19\nlocal.get 19\nlocal.get 18\nf32.mul\nlocal.set 20\nf32.const 0x1p+4 (;=16;)\nlocal.set 21\nlocal.get 20\nlocal.get 21\nf32.div\nlocal.set 22\nlocal.get 3\nlocal.get 22\nf32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\nf32.load offset=8\nlocal.set 23\nf32.const 0x1.745d18p-1 (;=0.727273;)\nlocal.set 24\nlocal.get 23\nlocal.get 24\nf32.lt\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\nf32.load offset=4\nlocal.set 25\nlocal.get 3\nf32.load offset=8\nlocal.set 26\nf32.const 0x1.3cccccp+3 (;=9.9;)\nlocal.set 27\nlocal.get 27\nlocal.get 26\nf32.mul\nlocal.set 28\nlocal.get 28\nf32.neg\nlocal.set 29\nf32.const 0x1.226666p+3 (;=9.075;)\nlocal.set 30\nlocal.get 25\nlocal.get 30\nf32.mul\nlocal.set 31\nlocal.get 31\nlocal.get 29\nf32.add\nlocal.set 32\nf32.const 0x1.b33334p+1 (;=3.4;)\nlocal.set 33\nlocal.get 32\nlocal.get 33\nf32.add\nlocal.set 34\nlocal.get 3\nlocal.get 34\nf32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\nf32.load offset=8\nlocal.set 35\nf32.const 0x1.ccccccp-1 (;=0.9;)\nlocal.set 36\nlocal.get 35\nlocal.get 36\nf32.lt\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nblock  ;; label = @2\nlocal.get 12\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\nf32.load offset=4\nlocal.set 37\nlocal.get 3\nf32.load offset=8\nlocal.set 38\nf32.const 0x1.3a2ad6p+4 (;=19.6355;)\nlocal.set 39\nlocal.get 39\nlocal.get 38\nf32.mul\nlocal.set 40\nlocal.get 40\nf32.neg\nlocal.set 41\nf32.const 0x1.82209ep+3 (;=12.0665;)\nlocal.set 42\nlocal.get 37\nlocal.get 42\nf32.mul\nlocal.set 43\nlocal.get 43\nlocal.get 41\nf32.add\nlocal.set 44\nf32.const 0x1.1cbceap+3 (;=8.89806;)\nlocal.set 45\nlocal.get 44\nlocal.get 45\nf32.add\nlocal.set 46\nlocal.get 3\nlocal.get 46\nf32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\nf32.load offset=4\nlocal.set 47\nlocal.get 3\nf32.load offset=8\nlocal.set 48\nf32.const 0x1.4851ecp+4 (;=20.52;)\nlocal.set 49\nlocal.get 49\nlocal.get 48\nf32.mul\nlocal.set 50\nlocal.get 50\nf32.neg\nlocal.set 51\nf32.const 0x1.59999ap+3 (;=10.8;)\nlocal.set 52\nlocal.get 47\nlocal.get 52\nf32.mul\nlocal.set 53\nlocal.get 53\nlocal.get 51\nf32.add\nlocal.set 54\nf32.const 0x1.570a3ep+3 (;=10.72;)\nlocal.set 55\nlocal.get 54\nlocal.get 55\nf32.add\nlocal.set 56\nlocal.get 3\nlocal.get 56\nf32.store offset=12\nend\nlocal.get 3\nf32.load offset=12\nlocal.set 57\nlocal.get 57\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_276",
        "query_text": "The function computes the Root Mean Square (RMS) error between two arrays of double-precision floating-point numbers. It takes as input two arrays and an integer representing the number of elements in the arrays. The function iterates over the elements, calculates the squared difference between each pair of corresponding elements, and accumulates these values. It then divides the total by one less than the number of elements before taking the square root of the result. The output is a double-precision floating-point number representing the RMS error.",
        "code_id": "c_group_1_id_276",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\ni32.const 0\nlocal.set 6\nlocal.get 6\nf64.convert_i32_s\nlocal.set 37\nlocal.get 5\nlocal.get 37\nf64.store offset=8\ni32.const 0\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store offset=16\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=16\nlocal.set 8\nlocal.get 5\ni32.load offset=20\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=28\nlocal.set 13\nlocal.get 5\ni32.load offset=16\nlocal.set 14\ni32.const 3\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 13\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nf64.load\nlocal.set 38\nlocal.get 5\ni32.load offset=24\nlocal.set 18\nlocal.get 5\ni32.load offset=16\nlocal.set 19\ni32.const 3\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 18\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 22\nf64.load\nlocal.set 39\nlocal.get 38\nlocal.get 39\nf64.sub\nlocal.set 40\nlocal.get 5\ni32.load offset=28\nlocal.set 23\nlocal.get 5\ni32.load offset=16\nlocal.set 24\ni32.const 3\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.shl\nlocal.set 26\nlocal.get 23\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\nf64.load\nlocal.set 41\nlocal.get 5\ni32.load offset=24\nlocal.set 28\nlocal.get 5\ni32.load offset=16\nlocal.set 29\ni32.const 3\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.shl\nlocal.set 31\nlocal.get 28\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 32\nf64.load\nlocal.set 42\nlocal.get 41\nlocal.get 42\nf64.sub\nlocal.set 43\nlocal.get 5\nf64.load offset=8\nlocal.set 44\nlocal.get 40\nlocal.get 43\nf64.mul\nlocal.set 45\nlocal.get 45\nlocal.get 44\nf64.add\nlocal.set 46\nlocal.get 5\nlocal.get 46\nf64.store offset=8\nlocal.get 5\ni32.load offset=16\nlocal.set 33\ni32.const 1\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 5\nlocal.get 35\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 5\nf64.load offset=8\nlocal.set 47\nlocal.get 5\ni32.load offset=20\nlocal.set 36\nlocal.get 36\nf64.convert_i32_s\nlocal.set 48\nf64.const 0x1p+0 (;=1;)\nlocal.set 49\nlocal.get 48\nlocal.get 49\nf64.sub\nlocal.set 50\nlocal.get 47\nlocal.get 50\nf64.div\nlocal.set 51\nlocal.get 51\nf64.sqrt\nlocal.set 52\nlocal.get 52\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_277",
        "query_text": "The function takes two inputs: a pointer to a constant character string, and a pointer to a pointer to a constant character string. It checks whether the target string starts with the given prefix by comparing the beginning of the target string with the prefix. If the target string starts with the prefix, it advances the pointer to the target string by the length of the prefix and returns true; if not, it leaves the pointer unchanged and returns false. The input types are a pointer to a constant char and a pointer to a pointer to a constant char, and the output is of type bool.",
        "code_id": "c_group_1_id_277",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 5\nlocal.get 5\ncall 3\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store\nlocal.get 4\ni32.load offset=4\nlocal.set 7\nlocal.get 7\ni32.load\nlocal.set 8\nlocal.get 4\ni32.load offset=8\nlocal.set 9\nlocal.get 4\ni32.load\nlocal.set 10\nlocal.get 8\nlocal.get 9\nlocal.get 10\ncall 4\nlocal.set 11\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 11\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load\nlocal.set 12\nlocal.get 4\ni32.load offset=4\nlocal.set 13\nlocal.get 13\ni32.load\nlocal.set 14\nlocal.get 14\nlocal.get 12\ni32.add\nlocal.set 15\nlocal.get 13\nlocal.get 15\ni32.store\ni32.const 1\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 4\nlocal.get 18\ni32.store8 offset=15\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 19\ni32.const 1\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.and\nlocal.set 21\nlocal.get 4\nlocal.get 21\ni32.store8 offset=15\nend\nlocal.get 4\ni32.load8_u offset=15\nlocal.set 22\ni32.const 1\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.and\nlocal.set 24\ni32.const 16\nlocal.set 25\nlocal.get 4\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 26\nglobal.set 0\nlocal.get 24\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_278",
        "query_text": "The function accepts three parameters: an unsigned long integer, an unsigned char indicating the number of leading bits, and an unsigned char serving as a right shift amount. It first creates a header by computing a bit pattern where the specified number of highest-order bits are set. Then, it constructs a mask by right-shifting a full 8-bit value to leave room for the header. After shifting the integer by the provided amount and applying the mask to isolate the relevant bits, it combines these results using a bitwise OR operation. The final output is a char value that encodes the adjusted data based on the header and masked portion.",
        "code_id": "c_group_1_id_278",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store8 offset=11\nlocal.get 5\nlocal.get 2\ni32.store8 offset=10\nlocal.get 5\ni32.load8_u offset=11\nlocal.set 6\ni32.const 255\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 9\nlocal.get 8\ni32.shl\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.sub\nlocal.set 12\nlocal.get 5\ni32.load8_u offset=11\nlocal.set 13\ni32.const 255\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\ni32.const 8\nlocal.set 16\nlocal.get 16\nlocal.get 15\ni32.sub\nlocal.set 17\nlocal.get 12\nlocal.get 17\ni32.shl\nlocal.set 18\nlocal.get 5\nlocal.get 18\ni32.store8 offset=9\nlocal.get 5\ni32.load8_u offset=11\nlocal.set 19\ni32.const 255\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.and\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.add\nlocal.set 23\ni32.const 255\nlocal.set 24\nlocal.get 24\nlocal.get 23\ni32.shr_s\nlocal.set 25\nlocal.get 5\nlocal.get 25\ni32.store8 offset=8\nlocal.get 5\ni32.load8_u offset=9\nlocal.set 26\ni32.const 255\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.and\nlocal.set 28\nlocal.get 5\ni32.load offset=12\nlocal.set 29\nlocal.get 5\ni32.load8_u offset=10\nlocal.set 30\ni32.const 255\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nlocal.get 29\nlocal.get 32\ni32.shr_u\nlocal.set 33\nlocal.get 5\ni32.load8_u offset=8\nlocal.set 34\ni32.const 255\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.and\nlocal.set 36\nlocal.get 33\nlocal.get 36\ni32.and\nlocal.set 37\nlocal.get 28\nlocal.get 37\ni32.or\nlocal.set 38\ni32.const 24\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.shl\nlocal.set 40\nlocal.get 40\nlocal.get 39\ni32.shr_s\nlocal.set 41\nlocal.get 41\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_279",
        "query_text": "The function receives three inputs: an array of string pointers (with each string represented by an array of unsigned characters), an integer specifying the count of strings in the array, and another integer that indicates the starting offset within each string for comparisons. It performs an in-place ascending order sort on the array using an insertion sort algorithm. The comparison process begins at the provided offset for each string and continues character by character until a discrepancy is detected or the end of a string is reached. This function does not return any value since it modifies the input array directly.",
        "code_id": "c_group_1_id_279",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\nlocal.get 5\ni32.load offset=28\nlocal.set 6\ni32.const 4\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.store offset=16\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=24\nlocal.set 9\ni32.const -1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 5\nlocal.get 11\ni32.store offset=24\ni32.const 0\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.gt_s\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=16\nlocal.set 16\nlocal.get 5\nlocal.get 16\ni32.store offset=12\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 5\ni32.load offset=12\nlocal.set 17\nlocal.get 5\ni32.load offset=28\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.gt_u\nlocal.set 19\ni32.const 1\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.and\nlocal.set 21\nlocal.get 21\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 5\ni32.load offset=12\nlocal.set 22\ni32.const -4\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\ni32.load\nlocal.set 25\nlocal.get 5\ni32.load offset=20\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 5\nlocal.get 27\ni32.store offset=8\nlocal.get 5\ni32.load offset=12\nlocal.set 28\nlocal.get 28\ni32.load\nlocal.set 29\nlocal.get 5\ni32.load offset=20\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 5\nlocal.get 31\ni32.store offset=4\nloop  ;; label = @5\nlocal.get 5\ni32.load offset=8\nlocal.set 32\nlocal.get 32\ni32.load8_u\nlocal.set 33\ni32.const 255\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.and\nlocal.set 35\nlocal.get 5\ni32.load offset=4\nlocal.set 36\nlocal.get 36\ni32.load8_u\nlocal.set 37\ni32.const 255\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.and\nlocal.set 39\nlocal.get 35\nlocal.get 39\ni32.eq\nlocal.set 40\ni32.const 0\nlocal.set 41\ni32.const 1\nlocal.set 42\nlocal.get 40\nlocal.get 42\ni32.and\nlocal.set 43\nlocal.get 41\nlocal.set 44\nblock  ;; label = @6\nlocal.get 43\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 5\ni32.load offset=8\nlocal.set 45\nlocal.get 45\ni32.load8_u\nlocal.set 46\ni32.const 255\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.and\nlocal.set 48\ni32.const 0\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.ne\nlocal.set 50\nlocal.get 50\nlocal.set 44\nend\nlocal.get 44\nlocal.set 51\ni32.const 1\nlocal.set 52\nlocal.get 51\nlocal.get 52\ni32.and\nlocal.set 53\nblock  ;; label = @6\nlocal.get 53\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 5\ni32.load offset=8\nlocal.set 54\ni32.const 1\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.add\nlocal.set 56\nlocal.get 5\nlocal.get 56\ni32.store offset=8\nlocal.get 5\ni32.load offset=4\nlocal.set 57\ni32.const 1\nlocal.set 58\nlocal.get 57\nlocal.get 58\ni32.add\nlocal.set 59\nlocal.get 5\nlocal.get 59\ni32.store offset=4\nbr 1 (;@5;)\nend\nend\nlocal.get 5\ni32.load offset=8\nlocal.set 60\nlocal.get 60\ni32.load8_u\nlocal.set 61\ni32.const 255\nlocal.set 62\nlocal.get 61\nlocal.get 62\ni32.and\nlocal.set 63\nlocal.get 5\ni32.load offset=4\nlocal.set 64\nlocal.get 64\ni32.load8_u\nlocal.set 65\ni32.const 255\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.and\nlocal.set 67\nlocal.get 63\nlocal.get 67\ni32.le_s\nlocal.set 68\ni32.const 1\nlocal.set 69\nlocal.get 68\nlocal.get 69\ni32.and\nlocal.set 70\nblock  ;; label = @5\nlocal.get 70\ni32.eqz\nbr_if 0 (;@5;)\nbr 2 (;@3;)\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 71\nlocal.get 71\ni32.load\nlocal.set 72\nlocal.get 5\nlocal.get 72\ni32.store offset=4\nlocal.get 5\ni32.load offset=12\nlocal.set 73\ni32.const -4\nlocal.set 74\nlocal.get 73\nlocal.get 74\ni32.add\nlocal.set 75\nlocal.get 75\ni32.load\nlocal.set 76\nlocal.get 5\ni32.load offset=12\nlocal.set 77\nlocal.get 77\nlocal.get 76\ni32.store\nlocal.get 5\ni32.load offset=4\nlocal.set 78\nlocal.get 5\ni32.load offset=12\nlocal.set 79\ni32.const -4\nlocal.set 80\nlocal.get 79\nlocal.get 80\ni32.add\nlocal.set 81\nlocal.get 81\nlocal.get 78\ni32.store\nlocal.get 5\ni32.load offset=12\nlocal.set 82\ni32.const -4\nlocal.set 83\nlocal.get 82\nlocal.get 83\ni32.add\nlocal.set 84\nlocal.get 5\nlocal.get 84\ni32.store offset=12\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 5\ni32.load offset=16\nlocal.set 85\ni32.const 4\nlocal.set 86\nlocal.get 85\nlocal.get 86\ni32.add\nlocal.set 87\nlocal.get 5\nlocal.get 87\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_280",
        "query_text": "The function takes a single input\u2014a pointer to a character array representing the program's name or path. It first extracts only the program name by removing any preceding directory path components if a '/' is present. Next, it prints a formatted message that details how to run the program, showing two examples: one for executing a single throughput test and another for running multiple tests (indicating the best result among them). Finally, the function terminates the program with an exit status of 0. The input is of type \"const char *\", and the function does not return any value (void).",
        "code_id": "c_group_1_id_280",
        "code_text": "(func (;3;) (type 2) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 47\nlocal.set 5\nlocal.get 4\nlocal.get 5\ncall 4\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.store offset=8\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nblock  ;; label = @1\nlocal.get 10\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 12\nlocal.get 3\ni32.load offset=12\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.store offset=4\nlocal.get 3\nlocal.get 12\ni32.store\ni32.const 65590\nlocal.set 14\nlocal.get 14\nlocal.get 3\ncall 10\ndrop\ni32.const 0\nlocal.set 15\nlocal.get 15\ncall 8\nunreachable)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_281",
        "query_text": "The function accepts three floating-point inputs. The first two inputs define a range, while the third represents a value within or beyond this range. The function determines the relative position of the third value between the two endpoints. It starts by calculating the difference between the second and first values. If this difference is zero, meaning the range is degenerate, the function returns 1.0 to indicate that the third value is considered at the end of the range. Otherwise, it computes the ratio of the difference between the third value and the first value to that overall range, effectively expressing the position as a percentage. The function then returns this computed ratio as the output.",
        "code_id": "c_group_1_id_281",
        "code_text": "(func (;1;) (type 2) (param f32 f32 f32) (result f32)\n(local i32 i32 i32 i32 i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\nf32.store offset=24\nlocal.get 5\nlocal.get 1\nf32.store offset=20\nlocal.get 5\nlocal.get 2\nf32.store offset=16\nlocal.get 5\nf32.load offset=20\nlocal.set 10\nlocal.get 5\nf32.load offset=24\nlocal.set 11\nlocal.get 10\nlocal.get 11\nf32.sub\nlocal.set 12\nlocal.get 5\nlocal.get 12\nf32.store offset=12\ni32.const 0\nlocal.set 6\nlocal.get 6\nf32.convert_i32_s\nlocal.set 13\nlocal.get 12\nlocal.get 13\nf32.eq\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nf32.const 0x1p+0 (;=1;)\nlocal.set 14\nlocal.get 5\nlocal.get 14\nf32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 5\nf32.load offset=16\nlocal.set 15\nlocal.get 5\nf32.load offset=24\nlocal.set 16\nlocal.get 15\nlocal.get 16\nf32.sub\nlocal.set 17\nlocal.get 5\nf32.load offset=12\nlocal.set 18\nlocal.get 17\nlocal.get 18\nf32.div\nlocal.set 19\nlocal.get 5\nlocal.get 19\nf32.store offset=28\nend\nlocal.get 5\nf32.load offset=28\nlocal.set 20\nlocal.get 20\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_282",
        "query_text": "The function accepts two parameters: a pointer to an array of floating-point numbers and an integer representing the number of elements in the array. It processes the array by swapping elements from opposite ends, starting with the first and last elements, gradually moving towards the center. This approach results in the entire array being reversed in place, meaning the original array is directly modified. The function does not return any value.",
        "code_id": "c_group_1_id_282",
        "code_text": "(func (;1;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f32 f32 f32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.sub\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=16\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=20\nlocal.set 9\nlocal.get 4\ni32.load offset=16\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.lt_s\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 13\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=28\nlocal.set 14\nlocal.get 4\ni32.load offset=20\nlocal.set 15\ni32.const 2\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.shl\nlocal.set 17\nlocal.get 14\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 18\nf32.load\nlocal.set 40\nlocal.get 4\nlocal.get 40\nf32.store offset=12\nlocal.get 4\ni32.load offset=28\nlocal.set 19\nlocal.get 4\ni32.load offset=16\nlocal.set 20\ni32.const 2\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.shl\nlocal.set 22\nlocal.get 19\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 23\nf32.load\nlocal.set 41\nlocal.get 4\ni32.load offset=28\nlocal.set 24\nlocal.get 4\ni32.load offset=20\nlocal.set 25\ni32.const 2\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.shl\nlocal.set 27\nlocal.get 24\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 28\nlocal.get 41\nf32.store\nlocal.get 4\nf32.load offset=12\nlocal.set 42\nlocal.get 4\ni32.load offset=28\nlocal.set 29\nlocal.get 4\ni32.load offset=16\nlocal.set 30\ni32.const 2\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.shl\nlocal.set 32\nlocal.get 29\nlocal.get 32\ni32.add\nlocal.set 33\nlocal.get 33\nlocal.get 42\nf32.store\nlocal.get 4\ni32.load offset=20\nlocal.set 34\ni32.const 1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 4\nlocal.get 36\ni32.store offset=20\nlocal.get 4\ni32.load offset=16\nlocal.set 37\ni32.const -1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 4\nlocal.get 39\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_283",
        "query_text": "This function is responsible for handling critical errors within a program. It accepts a single input\u2014a constant character pointer representing an error message. If the message is non-null, the function writes the message to the standard error stream with a fixed error prefix. Immediately after outputting the error message, the function terminates the program by calling for an exit with a failure status. The design of this function uses a non-returning attribute, indicating that it does not return any value and that its execution forces program termination.",
        "code_id": "c_group_1_id_283",
        "code_text": "(func (;5;) (type 2) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 0\nlocal.set 4\nlocal.get 4\ni32.load offset=65612\nlocal.set 5\nlocal.get 3\ni32.load offset=12\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.store\ni32.const 65590\nlocal.set 7\nlocal.get 5\nlocal.get 7\nlocal.get 3\ncall 11\ndrop\ni32.const 1\nlocal.set 8\nlocal.get 8\ncall 9\nunreachable)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_284",
        "query_text": "This function determines the length of a wide-character string by counting its characters until the null terminator is reached. It validates that the input pointer (of type const wide-character string pointer) is not null using an assertion. Depending on a compile-time flag, it either employs a standard library function to obtain the length or iterates manually through the string. The computed length, excluding the null termiantor, is returned as a value of type size_t.",
        "code_id": "c_group_1_id_284",
        "code_text": "(func (;5;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.ne\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 8\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 65565\nlocal.set 9\ni32.const 65567\nlocal.set 10\ni32.const 19\nlocal.set 11\ni32.const 65670\nlocal.set 12\nlocal.get 9\nlocal.get 10\nlocal.get 11\nlocal.get 12\ncall 7\nunreachable\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.store offset=8\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 14\nlocal.get 14\ni32.load\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 16\ni32.const 4\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 3\nlocal.get 18\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 19\nlocal.get 3\ni32.load offset=12\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.sub\nlocal.set 21\ni32.const 2\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.shr_s\nlocal.set 23\ni32.const 16\nlocal.set 24\nlocal.get 3\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\nglobal.set 0\nlocal.get 23\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_285",
        "query_text": "The function takes no input arguments and does not return any value. It outputs a series of formatted messages to the console that provide usage instructions for a unit testing program. Specifically, it prints details on available command-line options, including displaying help information, listing available tests, running specific tests by either number or name, and specifying a file for cipher suite testing. This information serves as guidance on how to operate the unit testing tool.",
        "code_id": "c_group_1_id_285",
        "code_text": "(func (;2;) (type 2)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\ni32.const 65590\nlocal.set 0\ni32.const 0\nlocal.set 1\nlocal.get 0\nlocal.get 1\ncall 12\ndrop\ni32.const 0\nlocal.set 2\nlocal.get 2\ni32.load offset=65968\nlocal.set 3\nlocal.get 3\ncall 6\ndrop\ni32.const 65810\nlocal.set 4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ncall 12\ndrop\ni32.const 0\nlocal.set 6\nlocal.get 6\ni32.load offset=65968\nlocal.set 7\nlocal.get 7\ncall 6\ndrop\ni32.const 65667\nlocal.set 8\ni32.const 0\nlocal.set 9\nlocal.get 8\nlocal.get 9\ncall 12\ndrop\ni32.const 0\nlocal.set 10\nlocal.get 10\ni32.load offset=65968\nlocal.set 11\nlocal.get 11\ncall 6\ndrop\ni32.const 65626\nlocal.set 12\ni32.const 0\nlocal.set 13\nlocal.get 12\nlocal.get 13\ncall 12\ndrop\ni32.const 0\nlocal.set 14\nlocal.get 14\ni32.load offset=65968\nlocal.set 15\nlocal.get 15\ncall 6\ndrop\ni32.const 65754\nlocal.set 16\ni32.const 0\nlocal.set 17\nlocal.get 16\nlocal.get 17\ncall 12\ndrop\ni32.const 0\nlocal.set 18\nlocal.get 18\ni32.load offset=65968\nlocal.set 19\nlocal.get 19\ncall 6\ndrop\ni32.const 65704\nlocal.set 20\ni32.const 0\nlocal.set 21\nlocal.get 20\nlocal.get 21\ncall 12\ndrop\ni32.const 0\nlocal.set 22\nlocal.get 22\ni32.load offset=65968\nlocal.set 23\nlocal.get 23\ncall 6\ndrop\ni32.const 65859\nlocal.set 24\ni32.const 0\nlocal.set 25\nlocal.get 24\nlocal.get 25\ncall 12\ndrop\ni32.const 0\nlocal.set 26\nlocal.get 26\ni32.load offset=65968\nlocal.set 27\nlocal.get 27\ncall 6\ndrop\ni32.const 65704\nlocal.set 28\ni32.const 0\nlocal.set 29\nlocal.get 28\nlocal.get 29\ncall 12\ndrop\ni32.const 0\nlocal.set 30\nlocal.get 30\ni32.load offset=65968\nlocal.set 31\nlocal.get 31\ncall 6\ndrop\ni32.const 65913\nlocal.set 32\ni32.const 0\nlocal.set 33\nlocal.get 32\nlocal.get 33\ncall 12\ndrop\ni32.const 0\nlocal.set 34\nlocal.get 34\ni32.load offset=65968\nlocal.set 35\nlocal.get 35\ncall 6\ndrop\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_287",
        "query_text": "The function takes no parameters and returns a std::string representing the temporary directory path, determined based on the operating system and environment. It first checks if a custom temporary directory function is defined via a specific macro; if so, it returns the result of that function. On Windows Mobile, it directly returns a hard-coded directory path (\"\\\\temp\\\\\"). For Windows systems, it retrieves an environment variable; if the variable is either unset or empty, it defaults to the same hard-coded path, and if it exists but lacks a trailing backslash, it appends one before returning. On Android, it returns a predefined path (\"/sdcard/\"), while for other systems such as Linux or Unix-like environments, it defaults to returning \"/tmp/\".",
        "code_id": "c_group_1_id_287",
        "code_text": "(func (;2;) (type 6) (param i32)\n(local i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 65549\nlocal.set 4\nlocal.get 0\nlocal.get 4\ncall 3\ndrop\ni32.const 16\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_288",
        "query_text": "The function takes an integer as input, representing a signature algorithm identifier, and returns an integer indicating whether this algorithm is supported. It checks the input against a set of supported algorithms, which are conditionally included based on compile-time flags. If the input matches any one of these supported algorithms, the function returns 1; otherwise, it returns 0. The input is of type int and the output is also an int.",
        "code_id": "c_group_1_id_288",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 5\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_289",
        "query_text": "The function accepts a pointer to a double as its input and returns a value of type const char*. Its primary objective is to select and return the appropriate unit of measurement (for example, \"GiB\", \"MiB\", \"KiB\", or \"bytes\") based on the value pointed to by the input. Additionally, the function scales the numeric value in place by dividing it by the corresponding factor for the selected unit. In configurations where fixed units are specified via preprocessor directives, the function uses the predetermined unit and scaling factor. If no fixed unit is configured, it dynamically determines the unit based on whether the value exceeds certain thresholds (for instance, greater than 1024 or 1024\u00d71024), applying the corresponding division and returning the related unit string.",
        "code_id": "c_group_1_id_289",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nf64.load\nlocal.set 18\nf64.const 0x1p+20 (;=1.04858e+06;)\nlocal.set 19\nlocal.get 18\nlocal.get 19\nf64.gt\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 7\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=12\nlocal.set 8\nlocal.get 8\nf64.load\nlocal.set 20\nf64.const 0x1p+20 (;=1.04858e+06;)\nlocal.set 21\nlocal.get 20\nlocal.get 21\nf64.div\nlocal.set 22\nlocal.get 8\nlocal.get 22\nf64.store\ni32.const 65542\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=8\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 10\nlocal.get 10\nf64.load\nlocal.set 23\nf64.const 0x1p+10 (;=1024;)\nlocal.set 24\nlocal.get 23\nlocal.get 24\nf64.gt\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 13\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load offset=12\nlocal.set 14\nlocal.get 14\nf64.load\nlocal.set 25\nf64.const 0x1p+10 (;=1024;)\nlocal.set 26\nlocal.get 25\nlocal.get 26\nf64.div\nlocal.set 27\nlocal.get 14\nlocal.get 27\nf64.store\ni32.const 65546\nlocal.set 15\nlocal.get 3\nlocal.get 15\ni32.store offset=8\nbr 1 (;@2;)\nend\ni32.const 65536\nlocal.set 16\nlocal.get 3\nlocal.get 16\ni32.store offset=8\nend\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 17\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_291",
        "query_text": "The function takes no input arguments and returns a constant string representing the version information of a specific library. The output is of type const char*, which points to a predefined constant string holding the version details. This function serves as a straightforward utility to retrieve the library's version without performing any additional processing.",
        "code_id": "c_group_1_id_291",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 65536\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_292",
        "query_text": "The function takes an unsigned long integer as input and returns an integer. It starts by applying a built-in operation to count the consecutive zero bits in the binary representation of the input, scanning from the most significant bit until it reaches the first non-zero bit. The resulting count is then returned, and the function guarantees that no exceptions are thrown.",
        "code_id": "c_group_1_id_292",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ni32.clz\nlocal.set 5\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_293",
        "query_text": "The function takes a single character as input and returns a character converted to lowercase. It first converts the input to an unsigned character to ensure safe handling of potential negative values, then applies a standard lowercase conversion routine, and finally casts the result back to a character. This process guarantees that the output is the lowercase equivalent of the input.",
        "code_id": "c_group_1_id_293",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shl\nlocal.set 9\nlocal.get 9\nlocal.get 8\ni32.shr_s\nlocal.set 10\ni32.const 16\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nglobal.set 0\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_294",
        "query_text": "The function accepts an input of type const char*, representing the name of an environment variable. It queries the system's environment for the variable and returns a const char* representing the corresponding value if it exists and is non-empty. If the environment variable does not exist, is an empty string, or if the platform is unsupported, the function returns NULL.",
        "code_id": "c_group_1_id_294",
        "code_text": "(func (;3;) (type 1) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 6\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_295",
        "query_text": "The function takes three parameters: an integer representing the total number of elements, and two arrays containing double-precision floating-point numbers that hold the datasets to be compared. It calculates the squared differences between corresponding elements in the two arrays, accumulates these values, and then divides the total by the number of elements to compute the average of the squared differences. Finally, it takes the square root of this average to obtain the Root Mean Square Error (RMSE), which is returned as a double.",
        "code_id": "c_group_1_id_295",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\ni32.const 0\nlocal.set 6\nlocal.get 6\nf64.convert_i32_s\nlocal.set 37\nlocal.get 5\nlocal.get 37\nf64.store offset=8\ni32.const 0\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store offset=4\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=4\nlocal.set 8\nlocal.get 5\ni32.load offset=28\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=24\nlocal.set 13\nlocal.get 5\ni32.load offset=4\nlocal.set 14\ni32.const 3\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 13\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nf64.load\nlocal.set 38\nlocal.get 5\ni32.load offset=20\nlocal.set 18\nlocal.get 5\ni32.load offset=4\nlocal.set 19\ni32.const 3\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 18\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 22\nf64.load\nlocal.set 39\nlocal.get 38\nlocal.get 39\nf64.sub\nlocal.set 40\nlocal.get 5\ni32.load offset=24\nlocal.set 23\nlocal.get 5\ni32.load offset=4\nlocal.set 24\ni32.const 3\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.shl\nlocal.set 26\nlocal.get 23\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\nf64.load\nlocal.set 41\nlocal.get 5\ni32.load offset=20\nlocal.set 28\nlocal.get 5\ni32.load offset=4\nlocal.set 29\ni32.const 3\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.shl\nlocal.set 31\nlocal.get 28\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 32\nf64.load\nlocal.set 42\nlocal.get 41\nlocal.get 42\nf64.sub\nlocal.set 43\nlocal.get 5\nf64.load offset=8\nlocal.set 44\nlocal.get 40\nlocal.get 43\nf64.mul\nlocal.set 45\nlocal.get 45\nlocal.get 44\nf64.add\nlocal.set 46\nlocal.get 5\nlocal.get 46\nf64.store offset=8\nlocal.get 5\ni32.load offset=4\nlocal.set 33\ni32.const 1\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 5\nlocal.get 35\ni32.store offset=4\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 5\nf64.load offset=8\nlocal.set 47\nlocal.get 5\ni32.load offset=28\nlocal.set 36\nlocal.get 36\nf64.convert_i32_s\nlocal.set 48\nlocal.get 47\nlocal.get 48\nf64.div\nlocal.set 49\nlocal.get 49\nf64.sqrt\nlocal.set 50\nlocal.get 5\nlocal.get 50\nf64.store offset=8\nlocal.get 5\nf64.load offset=8\nlocal.set 51\nlocal.get 51\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_296",
        "query_text": "The function takes an array of floating-point numbers and an integer representing the array's length. It iterates over the array, calculates the absolute value of each element, and updates the current maximum when a larger absolute value is found. Finally, it returns the maximum absolute value as a floating-point number.",
        "code_id": "c_group_1_id_296",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 0\nlocal.set 5\nlocal.get 5\nf64.convert_i32_s\nlocal.set 28\nlocal.get 4\nlocal.get 28\nf64.store offset=16\ni32.const 0\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=12\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=12\nlocal.set 7\nlocal.get 4\ni32.load offset=24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.lt_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=28\nlocal.set 12\nlocal.get 4\ni32.load offset=12\nlocal.set 13\ni32.const 3\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 12\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\nf64.load\nlocal.set 29\nlocal.get 29\nf64.abs\nlocal.set 30\nlocal.get 4\nf64.load offset=16\nlocal.set 31\nlocal.get 30\nlocal.get 31\nf64.ge\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nblock  ;; label = @3\nlocal.get 19\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=28\nlocal.set 20\nlocal.get 4\ni32.load offset=12\nlocal.set 21\ni32.const 3\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.shl\nlocal.set 23\nlocal.get 20\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nf64.load\nlocal.set 32\nlocal.get 32\nf64.abs\nlocal.set 33\nlocal.get 4\nlocal.get 33\nf64.store offset=16\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 25\ni32.const 1\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 4\nlocal.get 27\ni32.store offset=12\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\nf64.load offset=16\nlocal.set 34\nlocal.get 34\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_297",
        "query_text": "The function takes a single character (of type char) as input and returns its lowercase equivalent (of type char). It leverages the standard C++ locale facilities to perform the conversion according to the rules of the classic \"C\" locale.",
        "code_id": "c_group_1_id_297",
        "code_text": "(func (;7;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\ncall 847\nlocal.set 4\nlocal.get 4\ncall 8\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 6\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 7\ni32.const 24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shl\nlocal.set 9\nlocal.get 9\nlocal.get 8\ni32.shr_s\nlocal.set 10\nlocal.get 6\nlocal.get 10\ncall 9\nlocal.set 11\ni32.const 24\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.shl\nlocal.set 13\nlocal.get 13\nlocal.get 12\ni32.shr_s\nlocal.set 14\ni32.const 16\nlocal.set 15\nlocal.get 3\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\nglobal.set 0\nlocal.get 14\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_298",
        "query_text": "The function returns a reference to a constant pointer to a stream buffer linked to the standard output stream. It takes no input arguments and employs a static variable to ensure the same pointer is reused on every call, thereby providing consistent access to the output stream's buffer.",
        "code_id": "c_group_1_id_298",
        "code_text": "(func (;8;) (type 9) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ni32.const 0\nlocal.set 3\nlocal.get 3\ni32.load offset=82808\nlocal.set 4\ni32.const -12\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\ni32.load\nlocal.set 7\ni32.const 82808\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.add\nlocal.set 9\nlocal.get 9\ncall 9\nlocal.set 10\nlocal.get 2\nlocal.get 10\ni32.store offset=12\ni32.const 12\nlocal.set 11\nlocal.get 2\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nlocal.set 13\ni32.const 16\nlocal.set 14\nlocal.get 2\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nglobal.set 0\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_299",
        "query_text": "This function accepts a pointer to a character array along with its length as inputs. It iterates through each character in the array and checks if the character is an unprintable control character, while explicitly ignoring the tab, newline, and carriage return characters. If an unprintable control character is found, the function returns a boolean true immediately. If no such character is encountered after examining the entire string, it returns false.",
        "code_id": "c_group_1_id_299",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=16\ni32.const 0\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=12\nblock  ;; label = @1\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 4\ni32.load offset=12\nlocal.set 7\nlocal.get 4\ni32.load offset=20\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.lt_u\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 4\ni32.load offset=16\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 4\nlocal.get 14\ni32.store offset=16\nlocal.get 12\ni32.load8_u\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.store8 offset=11\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 16\ni32.const 255\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 18\ncall 3\nlocal.set 19\nblock  ;; label = @4\nlocal.get 19\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 20\ni32.const -9\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.add\nlocal.set 22\ni32.const 2\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.lt_u\nlocal.set 24\nblock  ;; label = @5\nblock  ;; label = @6\nblock  ;; label = @7\nlocal.get 24\nbr_if 0 (;@7;)\ni32.const 13\nlocal.set 25\nlocal.get 20\nlocal.get 25\ni32.ne\nlocal.set 26\nlocal.get 26\nbr_if 1 (;@6;)\nend\nbr 1 (;@5;)\nend\ni32.const 1\nlocal.set 27\ni32.const 1\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.and\nlocal.set 29\nlocal.get 4\nlocal.get 29\ni32.store8 offset=31\nbr 4 (;@1;)\nend\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 4\nlocal.get 32\ni32.store offset=12\nbr 0 (;@3;)\nend\nunreachable\nend\ni32.const 0\nlocal.set 33\ni32.const 1\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.and\nlocal.set 35\nlocal.get 4\nlocal.get 35\ni32.store8 offset=31\nend\nlocal.get 4\ni32.load8_u offset=31\nlocal.set 36\ni32.const 1\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.and\nlocal.set 38\ni32.const 32\nlocal.set 39\nlocal.get 4\nlocal.get 39\ni32.add\nlocal.set 40\nlocal.get 40\nglobal.set 0\nlocal.get 38\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_300",
        "query_text": "The function begins by receiving a string input that is meant to be converted to a 64-bit integer, along with a pointer to an integer that reflects the success or failure of this conversion. It attempts to perform the conversion using a standard library routine, and then examines any remaining characters or error flags to determine whether the conversion completed without issues. If extraneous characters are found or an error occurs, it sets the provided status pointer to indicate failure and returns a zero value. Otherwise, it marks the conversion as successful via the status pointer and returns the successfully parsed 64-bit integer.",
        "code_id": "c_group_1_id_300",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=20\nlocal.get 4\nlocal.get 1\ni32.store offset=16\ncall 3\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store\ncall 3\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.store\nlocal.get 4\ni32.load offset=20\nlocal.set 9\ni32.const 4\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 11\nlocal.set 12\ni32.const 0\nlocal.set 13\nlocal.get 9\nlocal.get 12\nlocal.get 13\ncall 6\nlocal.set 36\nlocal.get 4\nlocal.get 36\ni64.store offset=8\nlocal.get 4\ni32.load offset=4\nlocal.set 14\nlocal.get 14\ni32.load8_u\nlocal.set 15\ni32.const 0\nlocal.set 16\ni32.const 255\nlocal.set 17\nlocal.get 15\nlocal.get 17\ni32.and\nlocal.set 18\ni32.const 255\nlocal.set 19\nlocal.get 16\nlocal.get 19\ni32.and\nlocal.set 20\nlocal.get 18\nlocal.get 20\ni32.ne\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.and\nlocal.set 23\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 23\nbr_if 0 (;@3;)\ncall 3\nlocal.set 24\nlocal.get 24\ni32.load\nlocal.set 25\nlocal.get 25\ni32.eqz\nbr_if 1 (;@2;)\nend\ncall 3\nlocal.set 26\ni32.const 0\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.store\nlocal.get 4\ni32.load offset=16\nlocal.set 28\ni32.const 0\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.store\ni64.const 0\nlocal.set 37\nlocal.get 4\nlocal.get 37\ni64.store offset=24\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load\nlocal.set 30\ncall 3\nlocal.set 31\nlocal.get 31\nlocal.get 30\ni32.store\nlocal.get 4\ni32.load offset=16\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.store\nlocal.get 4\ni64.load offset=8\nlocal.set 38\nlocal.get 4\nlocal.get 38\ni64.store offset=24\nend\nlocal.get 4\ni64.load offset=24\nlocal.set 39\ni32.const 32\nlocal.set 34\nlocal.get 4\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 35\nglobal.set 0\nlocal.get 39\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_301",
        "query_text": "This description details a function that writes two arrays of double-precision numbers to a file formatted for compatibility with a numerical computing tool. The function takes five parameters: a filename specifying where to write the data, a pointer to a double array representing input values, an integer denoting the number of elements in the input array, a pointer to a double array representing output values, and an integer for the number of elements in the output array. Initially, the function attempts to open the specified file for writing. If the file cannot be opened, it exits immediately without performing any operations. Otherwise, it writes a header comment to indicate that the file was not generated by the numerical computing tool. It then writes metadata for the input dataset, including the type identifier, the row count (derived from the input array length), and a fixed column count, followed by the actual input data values. Next, it writes analogous metadata for the output dataset and sequentially writes the corresponding output data. Finally, the file is closed, and the function completes without returning any value.",
        "code_id": "c_group_1_id_301",
        "code_text": "(func (;5;) (type 8) (param i32 i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64)\nglobal.get 0\nlocal.set 5\ni32.const 96\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.sub\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 7\nlocal.get 0\ni32.store offset=92\nlocal.get 7\nlocal.get 1\ni32.store offset=88\nlocal.get 7\nlocal.get 2\ni32.store offset=84\nlocal.get 7\nlocal.get 3\ni32.store offset=80\nlocal.get 7\nlocal.get 4\ni32.store offset=76\nlocal.get 7\ni32.load offset=92\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.store offset=64\ni32.const 65734\nlocal.set 9\ni32.const 64\nlocal.set 10\nlocal.get 7\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 9\nlocal.get 11\ncall 34\ndrop\nlocal.get 7\ni32.load offset=92\nlocal.set 12\ni32.const 65565\nlocal.set 13\nlocal.get 12\nlocal.get 13\ncall 26\nlocal.set 14\nlocal.get 7\nlocal.get 14\ni32.store offset=72\ni32.const 0\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.ne\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 18\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\nlocal.get 7\ni32.load offset=72\nlocal.set 19\ni32.const 65683\nlocal.set 20\ni32.const 0\nlocal.set 21\nlocal.get 19\nlocal.get 20\nlocal.get 21\ncall 27\ndrop\nlocal.get 7\ni32.load offset=72\nlocal.set 22\ni32.const 65663\nlocal.set 23\ni32.const 0\nlocal.set 24\nlocal.get 22\nlocal.get 23\nlocal.get 24\ncall 27\ndrop\nlocal.get 7\ni32.load offset=72\nlocal.set 25\ni32.const 65631\nlocal.set 26\ni32.const 0\nlocal.set 27\nlocal.get 25\nlocal.get 26\nlocal.get 27\ncall 27\ndrop\nlocal.get 7\ni32.load offset=72\nlocal.set 28\nlocal.get 7\ni32.load offset=84\nlocal.set 29\nlocal.get 7\nlocal.get 29\ni32.store offset=48\ni32.const 65708\nlocal.set 30\ni32.const 48\nlocal.set 31\nlocal.get 7\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 28\nlocal.get 30\nlocal.get 32\ncall 27\ndrop\nlocal.get 7\ni32.load offset=72\nlocal.set 33\ni32.const 65720\nlocal.set 34\ni32.const 0\nlocal.set 35\nlocal.get 33\nlocal.get 34\nlocal.get 35\ncall 27\ndrop\ni32.const 0\nlocal.set 36\nlocal.get 7\nlocal.get 36\ni32.store offset=68\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 7\ni32.load offset=68\nlocal.set 37\nlocal.get 7\ni32.load offset=84\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.lt_s\nlocal.set 39\ni32.const 1\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.and\nlocal.set 41\nlocal.get 41\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 7\ni32.load offset=72\nlocal.set 42\nlocal.get 7\ni32.load offset=88\nlocal.set 43\nlocal.get 7\ni32.load offset=68\nlocal.set 44\ni32.const 3\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.shl\nlocal.set 46\nlocal.get 43\nlocal.get 46\ni32.add\nlocal.set 47\nlocal.get 47\nf64.load\nlocal.set 87\nlocal.get 7\nlocal.get 87\nf64.store\ni32.const 65678\nlocal.set 48\nlocal.get 42\nlocal.get 48\nlocal.get 7\ncall 27\ndrop\nlocal.get 7\ni32.load offset=68\nlocal.set 49\ni32.const 1\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.add\nlocal.set 51\nlocal.get 7\nlocal.get 51\ni32.store offset=68\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 7\ni32.load offset=72\nlocal.set 52\ni32.const 65647\nlocal.set 53\ni32.const 0\nlocal.set 54\nlocal.get 52\nlocal.get 53\nlocal.get 54\ncall 27\ndrop\nlocal.get 7\ni32.load offset=72\nlocal.set 55\ni32.const 65631\nlocal.set 56\ni32.const 0\nlocal.set 57\nlocal.get 55\nlocal.get 56\nlocal.get 57\ncall 27\ndrop\nlocal.get 7\ni32.load offset=72\nlocal.set 58\nlocal.get 7\ni32.load offset=76\nlocal.set 59\nlocal.get 7\nlocal.get 59\ni32.store offset=32\ni32.const 65708\nlocal.set 60\ni32.const 32\nlocal.set 61\nlocal.get 7\nlocal.get 61\ni32.add\nlocal.set 62\nlocal.get 58\nlocal.get 60\nlocal.get 62\ncall 27\ndrop\nlocal.get 7\ni32.load offset=72\nlocal.set 63\ni32.const 65720\nlocal.set 64\ni32.const 0\nlocal.set 65\nlocal.get 63\nlocal.get 64\nlocal.get 65\ncall 27\ndrop\ni32.const 0\nlocal.set 66\nlocal.get 7\nlocal.get 66\ni32.store offset=68\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 7\ni32.load offset=68\nlocal.set 67\nlocal.get 7\ni32.load offset=76\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.lt_s\nlocal.set 69\ni32.const 1\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.and\nlocal.set 71\nlocal.get 71\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 7\ni32.load offset=72\nlocal.set 72\nlocal.get 7\ni32.load offset=80\nlocal.set 73\nlocal.get 7\ni32.load offset=68\nlocal.set 74\ni32.const 3\nlocal.set 75\nlocal.get 74\nlocal.get 75\ni32.shl\nlocal.set 76\nlocal.get 73\nlocal.get 76\ni32.add\nlocal.set 77\nlocal.get 77\nf64.load\nlocal.set 88\nlocal.get 7\nlocal.get 88\nf64.store offset=16\ni32.const 65678\nlocal.set 78\ni32.const 16\nlocal.set 79\nlocal.get 7\nlocal.get 79\ni32.add\nlocal.set 80\nlocal.get 72\nlocal.get 78\nlocal.get 80\ncall 27\ndrop\nlocal.get 7\ni32.load offset=68\nlocal.set 81\ni32.const 1\nlocal.set 82\nlocal.get 81\nlocal.get 82\ni32.add\nlocal.set 83\nlocal.get 7\nlocal.get 83\ni32.store offset=68\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 7\ni32.load offset=72\nlocal.set 84\nlocal.get 84\ncall 10\ndrop\nend\ni32.const 96\nlocal.set 85\nlocal.get 7\nlocal.get 85\ni32.add\nlocal.set 86\nlocal.get 86\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_302",
        "query_text": "The function accepts a pointer to an array of constant C-style strings (of type const char* const*). It checks whether the input pointer is null; if it is, the function exits without performing any operations. Otherwise, it iterates over the array, deleting each string via a helper routine, and finally deletes the array itself using the same helper. The function does not return any value (void).",
        "code_id": "c_group_1_id_302",
        "code_text": "(func (;1;) (type 2) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.ne\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 8\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=8\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 3\ni32.load offset=8\nlocal.set 10\nlocal.get 10\ni32.load\nlocal.set 11\ni32.const 0\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.ne\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 3\ni32.load offset=8\nlocal.set 16\nlocal.get 16\ni32.load\nlocal.set 17\nlocal.get 17\ncall 3\nlocal.get 3\ni32.load offset=8\nlocal.set 18\ni32.const 4\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 3\nlocal.get 20\ni32.store offset=8\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 21\nlocal.get 21\ncall 3\nend\ni32.const 16\nlocal.set 22\nlocal.get 3\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 23\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_303",
        "query_text": "The function accepts two wide character inputs (of type wchar_t) and returns a boolean value (bool). It determines whether these characters form a valid UTF-16 surrogate pair. To do so, it ensures that the first character falls within the high surrogate range (0xD800\u20130xDBFF) and the second falls within the low surrogate range (0xDC00\u20130xDFFF), while also confirming that the size of wchar_t is exactly 2 bytes. If all checks pass, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_303",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\ni32.const 0\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_304",
        "query_text": "The function accepts two characters as inputs. It computes the difference between their ASCII values and returns the result as an integer. A positive outcome indicates that the first character's ASCII value is greater, a negative outcome indicates it is lower, and zero signifies that both characters have the same ASCII value.",
        "code_id": "c_group_1_id_304",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store8 offset=15\nlocal.get 4\nlocal.get 1\ni32.store8 offset=14\nlocal.get 4\ni32.load8_u offset=15\nlocal.set 5\ni32.const 24\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.shl\nlocal.set 7\nlocal.get 7\nlocal.get 6\ni32.shr_s\nlocal.set 8\nlocal.get 4\ni32.load8_u offset=14\nlocal.set 9\ni32.const 24\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.shl\nlocal.set 11\nlocal.get 11\nlocal.get 10\ni32.shr_s\nlocal.set 12\nlocal.get 8\nlocal.get 12\ni32.sub\nlocal.set 13\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_305",
        "query_text": "The function takes two unsigned integers as inputs: a 64-bit value to be manipulated and a 32-bit value that specifies the number of bit positions for the rotation. It first confines the rotation count to a valid range (0 to 63) by applying a mask. The function then performs a right bitwise rotation by shifting the 64-bit input to the right by the specified count and combining it with the input shifted to the left by the complementary number (64 minus the count). Finally, it returns the resulting 64-bit unsigned integer after the rotation.",
        "code_id": "c_group_1_id_305",
        "code_text": "(func (;1;) (type 2) (param i64 i32) (result i64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni64.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nlocal.get 4\ni32.load offset=4\nlocal.set 5\ni32.const 63\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store offset=4\nlocal.get 4\ni64.load offset=8\nlocal.set 14\nlocal.get 4\ni32.load offset=4\nlocal.set 8\nlocal.get 8\nlocal.set 9\nlocal.get 9\ni64.extend_i32_u\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni64.shr_u\nlocal.set 16\nlocal.get 4\ni64.load offset=8\nlocal.set 17\nlocal.get 4\ni32.load offset=4\nlocal.set 10\ni32.const 64\nlocal.set 11\nlocal.get 11\nlocal.get 10\ni32.sub\nlocal.set 12\nlocal.get 12\nlocal.set 13\nlocal.get 13\ni64.extend_i32_u\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni64.shl\nlocal.set 19\nlocal.get 16\nlocal.get 19\ni64.or\nlocal.set 20\nlocal.get 20\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_306",
        "query_text": "The function receives two inputs, each being a generic pointer that represents a constant string. It casts these generic inputs into string types and then compares them lexicographically using a standard library routine. The function returns an integer: a negative value indicates that the first string is lexicographically smaller than the second, zero indicates that they are equal, and a positive value indicates that the first string is lexicographically larger than the second.",
        "code_id": "c_group_1_id_306",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 16\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nglobal.set 0\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_307",
        "query_text": "The function takes one input: an unsigned integer, and produces an output of type bool. It shifts the unsigned integer right by 10 bits and then verifies whether the resulting value does not equal the hexadecimal constant 0x36. If the condition is met, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_307",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 10\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shr_u\nlocal.set 6\ni32.const 54\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_308",
        "query_text": "The function takes an unsigned integer as input and returns a string. It returns an empty string if the input is 1, \"both \" if the input is 2, and \"all \" if the input is greater than 2. The output is a string determined by the value of the input.",
        "code_id": "c_group_1_id_308",
        "code_text": "(func (;2;) (type 4) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.eq\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 0\ncall 3\ndrop\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 10\ni32.const 2\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.eq\nlocal.set 12\ni32.const 65554\nlocal.set 13\ni32.const 65549\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 12\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 13\nlocal.get 14\nlocal.get 16\nselect\nlocal.set 17\nlocal.get 0\nlocal.get 17\ncall 4\ndrop\nend\ni32.const 16\nlocal.set 18\nlocal.get 4\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 19\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_309",
        "query_text": "This description details a function that prints a failure notification along with contextual information to standard output. It accepts three parameters: a pointer to a null-terminated string representing a file identifier, an integer signifying a source code line number, and a formatted string with optional variable arguments. The function begins by outputting the file identifier and line number in a formatted manner, then proceeds to print the dynamically formatted message, and finally appends a newline character. Note that the function does not return any value (void).",
        "code_id": "c_group_1_id_309",
        "code_text": "(func (;2;) (type 5) (param i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 4\ni32.const 32\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nglobal.set 0\nlocal.get 6\nlocal.get 0\ni32.store offset=28\nlocal.get 6\nlocal.get 1\ni32.store offset=24\nlocal.get 6\nlocal.get 2\ni32.store offset=20\nlocal.get 6\nlocal.get 3\ni32.store offset=16\nlocal.get 6\ni32.load offset=28\nlocal.set 7\nlocal.get 6\ni32.load offset=24\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.store offset=4\nlocal.get 6\nlocal.get 7\ni32.store\ni32.const 65590\nlocal.set 9\nlocal.get 9\nlocal.get 6\ncall 4\ndrop\nlocal.get 6\ni32.load offset=20\nlocal.set 10\nlocal.get 6\ni32.load offset=16\nlocal.set 11\nlocal.get 10\nlocal.get 11\ncall 43\ndrop\ni32.const 10\nlocal.set 12\nlocal.get 12\ncall 16\ndrop\ni32.const 32\nlocal.set 13\nlocal.get 6\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_310",
        "query_text": "The function accepts a single parameter: a character. It first determines if the character corresponds to a valid hexadecimal digit\u2014specifically, one of the characters that represent the digits 0-9 or the letters A-F/a-f. Based on this check, it returns a boolean value: true if the character is a hexadecimal digit, or false otherwise.",
        "code_id": "c_group_1_id_310",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.ne\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\ni32.const 16\nlocal.set 12\nlocal.get 3\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_311",
        "query_text": "The function accepts two inputs: a string and a character. It first checks if the string is non-empty. If the string is not empty, it compares the first character of the string with the provided character and returns a boolean value indicating whether they match. If the string is empty, the function returns false.",
        "code_id": "c_group_1_id_311",
        "code_text": "(func (;1;) (type 3) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store8 offset=11\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ncall 2\nlocal.set 6\ni32.const 0\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 7\nlocal.set 10\nblock  ;; label = @1\nlocal.get 9\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=12\nlocal.set 11\ni32.const 0\nlocal.set 12\nlocal.get 11\nlocal.get 12\ncall 3\nlocal.set 13\nlocal.get 13\ni32.load8_u\nlocal.set 14\ni32.const 24\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 16\nlocal.get 15\ni32.shr_s\nlocal.set 17\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 18\ni32.const 24\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.shl\nlocal.set 20\nlocal.get 20\nlocal.get 19\ni32.shr_s\nlocal.set 21\nlocal.get 17\nlocal.get 21\ni32.eq\nlocal.set 22\nlocal.get 22\nlocal.set 10\nend\nlocal.get 10\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\ni32.const 16\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\nglobal.set 0\nlocal.get 25\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_312",
        "query_text": "The function takes two inputs: a constant string (passed by reference) and a character. It verifies that the string is not empty and then checks if the last character of the string is equal to the specified character. If the conditions are met, it returns a boolean value true; otherwise, it returns false.",
        "code_id": "c_group_1_id_312",
        "code_text": "(func (;1;) (type 3) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store8 offset=11\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ncall 2\nlocal.set 6\ni32.const 0\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 7\nlocal.set 10\nblock  ;; label = @1\nlocal.get 9\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=12\nlocal.set 11\nlocal.get 4\ni32.load offset=12\nlocal.set 12\nlocal.get 12\ncall 3\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.sub\nlocal.set 15\nlocal.get 11\nlocal.get 15\ncall 4\nlocal.set 16\nlocal.get 16\ni32.load8_u\nlocal.set 17\ni32.const 24\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.shl\nlocal.set 19\nlocal.get 19\nlocal.get 18\ni32.shr_s\nlocal.set 20\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 21\ni32.const 24\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.shl\nlocal.set 23\nlocal.get 23\nlocal.get 22\ni32.shr_s\nlocal.set 24\nlocal.get 20\nlocal.get 24\ni32.eq\nlocal.set 25\nlocal.get 25\nlocal.set 10\nend\nlocal.get 10\nlocal.set 26\ni32.const 1\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.and\nlocal.set 28\ni32.const 16\nlocal.set 29\nlocal.get 4\nlocal.get 29\ni32.add\nlocal.set 30\nlocal.get 30\nglobal.set 0\nlocal.get 28\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_313",
        "query_text": "The function accepts three double-precision floating-point numbers as inputs and returns a boolean value. It determines whether two floating-point numbers are approximately equal within a provided tolerance. To do this, it computes whether adding the tolerance to the first number results in a value that is at least as large as the second number, and similarly, whether adding the tolerance to the second number results in a value that is at least as large as the first. If both these conditions hold true, the function returns true; otherwise, it returns false. This behavior makes the function useful for comparing floating-point numbers while accounting for potential inaccuracies due to precision limitations.",
        "code_id": "c_group_1_id_313",
        "code_text": "(func (;1;) (type 2) (param f64 f64 f64) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\nf64.store offset=24\nlocal.get 5\nlocal.get 1\nf64.store offset=16\nlocal.get 5\nlocal.get 2\nf64.store offset=8\nlocal.get 5\nf64.load offset=24\nlocal.set 15\nlocal.get 5\nf64.load offset=8\nlocal.set 16\nlocal.get 15\nlocal.get 16\nf64.add\nlocal.set 17\nlocal.get 5\nf64.load offset=16\nlocal.set 18\nlocal.get 17\nlocal.get 18\nf64.ge\nlocal.set 6\ni32.const 0\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 7\nlocal.set 10\nblock  ;; label = @1\nlocal.get 9\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 5\nf64.load offset=16\nlocal.set 19\nlocal.get 5\nf64.load offset=8\nlocal.set 20\nlocal.get 19\nlocal.get 20\nf64.add\nlocal.set 21\nlocal.get 5\nf64.load offset=24\nlocal.set 22\nlocal.get 21\nlocal.get 22\nf64.ge\nlocal.set 11\nlocal.get 11\nlocal.set 10\nend\nlocal.get 10\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nlocal.get 14\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_314",
        "query_text": "The function accepts three integers as input: one representing the total number of partitions in a distributed testing framework, another indicating the current partition's index, and the last representing a test identifier. It computes the remainder of the test identifier divided by the total number of partitions and compares this result to the current partition index. If they match, the function returns a boolean true, signifying that the test associated with the identifier should execute on the given partition; otherwise, it returns false. The function's primary purpose is to distribute tests evenly across partitions using modulo arithmetic.",
        "code_id": "c_group_1_id_314",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nlocal.get 5\ni32.load offset=4\nlocal.set 6\nlocal.get 5\ni32.load offset=12\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.rem_s\nlocal.set 8\nlocal.get 5\ni32.load offset=8\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.eq\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_315",
        "query_text": "The function takes a boolean value as input and returns its corresponding string representation. Specifically, if the input is true, it returns the string \"true\"; if the input is false, it returns the string \"false.\" The input is of type bool, and the output is of type std::string.",
        "code_id": "c_group_1_id_315",
        "code_text": "(func (;2;) (type 4) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store8 offset=11\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 6\ni32.const 65549\nlocal.set 7\ni32.const 65554\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 6\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 7\nlocal.get 8\nlocal.get 10\nselect\nlocal.set 11\nlocal.get 0\nlocal.get 11\ncall 3\ndrop\ni32.const 16\nlocal.set 12\nlocal.get 4\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_316",
        "query_text": "The function takes a single character as input and returns a boolean value. It checks whether the provided character matches the standard option prefix. On all platforms, it verifies if the character is a hyphen ('-'). Additionally, on Windows systems, it also checks if the character is a forward slash ('/'). If the input character meets any of these conditions, the function returns true; otherwise, it returns false. The input is of type char and the output is of type bool.",
        "code_id": "c_group_1_id_316",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.shr_s\nlocal.set 7\ni32.const 45\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.eq\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_318",
        "query_text": "The function accepts a constant string reference as input and returns a new string with leading and trailing whitespace characters removed. It locates the first and last characters in the input that are not whitespace and extracts the substring between these positions. If the input string consists solely of whitespace, the function returns an empty string. The input is of type std::string (passed as a constant reference), and the output is of type std::string.",
        "code_id": "c_group_1_id_318",
        "code_text": "(func (;2;) (type 5) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 65549\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 6\nlocal.get 4\ni32.load offset=20\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 6\nlocal.get 7\nlocal.get 8\ncall 3\nlocal.set 9\nlocal.get 4\nlocal.get 9\ni32.store offset=16\nlocal.get 4\ni32.load offset=24\nlocal.set 10\nlocal.get 4\ni32.load offset=20\nlocal.set 11\ni32.const -1\nlocal.set 12\nlocal.get 10\nlocal.get 11\nlocal.get 12\ncall 4\nlocal.set 13\nlocal.get 4\nlocal.get 13\ni32.store offset=12\nlocal.get 4\ni32.load offset=16\nlocal.set 14\ni32.const -1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.ne\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 18\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=24\nlocal.set 19\nlocal.get 4\ni32.load offset=16\nlocal.set 20\nlocal.get 4\ni32.load offset=12\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 4\ni32.load offset=16\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.sub\nlocal.set 25\nlocal.get 0\nlocal.get 19\nlocal.get 20\nlocal.get 25\ncall 5\nbr 1 (;@1;)\nend\nlocal.get 0\ncall 6\ndrop\nend\ni32.const 32\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_319",
        "query_text": "The function takes four unsigned integers that represent individual bytes of a UTF-8 encoded character, and it outputs a single unsigned integer representing the decoded Unicode code point. It does so by first applying bit masks to each byte to extract the relevant bits, then shifting these bits to their correct positions, and finally combining them using bitwise OR operations.",
        "code_id": "c_group_1_id_319",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 4\ni32.const 16\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nlocal.get 0\ni32.store offset=12\nlocal.get 6\nlocal.get 1\ni32.store offset=8\nlocal.get 6\nlocal.get 2\ni32.store offset=4\nlocal.get 6\nlocal.get 3\ni32.store\nlocal.get 6\ni32.load offset=12\nlocal.set 7\ni32.const 7\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\ni32.const 18\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.shl\nlocal.set 11\nlocal.get 6\ni32.load offset=8\nlocal.set 12\ni32.const 63\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\ni32.const 12\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 11\nlocal.get 16\ni32.or\nlocal.set 17\nlocal.get 6\ni32.load offset=4\nlocal.set 18\ni32.const 63\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\ni32.const 6\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.shl\nlocal.set 22\nlocal.get 17\nlocal.get 22\ni32.or\nlocal.set 23\nlocal.get 6\ni32.load\nlocal.set 24\ni32.const 63\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\ni32.const 0\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.shl\nlocal.set 28\nlocal.get 23\nlocal.get 28\ni32.or\nlocal.set 29\nlocal.get 29\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_320",
        "query_text": "The function accepts two inputs of type float. It considers one input as the first value and the other as the second value, then compares them to determine which is larger. The function returns the greater float value as its output. Its primary purpose is to compute the maximum value between the two provided floating-point numbers.",
        "code_id": "c_group_1_id_320",
        "code_text": "(func (;1;) (type 2) (param f32 f32) (result f32)\n(local i32 i32 i32 i32 i32 i32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\nf32.store offset=8\nlocal.get 4\nlocal.get 1\nf32.store offset=4\nlocal.get 4\nf32.load offset=8\nlocal.set 8\nlocal.get 4\nf32.load offset=4\nlocal.set 9\nlocal.get 8\nlocal.get 9\nf32.gt\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 7\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\nf32.load offset=8\nlocal.set 10\nlocal.get 4\nlocal.get 10\nf32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 4\nf32.load offset=4\nlocal.set 11\nlocal.get 4\nlocal.get 11\nf32.store offset=12\nend\nlocal.get 4\nf32.load offset=12\nlocal.set 12\nlocal.get 12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_321",
        "query_text": "The function takes two parameters: one representing the number of seconds since the epoch (a time specification) and another, a pointer to a structure for holding the broken-down time. It converts the time specification into its broken-down format in a thread-safe and platform-independent manner. Depending on the platform, it uses different conversion routines: a secure conversion function on one platform, a fallback approach that manually copies the result on another, and a reentrant conversion function on the remaining systems. The function returns a boolean value indicating whether the conversion was successful.",
        "code_id": "c_group_1_id_321",
        "code_text": "(func (;4;) (type 9) (param i64 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni64.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\nlocal.get 4\ni32.load offset=4\nlocal.set 5\ni32.const 8\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.set 8\nlocal.get 8\nlocal.get 5\ncall 21\nlocal.set 9\ni32.const 0\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.ne\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\ni32.const 16\nlocal.set 14\nlocal.get 4\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nglobal.set 0\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_322",
        "query_text": "The function receives one floating-point parameter, typically representing a normalized time value between 0 and 1, and returns a floating-point result. For input values below 0.5, it computes a quintic easing-in transformation by raising the input to the fifth power (after appropriate intermediate steps). For input values of 0.5 or greater, it calculates a quintic easing-out effect by first transforming the input and then applying a quintic formula. The outcome is a smoothly interpolated value that transitions from 0 to 1 with symmetric acceleration and deceleration around the midpoint, making it suitable for natural-looking animations and transitions.",
        "code_id": "c_group_1_id_322",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 7\nf32.const 0x1p-1 (;=0.5;)\nlocal.set 8\nlocal.get 7\nlocal.get 8\nf32.lt\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 6\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\nf32.load offset=8\nlocal.set 9\nlocal.get 3\nf32.load offset=8\nlocal.set 10\nlocal.get 9\nlocal.get 10\nf32.mul\nlocal.set 11\nlocal.get 3\nlocal.get 11\nf32.store offset=4\nlocal.get 3\nf32.load offset=4\nlocal.set 12\nf32.const 0x1p+4 (;=16;)\nlocal.set 13\nlocal.get 13\nlocal.get 12\nf32.mul\nlocal.set 14\nlocal.get 3\nf32.load offset=4\nlocal.set 15\nlocal.get 14\nlocal.get 15\nf32.mul\nlocal.set 16\nlocal.get 3\nf32.load offset=8\nlocal.set 17\nlocal.get 16\nlocal.get 17\nf32.mul\nlocal.set 18\nlocal.get 3\nlocal.get 18\nf32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\nf32.load offset=8\nlocal.set 19\nlocal.get 19\nlocal.get 19\nf32.add\nlocal.set 20\nf32.const -0x1p+1 (;=-2;)\nlocal.set 21\nlocal.get 20\nlocal.get 21\nf32.add\nlocal.set 22\nlocal.get 3\nlocal.get 22\nf32.store offset=4\nlocal.get 3\nf32.load offset=4\nlocal.set 23\nlocal.get 3\nf32.load offset=4\nlocal.set 24\nlocal.get 23\nlocal.get 24\nf32.mul\nlocal.set 25\nlocal.get 3\nlocal.get 25\nf32.store\nlocal.get 3\nf32.load\nlocal.set 26\nf32.const 0x1p-1 (;=0.5;)\nlocal.set 27\nlocal.get 27\nlocal.get 26\nf32.mul\nlocal.set 28\nlocal.get 3\nf32.load\nlocal.set 29\nlocal.get 28\nlocal.get 29\nf32.mul\nlocal.set 30\nlocal.get 3\nf32.load offset=4\nlocal.set 31\nlocal.get 30\nlocal.get 31\nf32.mul\nlocal.set 32\nf32.const 0x1p+0 (;=1;)\nlocal.set 33\nlocal.get 32\nlocal.get 33\nf32.add\nlocal.set 34\nlocal.get 3\nlocal.get 34\nf32.store offset=12\nend\nlocal.get 3\nf32.load offset=12\nlocal.set 35\nlocal.get 35\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_323",
        "query_text": "The function takes a pointer to an array of unsigned characters along with an integer representing the number of elements in the array. It reverses the order of the elements in place by swapping the first element with the last, the second with the second-to-last, and so on until the array is completely reversed. The function does not return any value (void). Its primary purpose is to modify the array directly by reversing its content.",
        "code_id": "c_group_1_id_323",
        "code_text": "(func (;1;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.sub\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=16\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=20\nlocal.set 9\nlocal.get 4\ni32.load offset=16\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.lt_s\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 13\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=28\nlocal.set 14\nlocal.get 4\ni32.load offset=20\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\ni32.load8_u\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.store8 offset=15\nlocal.get 4\ni32.load offset=28\nlocal.set 18\nlocal.get 4\ni32.load offset=16\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\ni32.load8_u\nlocal.set 21\nlocal.get 4\ni32.load offset=28\nlocal.set 22\nlocal.get 4\ni32.load offset=20\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nlocal.get 21\ni32.store8\nlocal.get 4\ni32.load8_u offset=15\nlocal.set 25\nlocal.get 4\ni32.load offset=28\nlocal.set 26\nlocal.get 4\ni32.load offset=16\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 28\nlocal.get 25\ni32.store8\nlocal.get 4\ni32.load offset=20\nlocal.set 29\ni32.const 1\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 4\nlocal.get 31\ni32.store offset=20\nlocal.get 4\ni32.load offset=16\nlocal.set 32\ni32.const -1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.add\nlocal.set 34\nlocal.get 4\nlocal.get 34\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_324",
        "query_text": "The function accepts a single integer input representing a CPU index and returns an integer output. It assembles a file path referencing a system file in the CPU frequency directory by incorporating the CPU index into the path string. It then opens the file in read mode and attempts to read the minimum frequency setting from it. If the file cannot be opened or if the frequency value cannot be correctly retrieved, the function returns -1 to signal an error. Otherwise, it returns the obtained frequency value as an integer. Additionally, the function manages any necessary dynamic memory allocation for constructing the file path and ensures the file is closed properly after the operation.",
        "code_id": "c_group_1_id_324",
        "code_text": "(func (;5;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 48\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=40\ni32.const 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=28\nlocal.get 3\ni32.load offset=40\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.store offset=16\ni32.const 65598\nlocal.set 6\ni32.const 28\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.add\nlocal.set 8\ni32.const 16\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 8\nlocal.get 6\nlocal.get 10\ncall 7\nlocal.set 11\ni32.const -1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.eq\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 15\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 16\nlocal.get 3\nlocal.get 16\ni32.store offset=44\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=28\nlocal.set 17\ni32.const 65596\nlocal.set 18\nlocal.get 17\nlocal.get 18\ncall 27\nlocal.set 19\nlocal.get 3\nlocal.get 19\ni32.store offset=32\nlocal.get 3\ni32.load offset=28\nlocal.set 20\nlocal.get 20\ncall 95\nlocal.get 3\ni32.load offset=32\nlocal.set 21\ni32.const 0\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.ne\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\nblock  ;; label = @2\nlocal.get 25\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 26\nlocal.get 3\nlocal.get 26\ni32.store offset=44\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=32\nlocal.set 27\ni32.const 36\nlocal.set 28\nlocal.get 3\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 3\nlocal.get 29\ni32.store\ni32.const 65672\nlocal.set 30\nlocal.get 27\nlocal.get 30\nlocal.get 3\ncall 28\nlocal.set 31\ni32.const 1\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.ne\nlocal.set 33\ni32.const 1\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.and\nlocal.set 35\nblock  ;; label = @2\nlocal.get 35\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 36\nlocal.get 3\nlocal.get 36\ni32.store offset=36\nend\nlocal.get 3\ni32.load offset=32\nlocal.set 37\nlocal.get 37\ncall 11\ndrop\nlocal.get 3\ni32.load offset=36\nlocal.set 38\nlocal.get 3\nlocal.get 38\ni32.store offset=44\nend\nlocal.get 3\ni32.load offset=44\nlocal.set 39\ni32.const 48\nlocal.set 40\nlocal.get 3\nlocal.get 40\ni32.add\nlocal.set 41\nlocal.get 41\nglobal.set 0\nlocal.get 39\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_325",
        "query_text": "The function takes an integer as input, representing a day-of-week index (with 0 corresponding to Sunday and 6 to Saturday). It checks if the provided index falls within the valid range of 0 to 6. If the input is valid, the function returns a pointer to a constant string that holds the full name of the day. If the input is outside the valid range, it returns a pointer to a constant string containing a question mark (\"?\"). The input is of type int, and the output is of type const char*.",
        "code_id": "c_group_1_id_325",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 32\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=28\ni32.const 0\nlocal.set 4\nlocal.get 4\ni32.load offset=65624\nlocal.set 5\ni32.const 24\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.get 5\ni32.store\nlocal.get 4\ni64.load offset=65616\nlocal.set 29\ni32.const 16\nlocal.set 8\nlocal.get 3\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nlocal.get 29\ni64.store\nlocal.get 4\ni64.load offset=65608\nlocal.set 30\nlocal.get 3\nlocal.get 30\ni64.store offset=8\nlocal.get 4\ni64.load offset=65600\nlocal.set 31\nlocal.get 3\nlocal.get 31\ni64.store\nlocal.get 3\ni32.load offset=28\nlocal.set 10\ni32.const 0\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.ge_s\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 14\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=28\nlocal.set 15\ni32.const 6\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.le_s\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 19\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=28\nlocal.set 20\nlocal.get 3\nlocal.set 21\ni32.const 2\nlocal.set 22\nlocal.get 20\nlocal.get 22\ni32.shl\nlocal.set 23\nlocal.get 21\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\ni32.load\nlocal.set 25\nlocal.get 25\nlocal.set 26\nbr 1 (;@1;)\nend\ni32.const 65593\nlocal.set 27\nlocal.get 27\nlocal.set 26\nend\nlocal.get 26\nlocal.set 28\nlocal.get 28\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_326",
        "query_text": "The function takes a string as input and returns a boolean value. It evaluates the input string to determine if it is readable by checking two conditions: whether the string\u2019s length is 20 characters or fewer, or whether it does not contain the characters '<' or '('. If either condition is satisfied, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_326",
        "code_text": "(func (;1;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 2\nlocal.set 5\ni32.const 20\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.le_u\nlocal.set 7\ni32.const 1\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 7\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 8\nlocal.set 11\nblock  ;; label = @1\nlocal.get 10\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 12\ni32.const 65536\nlocal.set 13\ni32.const 0\nlocal.set 14\nlocal.get 12\nlocal.get 13\nlocal.get 14\ncall 3\nlocal.set 15\ni32.const -1\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.eq\nlocal.set 17\nlocal.get 17\nlocal.set 11\nend\nlocal.get 11\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\ni32.const 16\nlocal.set 21\nlocal.get 3\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 22\nglobal.set 0\nlocal.get 20\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_327",
        "query_text": "The function takes a reference to a string as input and modifies it in place by converting any uppercase letters to their corresponding lowercase letters. It achieves the conversion by iterating over each character and applying a transformation that checks if the character is uppercase; if so, it adjusts its value to the lowercase equivalent. Subsequently, the function returns the modified string, maintaining the input\u2019s type.",
        "code_id": "c_group_1_id_327",
        "code_text": "(func (;1;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 32\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=28\nlocal.get 3\ni32.load offset=28\nlocal.set 4\nlocal.get 4\ncall 2\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.store offset=24\nlocal.get 3\ni32.load offset=28\nlocal.set 6\nlocal.get 6\ncall 3\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.store offset=20\nlocal.get 3\ni32.load offset=28\nlocal.set 8\nlocal.get 8\ncall 2\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=16\nlocal.get 3\ni32.load offset=24\nlocal.set 10\nlocal.get 3\ni32.load offset=20\nlocal.set 11\nlocal.get 3\ni32.load offset=16\nlocal.set 12\nlocal.get 10\nlocal.get 11\nlocal.get 12\ncall 4\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.store offset=8\nlocal.get 3\ni32.load offset=28\nlocal.set 14\ni32.const 32\nlocal.set 15\nlocal.get 3\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\nglobal.set 0\nlocal.get 14\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_328",
        "query_text": "The function accepts five floating-point inputs. The first represents a position along a curve (a value between 0 and 1), and the remaining four denote the points defining a cubic B\u00e9zier curve: the starting point, two control points, and the ending point. Internally, the function uses B\u00e9zier interpolation formulas to blend these points mathematically and calculates an intermediate value corresponding to the position on the curve at the specified parameter. It then returns this computed floating-point value as the output.",
        "code_id": "c_group_1_id_328",
        "code_text": "(func (;1;) (type 2) (param f32 f32 f32 f32 f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 5\ni32.const 48\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.sub\nlocal.set 7\nlocal.get 7\nlocal.get 0\nf32.store offset=44\nlocal.get 7\nlocal.get 1\nf32.store offset=40\nlocal.get 7\nlocal.get 2\nf32.store offset=36\nlocal.get 7\nlocal.get 3\nf32.store offset=32\nlocal.get 7\nlocal.get 4\nf32.store offset=28\nlocal.get 7\nf32.load offset=44\nlocal.set 8\nf32.const 0x1p+0 (;=1;)\nlocal.set 9\nlocal.get 9\nlocal.get 8\nf32.sub\nlocal.set 10\nlocal.get 7\nlocal.get 10\nf32.store offset=24\nlocal.get 7\nf32.load offset=24\nlocal.set 11\nlocal.get 7\nf32.load offset=24\nlocal.set 12\nlocal.get 11\nlocal.get 12\nf32.mul\nlocal.set 13\nlocal.get 7\nlocal.get 13\nf32.store offset=20\nlocal.get 7\nf32.load offset=44\nlocal.set 14\nlocal.get 7\nf32.load offset=44\nlocal.set 15\nlocal.get 14\nlocal.get 15\nf32.mul\nlocal.set 16\nlocal.get 7\nlocal.get 16\nf32.store offset=16\nlocal.get 7\nf32.load offset=44\nlocal.set 17\nlocal.get 7\nf32.load offset=16\nlocal.set 18\nlocal.get 17\nlocal.get 18\nf32.sub\nlocal.set 19\nf32.const 0x1.8p+1 (;=3;)\nlocal.set 20\nlocal.get 19\nlocal.get 20\nf32.mul\nlocal.set 21\nlocal.get 7\nlocal.get 21\nf32.store offset=12\nlocal.get 7\nf32.load offset=40\nlocal.set 22\nlocal.get 7\nf32.load offset=20\nlocal.set 23\nlocal.get 7\nf32.load offset=36\nlocal.set 24\nlocal.get 7\nf32.load offset=12\nlocal.set 25\nlocal.get 24\nlocal.get 25\nf32.mul\nlocal.set 26\nlocal.get 22\nlocal.get 23\nf32.mul\nlocal.set 27\nlocal.get 27\nlocal.get 26\nf32.add\nlocal.set 28\nlocal.get 7\nlocal.get 28\nf32.store offset=8\nlocal.get 7\nf32.load offset=8\nlocal.set 29\nlocal.get 7\nf32.load offset=44\nlocal.set 30\nlocal.get 7\nf32.load offset=32\nlocal.set 31\nlocal.get 7\nf32.load offset=12\nlocal.set 32\nlocal.get 7\nf32.load offset=28\nlocal.set 33\nlocal.get 7\nf32.load offset=16\nlocal.set 34\nlocal.get 33\nlocal.get 34\nf32.mul\nlocal.set 35\nlocal.get 31\nlocal.get 32\nf32.mul\nlocal.set 36\nlocal.get 36\nlocal.get 35\nf32.add\nlocal.set 37\nlocal.get 7\nf32.load offset=8\nlocal.set 38\nlocal.get 37\nlocal.get 38\nf32.sub\nlocal.set 39\nlocal.get 30\nlocal.get 39\nf32.mul\nlocal.set 40\nlocal.get 40\nlocal.get 29\nf32.add\nlocal.set 41\nlocal.get 41\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_329",
        "query_text": "The function accepts three inputs: an integer denoting the number of elements, and two pointers to arrays of double-precision floating-point numbers. It begins by computing the mean of each dataset by iterating through each array and averaging the values. Using these means, the function calculates the covariance between the two datasets by summing the product of the differences from the mean for each pair of corresponding elements. Simultaneously, it determines the sum of squared differences for each dataset to evaluate the standard deviations. Finally, it computes the Pearson correlation coefficient by dividing the covariance by the product of the two standard deviations, and returns this value as a double representing the strength and direction of the linear relationship between the datasets.",
        "code_id": "c_group_1_id_329",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 3\ni32.const 96\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=92\nlocal.get 5\nlocal.get 1\ni32.store offset=88\nlocal.get 5\nlocal.get 2\ni32.store offset=84\ni32.const 0\nlocal.set 6\nlocal.get 6\nf64.convert_i32_s\nlocal.set 51\nlocal.get 5\nlocal.get 51\nf64.store offset=56\ni32.const 0\nlocal.set 7\nlocal.get 7\nf64.convert_i32_s\nlocal.set 52\nlocal.get 5\nlocal.get 52\nf64.store offset=64\ni32.const 0\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.store offset=12\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=12\nlocal.set 9\nlocal.get 5\ni32.load offset=92\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.lt_s\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 13\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=88\nlocal.set 14\nlocal.get 5\ni32.load offset=12\nlocal.set 15\ni32.const 3\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.shl\nlocal.set 17\nlocal.get 14\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 18\nf64.load\nlocal.set 53\nlocal.get 5\nf64.load offset=64\nlocal.set 54\nlocal.get 54\nlocal.get 53\nf64.add\nlocal.set 55\nlocal.get 5\nlocal.get 55\nf64.store offset=64\nlocal.get 5\ni32.load offset=84\nlocal.set 19\nlocal.get 5\ni32.load offset=12\nlocal.set 20\ni32.const 3\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.shl\nlocal.set 22\nlocal.get 19\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 23\nf64.load\nlocal.set 56\nlocal.get 5\nf64.load offset=56\nlocal.set 57\nlocal.get 57\nlocal.get 56\nf64.add\nlocal.set 58\nlocal.get 5\nlocal.get 58\nf64.store offset=56\nlocal.get 5\ni32.load offset=12\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.add\nlocal.set 26\nlocal.get 5\nlocal.get 26\ni32.store offset=12\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 5\nf64.load offset=64\nlocal.set 59\nlocal.get 5\ni32.load offset=92\nlocal.set 27\nlocal.get 27\nf64.convert_i32_s\nlocal.set 60\nlocal.get 59\nlocal.get 60\nf64.div\nlocal.set 61\nlocal.get 5\nlocal.get 61\nf64.store offset=64\nlocal.get 5\nf64.load offset=56\nlocal.set 62\nlocal.get 5\ni32.load offset=92\nlocal.set 28\nlocal.get 28\nf64.convert_i32_s\nlocal.set 63\nlocal.get 62\nlocal.get 63\nf64.div\nlocal.set 64\nlocal.get 5\nlocal.get 64\nf64.store offset=56\ni32.const 0\nlocal.set 29\nlocal.get 29\nf64.convert_i32_s\nlocal.set 65\nlocal.get 5\nlocal.get 65\nf64.store offset=16\ni32.const 0\nlocal.set 30\nlocal.get 30\nf64.convert_i32_s\nlocal.set 66\nlocal.get 5\nlocal.get 66\nf64.store offset=24\ni32.const 0\nlocal.set 31\nlocal.get 31\nf64.convert_i32_s\nlocal.set 67\nlocal.get 5\nlocal.get 67\nf64.store offset=32\ni32.const 0\nlocal.set 32\nlocal.get 5\nlocal.get 32\ni32.store offset=12\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=12\nlocal.set 33\nlocal.get 5\ni32.load offset=92\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.lt_s\nlocal.set 35\ni32.const 1\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.and\nlocal.set 37\nlocal.get 37\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=88\nlocal.set 38\nlocal.get 5\ni32.load offset=12\nlocal.set 39\ni32.const 3\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.shl\nlocal.set 41\nlocal.get 38\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 42\nf64.load\nlocal.set 68\nlocal.get 5\nf64.load offset=64\nlocal.set 69\nlocal.get 68\nlocal.get 69\nf64.sub\nlocal.set 70\nlocal.get 5\nlocal.get 70\nf64.store offset=48\nlocal.get 5\ni32.load offset=84\nlocal.set 43\nlocal.get 5\ni32.load offset=12\nlocal.set 44\ni32.const 3\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.shl\nlocal.set 46\nlocal.get 43\nlocal.get 46\ni32.add\nlocal.set 47\nlocal.get 47\nf64.load\nlocal.set 71\nlocal.get 5\nf64.load offset=56\nlocal.set 72\nlocal.get 71\nlocal.get 72\nf64.sub\nlocal.set 73\nlocal.get 5\nlocal.get 73\nf64.store offset=40\nlocal.get 5\nf64.load offset=48\nlocal.set 74\nlocal.get 5\nf64.load offset=40\nlocal.set 75\nlocal.get 5\nf64.load offset=32\nlocal.set 76\nlocal.get 74\nlocal.get 75\nf64.mul\nlocal.set 77\nlocal.get 77\nlocal.get 76\nf64.add\nlocal.set 78\nlocal.get 5\nlocal.get 78\nf64.store offset=32\nlocal.get 5\nf64.load offset=48\nlocal.set 79\nlocal.get 5\nf64.load offset=48\nlocal.set 80\nlocal.get 5\nf64.load offset=24\nlocal.set 81\nlocal.get 79\nlocal.get 80\nf64.mul\nlocal.set 82\nlocal.get 82\nlocal.get 81\nf64.add\nlocal.set 83\nlocal.get 5\nlocal.get 83\nf64.store offset=24\nlocal.get 5\nf64.load offset=40\nlocal.set 84\nlocal.get 5\nf64.load offset=40\nlocal.set 85\nlocal.get 5\nf64.load offset=16\nlocal.set 86\nlocal.get 84\nlocal.get 85\nf64.mul\nlocal.set 87\nlocal.get 87\nlocal.get 86\nf64.add\nlocal.set 88\nlocal.get 5\nlocal.get 88\nf64.store offset=16\nlocal.get 5\ni32.load offset=12\nlocal.set 48\ni32.const 1\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.add\nlocal.set 50\nlocal.get 5\nlocal.get 50\ni32.store offset=12\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 5\nf64.load offset=32\nlocal.set 89\nlocal.get 5\nf64.load offset=24\nlocal.set 90\nlocal.get 5\nf64.load offset=16\nlocal.set 91\nlocal.get 90\nlocal.get 91\nf64.mul\nlocal.set 92\nlocal.get 92\nf64.sqrt\nlocal.set 93\nlocal.get 89\nlocal.get 93\nf64.div\nlocal.set 94\nlocal.get 5\nlocal.get 94\nf64.store offset=72\nlocal.get 5\nf64.load offset=72\nlocal.set 95\nlocal.get 95\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_330",
        "query_text": "The function takes two integers as input and returns an integer. It computes a divisor by raising 2 to the power of the second input, then checks whether the first input is divisible by this divisor. If it is divisible, the function returns 1; otherwise, it returns 0.",
        "code_id": "c_group_1_id_330",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=20\ni32.const 1\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=16\ni32.const 0\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store offset=12\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=12\nlocal.set 8\nlocal.get 4\ni32.load offset=24\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=16\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.store offset=16\nlocal.get 4\ni32.load offset=12\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 4\nlocal.get 18\ni32.store offset=12\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 19\nlocal.get 4\ni32.load offset=16\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.rem_s\nlocal.set 21\nblock  ;; label = @1\nlocal.get 21\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 0\nlocal.set 22\nlocal.get 4\nlocal.get 22\ni32.store offset=20\nend\nlocal.get 4\ni32.load offset=20\nlocal.set 23\nlocal.get 23\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_331",
        "query_text": "The function takes a 64-bit unsigned integer as input and returns an integer that corresponds to the number of digits in that number. Internally, it leverages a precomputed lookup table that maps bit-level information to an initial digit count estimate, and it uses a table of powers of 10 to refine this count. The method avoids explicit loops or recursion, thereby optimizing performance. The output value ranges from 1 to 20, depending on the size of the input number.",
        "code_id": "c_group_1_id_331",
        "code_text": "(func (;1;) (type 2) (param i64) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 256\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni64.store offset=248\ni32.const 0\nlocal.set 4\nlocal.get 4\ni64.load offset=65592\nlocal.set 43\ni32.const 232\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\nlocal.get 43\ni64.store\nlocal.get 4\ni64.load offset=65584\nlocal.set 44\ni32.const 224\nlocal.set 7\nlocal.get 3\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\nlocal.get 44\ni64.store\nlocal.get 4\ni64.load offset=65576\nlocal.set 45\ni32.const 216\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nlocal.get 45\ni64.store\nlocal.get 4\ni64.load offset=65568\nlocal.set 46\ni32.const 208\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nlocal.get 46\ni64.store\nlocal.get 4\ni64.load offset=65560\nlocal.set 47\ni32.const 200\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\nlocal.get 47\ni64.store\nlocal.get 4\ni64.load offset=65552\nlocal.set 48\ni32.const 192\nlocal.set 15\nlocal.get 3\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\nlocal.get 48\ni64.store\nlocal.get 4\ni64.load offset=65544\nlocal.set 49\nlocal.get 3\nlocal.get 49\ni64.store offset=184\nlocal.get 4\ni64.load offset=65536\nlocal.set 50\nlocal.get 3\nlocal.get 50\ni64.store offset=176\nlocal.get 3\ni64.load offset=248\nlocal.set 51\ni64.const 1\nlocal.set 52\nlocal.get 51\nlocal.get 52\ni64.or\nlocal.set 53\nlocal.get 53\ni64.clz\nlocal.set 54\nlocal.get 54\ni32.wrap_i64\nlocal.set 17\ni32.const 63\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.xor\nlocal.set 19\ni32.const 176\nlocal.set 20\nlocal.get 3\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nlocal.set 22\nlocal.get 22\nlocal.get 19\ni32.add\nlocal.set 23\nlocal.get 23\ni32.load8_u\nlocal.set 24\nlocal.get 3\nlocal.get 24\ni32.store8 offset=175\ni32.const 65600\nlocal.set 25\ni32.const 168\nlocal.set 26\nlocal.get 3\nlocal.get 25\nlocal.get 26\ncall 3\ndrop\nlocal.get 3\ni32.load8_u offset=175\nlocal.set 27\ni32.const 255\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.and\nlocal.set 29\nlocal.get 3\ni64.load offset=248\nlocal.set 55\nlocal.get 3\ni32.load8_u offset=175\nlocal.set 30\ni32.const 255\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nlocal.get 3\nlocal.set 33\ni32.const 3\nlocal.set 34\nlocal.get 32\nlocal.get 34\ni32.shl\nlocal.set 35\nlocal.get 33\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 36\ni64.load\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni64.lt_u\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.and\nlocal.set 39\nlocal.get 29\nlocal.get 39\ni32.sub\nlocal.set 40\ni32.const 256\nlocal.set 41\nlocal.get 3\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 42\nglobal.set 0\nlocal.get 40\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_332",
        "query_text": "The function accepts two 64-bit unsigned integers as inputs and returns a 64-bit unsigned integer output computed as the high-order 64 bits of their product. If the system provides native support for 128-bit integers, the function multiplies the inputs directly, shifts the result right by 64 bits to obtain the high-order portion, and performs a conditional adjustment based on the sign bit. Otherwise, the function manually performs the multiplication by splitting each input into higher and lower 32-bit segments, calculates the respective partial products, and combines them\u2014taking into account necessary carry-overs\u2014to yield the correct high-order bits of the overall product.",
        "code_id": "c_group_1_id_332",
        "code_text": "(func (;1;) (type 2) (param i64 i64) (result i64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 2\ni32.const 64\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni64.store offset=56\nlocal.get 4\nlocal.get 1\ni64.store offset=48\nlocal.get 4\ni64.load offset=56\nlocal.set 14\nlocal.get 4\ni64.load offset=48\nlocal.set 15\ni64.const 0\nlocal.set 16\ni32.const 8\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\nlocal.get 14\nlocal.get 16\nlocal.get 15\nlocal.get 16\ncall 3\ni32.const 16\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\ni64.load\nlocal.set 17\nlocal.get 4\ni64.load offset=8\nlocal.set 18\nlocal.get 4\nlocal.get 17\ni64.store offset=40\nlocal.get 4\nlocal.get 18\ni64.store offset=32\nlocal.get 4\ni64.load offset=40\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni64.store offset=24\nlocal.get 4\ni64.load offset=32\nlocal.set 20\ni64.const -9223372036854775808\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni64.and\nlocal.set 22\ni64.const 0\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni64.ne\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 11\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni64.load offset=24\nlocal.set 24\ni64.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni64.add\nlocal.set 26\nlocal.get 26\nlocal.set 27\nbr 1 (;@1;)\nend\nlocal.get 4\ni64.load offset=24\nlocal.set 28\nlocal.get 28\nlocal.set 27\nend\nlocal.get 27\nlocal.set 29\ni32.const 64\nlocal.set 12\nlocal.get 4\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nglobal.set 0\nlocal.get 29\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_333",
        "query_text": "The function accepts a constant character pointer as input, representing a path to a directory. It checks if a directory actually exists at the specified path by inspecting the file system attributes of the path. If the path corresponds to an existing directory, the function returns 1; otherwise, if the directory does not exist or if the path points to a non-directory object, it returns 0. The input is of type const char*, and the output is an integer indicating the existence of a directory.",
        "code_id": "c_group_1_id_333",
        "code_text": "(func (;1;) (type 3) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 112\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=104\nlocal.get 3\ni32.load offset=104\nlocal.set 4\ni32.const 8\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\nlocal.set 7\nlocal.get 4\nlocal.get 7\ncall 9\nlocal.set 8\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 8\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=108\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 10\ni32.const 16384\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nblock  ;; label = @2\nlocal.get 12\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 1\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.store offset=108\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 14\nlocal.get 3\nlocal.get 14\ni32.store offset=108\nend\nlocal.get 3\ni32.load offset=108\nlocal.set 15\ni32.const 112\nlocal.set 16\nlocal.get 3\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nglobal.set 0\nlocal.get 15\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_334",
        "query_text": "The function accepts two arrays of double-precision floating-point numbers and an integer that indicates the number of elements in each array. It computes the relative error between the arrays by first calculating the square root of the cumulative squared differences between corresponding elements in the arrays, and then dividing this value by the square root of the cumulative squared values of the elements in the first array. The function returns the resulting double-precision floating-point number as the relative error.",
        "code_id": "c_group_1_id_334",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\ni32.const 0\nlocal.set 6\nlocal.get 6\nf64.convert_i32_s\nlocal.set 47\nlocal.get 5\nlocal.get 47\nf64.store offset=8\ni32.const 0\nlocal.set 7\nlocal.get 7\nf64.convert_i32_s\nlocal.set 48\nlocal.get 5\nlocal.get 48\nf64.store\ni32.const 0\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.store offset=16\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=16\nlocal.set 9\nlocal.get 5\ni32.load offset=20\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.lt_s\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 13\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=28\nlocal.set 14\nlocal.get 5\ni32.load offset=16\nlocal.set 15\ni32.const 3\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.shl\nlocal.set 17\nlocal.get 14\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 18\nf64.load\nlocal.set 49\nlocal.get 5\ni32.load offset=24\nlocal.set 19\nlocal.get 5\ni32.load offset=16\nlocal.set 20\ni32.const 3\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.shl\nlocal.set 22\nlocal.get 19\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 23\nf64.load\nlocal.set 50\nlocal.get 49\nlocal.get 50\nf64.sub\nlocal.set 51\nlocal.get 5\ni32.load offset=28\nlocal.set 24\nlocal.get 5\ni32.load offset=16\nlocal.set 25\ni32.const 3\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.shl\nlocal.set 27\nlocal.get 24\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 28\nf64.load\nlocal.set 52\nlocal.get 5\ni32.load offset=24\nlocal.set 29\nlocal.get 5\ni32.load offset=16\nlocal.set 30\ni32.const 3\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.shl\nlocal.set 32\nlocal.get 29\nlocal.get 32\ni32.add\nlocal.set 33\nlocal.get 33\nf64.load\nlocal.set 53\nlocal.get 52\nlocal.get 53\nf64.sub\nlocal.set 54\nlocal.get 5\nf64.load offset=8\nlocal.set 55\nlocal.get 51\nlocal.get 54\nf64.mul\nlocal.set 56\nlocal.get 56\nlocal.get 55\nf64.add\nlocal.set 57\nlocal.get 5\nlocal.get 57\nf64.store offset=8\nlocal.get 5\ni32.load offset=28\nlocal.set 34\nlocal.get 5\ni32.load offset=16\nlocal.set 35\ni32.const 3\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.shl\nlocal.set 37\nlocal.get 34\nlocal.get 37\ni32.add\nlocal.set 38\nlocal.get 38\nf64.load\nlocal.set 58\nlocal.get 5\ni32.load offset=28\nlocal.set 39\nlocal.get 5\ni32.load offset=16\nlocal.set 40\ni32.const 3\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.shl\nlocal.set 42\nlocal.get 39\nlocal.get 42\ni32.add\nlocal.set 43\nlocal.get 43\nf64.load\nlocal.set 59\nlocal.get 5\nf64.load\nlocal.set 60\nlocal.get 58\nlocal.get 59\nf64.mul\nlocal.set 61\nlocal.get 61\nlocal.get 60\nf64.add\nlocal.set 62\nlocal.get 5\nlocal.get 62\nf64.store\nlocal.get 5\ni32.load offset=16\nlocal.set 44\ni32.const 1\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.add\nlocal.set 46\nlocal.get 5\nlocal.get 46\ni32.store offset=16\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 5\nf64.load offset=8\nlocal.set 63\nlocal.get 63\nf64.sqrt\nlocal.set 64\nlocal.get 5\nf64.load\nlocal.set 65\nlocal.get 65\nf64.sqrt\nlocal.set 66\nlocal.get 64\nlocal.get 66\nf64.div\nlocal.set 67\nlocal.get 67\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_335",
        "query_text": "The function accepts four parameters: a pointer to floating-point input data representing deinterleaved multi-channel audio, a pointer to a floating-point output buffer for interleaved audio, an integer specifying the number of audio frames, and an integer specifying the number of channels. It iterates over each frame and then each channel, reordering the samples from the input buffer into the output buffer so that all channel samples for a given frame are stored contiguously. The output is the interleaved audio data arranged by frame and channel.",
        "code_id": "c_group_1_id_335",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f32)\nglobal.get 0\nlocal.set 4\ni32.const 32\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nlocal.get 0\ni32.store offset=28\nlocal.get 6\nlocal.get 1\ni32.store offset=24\nlocal.get 6\nlocal.get 2\ni32.store offset=20\nlocal.get 6\nlocal.get 3\ni32.store offset=16\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.store offset=12\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 6\ni32.load offset=12\nlocal.set 8\nlocal.get 6\ni32.load offset=20\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_s\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@1;)\ni32.const 0\nlocal.set 13\nlocal.get 6\nlocal.get 13\ni32.store offset=8\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 6\ni32.load offset=8\nlocal.set 14\nlocal.get 6\ni32.load offset=16\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.lt_s\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 18\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 6\ni32.load offset=28\nlocal.set 19\nlocal.get 6\ni32.load offset=12\nlocal.set 20\nlocal.get 6\ni32.load offset=20\nlocal.set 21\nlocal.get 6\ni32.load offset=8\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.mul\nlocal.set 23\nlocal.get 20\nlocal.get 23\ni32.add\nlocal.set 24\ni32.const 2\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.shl\nlocal.set 26\nlocal.get 19\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\nf32.load\nlocal.set 43\nlocal.get 6\ni32.load offset=24\nlocal.set 28\nlocal.get 6\ni32.load offset=8\nlocal.set 29\nlocal.get 6\ni32.load offset=16\nlocal.set 30\nlocal.get 6\ni32.load offset=12\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.mul\nlocal.set 32\nlocal.get 29\nlocal.get 32\ni32.add\nlocal.set 33\ni32.const 2\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.shl\nlocal.set 35\nlocal.get 28\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 36\nlocal.get 43\nf32.store\nlocal.get 6\ni32.load offset=8\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 6\nlocal.get 39\ni32.store offset=8\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=12\nlocal.set 40\ni32.const 1\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 6\nlocal.get 42\ni32.store offset=12\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_336",
        "query_text": "The function takes two inputs: a pointer to an array of floating-point numbers and an integer representing the number of elements in the array. It initializes a floating-point variable to hold a computed total. The function then iterates sequentially through the array, squaring each element and adding the resulting value to the total. After processing every element, it returns the final computed total, which represents the sum of the squares of the array's elements.",
        "code_id": "c_group_1_id_336",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 0\nlocal.set 5\nlocal.get 5\nf64.convert_i32_s\nlocal.set 25\nlocal.get 4\nlocal.get 25\nf64.store offset=16\ni32.const 0\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=12\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=12\nlocal.set 7\nlocal.get 4\ni32.load offset=24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.lt_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 4\ni32.load offset=28\nlocal.set 12\nlocal.get 4\ni32.load offset=12\nlocal.set 13\ni32.const 3\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 12\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\nf64.load\nlocal.set 26\nlocal.get 4\ni32.load offset=28\nlocal.set 17\nlocal.get 4\ni32.load offset=12\nlocal.set 18\ni32.const 3\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.shl\nlocal.set 20\nlocal.get 17\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nf64.load\nlocal.set 27\nlocal.get 4\nf64.load offset=16\nlocal.set 28\nlocal.get 26\nlocal.get 27\nf64.mul\nlocal.set 29\nlocal.get 29\nlocal.get 28\nf64.add\nlocal.set 30\nlocal.get 4\nlocal.get 30\nf64.store offset=16\nlocal.get 4\ni32.load offset=12\nlocal.set 22\ni32.const 1\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 4\nlocal.get 24\ni32.store offset=12\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 4\nf64.load offset=16\nlocal.set 31\nlocal.get 31\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_337",
        "query_text": "The function accepts a single parameter: a pointer to a constant character string representing the name of an environment variable. It retrieves the corresponding value for that environment variable from the system using the standard runtime library, and returns a pointer to a constant character string containing the value. If the specified environment variable is not found, the function returns a null pointer. Its primary purpose is to access the environment variable's value based on its name.",
        "code_id": "c_group_1_id_337",
        "code_text": "(func (;3;) (type 1) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 6\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_338",
        "query_text": "This function outputs a two-dimensional array formatted as text. It accepts a one-dimensional array of double-precision values representing the matrix, along with integer parameters specifying the number of rows and columns. Initially, the function prints the matrix dimensions in a \"rows x columns\" format. It then iterates through each row, prefacing the row with its index and printing each element sequentially, followed by a closing row index. The result is a neatly formatted display on the console, and no value is returned.",
        "code_id": "c_group_1_id_338",
        "code_text": "(func (;2;) (type 5) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64)\nglobal.get 0\nlocal.set 3\ni32.const 80\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=76\nlocal.get 5\nlocal.get 1\ni32.store offset=72\nlocal.get 5\nlocal.get 2\ni32.store offset=68\nlocal.get 5\ni32.load offset=72\nlocal.set 6\nlocal.get 5\ni32.load offset=68\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store offset=52\nlocal.get 5\nlocal.get 6\ni32.store offset=48\ni32.const 65607\nlocal.set 8\ni32.const 48\nlocal.set 9\nlocal.get 5\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 8\nlocal.get 10\ncall 4\ndrop\ni32.const 0\nlocal.set 11\nlocal.get 5\nlocal.get 11\ni32.store offset=64\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=64\nlocal.set 12\nlocal.get 5\ni32.load offset=72\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.lt_s\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 16\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=64\nlocal.set 17\nlocal.get 5\nlocal.get 17\ni32.store offset=32\ni32.const 65594\nlocal.set 18\ni32.const 32\nlocal.set 19\nlocal.get 5\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 18\nlocal.get 20\ncall 4\ndrop\ni32.const 0\nlocal.set 21\nlocal.get 5\nlocal.get 21\ni32.store offset=60\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 5\ni32.load offset=60\nlocal.set 22\nlocal.get 5\ni32.load offset=68\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.lt_s\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nlocal.get 26\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 5\ni32.load offset=76\nlocal.set 27\nlocal.get 5\ni32.load offset=64\nlocal.set 28\nlocal.get 5\ni32.load offset=68\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.mul\nlocal.set 30\nlocal.get 5\ni32.load offset=60\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.add\nlocal.set 32\ni32.const 3\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.shl\nlocal.set 34\nlocal.get 27\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 35\nf64.load\nlocal.set 49\nlocal.get 5\nlocal.get 49\nf64.store\ni32.const 65590\nlocal.set 36\nlocal.get 36\nlocal.get 5\ncall 4\ndrop\nlocal.get 5\ni32.load offset=60\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 5\nlocal.get 39\ni32.store offset=60\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 5\ni32.load offset=64\nlocal.set 40\nlocal.get 5\nlocal.get 40\ni32.store offset=16\ni32.const 65600\nlocal.set 41\ni32.const 16\nlocal.set 42\nlocal.get 5\nlocal.get 42\ni32.add\nlocal.set 43\nlocal.get 41\nlocal.get 43\ncall 4\ndrop\nlocal.get 5\ni32.load offset=64\nlocal.set 44\ni32.const 1\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.add\nlocal.set 46\nlocal.get 5\nlocal.get 46\ni32.store offset=64\nbr 0 (;@2;)\nend\nunreachable\nend\ni32.const 80\nlocal.set 47\nlocal.get 5\nlocal.get 47\ni32.add\nlocal.set 48\nlocal.get 48\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_339",
        "query_text": "The function accepts a single 64-bit unsigned integer as input and returns a 32-bit unsigned integer. It counts the number of trailing zero bits (i.e., the consecutive zeros starting from the least significant bit) present in the binary representation of the input. The function first attempts to use platform-specific optimizations, such as compiler intrinsics, to perform this calculation efficiently. If these optimizations are unavailable, it falls back to a bitwise algorithm to determine the count. The design emphasizes both performance and portability across different platforms and compilers.",
        "code_id": "c_group_1_id_339",
        "code_text": "(func (;1;) (type 2) (param i64) (result i32)\n(local i32 i32 i32 i32 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 5\nlocal.get 5\ni64.ctz\nlocal.set 6\nlocal.get 6\ni32.wrap_i64\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_340",
        "query_text": "The function accepts an array of double-precision values along with its length. It also takes two sets of filter coefficients\u2014one for low-pass and one for high-pass filtering\u2014along with information specifying their lengths and stride values for both input and output indexing. The function applies a symmetric discrete wavelet transform on the input array. It computes two separate output arrays: one storing approximation coefficients and the other storing detail coefficients derived from the transformation. To correctly handle cases where filter indices exceed the boundaries of the input array, the function mirrors the array values. This approach ensures that every computed coefficient is based on valid, reflected data.",
        "code_id": "c_group_1_id_340",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 10\ni32.const 64\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.sub\nlocal.set 12\nlocal.get 12\nlocal.get 0\ni32.store offset=60\nlocal.get 12\nlocal.get 1\ni32.store offset=56\nlocal.get 12\nlocal.get 2\ni32.store offset=52\nlocal.get 12\nlocal.get 3\ni32.store offset=48\nlocal.get 12\nlocal.get 4\ni32.store offset=44\nlocal.get 12\nlocal.get 5\ni32.store offset=40\nlocal.get 12\nlocal.get 6\ni32.store offset=36\nlocal.get 12\nlocal.get 7\ni32.store offset=32\nlocal.get 12\nlocal.get 8\ni32.store offset=28\nlocal.get 12\nlocal.get 9\ni32.store offset=24\nlocal.get 12\ni32.load offset=44\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.store offset=8\ni32.const 0\nlocal.set 14\nlocal.get 12\nlocal.get 14\ni32.store offset=20\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 12\ni32.load offset=20\nlocal.set 15\nlocal.get 12\ni32.load offset=36\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.lt_s\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nlocal.get 19\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 12\ni32.load offset=20\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.shl\nlocal.set 22\ni32.const 1\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 12\nlocal.get 24\ni32.store offset=12\nlocal.get 12\ni32.load offset=20\nlocal.set 25\nlocal.get 12\ni32.load offset=24\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.mul\nlocal.set 27\nlocal.get 12\nlocal.get 27\ni32.store\nlocal.get 12\ni32.load offset=40\nlocal.set 28\nlocal.get 12\ni32.load\nlocal.set 29\ni32.const 3\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.shl\nlocal.set 31\nlocal.get 28\nlocal.get 31\ni32.add\nlocal.set 32\ni32.const 0\nlocal.set 33\nlocal.get 33\nf64.convert_i32_s\nlocal.set 195\nlocal.get 32\nlocal.get 195\nf64.store\nlocal.get 12\ni32.load offset=32\nlocal.set 34\nlocal.get 12\ni32.load\nlocal.set 35\ni32.const 3\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.shl\nlocal.set 37\nlocal.get 34\nlocal.get 37\ni32.add\nlocal.set 38\ni32.const 0\nlocal.set 39\nlocal.get 39\nf64.convert_i32_s\nlocal.set 196\nlocal.get 38\nlocal.get 196\nf64.store\ni32.const 0\nlocal.set 40\nlocal.get 12\nlocal.get 40\ni32.store offset=16\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 12\ni32.load offset=16\nlocal.set 41\nlocal.get 12\ni32.load offset=8\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.lt_s\nlocal.set 43\ni32.const 1\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.and\nlocal.set 45\nlocal.get 45\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 12\ni32.load offset=12\nlocal.set 46\nlocal.get 12\ni32.load offset=16\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.sub\nlocal.set 48\ni32.const 0\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.ge_s\nlocal.set 50\ni32.const 1\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.and\nlocal.set 52\nblock  ;; label = @5\nblock  ;; label = @6\nlocal.get 52\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 12\ni32.load offset=12\nlocal.set 53\nlocal.get 12\ni32.load offset=16\nlocal.set 54\nlocal.get 53\nlocal.get 54\ni32.sub\nlocal.set 55\nlocal.get 12\ni32.load offset=56\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.lt_s\nlocal.set 57\ni32.const 1\nlocal.set 58\nlocal.get 57\nlocal.get 58\ni32.and\nlocal.set 59\nlocal.get 59\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 12\ni32.load offset=12\nlocal.set 60\nlocal.get 12\ni32.load offset=16\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.sub\nlocal.set 62\nlocal.get 12\ni32.load offset=28\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.mul\nlocal.set 64\nlocal.get 12\nlocal.get 64\ni32.store offset=4\nlocal.get 12\ni32.load offset=52\nlocal.set 65\nlocal.get 12\ni32.load offset=16\nlocal.set 66\ni32.const 3\nlocal.set 67\nlocal.get 66\nlocal.get 67\ni32.shl\nlocal.set 68\nlocal.get 65\nlocal.get 68\ni32.add\nlocal.set 69\nlocal.get 69\nf64.load\nlocal.set 197\nlocal.get 12\ni32.load offset=60\nlocal.set 70\nlocal.get 12\ni32.load offset=4\nlocal.set 71\ni32.const 3\nlocal.set 72\nlocal.get 71\nlocal.get 72\ni32.shl\nlocal.set 73\nlocal.get 70\nlocal.get 73\ni32.add\nlocal.set 74\nlocal.get 74\nf64.load\nlocal.set 198\nlocal.get 12\ni32.load offset=40\nlocal.set 75\nlocal.get 12\ni32.load\nlocal.set 76\ni32.const 3\nlocal.set 77\nlocal.get 76\nlocal.get 77\ni32.shl\nlocal.set 78\nlocal.get 75\nlocal.get 78\ni32.add\nlocal.set 79\nlocal.get 79\nf64.load\nlocal.set 199\nlocal.get 197\nlocal.get 198\nf64.mul\nlocal.set 200\nlocal.get 200\nlocal.get 199\nf64.add\nlocal.set 201\nlocal.get 79\nlocal.get 201\nf64.store\nlocal.get 12\ni32.load offset=48\nlocal.set 80\nlocal.get 12\ni32.load offset=16\nlocal.set 81\ni32.const 3\nlocal.set 82\nlocal.get 81\nlocal.get 82\ni32.shl\nlocal.set 83\nlocal.get 80\nlocal.get 83\ni32.add\nlocal.set 84\nlocal.get 84\nf64.load\nlocal.set 202\nlocal.get 12\ni32.load offset=60\nlocal.set 85\nlocal.get 12\ni32.load offset=4\nlocal.set 86\ni32.const 3\nlocal.set 87\nlocal.get 86\nlocal.get 87\ni32.shl\nlocal.set 88\nlocal.get 85\nlocal.get 88\ni32.add\nlocal.set 89\nlocal.get 89\nf64.load\nlocal.set 203\nlocal.get 12\ni32.load offset=32\nlocal.set 90\nlocal.get 12\ni32.load\nlocal.set 91\ni32.const 3\nlocal.set 92\nlocal.get 91\nlocal.get 92\ni32.shl\nlocal.set 93\nlocal.get 90\nlocal.get 93\ni32.add\nlocal.set 94\nlocal.get 94\nf64.load\nlocal.set 204\nlocal.get 202\nlocal.get 203\nf64.mul\nlocal.set 205\nlocal.get 205\nlocal.get 204\nf64.add\nlocal.set 206\nlocal.get 94\nlocal.get 206\nf64.store\nbr 1 (;@5;)\nend\nlocal.get 12\ni32.load offset=12\nlocal.set 95\nlocal.get 12\ni32.load offset=16\nlocal.set 96\nlocal.get 95\nlocal.get 96\ni32.sub\nlocal.set 97\ni32.const 0\nlocal.set 98\nlocal.get 97\nlocal.get 98\ni32.lt_s\nlocal.set 99\ni32.const 1\nlocal.set 100\nlocal.get 99\nlocal.get 100\ni32.and\nlocal.set 101\nblock  ;; label = @6\nblock  ;; label = @7\nlocal.get 101\ni32.eqz\nbr_if 0 (;@7;)\nlocal.get 12\ni32.load offset=12\nlocal.set 102\ni32.const 0\nlocal.set 103\nlocal.get 103\nlocal.get 102\ni32.sub\nlocal.set 104\nlocal.get 12\ni32.load offset=16\nlocal.set 105\nlocal.get 104\nlocal.get 105\ni32.add\nlocal.set 106\ni32.const 1\nlocal.set 107\nlocal.get 106\nlocal.get 107\ni32.sub\nlocal.set 108\nlocal.get 12\ni32.load offset=28\nlocal.set 109\nlocal.get 108\nlocal.get 109\ni32.mul\nlocal.set 110\nlocal.get 12\nlocal.get 110\ni32.store offset=4\nlocal.get 12\ni32.load offset=52\nlocal.set 111\nlocal.get 12\ni32.load offset=16\nlocal.set 112\ni32.const 3\nlocal.set 113\nlocal.get 112\nlocal.get 113\ni32.shl\nlocal.set 114\nlocal.get 111\nlocal.get 114\ni32.add\nlocal.set 115\nlocal.get 115\nf64.load\nlocal.set 207\nlocal.get 12\ni32.load offset=60\nlocal.set 116\nlocal.get 12\ni32.load offset=4\nlocal.set 117\ni32.const 3\nlocal.set 118\nlocal.get 117\nlocal.get 118\ni32.shl\nlocal.set 119\nlocal.get 116\nlocal.get 119\ni32.add\nlocal.set 120\nlocal.get 120\nf64.load\nlocal.set 208\nlocal.get 12\ni32.load offset=40\nlocal.set 121\nlocal.get 12\ni32.load\nlocal.set 122\ni32.const 3\nlocal.set 123\nlocal.get 122\nlocal.get 123\ni32.shl\nlocal.set 124\nlocal.get 121\nlocal.get 124\ni32.add\nlocal.set 125\nlocal.get 125\nf64.load\nlocal.set 209\nlocal.get 207\nlocal.get 208\nf64.mul\nlocal.set 210\nlocal.get 210\nlocal.get 209\nf64.add\nlocal.set 211\nlocal.get 125\nlocal.get 211\nf64.store\nlocal.get 12\ni32.load offset=48\nlocal.set 126\nlocal.get 12\ni32.load offset=16\nlocal.set 127\ni32.const 3\nlocal.set 128\nlocal.get 127\nlocal.get 128\ni32.shl\nlocal.set 129\nlocal.get 126\nlocal.get 129\ni32.add\nlocal.set 130\nlocal.get 130\nf64.load\nlocal.set 212\nlocal.get 12\ni32.load offset=60\nlocal.set 131\nlocal.get 12\ni32.load offset=4\nlocal.set 132\ni32.const 3\nlocal.set 133\nlocal.get 132\nlocal.get 133\ni32.shl\nlocal.set 134\nlocal.get 131\nlocal.get 134\ni32.add\nlocal.set 135\nlocal.get 135\nf64.load\nlocal.set 213\nlocal.get 12\ni32.load offset=32\nlocal.set 136\nlocal.get 12\ni32.load\nlocal.set 137\ni32.const 3\nlocal.set 138\nlocal.get 137\nlocal.get 138\ni32.shl\nlocal.set 139\nlocal.get 136\nlocal.get 139\ni32.add\nlocal.set 140\nlocal.get 140\nf64.load\nlocal.set 214\nlocal.get 212\nlocal.get 213\nf64.mul\nlocal.set 215\nlocal.get 215\nlocal.get 214\nf64.add\nlocal.set 216\nlocal.get 140\nlocal.get 216\nf64.store\nbr 1 (;@6;)\nend\nlocal.get 12\ni32.load offset=12\nlocal.set 141\nlocal.get 12\ni32.load offset=16\nlocal.set 142\nlocal.get 141\nlocal.get 142\ni32.sub\nlocal.set 143\nlocal.get 12\ni32.load offset=56\nlocal.set 144\nlocal.get 143\nlocal.get 144\ni32.ge_s\nlocal.set 145\ni32.const 1\nlocal.set 146\nlocal.get 145\nlocal.get 146\ni32.and\nlocal.set 147\nblock  ;; label = @7\nlocal.get 147\ni32.eqz\nbr_if 0 (;@7;)\nlocal.get 12\ni32.load offset=56\nlocal.set 148\ni32.const 1\nlocal.set 149\nlocal.get 148\nlocal.get 149\ni32.shl\nlocal.set 150\nlocal.get 12\ni32.load offset=12\nlocal.set 151\nlocal.get 150\nlocal.get 151\ni32.sub\nlocal.set 152\nlocal.get 12\ni32.load offset=16\nlocal.set 153\nlocal.get 152\nlocal.get 153\ni32.add\nlocal.set 154\ni32.const 1\nlocal.set 155\nlocal.get 154\nlocal.get 155\ni32.sub\nlocal.set 156\nlocal.get 12\ni32.load offset=28\nlocal.set 157\nlocal.get 156\nlocal.get 157\ni32.mul\nlocal.set 158\nlocal.get 12\nlocal.get 158\ni32.store offset=4\nlocal.get 12\ni32.load offset=52\nlocal.set 159\nlocal.get 12\ni32.load offset=16\nlocal.set 160\ni32.const 3\nlocal.set 161\nlocal.get 160\nlocal.get 161\ni32.shl\nlocal.set 162\nlocal.get 159\nlocal.get 162\ni32.add\nlocal.set 163\nlocal.get 163\nf64.load\nlocal.set 217\nlocal.get 12\ni32.load offset=60\nlocal.set 164\nlocal.get 12\ni32.load offset=4\nlocal.set 165\ni32.const 3\nlocal.set 166\nlocal.get 165\nlocal.get 166\ni32.shl\nlocal.set 167\nlocal.get 164\nlocal.get 167\ni32.add\nlocal.set 168\nlocal.get 168\nf64.load\nlocal.set 218\nlocal.get 12\ni32.load offset=40\nlocal.set 169\nlocal.get 12\ni32.load\nlocal.set 170\ni32.const 3\nlocal.set 171\nlocal.get 170\nlocal.get 171\ni32.shl\nlocal.set 172\nlocal.get 169\nlocal.get 172\ni32.add\nlocal.set 173\nlocal.get 173\nf64.load\nlocal.set 219\nlocal.get 217\nlocal.get 218\nf64.mul\nlocal.set 220\nlocal.get 220\nlocal.get 219\nf64.add\nlocal.set 221\nlocal.get 173\nlocal.get 221\nf64.store\nlocal.get 12\ni32.load offset=48\nlocal.set 174\nlocal.get 12\ni32.load offset=16\nlocal.set 175\ni32.const 3\nlocal.set 176\nlocal.get 175\nlocal.get 176\ni32.shl\nlocal.set 177\nlocal.get 174\nlocal.get 177\ni32.add\nlocal.set 178\nlocal.get 178\nf64.load\nlocal.set 222\nlocal.get 12\ni32.load offset=60\nlocal.set 179\nlocal.get 12\ni32.load offset=4\nlocal.set 180\ni32.const 3\nlocal.set 181\nlocal.get 180\nlocal.get 181\ni32.shl\nlocal.set 182\nlocal.get 179\nlocal.get 182\ni32.add\nlocal.set 183\nlocal.get 183\nf64.load\nlocal.set 223\nlocal.get 12\ni32.load offset=32\nlocal.set 184\nlocal.get 12\ni32.load\nlocal.set 185\ni32.const 3\nlocal.set 186\nlocal.get 185\nlocal.get 186\ni32.shl\nlocal.set 187\nlocal.get 184\nlocal.get 187\ni32.add\nlocal.set 188\nlocal.get 188\nf64.load\nlocal.set 224\nlocal.get 222\nlocal.get 223\nf64.mul\nlocal.set 225\nlocal.get 225\nlocal.get 224\nf64.add\nlocal.set 226\nlocal.get 188\nlocal.get 226\nf64.store\nend\nend\nend\nlocal.get 12\ni32.load offset=16\nlocal.set 189\ni32.const 1\nlocal.set 190\nlocal.get 189\nlocal.get 190\ni32.add\nlocal.set 191\nlocal.get 12\nlocal.get 191\ni32.store offset=16\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 12\ni32.load offset=20\nlocal.set 192\ni32.const 1\nlocal.set 193\nlocal.get 192\nlocal.get 193\ni32.add\nlocal.set 194\nlocal.get 12\nlocal.get 194\ni32.store offset=20\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_341",
        "query_text": "The function accepts a single integer parameter representing a file descriptor. It calculates the size of the file by moving the file pointer to the end and capturing the resulting offset as an off_t value. If moving the file pointer fails at any point, the function prints an error message to the standard error stream and terminates the program. After determining the file size, the function resets the file pointer back to the beginning before returning the computed size.",
        "code_id": "c_group_1_id_341",
        "code_text": "(func (;5;) (type 13) (param i32) (result i64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64 i64 i64 i64 i64 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 48\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=44\nlocal.get 3\ni32.load offset=44\nlocal.set 4\ni64.const 0\nlocal.set 32\ni32.const 2\nlocal.set 5\nlocal.get 4\nlocal.get 32\nlocal.get 5\ncall 13\nlocal.set 33\nlocal.get 3\nlocal.get 33\ni64.store offset=32\nlocal.get 3\ni64.load offset=32\nlocal.set 34\ni64.const -1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni64.eq\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nblock  ;; label = @1\nlocal.get 8\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 0\nlocal.set 9\nlocal.get 9\ni32.load offset=65632\nlocal.set 10\ncall 11\nlocal.set 11\nlocal.get 11\ni32.load\nlocal.set 12\nlocal.get 12\ncall 27\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.store\ni32.const 65590\nlocal.set 14\nlocal.get 10\nlocal.get 14\nlocal.get 3\ncall 12\ndrop\ni32.const 1\nlocal.set 15\nlocal.get 15\ncall 9\nunreachable\nend\nlocal.get 3\ni32.load offset=44\nlocal.set 16\ni64.const 0\nlocal.set 36\ni32.const 0\nlocal.set 17\nlocal.get 16\nlocal.get 36\nlocal.get 17\ncall 13\nlocal.set 37\ni64.const -1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni64.eq\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\nblock  ;; label = @1\nlocal.get 20\ni32.eqz\nbr_if 0 (;@1;)\ni32.const 0\nlocal.set 21\nlocal.get 21\ni32.load offset=65632\nlocal.set 22\ncall 11\nlocal.set 23\nlocal.get 23\ni32.load\nlocal.set 24\nlocal.get 24\ncall 27\nlocal.set 25\nlocal.get 3\nlocal.get 25\ni32.store offset=16\ni32.const 65590\nlocal.set 26\ni32.const 16\nlocal.set 27\nlocal.get 3\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 22\nlocal.get 26\nlocal.get 28\ncall 12\ndrop\ni32.const 1\nlocal.set 29\nlocal.get 29\ncall 9\nunreachable\nend\nlocal.get 3\ni64.load offset=32\nlocal.set 39\ni32.const 48\nlocal.set 30\nlocal.get 3\nlocal.get 30\ni32.add\nlocal.set 31\nlocal.get 31\nglobal.set 0\nlocal.get 39\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_342",
        "query_text": "The function takes four inputs: an integer specifying the count of frequency values, a pointer to an array of double values representing these frequencies, a double value indicating the maximum amplitude, and an integer defining the length of a pre-allocated array of floating-point values for output. Initially, it computes an effective amplitude by dividing the maximum amplitude by the number of frequencies and sets all elements of the output array to zero. It then iterates over each frequency, checking that each value lies within a valid range (greater than 0 and less than 0.5). If a frequency falls outside this range, the function halts execution after outputting an error message. For every valid frequency, the function calculates a sine wave component using the frequency, a predetermined phase offset, and the effective amplitude, accumulating the result in the output array. Finally, a windowing function is applied to the entire output array to smooth the signal, and the modified array is returned as the final output.",
        "code_id": "c_group_1_id_342",
        "code_text": "(func (;3;) (type 15) (param i32 i32 f64 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f64 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 5\ni32.const 64\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.sub\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 7\nlocal.get 0\ni32.store offset=60\nlocal.get 7\nlocal.get 1\ni32.store offset=56\nlocal.get 7\nlocal.get 2\nf64.store offset=48\nlocal.get 7\nlocal.get 3\ni32.store offset=44\nlocal.get 7\nlocal.get 4\ni32.store offset=40\nlocal.get 7\nf64.load offset=48\nlocal.set 112\nlocal.get 7\ni32.load offset=60\nlocal.set 8\nlocal.get 8\nf64.convert_i32_s\nlocal.set 113\nlocal.get 112\nlocal.get 113\nf64.div\nlocal.set 114\nlocal.get 7\nlocal.get 114\nf64.store offset=24\ni32.const 0\nlocal.set 9\nlocal.get 7\nlocal.get 9\ni32.store offset=36\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 7\ni32.load offset=36\nlocal.set 10\nlocal.get 7\ni32.load offset=40\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.lt_s\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nlocal.get 14\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 7\ni32.load offset=44\nlocal.set 15\nlocal.get 7\ni32.load offset=36\nlocal.set 16\ni32.const 2\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.shl\nlocal.set 18\nlocal.get 15\nlocal.get 18\ni32.add\nlocal.set 19\ni32.const 0\nlocal.set 20\nlocal.get 20\nf32.convert_i32_s\nlocal.set 147\nlocal.get 19\nlocal.get 147\nf32.store\nlocal.get 7\ni32.load offset=36\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 7\nlocal.get 23\ni32.store offset=36\nbr 0 (;@2;)\nend\nunreachable\nend\ni32.const 0\nlocal.set 24\nlocal.get 7\nlocal.get 24\ni32.store offset=32\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 7\ni32.load offset=32\nlocal.set 25\nlocal.get 7\ni32.load offset=60\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.lt_s\nlocal.set 27\ni32.const 1\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.and\nlocal.set 29\nlocal.get 29\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 7\ni32.load offset=60\nlocal.set 30\nlocal.get 30\nf64.convert_i32_s\nlocal.set 115\nf64.const 0x1.69e9565708efcp+1 (;=2.82743;)\nlocal.set 116\nlocal.get 116\nlocal.get 115\nf64.div\nlocal.set 117\nlocal.get 7\nlocal.get 117\nf64.store offset=16\nlocal.get 7\ni32.load offset=56\nlocal.set 31\nlocal.get 7\ni32.load offset=32\nlocal.set 32\ni32.const 3\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.shl\nlocal.set 34\nlocal.get 31\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 35\nf64.load\nlocal.set 118\ni32.const 0\nlocal.set 36\nlocal.get 36\nf64.convert_i32_s\nlocal.set 119\nlocal.get 118\nlocal.get 119\nf64.le\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.and\nlocal.set 39\nblock  ;; label = @3\nblock  ;; label = @4\nlocal.get 39\nbr_if 0 (;@4;)\nlocal.get 7\ni32.load offset=56\nlocal.set 40\nlocal.get 7\ni32.load offset=32\nlocal.set 41\ni32.const 3\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.shl\nlocal.set 43\nlocal.get 40\nlocal.get 43\ni32.add\nlocal.set 44\nlocal.get 44\nf64.load\nlocal.set 120\nf64.const 0x1p-1 (;=0.5;)\nlocal.set 121\nlocal.get 120\nlocal.get 121\nf64.ge\nlocal.set 45\ni32.const 1\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.and\nlocal.set 47\nlocal.get 47\ni32.eqz\nbr_if 1 (;@3;)\nend\nlocal.get 7\ni32.load offset=32\nlocal.set 48\nlocal.get 7\ni32.load offset=56\nlocal.set 49\nlocal.get 7\ni32.load offset=32\nlocal.set 50\ni32.const 3\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.shl\nlocal.set 52\nlocal.get 49\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\nf64.load\nlocal.set 122\nlocal.get 7\nlocal.get 122\nf64.store offset=8\nlocal.get 7\nlocal.get 48\ni32.store offset=4\ni32.const 65565\nlocal.set 54\nlocal.get 7\nlocal.get 54\ni32.store\ni32.const 65668\nlocal.set 55\nlocal.get 55\nlocal.get 7\ncall 15\ndrop\ni32.const 1\nlocal.set 56\nlocal.get 56\ncall 7\nunreachable\nend\ni32.const 0\nlocal.set 57\nlocal.get 7\nlocal.get 57\ni32.store offset=36\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 7\ni32.load offset=36\nlocal.set 58\nlocal.get 7\ni32.load offset=40\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.lt_s\nlocal.set 60\ni32.const 1\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.and\nlocal.set 62\nlocal.get 62\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 7\ni32.load offset=44\nlocal.set 63\nlocal.get 7\ni32.load offset=36\nlocal.set 64\ni32.const 2\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.shl\nlocal.set 66\nlocal.get 63\nlocal.get 66\ni32.add\nlocal.set 67\nlocal.get 67\nf32.load\nlocal.set 148\nlocal.get 148\nf64.promote_f32\nlocal.set 123\nlocal.get 7\nf64.load offset=24\nlocal.set 124\nlocal.get 7\ni32.load offset=56\nlocal.set 68\nlocal.get 7\ni32.load offset=32\nlocal.set 69\ni32.const 3\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.shl\nlocal.set 71\nlocal.get 68\nlocal.get 71\ni32.add\nlocal.set 72\nlocal.get 72\nf64.load\nlocal.set 125\ni32.const 1\nlocal.set 73\nlocal.get 64\nlocal.get 73\ni32.shl\nlocal.set 74\nlocal.get 74\nf64.convert_i32_s\nlocal.set 126\nlocal.get 125\nlocal.get 126\nf64.mul\nlocal.set 127\nlocal.get 7\nf64.load offset=16\nlocal.set 128\nf64.const 0x1.921fb54442d18p+1 (;=3.14159;)\nlocal.set 129\nlocal.get 127\nlocal.get 129\nf64.mul\nlocal.set 130\nlocal.get 130\nlocal.get 128\nf64.add\nlocal.set 131\nlocal.get 131\ncall 17\nlocal.set 132\nlocal.get 124\nlocal.get 132\nf64.mul\nlocal.set 133\nlocal.get 133\nlocal.get 123\nf64.add\nlocal.set 134\nlocal.get 134\nf32.demote_f64\nlocal.set 149\nlocal.get 7\ni32.load offset=44\nlocal.set 75\nlocal.get 7\ni32.load offset=36\nlocal.set 76\ni32.const 2\nlocal.set 77\nlocal.get 76\nlocal.get 77\ni32.shl\nlocal.set 78\nlocal.get 75\nlocal.get 78\ni32.add\nlocal.set 79\nlocal.get 79\nlocal.get 149\nf32.store\nlocal.get 7\ni32.load offset=36\nlocal.set 80\ni32.const 1\nlocal.set 81\nlocal.get 80\nlocal.get 81\ni32.add\nlocal.set 82\nlocal.get 7\nlocal.get 82\ni32.store offset=36\nbr 0 (;@4;)\nend\nunreachable\nend\nlocal.get 7\ni32.load offset=32\nlocal.set 83\ni32.const 1\nlocal.set 84\nlocal.get 83\nlocal.get 84\ni32.add\nlocal.set 85\nlocal.get 7\nlocal.get 85\ni32.store offset=32\nbr 0 (;@2;)\nend\nunreachable\nend\ni32.const 0\nlocal.set 86\nlocal.get 7\nlocal.get 86\ni32.store offset=36\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 7\ni32.load offset=36\nlocal.set 87\nlocal.get 7\ni32.load offset=40\nlocal.set 88\nlocal.get 87\nlocal.get 88\ni32.lt_s\nlocal.set 89\ni32.const 1\nlocal.set 90\nlocal.get 89\nlocal.get 90\ni32.and\nlocal.set 91\nlocal.get 91\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 7\ni32.load offset=44\nlocal.set 92\nlocal.get 7\ni32.load offset=36\nlocal.set 93\ni32.const 2\nlocal.set 94\nlocal.get 93\nlocal.get 94\ni32.shl\nlocal.set 95\nlocal.get 92\nlocal.get 95\ni32.add\nlocal.set 96\nlocal.get 96\nf32.load\nlocal.set 150\nlocal.get 150\nf64.promote_f32\nlocal.set 135\ni32.const 1\nlocal.set 97\nlocal.get 93\nlocal.get 97\ni32.shl\nlocal.set 98\nlocal.get 98\nf64.convert_i32_s\nlocal.set 136\nf64.const 0x1.921fb54442d18p+1 (;=3.14159;)\nlocal.set 137\nlocal.get 136\nlocal.get 137\nf64.mul\nlocal.set 138\nlocal.get 7\ni32.load offset=40\nlocal.set 99\ni32.const -1\nlocal.set 100\nlocal.get 99\nlocal.get 100\ni32.add\nlocal.set 101\nlocal.get 101\nf64.convert_i32_s\nlocal.set 139\nlocal.get 138\nlocal.get 139\nf64.div\nlocal.set 140\nlocal.get 140\ncall 13\nlocal.set 141\nf64.const -0x1p-1 (;=-0.5;)\nlocal.set 142\nlocal.get 141\nlocal.get 142\nf64.mul\nlocal.set 143\nf64.const 0x1p-1 (;=0.5;)\nlocal.set 144\nlocal.get 143\nlocal.get 144\nf64.add\nlocal.set 145\nlocal.get 135\nlocal.get 145\nf64.mul\nlocal.set 146\nlocal.get 146\nf32.demote_f64\nlocal.set 151\nlocal.get 7\ni32.load offset=44\nlocal.set 102\nlocal.get 7\ni32.load offset=36\nlocal.set 103\ni32.const 2\nlocal.set 104\nlocal.get 103\nlocal.get 104\ni32.shl\nlocal.set 105\nlocal.get 102\nlocal.get 105\ni32.add\nlocal.set 106\nlocal.get 106\nlocal.get 151\nf32.store\nlocal.get 7\ni32.load offset=36\nlocal.set 107\ni32.const 1\nlocal.set 108\nlocal.get 107\nlocal.get 108\ni32.add\nlocal.set 109\nlocal.get 7\nlocal.get 109\ni32.store offset=36\nbr 0 (;@2;)\nend\nunreachable\nend\ni32.const 64\nlocal.set 110\nlocal.get 7\nlocal.get 110\ni32.add\nlocal.set 111\nlocal.get 111\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_343",
        "query_text": "The function accepts two generic pointers of type const void* as inputs and returns an integer. It compares the memory addresses pointed to by the two input parameters. If the addresses differ, the function yields an integer value of 1; if the addresses are identical, it yields 0. The input parameters are generic pointers (const void*), and the output is an integer reflecting whether the pointers reference different memory locations.",
        "code_id": "c_group_1_id_343",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.eq\nlocal.set 7\ni32.const -1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.xor\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_344",
        "query_text": "The function takes a 32-bit unsigned integer as input and returns a 32-bit unsigned integer as output. It reverses the byte order of the input value\u2014transforming the first byte into the last, the second byte into the third, the third byte into the second, and the last byte into the first\u2014effectively swapping between big-endian and little-endian representations. This is accomplished by isolating and rearranging the individual bytes using bitwise operations.",
        "code_id": "c_group_1_id_344",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 255\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\ni32.const 24\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.shl\nlocal.set 8\nlocal.get 3\ni32.load offset=12\nlocal.set 9\ni32.const 65280\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\ni32.const 8\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.shl\nlocal.set 13\nlocal.get 8\nlocal.get 13\ni32.or\nlocal.set 14\nlocal.get 3\ni32.load offset=12\nlocal.set 15\ni32.const 16711680\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.and\nlocal.set 17\ni32.const 8\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.shr_u\nlocal.set 19\nlocal.get 14\nlocal.get 19\ni32.or\nlocal.set 20\nlocal.get 3\ni32.load offset=12\nlocal.set 21\ni32.const 24\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.shr_u\nlocal.set 23\nlocal.get 20\nlocal.get 23\ni32.or\nlocal.set 24\nlocal.get 24\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_345",
        "query_text": "The function takes no input parameters and returns a constant reference to a locale object representing the classic (or \"C\") locale. It uses a static local variable to ensure that the locale is initialized only once and then reused on subsequent calls, providing an efficient, shared access point to the minimal default locale settings.",
        "code_id": "c_group_1_id_345",
        "code_text": "(func (;7;) (type 11) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ncall 845\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\ni32.const 16\nlocal.set 5\nlocal.get 2\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\nglobal.set 0\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_346",
        "query_text": "The function receives two strings as inputs and returns a boolean value. It begins by verifying that the length of the first string is at least as long as the second (serving as the suffix). If this condition is met, the function compares the characters at the end of the first string with those of the suffix by iterating over them in reverse order. The function ultimately returns true if all corresponding characters match, indicating that the first string indeed ends with the provided suffix; otherwise, it returns false.",
        "code_id": "c_group_1_id_346",
        "code_text": "(func (;1;) (type 1) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\nlocal.get 4\ni32.load offset=28\nlocal.set 5\nlocal.get 5\ncall 2\nlocal.set 6\nlocal.get 4\ni32.load offset=24\nlocal.set 7\nlocal.get 7\ncall 2\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.ge_u\nlocal.set 9\ni32.const 0\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 9\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 10\nlocal.set 13\nblock  ;; label = @1\nlocal.get 12\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 4\ni32.load offset=24\nlocal.set 14\nlocal.get 14\ncall 3\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 16\nlocal.get 16\ncall 4\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.store offset=16\nlocal.get 4\ni32.load offset=28\nlocal.set 18\nlocal.get 18\ncall 3\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.store offset=12\nlocal.get 4\ni32.load offset=20\nlocal.set 20\nlocal.get 4\ni32.load offset=16\nlocal.set 21\nlocal.get 4\ni32.load offset=12\nlocal.set 22\nlocal.get 20\nlocal.get 21\nlocal.get 22\ncall 5\nlocal.set 23\nlocal.get 23\nlocal.set 13\nend\nlocal.get 13\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\ni32.const 32\nlocal.set 27\nlocal.get 4\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 28\nglobal.set 0\nlocal.get 26\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_348",
        "query_text": "The function takes a constant character string as input and does not return any value. Its sole purpose is to immediately trigger an exception by throwing an instance of a memory allocation failure exception, without utilizing the provided message.",
        "code_id": "c_group_1_id_348",
        "code_text": "(func (;2;) (type 0) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 4\nlocal.set 4\nlocal.get 4\ncall 16\nlocal.set 5\nlocal.get 5\ncall 39\ndrop\ni32.const 65876\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 5\nlocal.get 6\nlocal.get 7\ncall 6\nunreachable)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_349",
        "query_text": "The function takes a single character as input and determines if it is a lowercase letter according to the ASCII standard. It returns a boolean value that is true if the character falls within the range of lowercase letters ('a' to 'z'); otherwise, it returns false.",
        "code_id": "c_group_1_id_349",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.shr_s\nlocal.set 7\ni32.const 97\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.le_s\nlocal.set 9\ni32.const 0\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 9\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 10\nlocal.set 13\nblock  ;; label = @1\nlocal.get 12\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 14\ni32.const 24\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 16\nlocal.get 15\ni32.shr_s\nlocal.set 17\ni32.const 122\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.le_s\nlocal.set 19\nlocal.get 19\nlocal.set 13\nend\nlocal.get 13\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 22\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_350",
        "query_text": "The function accepts a single character as input and determines whether its value lies between 'A' and 'Z', inclusive. It returns true if the character is uppercase and false otherwise, effectively using the ASCII ordering of characters to perform the check.",
        "code_id": "c_group_1_id_350",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.shr_s\nlocal.set 7\ni32.const 65\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.le_s\nlocal.set 9\ni32.const 0\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 9\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 10\nlocal.set 13\nblock  ;; label = @1\nlocal.get 12\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 14\ni32.const 24\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 16\nlocal.get 15\ni32.shr_s\nlocal.set 17\ni32.const 90\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.le_s\nlocal.set 19\nlocal.get 19\nlocal.set 13\nend\nlocal.get 13\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.and\nlocal.set 22\nlocal.get 22\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_351",
        "query_text": "The function accepts a character and returns a boolean. It assesses whether the character is a trailing byte in a UTF-8 sequence by examining if its two most significant bits conform to the binary pattern 10. The character is treated as part of a potential multi-byte encoding, and if the bit pattern matches, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_351",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.shr_s\nlocal.set 7\ni32.const 192\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\ni32.const 128\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.eq\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_352",
        "query_text": "This function accepts an integer input that represents a Unicode code point and converts it into a UTF-16 surrogate pair. It generates the high surrogate by right-shifting the input and combining it with an offset constant, while the low surrogate is produced by applying a bitmask to the input and then merging it with a fixed bit pattern. The two 16-bit values, representing the high and low surrogates respectively, are returned together as a pair, thus ensuring proper encoding of characters outside the Basic Multilingual Plane according to the UTF-16 standard.",
        "code_id": "c_group_1_id_352",
        "code_text": "(func (;1;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 1\ni32.store offset=12\ni32.const 55232\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 6\ni32.const 10\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.shr_s\nlocal.set 8\ni32.const 55232\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.or\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.store offset=4\nlocal.get 4\ni32.load offset=12\nlocal.set 11\ni32.const 1023\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\ni32.const 56320\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.or\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.store\ni32.const 4\nlocal.set 16\nlocal.get 4\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nlocal.set 18\nlocal.get 4\nlocal.set 19\nlocal.get 0\nlocal.get 18\nlocal.get 19\ncall 2\ndrop\ni32.const 16\nlocal.set 20\nlocal.get 4\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_353",
        "query_text": "The function converts an unsigned integer input into a single-character string output. It casts the unsigned integer to a character and constructs a new string comprised of that character. The output is of type std::string, encapsulating the converted character.",
        "code_id": "c_group_1_id_353",
        "code_text": "(func (;2;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 1\nlocal.set 6\ni32.const 24\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.shl\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.shr_s\nlocal.set 9\nlocal.get 0\nlocal.get 6\nlocal.get 9\ncall 3\ndrop\ni32.const 16\nlocal.set 10\nlocal.get 4\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 11\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_354",
        "query_text": "The function does not return any value and accepts no input parameters. When called, it prints a usage guide to the standard error stream, describing the expected command-line arguments for a program. Specifically, the message outlines that the program may be invoked with an optional numeric argument, a boolean flag specified as either a short or a long option, and an optional filename.",
        "code_id": "c_group_1_id_354",
        "code_text": "(func (;8;) (type 7)\n(local i32 i32)\ni32.const 83024\nlocal.set 0\ni32.const 66152\nlocal.set 1\nlocal.get 0\nlocal.get 1\ncall 9\ndrop\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_355",
        "query_text": "The function takes an integer as input and returns a constant string pointer. It checks the input value against a set of predefined error codes and returns the corresponding error message. If the input matches one of the specific error codes, the function outputs the associated message. Otherwise, if the input is a negative value, it returns \"Unknown error code\"; if the input is non-negative, it returns \"Success\". The input type is int, and the output type is a constant char pointer.",
        "code_id": "c_group_1_id_355",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 4\ni32.const 4\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.add\nlocal.set 6\ni32.const 3\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.gt_u\ndrop\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nblock  ;; label = @4\nblock  ;; label = @5\nblock  ;; label = @6\nlocal.get 6\nbr_table 1 (;@5;) 3 (;@3;) 2 (;@4;) 0 (;@6;) 4 (;@2;)\nend\ni32.const 65536\nlocal.set 8\nlocal.get 3\nlocal.get 8\ni32.store offset=12\nbr 4 (;@1;)\nend\ni32.const 65598\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=12\nbr 3 (;@1;)\nend\ni32.const 65550\nlocal.set 10\nlocal.get 3\nlocal.get 10\ni32.store offset=12\nbr 2 (;@1;)\nend\ni32.const 65575\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 12\ni32.const 0\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.lt_s\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nblock  ;; label = @2\nlocal.get 16\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 65612\nlocal.set 17\nlocal.get 3\nlocal.get 17\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const 65567\nlocal.set 18\nlocal.get 3\nlocal.get 18\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 19\nlocal.get 19\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_356",
        "query_text": "The function accepts two pointers to sequences of unsigned characters and compares them byte by byte. It iterates through both sequences simultaneously until it encounters a null terminator in each. During the iteration, if a byte from the first sequence is less than the corresponding byte from the second sequence, it immediately returns -1; if that byte is greater, it returns 1. If the end of both strings is reached without any differences, it returns 0 to indicate the sequences are identical. Although designed for UTF-8 encoded strings, the function performs a simple byte-wise comparison without interpreting multi-byte characters.",
        "code_id": "c_group_1_id_356",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=16\nlocal.get 4\ni32.load offset=20\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=12\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=16\nlocal.set 7\nlocal.get 7\ni32.load8_u\nlocal.set 8\ni32.const 255\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\ni32.const 0\nlocal.set 11\nlocal.get 11\nlocal.get 10\ni32.ne\nlocal.set 12\ni32.const 1\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 12\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 13\nlocal.set 16\nblock  ;; label = @3\nlocal.get 15\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=12\nlocal.set 17\nlocal.get 17\ni32.load8_u\nlocal.set 18\ni32.const 255\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\ni32.const 0\nlocal.set 21\nlocal.get 21\nlocal.get 20\ni32.ne\nlocal.set 22\nlocal.get 22\nlocal.set 16\nend\nlocal.get 16\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\nblock  ;; label = @3\nlocal.get 25\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=16\nlocal.set 26\nlocal.get 26\ni32.load8_u\nlocal.set 27\ni32.const 255\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.and\nlocal.set 29\nlocal.get 4\ni32.load offset=12\nlocal.set 30\nlocal.get 30\ni32.load8_u\nlocal.set 31\ni32.const 255\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.and\nlocal.set 33\nlocal.get 29\nlocal.get 33\ni32.lt_s\nlocal.set 34\ni32.const 1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.and\nlocal.set 36\nblock  ;; label = @4\nlocal.get 36\ni32.eqz\nbr_if 0 (;@4;)\ni32.const -1\nlocal.set 37\nlocal.get 4\nlocal.get 37\ni32.store offset=28\nbr 3 (;@1;)\nend\nlocal.get 4\ni32.load offset=16\nlocal.set 38\nlocal.get 38\ni32.load8_u\nlocal.set 39\ni32.const 255\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.and\nlocal.set 41\nlocal.get 4\ni32.load offset=12\nlocal.set 42\nlocal.get 42\ni32.load8_u\nlocal.set 43\ni32.const 255\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.and\nlocal.set 45\nlocal.get 41\nlocal.get 45\ni32.gt_s\nlocal.set 46\ni32.const 1\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.and\nlocal.set 48\nblock  ;; label = @4\nlocal.get 48\ni32.eqz\nbr_if 0 (;@4;)\ni32.const 1\nlocal.set 49\nlocal.get 4\nlocal.get 49\ni32.store offset=28\nbr 3 (;@1;)\nend\nlocal.get 4\ni32.load offset=16\nlocal.set 50\ni32.const 1\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.add\nlocal.set 52\nlocal.get 4\nlocal.get 52\ni32.store offset=16\nlocal.get 4\ni32.load offset=12\nlocal.set 53\ni32.const 1\nlocal.set 54\nlocal.get 53\nlocal.get 54\ni32.add\nlocal.set 55\nlocal.get 4\nlocal.get 55\ni32.store offset=12\nbr 1 (;@2;)\nend\nend\ni32.const 0\nlocal.set 56\nlocal.get 4\nlocal.get 56\ni32.store offset=28\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 57\nlocal.get 57\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_357",
        "query_text": "The function takes two input pointers: one pointing to a UTF-8 encoded source string and the other to a set of characters that should cause processing to cease. It iterates through the source string, decoding each UTF-8 character in turn. As it examines each character, it checks whether it appears in the reject set. If a character from the reject set is encountered, the function immediately stops processing and returns the count of UTF-8 characters processed up to that point. If it reaches the end of the source string without finding any rejected characters, it returns the total count of UTF-8 characters. The returned value is of type size_t, indicating the number of characters examined.",
        "code_id": "c_group_1_id_357",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=16\ni32.const 0\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=12\nblock  ;; label = @1\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 4\ni32.load offset=16\nlocal.set 7\nlocal.get 7\ni32.load8_u\nlocal.set 8\ni32.const 24\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.shl\nlocal.set 10\nlocal.get 10\nlocal.get 9\ni32.shr_s\nlocal.set 11\ni32.const 0\nlocal.set 12\nlocal.get 12\nlocal.get 11\ni32.ne\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 4\ni32.load offset=20\nlocal.set 16\nlocal.get 4\nlocal.get 16\ni32.store offset=8\ni32.const 0\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.store offset=4\nblock  ;; label = @4\nloop  ;; label = @5\nlocal.get 4\ni32.load offset=8\nlocal.set 18\nlocal.get 18\ni32.load8_u\nlocal.set 19\ni32.const 24\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 21\nlocal.get 20\ni32.shr_s\nlocal.set 22\ni32.const 0\nlocal.set 23\nlocal.get 23\nlocal.get 22\ni32.ne\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nlocal.get 26\ni32.eqz\nbr_if 1 (;@4;)\nlocal.get 4\ni32.load offset=8\nlocal.set 27\nlocal.get 27\ni32.load8_u\nlocal.set 28\ni32.const 24\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.shl\nlocal.set 30\nlocal.get 30\nlocal.get 29\ni32.shr_s\nlocal.set 31\ni32.const 192\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.and\nlocal.set 33\ni32.const 128\nlocal.set 34\nlocal.get 34\nlocal.get 33\ni32.ne\nlocal.set 35\ni32.const 1\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.and\nlocal.set 37\nblock  ;; label = @6\nlocal.get 37\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 4\ni32.load offset=4\nlocal.set 38\ni32.const 0\nlocal.set 39\nlocal.get 39\nlocal.get 38\ni32.lt_u\nlocal.set 40\ni32.const 1\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.and\nlocal.set 42\nlocal.get 42\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 4\ni32.load offset=12\nlocal.set 43\nlocal.get 4\nlocal.get 43\ni32.store offset=28\nbr 5 (;@1;)\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 44\nlocal.get 44\ni32.load8_u\nlocal.set 45\ni32.const 24\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.shl\nlocal.set 47\nlocal.get 47\nlocal.get 46\ni32.shr_s\nlocal.set 48\nlocal.get 4\ni32.load offset=16\nlocal.set 49\nlocal.get 4\ni32.load offset=4\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.add\nlocal.set 51\nlocal.get 51\ni32.load8_u\nlocal.set 52\ni32.const 24\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.shl\nlocal.set 54\nlocal.get 54\nlocal.get 53\ni32.shr_s\nlocal.set 55\nlocal.get 48\nlocal.get 55\ni32.eq\nlocal.set 56\ni32.const 1\nlocal.set 57\nlocal.get 56\nlocal.get 57\ni32.and\nlocal.set 58\nblock  ;; label = @6\nblock  ;; label = @7\nlocal.get 58\ni32.eqz\nbr_if 0 (;@7;)\nlocal.get 4\ni32.load offset=4\nlocal.set 59\ni32.const 1\nlocal.set 60\nlocal.get 59\nlocal.get 60\ni32.add\nlocal.set 61\nlocal.get 4\nlocal.get 61\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 62\ni32.const 1\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.add\nlocal.set 64\nlocal.get 4\nlocal.get 64\ni32.store offset=8\nbr 1 (;@6;)\nend\nloop  ;; label = @7\nlocal.get 4\ni32.load offset=8\nlocal.set 65\ni32.const 1\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.add\nlocal.set 67\nlocal.get 4\nlocal.get 67\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 68\nlocal.get 68\ni32.load8_u\nlocal.set 69\ni32.const 24\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.shl\nlocal.set 71\nlocal.get 71\nlocal.get 70\ni32.shr_s\nlocal.set 72\ni32.const 192\nlocal.set 73\nlocal.get 72\nlocal.get 73\ni32.and\nlocal.set 74\ni32.const 128\nlocal.set 75\nlocal.get 75\nlocal.get 74\ni32.eq\nlocal.set 76\ni32.const 1\nlocal.set 77\nlocal.get 76\nlocal.get 77\ni32.and\nlocal.set 78\nlocal.get 78\nbr_if 0 (;@7;)\nend\ni32.const 0\nlocal.set 79\nlocal.get 4\nlocal.get 79\ni32.store offset=4\nend\nbr 0 (;@5;)\nend\nunreachable\nend\nloop  ;; label = @4\nlocal.get 4\ni32.load offset=16\nlocal.set 80\ni32.const 1\nlocal.set 81\nlocal.get 80\nlocal.get 81\ni32.add\nlocal.set 82\nlocal.get 4\nlocal.get 82\ni32.store offset=16\nlocal.get 4\ni32.load offset=16\nlocal.set 83\nlocal.get 83\ni32.load8_u\nlocal.set 84\ni32.const 24\nlocal.set 85\nlocal.get 84\nlocal.get 85\ni32.shl\nlocal.set 86\nlocal.get 86\nlocal.get 85\ni32.shr_s\nlocal.set 87\ni32.const 192\nlocal.set 88\nlocal.get 87\nlocal.get 88\ni32.and\nlocal.set 89\ni32.const 128\nlocal.set 90\nlocal.get 90\nlocal.get 89\ni32.eq\nlocal.set 91\ni32.const 1\nlocal.set 92\nlocal.get 91\nlocal.get 92\ni32.and\nlocal.set 93\nlocal.get 93\nbr_if 0 (;@4;)\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 94\ni32.const 1\nlocal.set 95\nlocal.get 94\nlocal.get 95\ni32.add\nlocal.set 96\nlocal.get 4\nlocal.get 96\ni32.store offset=12\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 97\nlocal.get 4\nlocal.get 97\ni32.store offset=28\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 98\nlocal.get 98\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_358",
        "query_text": "The function receives three inputs: two pointers to constant memory blocks representing raw byte sequences and a size value indicating the maximum number of bytes to compare. It begins by casting the byte sequence pointers to pointers to unsigned characters so that it can process them one byte at a time. Then, it compares the two sequences lexicographically, examining corresponding bytes until either a null terminator is encountered in at least one sequence or the specified maximum byte count is reached. If it finds a byte in the first sequence that is less than its counterpart in the second, the function returns -1; if it is greater, it returns 1. If both sequences are identical for the compared portion or the comparison reaches the specified length, the function returns 0. Note that the function treats the inputs as raw byte arrays without any assumptions about character encoding.",
        "code_id": "c_group_1_id_358",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=24\nlocal.get 5\nlocal.get 1\ni32.store offset=20\nlocal.get 5\nlocal.get 2\ni32.store offset=16\nlocal.get 5\ni32.load offset=24\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store offset=12\nlocal.get 5\ni32.load offset=20\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store offset=8\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=16\nlocal.set 8\ni32.const -1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 5\nlocal.get 10\ni32.store offset=16\ni32.const 0\nlocal.set 11\nlocal.get 11\nlocal.get 8\ni32.ne\nlocal.set 12\ni32.const 0\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 12\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 13\nlocal.set 16\nblock  ;; label = @3\nlocal.get 15\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load offset=12\nlocal.set 17\nlocal.get 17\ni32.load8_u\nlocal.set 18\ni32.const 255\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\ni32.const 0\nlocal.set 21\nlocal.get 21\nlocal.get 20\ni32.ne\nlocal.set 22\ni32.const 1\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 22\nlocal.get 24\ni32.and\nlocal.set 25\nlocal.get 23\nlocal.set 26\nblock  ;; label = @4\nlocal.get 25\nbr_if 0 (;@4;)\nlocal.get 5\ni32.load offset=8\nlocal.set 27\nlocal.get 27\ni32.load8_u\nlocal.set 28\ni32.const 255\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.and\nlocal.set 30\ni32.const 0\nlocal.set 31\nlocal.get 31\nlocal.get 30\ni32.ne\nlocal.set 32\nlocal.get 32\nlocal.set 26\nend\nlocal.get 26\nlocal.set 33\nlocal.get 33\nlocal.set 16\nend\nlocal.get 16\nlocal.set 34\ni32.const 1\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.and\nlocal.set 36\nblock  ;; label = @3\nlocal.get 36\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load offset=12\nlocal.set 37\nlocal.get 37\ni32.load8_u\nlocal.set 38\ni32.const 255\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.and\nlocal.set 40\nlocal.get 5\ni32.load offset=8\nlocal.set 41\nlocal.get 41\ni32.load8_u\nlocal.set 42\ni32.const 255\nlocal.set 43\nlocal.get 42\nlocal.get 43\ni32.and\nlocal.set 44\nlocal.get 40\nlocal.get 44\ni32.lt_s\nlocal.set 45\ni32.const 1\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.and\nlocal.set 47\nblock  ;; label = @4\nlocal.get 47\ni32.eqz\nbr_if 0 (;@4;)\ni32.const -1\nlocal.set 48\nlocal.get 5\nlocal.get 48\ni32.store offset=28\nbr 3 (;@1;)\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 49\nlocal.get 49\ni32.load8_u\nlocal.set 50\ni32.const 255\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.and\nlocal.set 52\nlocal.get 5\ni32.load offset=8\nlocal.set 53\nlocal.get 53\ni32.load8_u\nlocal.set 54\ni32.const 255\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.and\nlocal.set 56\nlocal.get 52\nlocal.get 56\ni32.gt_s\nlocal.set 57\ni32.const 1\nlocal.set 58\nlocal.get 57\nlocal.get 58\ni32.and\nlocal.set 59\nblock  ;; label = @4\nlocal.get 59\ni32.eqz\nbr_if 0 (;@4;)\ni32.const 1\nlocal.set 60\nlocal.get 5\nlocal.get 60\ni32.store offset=28\nbr 3 (;@1;)\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 61\ni32.const 1\nlocal.set 62\nlocal.get 61\nlocal.get 62\ni32.add\nlocal.set 63\nlocal.get 5\nlocal.get 63\ni32.store offset=12\nlocal.get 5\ni32.load offset=8\nlocal.set 64\ni32.const 1\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.add\nlocal.set 66\nlocal.get 5\nlocal.get 66\ni32.store offset=8\nbr 1 (;@2;)\nend\nend\ni32.const 0\nlocal.set 67\nlocal.get 5\nlocal.get 67\ni32.store offset=28\nend\nlocal.get 5\ni32.load offset=28\nlocal.set 68\nlocal.get 68\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_359",
        "query_text": "This function accepts a pointer to a constant dataset that represents a sequence of characters. It determines the size of the string by iterating through the characters until a null terminator is encountered. After counting all the characters, the function increments the count by one to include the null terminator. Ultimately, it returns the computed size as a value of type size_t.",
        "code_id": "c_group_1_id_359",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\ni32.const 0\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.store offset=4\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 6\nlocal.get 3\ni32.load offset=4\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\ni32.load8_u\nlocal.set 9\ni32.const 24\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.shl\nlocal.set 11\nlocal.get 11\nlocal.get 10\ni32.shr_s\nlocal.set 12\ni32.const 0\nlocal.set 13\nlocal.get 13\nlocal.get 12\ni32.ne\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 16\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=4\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 3\nlocal.get 19\ni32.store offset=4\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 3\ni32.load offset=4\nlocal.set 20\ni32.const 1\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 3\nlocal.get 22\ni32.store offset=4\nlocal.get 3\ni32.load offset=4\nlocal.set 23\nlocal.get 23\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_360",
        "query_text": "The function takes four inputs. The first input is a pointer to a mutable character array that serves as the destination buffer, the second is an unsigned integer that specifies the maximum length of that buffer, the third is an unsigned integer indicating the number of times the source string should be concatenated, and the fourth is a pointer to a constant character array representing the source string. The function first determines the length of the source string, then verifies whether the destination buffer is large enough to accommodate the source string repeated the specified number of times. It returns an error code (-1) if the buffer size is insufficient or if the total number of characters to be written exceeds the maximum integer value. If the repetition count is zero or the source string is empty, it returns zero immediately. Otherwise, the function concatenates the source string into the destination buffer the specified number of times and finally returns the total number of characters written.",
        "code_id": "c_group_1_id_360",
        "code_text": "(func (;1;) (type 4) (param i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 4\ni32.const 48\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nglobal.set 0\nlocal.get 6\nlocal.get 0\ni32.store offset=40\nlocal.get 6\nlocal.get 1\ni32.store offset=36\nlocal.get 6\nlocal.get 2\ni32.store offset=32\nlocal.get 6\nlocal.get 3\ni32.store offset=28\nlocal.get 6\ni32.load offset=28\nlocal.set 7\nlocal.get 7\ncall 4\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.store offset=24\nlocal.get 6\ni32.load offset=36\nlocal.set 9\nlocal.get 6\ni32.load offset=32\nlocal.set 10\nlocal.get 6\ni32.load offset=24\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.mul\nlocal.set 12\nlocal.get 9\nlocal.get 12\ni32.le_u\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 15\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 16\nlocal.get 6\nlocal.get 16\ni32.store offset=44\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=32\nlocal.set 17\nblock  ;; label = @2\nlocal.get 17\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 18\nlocal.get 6\nlocal.get 18\ni32.store offset=44\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=32\nlocal.set 19\nlocal.get 6\ni32.load offset=24\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.mul\nlocal.set 21\ni32.const 2147483647\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.gt_u\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\nblock  ;; label = @2\nlocal.get 25\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 26\nlocal.get 6\nlocal.get 26\ni32.store offset=44\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=24\nlocal.set 27\nblock  ;; label = @2\nlocal.get 27\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 28\nlocal.get 6\nlocal.get 28\ni32.store offset=44\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=40\nlocal.set 29\nlocal.get 6\ni32.load offset=36\nlocal.set 30\nlocal.get 6\ni32.load offset=32\nlocal.set 31\nlocal.get 6\ni32.load offset=24\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.mul\nlocal.set 33\ni32.const 0\nlocal.set 34\nlocal.get 6\nlocal.get 34\ni32.store offset=4\nlocal.get 6\nlocal.get 33\ni32.store\ni32.const 65573\nlocal.set 35\nlocal.get 29\nlocal.get 30\nlocal.get 35\nlocal.get 6\ncall 3\nlocal.set 36\nlocal.get 6\nlocal.get 36\ni32.store offset=20\nlocal.get 6\ni32.load offset=20\nlocal.set 37\ni32.const 0\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.lt_s\nlocal.set 39\ni32.const 1\nlocal.set 40\nlocal.get 39\nlocal.get 40\ni32.and\nlocal.set 41\nblock  ;; label = @2\nlocal.get 41\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 6\ni32.load offset=20\nlocal.set 42\nlocal.get 6\nlocal.get 42\ni32.store offset=44\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 43\nlocal.get 6\nlocal.get 43\ni32.store offset=16\ni32.const 0\nlocal.set 44\nlocal.get 6\nlocal.get 44\ni32.store offset=16\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 6\ni32.load offset=16\nlocal.set 45\nlocal.get 6\ni32.load offset=32\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.lt_u\nlocal.set 47\ni32.const 1\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.and\nlocal.set 49\nlocal.get 49\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 6\ni32.load offset=28\nlocal.set 50\nlocal.get 6\nlocal.get 50\ni32.store offset=12\nblock  ;; label = @4\nloop  ;; label = @5\nlocal.get 6\ni32.load offset=12\nlocal.set 51\nlocal.get 51\ni32.load8_u\nlocal.set 52\ni32.const 0\nlocal.set 53\ni32.const 255\nlocal.set 54\nlocal.get 52\nlocal.get 54\ni32.and\nlocal.set 55\ni32.const 255\nlocal.set 56\nlocal.get 53\nlocal.get 56\ni32.and\nlocal.set 57\nlocal.get 55\nlocal.get 57\ni32.ne\nlocal.set 58\ni32.const 1\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.and\nlocal.set 60\nlocal.get 60\ni32.eqz\nbr_if 1 (;@4;)\nlocal.get 6\ni32.load offset=12\nlocal.set 61\ni32.const 1\nlocal.set 62\nlocal.get 61\nlocal.get 62\ni32.add\nlocal.set 63\nlocal.get 6\nlocal.get 63\ni32.store offset=12\nlocal.get 61\ni32.load8_u\nlocal.set 64\nlocal.get 6\ni32.load offset=40\nlocal.set 65\ni32.const 1\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.add\nlocal.set 67\nlocal.get 6\nlocal.get 67\ni32.store offset=40\nlocal.get 65\nlocal.get 64\ni32.store8\nbr 0 (;@5;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=16\nlocal.set 68\ni32.const 1\nlocal.set 69\nlocal.get 68\nlocal.get 69\ni32.add\nlocal.set 70\nlocal.get 6\nlocal.get 70\ni32.store offset=16\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=32\nlocal.set 71\nlocal.get 6\ni32.load offset=24\nlocal.set 72\nlocal.get 71\nlocal.get 72\ni32.mul\nlocal.set 73\nlocal.get 6\nlocal.get 73\ni32.store offset=44\nend\nlocal.get 6\ni32.load offset=44\nlocal.set 74\ni32.const 48\nlocal.set 75\nlocal.get 6\nlocal.get 75\ni32.add\nlocal.set 76\nlocal.get 76\nglobal.set 0\nlocal.get 74\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_361",
        "query_text": "The function accepts a buffer for wide characters, its size, a repetition count, and a narrow C-style string as input. It converts the narrow string into its wide-character representation and writes this result repeatedly into the provided buffer. The conversion handles both single-byte and multi-byte characters and validates the multi-byte sequences during processing. Prior to writing the repeated sequence, the function ensures that the resulting output fits within the allotted buffer size. On success, it returns the total number of wide characters written into the buffer; if an error occurs due to an invalid multi-byte sequence or insufficient buffer space, the function returns a negative value.",
        "code_id": "c_group_1_id_361",
        "code_text": "(func (;1;) (type 4) (param i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64)\nglobal.get 0\nlocal.set 4\ni32.const 336\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nglobal.set 0\nlocal.get 6\nlocal.get 0\ni32.store offset=328\nlocal.get 6\nlocal.get 1\ni32.store offset=324\nlocal.get 6\nlocal.get 2\ni32.store offset=320\nlocal.get 6\nlocal.get 3\ni32.store offset=316\nlocal.get 6\ni32.load offset=316\nlocal.set 7\nlocal.get 7\ncall 11\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.store offset=312\nlocal.get 6\ni32.load offset=312\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.gt_u\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 13\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 6\ni32.load offset=316\nlocal.set 14\nlocal.get 6\nlocal.get 14\ni32.store offset=308\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 6\ni32.load offset=308\nlocal.set 15\nlocal.get 15\ni32.load8_u\nlocal.set 16\ni32.const 0\nlocal.set 17\ni32.const 255\nlocal.set 18\nlocal.get 16\nlocal.get 18\ni32.and\nlocal.set 19\ni32.const 255\nlocal.set 20\nlocal.get 17\nlocal.get 20\ni32.and\nlocal.set 21\nlocal.get 19\nlocal.get 21\ni32.ne\nlocal.set 22\ni32.const 1\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.and\nlocal.set 24\nlocal.get 24\ni32.eqz\nbr_if 1 (;@3;)\nlocal.get 6\ni32.load offset=308\nlocal.set 25\nlocal.get 25\ni32.load8_u\nlocal.set 26\ni32.const 255\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.and\nlocal.set 28\ni32.const 127\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.le_s\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.and\nlocal.set 32\nblock  ;; label = @5\nblock  ;; label = @6\nlocal.get 32\ni32.eqz\nbr_if 0 (;@6;)\nlocal.get 6\ni32.load offset=308\nlocal.set 33\ni32.const 1\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 6\nlocal.get 35\ni32.store offset=308\nbr 1 (;@5;)\nend\nlocal.get 6\ni32.load offset=316\nlocal.set 36\nlocal.get 6\nlocal.get 36\ni32.store offset=44\ni64.const 0\nlocal.set 155\nlocal.get 6\nlocal.get 155\ni64.store offset=32\ni32.const 48\nlocal.set 37\nlocal.get 6\nlocal.get 37\ni32.add\nlocal.set 38\nlocal.get 38\nlocal.set 39\ni32.const 44\nlocal.set 40\nlocal.get 6\nlocal.get 40\ni32.add\nlocal.set 41\nlocal.get 41\nlocal.set 42\ni32.const 64\nlocal.set 43\ni32.const 32\nlocal.set 44\nlocal.get 6\nlocal.get 44\ni32.add\nlocal.set 45\nlocal.get 45\nlocal.set 46\nlocal.get 39\nlocal.get 42\nlocal.get 43\nlocal.get 46\ncall 4\nlocal.set 47\nlocal.get 6\nlocal.get 47\ni32.store offset=40\nlocal.get 6\ni32.load offset=40\nlocal.set 48\ni32.const -1\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.eq\nlocal.set 50\ni32.const 1\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.and\nlocal.set 52\nblock  ;; label = @6\nblock  ;; label = @7\nlocal.get 52\nbr_if 0 (;@7;)\nlocal.get 6\ni32.load offset=40\nlocal.set 53\ni32.const 1\nlocal.set 54\nlocal.get 53\nlocal.get 54\ni32.gt_u\nlocal.set 55\ni32.const 1\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.and\nlocal.set 57\nlocal.get 57\ni32.eqz\nbr_if 1 (;@6;)\nend\ni32.const -1\nlocal.set 58\nlocal.get 6\nlocal.get 58\ni32.store offset=332\nbr 5 (;@1;)\nend\nlocal.get 6\ni32.load offset=40\nlocal.set 59\ni32.const 48\nlocal.set 60\nlocal.get 6\nlocal.get 60\ni32.add\nlocal.set 61\nlocal.get 61\nlocal.set 62\ni32.const 2\nlocal.set 63\nlocal.get 59\nlocal.get 63\ni32.shl\nlocal.set 64\nlocal.get 62\nlocal.get 64\ni32.add\nlocal.set 65\ni32.const 0\nlocal.set 66\nlocal.get 65\nlocal.get 66\ni32.store\nlocal.get 6\ni32.load offset=320\nlocal.set 67\nlocal.get 6\nlocal.get 67\ni32.store offset=28\nblock  ;; label = @6\nloop  ;; label = @7\nlocal.get 6\ni32.load offset=28\nlocal.set 68\nlocal.get 68\ni32.eqz\nbr_if 1 (;@6;)\nlocal.get 6\ni32.load offset=48\nlocal.set 69\nlocal.get 6\ni32.load offset=328\nlocal.set 70\nlocal.get 70\nlocal.get 69\ni32.store\nlocal.get 6\ni32.load offset=328\nlocal.set 71\ni32.const 4\nlocal.set 72\nlocal.get 71\nlocal.get 72\ni32.add\nlocal.set 73\nlocal.get 6\nlocal.get 73\ni32.store offset=328\nlocal.get 6\ni32.load offset=28\nlocal.set 74\ni32.const -1\nlocal.set 75\nlocal.get 74\nlocal.get 75\ni32.add\nlocal.set 76\nlocal.get 6\nlocal.get 76\ni32.store offset=28\nbr 0 (;@7;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=328\nlocal.set 77\nlocal.get 6\ni32.load offset=320\nlocal.set 78\ni32.const 2\nlocal.set 79\nlocal.get 78\nlocal.get 79\ni32.shl\nlocal.set 80\nlocal.get 77\nlocal.get 80\ni32.add\nlocal.set 81\ni32.const 0\nlocal.set 82\nlocal.get 81\nlocal.get 82\ni32.store\nlocal.get 6\ni32.load offset=320\nlocal.set 83\nlocal.get 6\nlocal.get 83\ni32.store offset=332\nbr 4 (;@1;)\nend\nbr 0 (;@4;)\nend\nunreachable\nend\nend\nlocal.get 6\ni32.load offset=324\nlocal.set 84\nlocal.get 6\ni32.load offset=320\nlocal.set 85\nlocal.get 6\ni32.load offset=312\nlocal.set 86\nlocal.get 85\nlocal.get 86\ni32.mul\nlocal.set 87\nlocal.get 84\nlocal.get 87\ni32.le_u\nlocal.set 88\ni32.const 1\nlocal.set 89\nlocal.get 88\nlocal.get 89\ni32.and\nlocal.set 90\nblock  ;; label = @2\nlocal.get 90\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 91\nlocal.get 6\nlocal.get 91\ni32.store offset=332\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=320\nlocal.set 92\nblock  ;; label = @2\nlocal.get 92\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 93\nlocal.get 6\nlocal.get 93\ni32.store offset=332\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=320\nlocal.set 94\nlocal.get 6\ni32.load offset=312\nlocal.set 95\nlocal.get 94\nlocal.get 95\ni32.mul\nlocal.set 96\ni32.const 2147483647\nlocal.set 97\nlocal.get 96\nlocal.get 97\ni32.gt_u\nlocal.set 98\ni32.const 1\nlocal.set 99\nlocal.get 98\nlocal.get 99\ni32.and\nlocal.set 100\nblock  ;; label = @2\nlocal.get 100\ni32.eqz\nbr_if 0 (;@2;)\ni32.const -1\nlocal.set 101\nlocal.get 6\nlocal.get 101\ni32.store offset=332\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=312\nlocal.set 102\nblock  ;; label = @2\nlocal.get 102\nbr_if 0 (;@2;)\ni32.const 0\nlocal.set 103\nlocal.get 6\nlocal.get 103\ni32.store offset=332\nbr 1 (;@1;)\nend\nlocal.get 6\ni32.load offset=328\nlocal.set 104\nlocal.get 6\ni32.load offset=324\nlocal.set 105\nlocal.get 6\ni32.load offset=320\nlocal.set 106\nlocal.get 6\ni32.load offset=312\nlocal.set 107\nlocal.get 106\nlocal.get 107\ni32.mul\nlocal.set 108\ni32.const 0\nlocal.set 109\nlocal.get 6\nlocal.get 109\ni32.store offset=4\nlocal.get 6\nlocal.get 108\ni32.store\ni32.const 65536\nlocal.set 110\nlocal.get 104\nlocal.get 105\nlocal.get 110\nlocal.get 6\ncall 12\nlocal.set 111\nlocal.get 6\nlocal.get 111\ni32.store offset=24\nlocal.get 6\ni32.load offset=24\nlocal.set 112\ni32.const 0\nlocal.set 113\nlocal.get 112\nlocal.get 113\ni32.lt_s\nlocal.set 114\ni32.const 1\nlocal.set 115\nlocal.get 114\nlocal.get 115\ni32.and\nlocal.set 116\nblock  ;; label = @2\nlocal.get 116\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 6\ni32.load offset=24\nlocal.set 117\nlocal.get 6\nlocal.get 117\ni32.store offset=332\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 118\nlocal.get 6\nlocal.get 118\ni32.store offset=20\ni32.const 0\nlocal.set 119\nlocal.get 6\nlocal.get 119\ni32.store offset=20\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 6\ni32.load offset=20\nlocal.set 120\nlocal.get 6\ni32.load offset=320\nlocal.set 121\nlocal.get 120\nlocal.get 121\ni32.lt_u\nlocal.set 122\ni32.const 1\nlocal.set 123\nlocal.get 122\nlocal.get 123\ni32.and\nlocal.set 124\nlocal.get 124\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 6\ni32.load offset=316\nlocal.set 125\nlocal.get 6\nlocal.get 125\ni32.store offset=16\nblock  ;; label = @4\nloop  ;; label = @5\nlocal.get 6\ni32.load offset=16\nlocal.set 126\nlocal.get 126\ni32.load8_u\nlocal.set 127\ni32.const 0\nlocal.set 128\ni32.const 255\nlocal.set 129\nlocal.get 127\nlocal.get 129\ni32.and\nlocal.set 130\ni32.const 255\nlocal.set 131\nlocal.get 128\nlocal.get 131\ni32.and\nlocal.set 132\nlocal.get 130\nlocal.get 132\ni32.ne\nlocal.set 133\ni32.const 1\nlocal.set 134\nlocal.get 133\nlocal.get 134\ni32.and\nlocal.set 135\nlocal.get 135\ni32.eqz\nbr_if 1 (;@4;)\nlocal.get 6\ni32.load offset=16\nlocal.set 136\ni32.const 1\nlocal.set 137\nlocal.get 136\nlocal.get 137\ni32.add\nlocal.set 138\nlocal.get 6\nlocal.get 138\ni32.store offset=16\nlocal.get 136\ni32.load8_u\nlocal.set 139\ni32.const 24\nlocal.set 140\nlocal.get 139\nlocal.get 140\ni32.shl\nlocal.set 141\nlocal.get 141\nlocal.get 140\ni32.shr_s\nlocal.set 142\nlocal.get 6\ni32.load offset=328\nlocal.set 143\ni32.const 4\nlocal.set 144\nlocal.get 143\nlocal.get 144\ni32.add\nlocal.set 145\nlocal.get 6\nlocal.get 145\ni32.store offset=328\nlocal.get 143\nlocal.get 142\ni32.store\nbr 0 (;@5;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=20\nlocal.set 146\ni32.const 1\nlocal.set 147\nlocal.get 146\nlocal.get 147\ni32.add\nlocal.set 148\nlocal.get 6\nlocal.get 148\ni32.store offset=20\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 6\ni32.load offset=320\nlocal.set 149\nlocal.get 6\ni32.load offset=312\nlocal.set 150\nlocal.get 149\nlocal.get 150\ni32.mul\nlocal.set 151\nlocal.get 6\nlocal.get 151\ni32.store offset=332\nend\nlocal.get 6\ni32.load offset=332\nlocal.set 152\ni32.const 336\nlocal.set 153\nlocal.get 6\nlocal.get 153\ni32.add\nlocal.set 154\nlocal.get 154\nglobal.set 0\nlocal.get 152\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_362",
        "query_text": "The function takes two inputs, each a pointer to a constant character representing positions in a string. The first pointer marks the start position, while the second pointer indicates the end position. The function calculates the distance between these two pointers, effectively determining the length of the substring defined by them. It returns this distance as a signed integer of type ptrdiff_t. An assertion ensures that the end pointer is not before the start pointer.",
        "code_id": "c_group_1_id_362",
        "code_text": "(func (;5;) (type 5) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\nlocal.get 4\ni32.load offset=12\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.ge_u\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 65647\nlocal.set 10\ni32.const 65565\nlocal.set 11\ni32.const 19\nlocal.set 12\ni32.const 65679\nlocal.set 13\nlocal.get 10\nlocal.get 11\nlocal.get 12\nlocal.get 13\ncall 7\nunreachable\nend\nlocal.get 4\ni32.load offset=8\nlocal.set 14\nlocal.get 4\ni32.load offset=12\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.sub\nlocal.set 16\ni32.const 16\nlocal.set 17\nlocal.get 4\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 18\nglobal.set 0\nlocal.get 16\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_363",
        "query_text": "The function accepts three inputs: two pointers to memory locations (used to specify the beginning and end of a data block) and a pointer designated to store a computed size value. It compares the data between the two memory pointers with a predefined custom string. If the data matches the custom string, the function sets the size value to 25 and returns 0 to indicate success; otherwise, it returns 1 to indicate failure. The inputs are of type const void* for the memory locations and size_t* for the size value, and the output is an integer indicating whether the operation was successful (0) or not (1).",
        "code_id": "c_group_1_id_363",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=24\nlocal.get 5\nlocal.get 1\ni32.store offset=20\nlocal.get 5\nlocal.get 2\ni32.store offset=16\ni32.const 65536\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store offset=12\nlocal.get 5\ni32.load offset=20\nlocal.set 7\nlocal.get 5\ni32.load offset=24\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.sub\nlocal.set 9\nlocal.get 5\nlocal.get 9\ni32.store offset=8\nlocal.get 5\ni32.load offset=24\nlocal.set 10\nlocal.get 5\ni32.load offset=12\nlocal.set 11\nlocal.get 5\ni32.load offset=12\nlocal.set 12\nlocal.get 12\ncall 4\nlocal.set 13\nlocal.get 5\ni32.load offset=8\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.lt_u\nlocal.set 15\ni32.const 1\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.and\nlocal.set 17\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 17\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 5\ni32.load offset=12\nlocal.set 18\nlocal.get 18\ncall 4\nlocal.set 19\nlocal.get 19\nlocal.set 20\nbr 1 (;@1;)\nend\nlocal.get 5\ni32.load offset=8\nlocal.set 21\nlocal.get 21\nlocal.set 20\nend\nlocal.get 20\nlocal.set 22\nlocal.get 10\nlocal.get 11\nlocal.get 22\ncall 3\nlocal.set 23\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 23\nbr_if 0 (;@2;)\nlocal.get 5\ni32.load offset=16\nlocal.set 24\ni32.const 25\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.store\ni32.const 0\nlocal.set 26\nlocal.get 5\nlocal.get 26\ni32.store offset=28\nbr 1 (;@1;)\nend\ni32.const 1\nlocal.set 27\nlocal.get 5\nlocal.get 27\ni32.store offset=28\nend\nlocal.get 5\ni32.load offset=28\nlocal.set 28\ni32.const 32\nlocal.set 29\nlocal.get 5\nlocal.get 29\ni32.add\nlocal.set 30\nlocal.get 30\nglobal.set 0\nlocal.get 28\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_364",
        "query_text": "This function examines a contiguous block of memory to determine if it begins with any emoji characters from a predefined set. It accepts three inputs: two pointers that mark the start and end of the memory block, and a pointer to a size variable where the computed width will be stored. The function scans the beginning of the memory block for specific emoji sequences, and upon detecting one at the start, it sets the width to a fixed value and returns a success code. If no matching emoji is found, the function returns a failure code.",
        "code_id": "c_group_1_id_364",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64)\nglobal.get 0\nlocal.set 3\ni32.const 48\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=40\nlocal.get 5\nlocal.get 1\ni32.store offset=36\nlocal.get 5\nlocal.get 2\ni32.store offset=32\ni32.const 0\nlocal.set 6\nlocal.get 6\ni64.load offset=65548 align=4\nlocal.set 54\nlocal.get 5\nlocal.get 54\ni64.store offset=24\ni32.const 2\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store offset=20\nlocal.get 5\ni32.load offset=36\nlocal.set 8\nlocal.get 5\ni32.load offset=40\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.sub\nlocal.set 10\nlocal.get 5\nlocal.get 10\ni32.store offset=16\ni32.const 0\nlocal.set 11\nlocal.get 5\nlocal.get 11\ni32.store offset=12\nblock  ;; label = @1\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 5\ni32.load offset=12\nlocal.set 12\ni32.const 2\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.lt_u\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 16\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 5\ni32.load offset=40\nlocal.set 17\nlocal.get 5\ni32.load offset=12\nlocal.set 18\ni32.const 24\nlocal.set 19\nlocal.get 5\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\nlocal.set 21\ni32.const 2\nlocal.set 22\nlocal.get 18\nlocal.get 22\ni32.shl\nlocal.set 23\nlocal.get 21\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\ni32.load\nlocal.set 25\nlocal.get 5\ni32.load offset=12\nlocal.set 26\ni32.const 24\nlocal.set 27\nlocal.get 5\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 28\nlocal.set 29\ni32.const 2\nlocal.set 30\nlocal.get 26\nlocal.get 30\ni32.shl\nlocal.set 31\nlocal.get 29\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 32\ni32.load\nlocal.set 33\nlocal.get 33\ncall 7\nlocal.set 34\nlocal.get 5\nlocal.get 34\ni32.store offset=8\ni32.const 8\nlocal.set 35\nlocal.get 5\nlocal.get 35\ni32.add\nlocal.set 36\nlocal.get 36\nlocal.set 37\ni32.const 16\nlocal.set 38\nlocal.get 5\nlocal.get 38\ni32.add\nlocal.set 39\nlocal.get 39\nlocal.set 40\nlocal.get 37\nlocal.get 40\ncall 2\nlocal.set 41\nlocal.get 41\ni32.load\nlocal.set 42\nlocal.get 17\nlocal.get 25\nlocal.get 42\ncall 6\nlocal.set 43\nblock  ;; label = @4\nlocal.get 43\nbr_if 0 (;@4;)\nlocal.get 5\ni32.load offset=32\nlocal.set 44\ni32.const 2\nlocal.set 45\nlocal.get 44\nlocal.get 45\ni32.store\ni32.const 0\nlocal.set 46\nlocal.get 5\nlocal.get 46\ni32.store offset=44\nbr 3 (;@1;)\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 47\ni32.const 1\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.add\nlocal.set 49\nlocal.get 5\nlocal.get 49\ni32.store offset=12\nbr 0 (;@3;)\nend\nunreachable\nend\ni32.const 1\nlocal.set 50\nlocal.get 5\nlocal.get 50\ni32.store offset=44\nend\nlocal.get 5\ni32.load offset=44\nlocal.set 51\ni32.const 48\nlocal.set 52\nlocal.get 5\nlocal.get 52\ni32.add\nlocal.set 53\nlocal.get 53\nglobal.set 0\nlocal.get 51\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_365",
        "query_text": "The function retrieves memory usage data for the current process by opening a system file that holds memory statistics. It reads a fixed number of bytes into a buffer and prints the retrieved string to the console. The function takes no parameters, returns no value, and ensures that the file is properly closed after reading.",
        "code_id": "c_group_1_id_365",
        "code_text": "(func (;5;) (type 4)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 320\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ni32.const 65607\nlocal.set 3\ni32.const 65577\nlocal.set 4\nlocal.get 3\nlocal.get 4\ncall 26\nlocal.set 5\nlocal.get 2\nlocal.get 5\ni32.store offset=316\nlocal.get 2\ni32.load offset=316\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 10\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 16\nlocal.set 11\nlocal.get 2\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nlocal.set 13\nlocal.get 2\ni32.load offset=316\nlocal.set 14\ni32.const 1\nlocal.set 15\ni32.const 200\nlocal.set 16\nlocal.get 13\nlocal.get 15\nlocal.get 16\nlocal.get 14\ncall 29\nlocal.set 17\nlocal.get 2\nlocal.get 17\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 18\ni32.const 16\nlocal.set 19\nlocal.get 2\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\nlocal.set 21\nlocal.get 21\nlocal.get 18\ni32.add\nlocal.set 22\ni32.const 0\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.store8\ni32.const 16\nlocal.set 24\nlocal.get 2\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\nlocal.set 26\nlocal.get 2\nlocal.get 26\ni32.store\ni32.const 65649\nlocal.set 27\nlocal.get 27\nlocal.get 2\ncall 36\ndrop\nlocal.get 2\ni32.load offset=316\nlocal.set 28\nlocal.get 28\ncall 10\ndrop\nend\ni32.const 320\nlocal.set 29\nlocal.get 2\nlocal.get 29\ni32.add\nlocal.set 30\nlocal.get 30\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_366",
        "query_text": "The function takes no input arguments. It flushes all open output streams to ensure that any buffered data is immediately written out to their proper destinations. It does not return any value (void).",
        "code_id": "c_group_1_id_366",
        "code_text": "(func (;1;) (type 1)\n(local i32)\ni32.const 0\nlocal.set 0\nlocal.get 0\ncall 5\ndrop\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_367",
        "query_text": "The function accepts three parameters: a pointer to a destination character array, a pointer to a source character array, and a size value that specifies the maximum number of characters to copy. It copies characters from the source array to the destination array and, if the source is shorter than the specified limit, it pads the destination with null characters. The function then returns a pointer to the destination array.",
        "code_id": "c_group_1_id_367",
        "code_text": "(func (;1;) (type 1) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nlocal.get 5\ni32.load offset=12\nlocal.set 6\nlocal.get 5\ni32.load offset=8\nlocal.set 7\nlocal.get 5\ni32.load offset=4\nlocal.set 8\nlocal.get 6\nlocal.get 7\nlocal.get 8\ncall 5\nlocal.set 9\ni32.const 16\nlocal.set 10\nlocal.get 5\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 11\nglobal.set 0\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_368",
        "query_text": "The function accepts two inputs, each of type const char*, representing a file path and an operating mode (such as read, write, or append). It passes these arguments to a standard library function to open the file. The function returns a pointer to a FILE object if the file is successfully opened, and returns a null pointer if not.",
        "code_id": "c_group_1_id_368",
        "code_text": "(func (;5;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 21\nlocal.set 7\ni32.const 16\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nglobal.set 0\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_370",
        "query_text": "The function takes two inputs: a pointer to a generic memory location and a pointer to a boolean variable. Inside the function, a local variable is defined, and its memory address is compared with the provided pointer. The outcome of this comparison\u2014a boolean indicating whether the local variable's address is lower than the given address\u2014is stored in the boolean variable. No value is returned directly by the function.",
        "code_id": "c_group_1_id_370",
        "code_text": "(func (;1;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\ni32.const 4\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.set 8\nlocal.get 8\nlocal.get 5\ni32.lt_u\nlocal.set 9\nlocal.get 4\ni32.load offset=8\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 9\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 10\nlocal.get 12\ni32.store8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_371",
        "query_text": "The function takes no parameters and returns no value. Upon being called, it executes an empty body, meaning that it performs no operations or computations. Essentially, it is a no-op, serving as a placeholder or stub for potential future implementations.",
        "code_id": "c_group_1_id_371",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_372",
        "query_text": "This function accepts an integer as input and performs no operations on it. Its body is empty, and it returns no value (void). Essentially, it serves as a placeholder with no implemented functionality.",
        "code_id": "c_group_1_id_372",
        "code_text": "(func (;1;) (type 2) (param i32)\n(local i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_373",
        "query_text": "This function is a void function that accepts no input parameters and does not perform any operations. It serves solely as a placeholder with no effect when invoked, as it neither executes any computation nor returns a value.",
        "code_id": "c_group_1_id_373",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_374",
        "query_text": "The function accepts a single parameter: a pointer to a constant character array (const char*), representing a C-style string. It first computes the length of the string using a standard library function that counts characters. Prior to returning, the function includes a safety check to ensure that the computed length, originally of a size-type, can be safely converted to an integer without data loss. Once the check is successful, it returns the length as an integer.",
        "code_id": "c_group_1_id_374",
        "code_text": "(func (;5;) (type 1) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 18\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 6\nlocal.get 3\ni32.load offset=8\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.eq\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 10\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 65696\nlocal.set 11\ni32.const 65565\nlocal.set 12\ni32.const 19\nlocal.set 13\ni32.const 65668\nlocal.set 14\nlocal.get 11\nlocal.get 12\nlocal.get 13\nlocal.get 14\ncall 7\nunreachable\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 15\ni32.const 16\nlocal.set 16\nlocal.get 3\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nglobal.set 0\nlocal.get 15\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_375",
        "query_text": "The function accepts a single parameter of type char as input and simply returns that same character as output. It performs no modifications or transformations on the input, serving solely as a direct pass-through mechanism. The purpose of the function is to ensure that the input character is returned unchanged.",
        "code_id": "c_group_1_id_375",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 4\ni32.const 24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\nlocal.get 6\nlocal.get 5\ni32.shr_s\nlocal.set 7\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_376",
        "query_text": "The function takes one input: a boolean value. It returns a double-precision floating-point value. If the input is true, the function returns negative zero (i.e., -0.0), and if the input is false, it returns positive zero (i.e., 0.0). The function essentially determines the sign of zero based on the boolean input.",
        "code_id": "c_group_1_id_376",
        "code_text": "(func (;1;) (type 2) (param i32) (result f64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 5\nf64.const -0x0p+0 (;=-0;)\nlocal.set 9\ni32.const 0\nlocal.set 6\nlocal.get 6\nf64.convert_i32_s\nlocal.set 10\ni32.const 1\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.and\nlocal.set 8\nlocal.get 9\nlocal.get 10\nlocal.get 8\nselect\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_377",
        "query_text": "The function takes an unsigned 64-bit integer as input and returns an integer representing the count of bits set to 1 in the binary representation of the input. It computes what is commonly known as the Hamming weight or population count, utilizing an efficient built-in method provided by the compiler.",
        "code_id": "c_group_1_id_377",
        "code_text": "(func (;1;) (type 2) (param i64) (result i32)\n(local i32 i32 i32 i32 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni64.store offset=8\nlocal.get 3\ni64.load offset=8\nlocal.set 5\nlocal.get 5\ni64.popcnt\nlocal.set 6\nlocal.get 6\ni32.wrap_i64\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_378",
        "query_text": "The function accepts one parameter: a pointer to a constant character (of type const char*). It immediately returns this pointer without performing any modification or transformation on it. The function is marked for compile-time evaluation and is explicitly inlined for performance optimization. The input and output types are both const char*.",
        "code_id": "c_group_1_id_378",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_379",
        "query_text": "The function takes a single size_t input (expected to be within the range 0 to 99) and returns a pointer to a constant character string representing the two-digit number corresponding to the input value. Internally, it uses a precomputed lookup table that contains contiguous pairs of digits for the numbers 00 through 99. By calculating an offset based on the input, the function retrieves and returns the appropriate two-character substring from this table. The function does not produce any output other than the returned pointer.",
        "code_id": "c_group_1_id_379",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 208\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=204\ni32.const 65536\nlocal.set 4\ni32.const 201\nlocal.set 5\ni32.const 2\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.get 4\nlocal.get 5\ncall 3\ndrop\nlocal.get 3\ni32.load offset=204\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.shl\nlocal.set 10\ni32.const 2\nlocal.set 11\nlocal.get 3\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nlocal.set 13\nlocal.get 13\nlocal.get 10\ni32.add\nlocal.set 14\ni32.const 208\nlocal.set 15\nlocal.get 3\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\nglobal.set 0\nlocal.get 14\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_380",
        "query_text": "The function accepts a single input of type std::size_t and simply returns that same value as its output. It performs no modifications or additional processing on the input, effectively acting as a pass-through function. The input and output types are both std::size_t.",
        "code_id": "c_group_1_id_380",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_381",
        "query_text": "The function takes no arguments and returns no value. It calls a standard library function with a null pointer to flush all open output streams, ensuring that any buffered data is promptly written to their respective destinations.",
        "code_id": "c_group_1_id_381",
        "code_text": "(func (;1;) (type 1)\n(local i32)\ni32.const 0\nlocal.set 0\nlocal.get 0\ncall 5\ndrop\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_382",
        "query_text": "The function pauses the program's execution for a specified duration in milliseconds. It accepts an integer input representing the number of milliseconds to delay, converts this value into a timespec structure, and then calls a system-level function to suspend execution for that period. It does not return any value.",
        "code_id": "c_group_1_id_382",
        "code_text": "(func (;2;) (type 3) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64)\nglobal.get 0\nlocal.set 1\ni32.const 32\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=28\ni64.const 0\nlocal.set 15\nlocal.get 3\nlocal.get 15\ni64.store offset=8\nlocal.get 3\ni32.load offset=28\nlocal.set 4\ni32.const 1000\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.mul\nlocal.set 6\ni32.const 1000\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.mul\nlocal.set 8\nlocal.get 3\nlocal.get 8\ni32.store offset=16\ni32.const 8\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nlocal.set 11\ni32.const 0\nlocal.set 12\nlocal.get 11\nlocal.get 12\ncall 13\ndrop\ni32.const 32\nlocal.set 13\nlocal.get 3\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_383",
        "query_text": "The function accepts a string as its input and produces a string as its output. It first checks if the input string starts with a predetermined prefix. If the prefix is present, the function then searches for a specific delimiter that follows the prefix. When the delimiter is located, it removes a section of the string that lies between a defined static part of the prefix and the delimiter. If the input string does not start with the required prefix or if the delimiter is not found, the input string remains unmodified.",
        "code_id": "c_group_1_id_383",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i64)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 0\nlocal.set 5\nlocal.get 5\ni64.load offset=65564 align=1\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni64.store offset=16\ni32.const 16\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.set 8\ni32.const 0\nlocal.set 9\ni32.const 7\nlocal.set 10\nlocal.get 1\nlocal.get 9\nlocal.get 10\nlocal.get 8\ncall 101\nlocal.set 11\nblock  ;; label = @1\nlocal.get 11\nbr_if 0 (;@1;)\ni32.const 65572\nlocal.set 12\ni32.const 7\nlocal.set 13\nlocal.get 1\nlocal.get 12\nlocal.get 13\ncall 3\nlocal.set 14\nlocal.get 4\nlocal.get 14\ni32.store offset=12\nlocal.get 4\ni32.load offset=12\nlocal.set 15\ni32.const -1\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.ne\nlocal.set 17\ni32.const 1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.and\nlocal.set 19\nblock  ;; label = @2\nlocal.get 19\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load offset=12\nlocal.set 20\ni32.const 3\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.sub\nlocal.set 22\ni32.const 3\nlocal.set 23\nlocal.get 1\nlocal.get 23\nlocal.get 22\ncall 4\ndrop\nend\nend\nlocal.get 0\nlocal.get 1\ncall 5\ndrop\ni32.const 32\nlocal.set 24\nlocal.get 4\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_384",
        "query_text": "The function takes no arguments and returns a boolean value. It is implemented as a constexpr function that consistently returns true. Its primary purpose is to serve as a marker indicating that a certain feature is deprecated. The function does not perform any additional computations or operations; it merely provides a constant boolean output to signal the deprecation status.",
        "code_id": "c_group_1_id_384",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32)\ni32.const 1\nlocal.set 0\ni32.const 1\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.and\nlocal.set 2\nlocal.get 2\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_385",
        "query_text": "The function receives a null pointer constant and a pointer to an output stream as inputs. It writes the string \"(nullptr)\" to the output stream, thereby providing a clear textual representation of a null pointer. The function does not return any value (void).",
        "code_id": "c_group_1_id_385",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 65565\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 3\ndrop\ni32.const 16\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_386",
        "query_text": "The function takes a constant void pointer as its only input and returns the identical pointer without any alterations. The input and output are both of type \"const void*\". Essentially, the function acts as a pass-through, simply relaying the pointer that was provided.",
        "code_id": "c_group_1_id_386",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_387",
        "query_text": "The function accepts two wide characters as input and returns a 32-bit unsigned integer. It initially checks whether the underlying wide-character type is 2 bytes (UTF-16). If so, it combines the two characters into a single Unicode code point by extracting lower-order bits from each character, shifting bits accordingly, and adding a fixed offset. Otherwise, when the wide-character type exceeds 2 bytes, the function simply converts and returns the first input character as a 32-bit unsigned integer.",
        "code_id": "c_group_1_id_387",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\nlocal.get 4\ni32.load offset=28\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=16\ni32.const 1023\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store offset=12\nlocal.get 4\ni32.load offset=20\nlocal.set 8\nlocal.get 8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_388",
        "query_text": "The function accepts a single input of type std::string. It then iterates over the string to locate newline characters that indicate the end of each line. For every identified line, the function prefixes it with a fixed text segment. If the end of the string is reached and a newline is not encountered, the remaining part of the string is treated as the final line and the prefix is still applied. Finally, the function returns a new std::string containing all the lines, each with the prefixed text.",
        "code_id": "c_group_1_id_388",
        "code_text": "(func (;2;) (type 4) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 48\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=44\nlocal.get 4\nlocal.get 1\ni32.store offset=40\ni32.const 0\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store8 offset=39\nlocal.get 0\ncall 3\ndrop\ni32.const 0\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=32\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 4\ni32.load offset=40\nlocal.set 9\nlocal.get 4\ni32.load offset=32\nlocal.set 10\ni32.const 10\nlocal.set 11\ni32.const 24\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.shl\nlocal.set 13\nlocal.get 13\nlocal.get 12\ni32.shr_s\nlocal.set 14\nlocal.get 9\nlocal.get 14\nlocal.get 10\ncall 110\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.store offset=28\ni32.const 65549\nlocal.set 16\nlocal.get 0\nlocal.get 16\ncall 4\ndrop\nlocal.get 4\ni32.load offset=28\nlocal.set 17\ni32.const -1\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.eq\nlocal.set 19\ni32.const 1\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.and\nlocal.set 21\nblock  ;; label = @3\nlocal.get 21\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 4\ni32.load offset=40\nlocal.set 22\nlocal.get 4\ni32.load offset=32\nlocal.set 23\ni32.const 16\nlocal.set 24\nlocal.get 4\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 25\nlocal.set 26\ni32.const -1\nlocal.set 27\nlocal.get 26\nlocal.get 22\nlocal.get 23\nlocal.get 27\ncall 5\ni32.const 16\nlocal.set 28\nlocal.get 4\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 29\nlocal.set 30\nlocal.get 0\nlocal.get 30\ncall 6\ndrop\ni32.const 16\nlocal.set 31\nlocal.get 4\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 32\nlocal.set 33\nlocal.get 33\ncall 100\ndrop\nbr 2 (;@1;)\nend\nlocal.get 4\ni32.load offset=40\nlocal.set 34\nlocal.get 4\ni32.load offset=32\nlocal.set 35\nlocal.get 4\ni32.load offset=28\nlocal.set 36\ni32.const 1\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.add\nlocal.set 38\nlocal.get 4\ni32.load offset=32\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.sub\nlocal.set 40\ni32.const 4\nlocal.set 41\nlocal.get 4\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 42\nlocal.set 43\nlocal.get 43\nlocal.get 34\nlocal.get 35\nlocal.get 40\ncall 5\ni32.const 4\nlocal.set 44\nlocal.get 4\nlocal.get 44\ni32.add\nlocal.set 45\nlocal.get 45\nlocal.set 46\nlocal.get 0\nlocal.get 46\ncall 6\ndrop\ni32.const 4\nlocal.set 47\nlocal.get 4\nlocal.get 47\ni32.add\nlocal.set 48\nlocal.get 48\nlocal.set 49\nlocal.get 49\ncall 100\ndrop\nlocal.get 4\ni32.load offset=28\nlocal.set 50\ni32.const 1\nlocal.set 51\nlocal.get 50\nlocal.get 51\ni32.add\nlocal.set 52\nlocal.get 4\nlocal.get 52\ni32.store offset=32\nbr 0 (;@2;)\nend\nunreachable\nend\ni32.const 1\nlocal.set 53\ni32.const 1\nlocal.set 54\nlocal.get 53\nlocal.get 54\ni32.and\nlocal.set 55\nlocal.get 4\nlocal.get 55\ni32.store8 offset=39\nlocal.get 4\ni32.load8_u offset=39\nlocal.set 56\ni32.const 1\nlocal.set 57\nlocal.get 56\nlocal.get 57\ni32.and\nlocal.set 58\nblock  ;; label = @1\nlocal.get 58\nbr_if 0 (;@1;)\nlocal.get 0\ncall 100\ndrop\nend\ni32.const 48\nlocal.set 59\nlocal.get 4\nlocal.get 59\ni32.add\nlocal.set 60\nlocal.get 60\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_389",
        "query_text": "The function accepts two inputs: a pointer to a constant void type and a pointer to a boolean variable. It defines a local integer variable and compares its memory address with the provided pointer. If the local variable's address is lower (i.e., precedes in memory) than the given address, the function sets the boolean output to true; otherwise, it assigns false. The function solely performs this comparison without modifying the input pointer or conducting any additional operations.",
        "code_id": "c_group_1_id_389",
        "code_text": "(func (;1;) (type 2) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=28\nlocal.get 4\nlocal.get 1\ni32.store offset=24\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=20\ni32.const 20\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nlocal.set 8\nlocal.get 4\nlocal.get 8\ni32.store offset=12\ni32.const 19\nlocal.set 9\nlocal.get 4\nlocal.get 9\ni32.add\nlocal.set 10\nlocal.get 10\nlocal.set 11\ni32.const 12\nlocal.set 12\nlocal.get 4\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\nlocal.set 14\ni32.const 28\nlocal.set 15\nlocal.get 4\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\nlocal.set 17\nlocal.get 11\nlocal.get 14\nlocal.get 17\ncall 2\nlocal.set 18\nlocal.get 4\ni32.load offset=24\nlocal.set 19\ni32.const 1\nlocal.set 20\nlocal.get 18\nlocal.get 20\ni32.and\nlocal.set 21\nlocal.get 19\nlocal.get 21\ni32.store8\ni32.const 32\nlocal.set 22\nlocal.get 4\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 23\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_390",
        "query_text": "The function accepts a single character (of type char) as input and always returns a constant string (of type const char*). Regardless of the input provided, the function simply returns an empty string (\"\") without performing any additional operations or modifications.",
        "code_id": "c_group_1_id_390",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\ni32.const 65536\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_391",
        "query_text": "The function accepts a single input of type signed char and returns a constant string pointer. Regardless of the input, it always returns an empty string (\"\"). The primary purpose of the function is to provide a fixed, unchanging string output independent of the parameter value.",
        "code_id": "c_group_1_id_391",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\ni32.const 65536\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_392",
        "query_text": "The function receives an unsigned 8-bit integer (of type unsigned char) and produces an output of type constant character pointer (const char*). It returns a constant empty string (\"\") regardless of the input value, meaning that the function does not perform any computation or transformation on the provided input.",
        "code_id": "c_group_1_id_392",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store8 offset=15\ni32.const 65536\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_393",
        "query_text": "The function takes a single input\u2014a wide character (wchar_t)\u2014and always returns a pointer to a constant string. Regardless of the input value, the function produces the same constant output, the string literal \"L\" (of type const char*).",
        "code_id": "c_group_1_id_393",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 65536\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_394",
        "query_text": "The function takes three inputs: a string, a flag string, and a boolean indicating if the flag value is optional. It begins by constructing a prefix by concatenating a constant literal with the flag string and then checks if the input string starts with this prefix. If it does, the function examines the subsequent character(s): if the flag is marked as optional and the string ends immediately after the prefix, it returns a pointer to that position; otherwise, if the flag is expected to have a value, it verifies that an equals sign immediately follows the prefix and returns a pointer to the beginning of the value. If these conditions are not met, the function returns a null pointer. The output is a pointer to a constant character.",
        "code_id": "c_group_1_id_394",
        "code_text": "(func (;2;) (type 2) (param i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 64\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=56\nlocal.get 5\nlocal.get 1\ni32.store offset=52\nlocal.get 2\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store8 offset=51\nlocal.get 5\ni32.load offset=56\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.eq\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 11\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load offset=52\nlocal.set 12\ni32.const 0\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.eq\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 16\ni32.eqz\nbr_if 1 (;@2;)\nend\ni32.const 0\nlocal.set 17\nlocal.get 5\nlocal.get 17\ni32.store offset=60\nbr 1 (;@1;)\nend\ni32.const 24\nlocal.set 18\nlocal.get 5\nlocal.get 18\ni32.add\nlocal.set 19\nlocal.get 19\nlocal.set 20\ni32.const 65549\nlocal.set 21\nlocal.get 20\nlocal.get 21\ncall 3\ndrop\nlocal.get 5\ni32.load offset=52\nlocal.set 22\ni32.const 36\nlocal.set 23\nlocal.get 5\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 24\nlocal.set 25\ni32.const 24\nlocal.set 26\nlocal.get 5\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\nlocal.set 28\nlocal.get 25\nlocal.get 28\nlocal.get 22\ncall 4\ni32.const 24\nlocal.set 29\nlocal.get 5\nlocal.get 29\ni32.add\nlocal.set 30\nlocal.get 30\nlocal.set 31\nlocal.get 31\ncall 95\ndrop\ni32.const 36\nlocal.set 32\nlocal.get 5\nlocal.get 32\ni32.add\nlocal.set 33\nlocal.get 33\nlocal.set 34\nlocal.get 34\ncall 5\nlocal.set 35\nlocal.get 5\nlocal.get 35\ni32.store offset=20\nlocal.get 5\ni32.load offset=56\nlocal.set 36\ni32.const 36\nlocal.set 37\nlocal.get 5\nlocal.get 37\ni32.add\nlocal.set 38\nlocal.get 38\nlocal.set 39\nlocal.get 39\ncall 6\nlocal.set 40\nlocal.get 5\ni32.load offset=20\nlocal.set 41\nlocal.get 36\nlocal.get 40\nlocal.get 41\ncall 32\nlocal.set 42\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 42\ni32.eqz\nbr_if 0 (;@3;)\ni32.const 0\nlocal.set 43\nlocal.get 5\nlocal.get 43\ni32.store offset=60\ni32.const 1\nlocal.set 44\nlocal.get 5\nlocal.get 44\ni32.store offset=16\nbr 1 (;@2;)\nend\nlocal.get 5\ni32.load offset=56\nlocal.set 45\nlocal.get 5\ni32.load offset=20\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.add\nlocal.set 47\nlocal.get 5\nlocal.get 47\ni32.store offset=12\nlocal.get 5\ni32.load8_u offset=51\nlocal.set 48\ni32.const 1\nlocal.set 49\nlocal.get 48\nlocal.get 49\ni32.and\nlocal.set 50\nblock  ;; label = @3\nlocal.get 50\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load offset=12\nlocal.set 51\nlocal.get 51\ni32.load8_u\nlocal.set 52\ni32.const 24\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.shl\nlocal.set 54\nlocal.get 54\nlocal.get 53\ni32.shr_s\nlocal.set 55\nlocal.get 55\nbr_if 0 (;@3;)\nlocal.get 5\ni32.load offset=12\nlocal.set 56\nlocal.get 5\nlocal.get 56\ni32.store offset=60\ni32.const 1\nlocal.set 57\nlocal.get 5\nlocal.get 57\ni32.store offset=16\nbr 1 (;@2;)\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 58\nlocal.get 58\ni32.load8_u\nlocal.set 59\ni32.const 24\nlocal.set 60\nlocal.get 59\nlocal.get 60\ni32.shl\nlocal.set 61\nlocal.get 61\nlocal.get 60\ni32.shr_s\nlocal.set 62\ni32.const 61\nlocal.set 63\nlocal.get 62\nlocal.get 63\ni32.ne\nlocal.set 64\ni32.const 1\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.and\nlocal.set 66\nblock  ;; label = @3\nlocal.get 66\ni32.eqz\nbr_if 0 (;@3;)\ni32.const 0\nlocal.set 67\nlocal.get 5\nlocal.get 67\ni32.store offset=60\ni32.const 1\nlocal.set 68\nlocal.get 5\nlocal.get 68\ni32.store offset=16\nbr 1 (;@2;)\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 69\ni32.const 1\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.add\nlocal.set 71\nlocal.get 5\nlocal.get 71\ni32.store offset=60\ni32.const 1\nlocal.set 72\nlocal.get 5\nlocal.get 72\ni32.store offset=16\nend\ni32.const 36\nlocal.set 73\nlocal.get 5\nlocal.get 73\ni32.add\nlocal.set 74\nlocal.get 74\nlocal.set 75\nlocal.get 75\ncall 95\ndrop\nend\nlocal.get 5\ni32.load offset=60\nlocal.set 76\ni32.const 64\nlocal.set 77\nlocal.get 5\nlocal.get 77\ni32.add\nlocal.set 78\nlocal.get 78\nglobal.set 0\nlocal.get 76\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_395",
        "query_text": "The function takes no input arguments and returns a reference to a constant pointer. It is defined inline and begins by initializing a static constant pointer that points to the stream buffer associated with the standard error stream. Finally, it returns a reference to this pointer, effectively giving access to the stream buffer without allowing modifications. The output of the function is a reference to a pointer of type std::streambuf*.",
        "code_id": "c_group_1_id_395",
        "code_text": "(func (;8;) (type 9) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\nlocal.get 2\nglobal.set 0\ni32.const 0\nlocal.set 3\nlocal.get 3\ni32.load offset=82976\nlocal.set 4\ni32.const -12\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.add\nlocal.set 6\nlocal.get 6\ni32.load\nlocal.set 7\ni32.const 82976\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.add\nlocal.set 9\nlocal.get 9\ncall 9\nlocal.set 10\nlocal.get 2\nlocal.get 10\ni32.store offset=12\ni32.const 12\nlocal.set 11\nlocal.get 2\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nlocal.set 13\ni32.const 16\nlocal.set 14\nlocal.get 2\nlocal.get 14\ni32.add\nlocal.set 15\nlocal.get 15\nglobal.set 0\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_396",
        "query_text": "The function accepts four parameters, all of type size_t. It converts the first three parameters into their string representations, appends a fixed suffix (\"   |\") to each string, and then prints these strings to the console with a specific field width determined by the fourth parameter. The formatted output is printed directly to standard output, and the function does not return any value.",
        "code_id": "c_group_1_id_396",
        "code_text": "(func (;8;) (type 8) (param i32 i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 4\ni32.const 208\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.sub\nlocal.set 6\nlocal.get 6\nglobal.set 0\nlocal.get 6\nlocal.get 0\ni32.store offset=204\nlocal.get 6\nlocal.get 1\ni32.store offset=200\nlocal.get 6\nlocal.get 2\ni32.store offset=196\nlocal.get 6\nlocal.get 3\ni32.store offset=192\ni32.const 180\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\nlocal.set 9\nlocal.get 9\ncall 9\ndrop\ni32.const 168\nlocal.set 10\nlocal.get 6\nlocal.get 10\ni32.add\nlocal.set 11\nlocal.get 11\nlocal.set 12\nlocal.get 12\ncall 9\ndrop\ni32.const 156\nlocal.set 13\nlocal.get 6\nlocal.get 13\ni32.add\nlocal.set 14\nlocal.get 14\nlocal.set 15\nlocal.get 15\ncall 9\ndrop\ni32.const 12\nlocal.set 16\nlocal.get 6\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nlocal.set 18\nlocal.get 18\ncall 10\ndrop\ni32.const 12\nlocal.set 19\nlocal.get 6\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\nlocal.set 21\ni32.const 8\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.add\nlocal.set 23\nlocal.get 6\ni32.load offset=204\nlocal.set 24\nlocal.get 23\nlocal.get 24\ncall 227\nlocal.set 25\ni32.const 66155\nlocal.set 26\nlocal.get 25\nlocal.get 26\ncall 11\nlocal.set 27\nlocal.get 6\ni32.load offset=200\nlocal.set 28\nlocal.get 27\nlocal.get 28\ncall 227\nlocal.set 29\ni32.const 66155\nlocal.set 30\nlocal.get 29\nlocal.get 30\ncall 11\nlocal.set 31\nlocal.get 6\ni32.load offset=196\nlocal.set 32\nlocal.get 31\nlocal.get 32\ncall 227\ndrop\ni32.const 12\nlocal.set 33\nlocal.get 6\nlocal.get 33\ni32.add\nlocal.set 34\nlocal.get 34\nlocal.set 35\ni32.const 180\nlocal.set 36\nlocal.get 6\nlocal.get 36\ni32.add\nlocal.set 37\nlocal.get 37\nlocal.set 38\nlocal.get 35\nlocal.get 38\ncall 12\nlocal.set 39\ni32.const 168\nlocal.set 40\nlocal.get 6\nlocal.get 40\ni32.add\nlocal.set 41\nlocal.get 41\nlocal.set 42\nlocal.get 39\nlocal.get 42\ncall 12\nlocal.set 43\ni32.const 156\nlocal.set 44\nlocal.get 6\nlocal.get 44\ni32.add\nlocal.set 45\nlocal.get 45\nlocal.set 46\nlocal.get 43\nlocal.get 46\ncall 12\ndrop\ni32.const 180\nlocal.set 47\nlocal.get 6\nlocal.get 47\ni32.add\nlocal.set 48\nlocal.get 48\nlocal.set 49\ni32.const 65536\nlocal.set 50\nlocal.get 49\nlocal.get 50\ncall 13\ndrop\nlocal.get 6\ni32.load offset=192\nlocal.set 51\nlocal.get 51\ncall 14\nlocal.set 52\nlocal.get 6\nlocal.get 52\ni32.store offset=8\ni32.const 83528\nlocal.set 53\ni32.const 8\nlocal.set 54\nlocal.get 6\nlocal.get 54\ni32.add\nlocal.set 55\nlocal.get 55\nlocal.set 56\nlocal.get 53\nlocal.get 56\ncall 15\nlocal.set 57\ni32.const 180\nlocal.set 58\nlocal.get 6\nlocal.get 58\ni32.add\nlocal.set 59\nlocal.get 59\nlocal.set 60\nlocal.get 57\nlocal.get 60\ncall 16\ndrop\ni32.const 168\nlocal.set 61\nlocal.get 6\nlocal.get 61\ni32.add\nlocal.set 62\nlocal.get 62\nlocal.set 63\ni32.const 65536\nlocal.set 64\nlocal.get 63\nlocal.get 64\ncall 13\ndrop\nlocal.get 6\ni32.load offset=192\nlocal.set 65\nlocal.get 65\ncall 14\nlocal.set 66\nlocal.get 6\nlocal.get 66\ni32.store offset=4\ni32.const 83528\nlocal.set 67\ni32.const 4\nlocal.set 68\nlocal.get 6\nlocal.get 68\ni32.add\nlocal.set 69\nlocal.get 69\nlocal.set 70\nlocal.get 67\nlocal.get 70\ncall 15\nlocal.set 71\ni32.const 168\nlocal.set 72\nlocal.get 6\nlocal.get 72\ni32.add\nlocal.set 73\nlocal.get 73\nlocal.set 74\nlocal.get 71\nlocal.get 74\ncall 16\ndrop\ni32.const 156\nlocal.set 75\nlocal.get 6\nlocal.get 75\ni32.add\nlocal.set 76\nlocal.get 76\nlocal.set 77\ni32.const 65536\nlocal.set 78\nlocal.get 77\nlocal.get 78\ncall 13\ndrop\nlocal.get 6\ni32.load offset=192\nlocal.set 79\nlocal.get 79\ncall 14\nlocal.set 80\nlocal.get 6\nlocal.get 80\ni32.store\ni32.const 83528\nlocal.set 81\nlocal.get 6\nlocal.set 82\nlocal.get 81\nlocal.get 82\ncall 15\nlocal.set 83\ni32.const 156\nlocal.set 84\nlocal.get 6\nlocal.get 84\ni32.add\nlocal.set 85\nlocal.get 85\nlocal.set 86\nlocal.get 83\nlocal.get 86\ncall 16\nlocal.set 87\ni32.const 66157\nlocal.set 88\nlocal.get 87\nlocal.get 88\ncall 11\ndrop\ni32.const 12\nlocal.set 89\nlocal.get 6\nlocal.get 89\ni32.add\nlocal.set 90\nlocal.get 90\nlocal.set 91\nlocal.get 91\ncall 17\ndrop\ni32.const 156\nlocal.set 92\nlocal.get 6\nlocal.get 92\ni32.add\nlocal.set 93\nlocal.get 93\nlocal.set 94\nlocal.get 94\ncall 1788\ndrop\ni32.const 168\nlocal.set 95\nlocal.get 6\nlocal.get 95\ni32.add\nlocal.set 96\nlocal.get 96\nlocal.set 97\nlocal.get 97\ncall 1788\ndrop\ni32.const 180\nlocal.set 98\nlocal.get 6\nlocal.get 98\ni32.add\nlocal.set 99\nlocal.get 99\nlocal.set 100\nlocal.get 100\ncall 1788\ndrop\ni32.const 208\nlocal.set 101\nlocal.get 6\nlocal.get 101\ni32.add\nlocal.set 102\nlocal.get 102\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_397",
        "query_text": "The function takes no input parameters and returns an integer value. It calculates this value by simply returning a constant result, with no computations or conditional logic applied. The function always produces the same output, making it entirely deterministic, and its return type is int.",
        "code_id": "c_group_1_id_397",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 5\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_398",
        "query_text": "The function accepts an integer and performs a series of arithmetic transformations. Initially, it multiplies the input by a constant value, then adds a fixed offset to the result. Following this, it calculates the remainder when the sum is divided by a predetermined divisor. The final computed remainder is returned as an integer.",
        "code_id": "c_group_1_id_398",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 5\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.mul\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.add\nlocal.set 8\ni32.const 9\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.rem_s\nlocal.set 10\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_399",
        "query_text": "The function accepts an integer input and determines whether the number is odd. It accomplishes this by performing a bitwise AND operation with the value 1. If the result equals 1, the function returns a boolean value of true, indicating that the input integer is odd; otherwise, it returns false, indicating that the input is even. The primary purpose of this function is to check the parity of the given integer.",
        "code_id": "c_group_1_id_399",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_400",
        "query_text": "The function accepts an integer as input and returns a boolean value indicating whether the number is even. It determines evenness by inspecting the least significant bit of the integer; if this bit is not set, the function concludes that the number is even and returns true, otherwise it returns false. The input is of type integer, and the output is of type boolean.",
        "code_id": "c_group_1_id_400",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const -1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.xor\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_401",
        "query_text": "The function accepts two integer values and returns a boolean result. It compares the two integers by checking if the second is smaller than the first. If this condition holds, it returns true; otherwise, it returns false. This comparison logic is typically employed to establish a custom ordering for operations such as sorting.",
        "code_id": "c_group_1_id_401",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=8\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nlocal.get 4\ni32.load offset=12\nlocal.set 7\nlocal.get 7\ni32.load\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.lt_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_402",
        "query_text": "The function takes an integer input, increments its value by 1, and returns the updated integer as output. Both the input and the output are of type int.",
        "code_id": "c_group_1_id_402",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ni32.load\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_403",
        "query_text": "The function accepts two integer inputs and returns an integer computed by adding them together. It performs a straightforward arithmetic addition on the provided values and produces the resulting sum, leaving the original inputs unaltered.",
        "code_id": "c_group_1_id_403",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nlocal.get 4\ni32.load offset=8\nlocal.set 7\nlocal.get 7\ni32.load\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.add\nlocal.set 9\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_404",
        "query_text": "The function takes a single integer input and returns a boolean value. It determines whether the provided integer is odd by performing a bitwise AND operation with 1. If the outcome of the operation equals 1, the function concludes that the integer is odd and returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_404",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_405",
        "query_text": "The function accepts an integer as input and returns an integer as output representing the sign of the input. It returns \u20131 if the input is negative, 1 if the input is positive, and 0 if the input equals zero. The determination of the sign is performed using bitwise operations that compare the sign bit of the input and its negation.",
        "code_id": "c_group_1_id_405",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 31\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shr_s\nlocal.set 6\nlocal.get 3\ni32.load offset=12\nlocal.set 7\ni32.const 0\nlocal.set 8\nlocal.get 8\nlocal.get 7\ni32.sub\nlocal.set 9\ni32.const 31\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.shr_s\nlocal.set 11\nlocal.get 6\nlocal.get 11\ni32.sub\nlocal.set 12\nlocal.get 12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_407",
        "query_text": "The function takes two inputs: a pointer to a pointer to unsigned char, representing an array of pointers, and a size_t value indicating the length of the memory block. It releases the memory block by invoking the munmap system call on the specified address and length. The function does not return any value.",
        "code_id": "c_group_1_id_407",
        "code_text": "(func (;1;) (type 4) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 5\nlocal.get 6\ncall 10\ndrop\ni32.const 16\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_408",
        "query_text": "The function is defined with internal linkage and does not accept any input parameters. It returns no value. It is intended to output timing results in an XML format; however, its current implementation is empty and does not perform any operations or produce output.",
        "code_id": "c_group_1_id_408",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_409",
        "query_text": "The function takes two unsigned character inputs and returns an unsigned integer. It begins by asserting that the two inputs are not equal, ensuring that this condition holds true during execution. However, it does not perform any further computations or comparisons on the inputs; they are effectively ignored. Ultimately, the function always returns the constant value 0, serving as a placeholder or stub implementation. The inputs are of type unsigned char, and the output is of type unsigned int.",
        "code_id": "c_group_1_id_409",
        "code_text": "(func (;5;) (type 5) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store8 offset=15\nlocal.get 4\nlocal.get 1\ni32.store8 offset=14\nlocal.get 4\ni32.load8_u offset=15\nlocal.set 5\ni32.const 255\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 4\ni32.load8_u offset=14\nlocal.set 8\ni32.const 255\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 7\nlocal.get 10\ni32.ne\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 13\ni32.eqz\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\ni32.const 65651\nlocal.set 14\ni32.const 65565\nlocal.set 15\ni32.const 19\nlocal.set 16\ni32.const 65668\nlocal.set 17\nlocal.get 14\nlocal.get 15\nlocal.get 16\nlocal.get 17\ncall 7\nunreachable\nend\ni32.const 0\nlocal.set 18\ni32.const 16\nlocal.set 19\nlocal.get 4\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\nglobal.set 0\nlocal.get 18\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_410",
        "query_text": "This function is a stub that currently performs no operations. It accepts no input parameters and returns no value. Although marked as inline, its empty body indicates that it is intended as a placeholder for future implementation rather than providing any immediate functionality.",
        "code_id": "c_group_1_id_410",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_411",
        "query_text": "The function takes no input parameters and returns no output. It performs no operations when executed, acting as a no-operation (no-op) procedure. This function serves as a placeholder for situations where a function call is syntactically necessary but no functionality is required.",
        "code_id": "c_group_1_id_411",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_412",
        "query_text": "The function is a placeholder that accepts no parameters and returns no value. It is declared as an inline static function, indicating that its definition is provided in the header and may be substituted directly at the point of call. The empty function body signifies that no operations are performed when this function is invoked.",
        "code_id": "c_group_1_id_412",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_413",
        "query_text": "The function takes a constant string as input and returns a dynamically allocated string as output. It opens a system file that contains information about the current process and reads it line by line. For each line, the function splits the line at a delimiter and compares the first part with the provided key. If a match is found, it extracts the corresponding value by trimming any leading whitespace and removing the trailing newline character, then returns a copy of this value. If no matching entry is found or an error occurs (such as the file failing to open), it returns a NULL pointer, indicating failure. The caller is responsible for deallocating the returned string when it is no longer needed.",
        "code_id": "c_group_1_id_413",
        "code_text": "(func (;5;) (type 0) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 32\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=28\ni32.const 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=24\ni32.const 0\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.store offset=20\ni32.const 0\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.store offset=16\ni32.const 65548\nlocal.set 7\ni32.const 65576\nlocal.set 8\nlocal.get 7\nlocal.get 8\ncall 27\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 10\ni32.const 0\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.ne\nlocal.set 12\ni32.const 1\nlocal.set 13\nlocal.get 12\nlocal.get 13\ni32.and\nlocal.set 14\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 14\nbr_if 0 (;@2;)\nbr 1 (;@1;)\nend\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 3\ni32.load offset=12\nlocal.set 15\ni32.const 20\nlocal.set 16\nlocal.get 3\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 17\nlocal.set 18\ni32.const 16\nlocal.set 19\nlocal.get 3\nlocal.get 19\ni32.add\nlocal.set 20\nlocal.get 20\nlocal.set 21\nlocal.get 18\nlocal.get 21\nlocal.get 15\ncall 32\nlocal.set 22\ni32.const -1\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.ne\nlocal.set 24\ni32.const 1\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.and\nlocal.set 26\nlocal.get 26\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 3\ni32.load offset=20\nlocal.set 27\ni32.const 58\nlocal.set 28\nlocal.get 27\nlocal.get 28\ncall 6\nlocal.set 29\nlocal.get 3\nlocal.get 29\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 30\ni32.const 0\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.ne\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.and\nlocal.set 34\nblock  ;; label = @4\nblock  ;; label = @5\nlocal.get 34\ni32.eqz\nbr_if 0 (;@5;)\nlocal.get 3\ni32.load offset=8\nlocal.set 35\nlocal.get 35\ni32.load8_u\nlocal.set 36\ni32.const 24\nlocal.set 37\nlocal.get 36\nlocal.get 37\ni32.shl\nlocal.set 38\nlocal.get 38\nlocal.get 37\ni32.shr_s\nlocal.set 39\nlocal.get 39\nbr_if 1 (;@4;)\nend\nbr 1 (;@3;)\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 40\ni32.const 0\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.store8\nlocal.get 3\ni32.load offset=20\nlocal.set 42\nlocal.get 3\ni32.load offset=28\nlocal.set 43\nlocal.get 42\nlocal.get 43\ncall 42\nlocal.set 44\nblock  ;; label = @4\nlocal.get 44\ni32.eqz\nbr_if 0 (;@4;)\nbr 1 (;@3;)\nend\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 45\ni32.const 1\nlocal.set 46\nlocal.get 45\nlocal.get 46\ni32.add\nlocal.set 47\nlocal.get 3\nlocal.get 47\ni32.store offset=8\nloop  ;; label = @3\nlocal.get 3\ni32.load offset=8\nlocal.set 48\nlocal.get 48\ni32.load8_u\nlocal.set 49\ni32.const 24\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.shl\nlocal.set 51\nlocal.get 51\nlocal.get 50\ni32.shr_s\nlocal.set 52\ni32.const 32\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.eq\nlocal.set 54\ni32.const 1\nlocal.set 55\ni32.const 1\nlocal.set 56\nlocal.get 54\nlocal.get 56\ni32.and\nlocal.set 57\nlocal.get 55\nlocal.set 58\nblock  ;; label = @4\nlocal.get 57\nbr_if 0 (;@4;)\nlocal.get 3\ni32.load offset=8\nlocal.set 59\nlocal.get 59\ni32.load8_u\nlocal.set 60\ni32.const 24\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.shl\nlocal.set 62\nlocal.get 62\nlocal.get 61\ni32.shr_s\nlocal.set 63\ni32.const 9\nlocal.set 64\nlocal.get 63\nlocal.get 64\ni32.eq\nlocal.set 65\nlocal.get 65\nlocal.set 58\nend\nlocal.get 58\nlocal.set 66\ni32.const 1\nlocal.set 67\nlocal.get 66\nlocal.get 67\ni32.and\nlocal.set 68\nblock  ;; label = @4\nlocal.get 68\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 3\ni32.load offset=8\nlocal.set 69\ni32.const 1\nlocal.set 70\nlocal.get 69\nlocal.get 70\ni32.add\nlocal.set 71\nlocal.get 3\nlocal.get 71\ni32.store offset=8\nbr 1 (;@3;)\nend\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 72\nlocal.get 72\ncall 43\nlocal.set 73\ni32.const 1\nlocal.set 74\nlocal.get 73\nlocal.get 74\ni32.gt_u\nlocal.set 75\ni32.const 1\nlocal.set 76\nlocal.get 75\nlocal.get 76\ni32.and\nlocal.set 77\nblock  ;; label = @3\nlocal.get 77\ni32.eqz\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load offset=8\nlocal.set 78\nlocal.get 3\ni32.load offset=8\nlocal.set 79\nlocal.get 79\ncall 43\nlocal.set 80\ni32.const 1\nlocal.set 81\nlocal.get 80\nlocal.get 81\ni32.sub\nlocal.set 82\nlocal.get 78\nlocal.get 82\ni32.add\nlocal.set 83\ni32.const 0\nlocal.set 84\nlocal.get 83\nlocal.get 84\ni32.store8\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 85\nlocal.get 85\ni32.load8_u\nlocal.set 86\ni32.const 24\nlocal.set 87\nlocal.get 86\nlocal.get 87\ni32.shl\nlocal.set 88\nlocal.get 88\nlocal.get 87\ni32.shr_s\nlocal.set 89\nblock  ;; label = @3\nlocal.get 89\nbr_if 0 (;@3;)\nbr 2 (;@1;)\nend\nlocal.get 3\ni32.load offset=20\nlocal.set 90\nlocal.get 3\nlocal.get 90\ni32.store offset=24\nblock  ;; label = @3\nloop  ;; label = @4\nlocal.get 3\ni32.load offset=8\nlocal.set 91\ni32.const 1\nlocal.set 92\nlocal.get 91\nlocal.get 92\ni32.add\nlocal.set 93\nlocal.get 3\nlocal.get 93\ni32.store offset=8\nlocal.get 91\ni32.load8_u\nlocal.set 94\nlocal.get 3\ni32.load offset=20\nlocal.set 95\ni32.const 1\nlocal.set 96\nlocal.get 95\nlocal.get 96\ni32.add\nlocal.set 97\nlocal.get 3\nlocal.get 97\ni32.store offset=20\nlocal.get 95\nlocal.get 94\ni32.store8\ni32.const 0\nlocal.set 98\ni32.const 255\nlocal.set 99\nlocal.get 94\nlocal.get 99\ni32.and\nlocal.set 100\ni32.const 255\nlocal.set 101\nlocal.get 98\nlocal.get 101\ni32.and\nlocal.set 102\nlocal.get 100\nlocal.get 102\ni32.ne\nlocal.set 103\ni32.const 1\nlocal.set 104\nlocal.get 103\nlocal.get 104\ni32.and\nlocal.set 105\nlocal.get 105\ni32.eqz\nbr_if 1 (;@3;)\nbr 0 (;@4;)\nend\nunreachable\nend\nbr 1 (;@1;)\nend\nend\nlocal.get 3\ni32.load offset=24\nlocal.set 106\ni32.const 0\nlocal.set 107\nlocal.get 106\nlocal.get 107\ni32.ne\nlocal.set 108\ni32.const 1\nlocal.set 109\nlocal.get 108\nlocal.get 109\ni32.and\nlocal.set 110\nblock  ;; label = @1\nlocal.get 110\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=20\nlocal.set 111\nlocal.get 111\ncall 49\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 112\ni32.const 0\nlocal.set 113\nlocal.get 112\nlocal.get 113\ni32.ne\nlocal.set 114\ni32.const 1\nlocal.set 115\nlocal.get 114\nlocal.get 115\ni32.and\nlocal.set 116\nblock  ;; label = @1\nlocal.get 116\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 117\nlocal.get 117\ncall 11\ndrop\nend\nlocal.get 3\ni32.load offset=24\nlocal.set 118\ni32.const 32\nlocal.set 119\nlocal.get 3\nlocal.get 119\ni32.add\nlocal.set 120\nlocal.get 120\nglobal.set 0\nlocal.get 118\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_414",
        "query_text": "The function accepts three inputs: a character array that serves as a destination buffer, an array of character pointers representing strings, and an unsigned integer indicating the total number of strings. It iterates over the first half of the string array while pairing each element with a corresponding element from the second half. For each pair, the function removes the trailing newline (or similar character) from the first string, then appends it to the destination buffer with a set of spaces, followed by a separator and the paired string. If the total number of strings is odd, the leftover string (without a pair) is appended to the buffer without the separator. The function modifies the destination buffer directly and does not return any value.",
        "code_id": "c_group_1_id_414",
        "code_text": "(func (;1;) (type 3) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store offset=16\nlocal.get 5\ni32.load offset=20\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.shr_u\nlocal.set 9\nlocal.get 5\nlocal.get 9\ni32.store offset=12\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load offset=16\nlocal.set 10\nlocal.get 5\ni32.load offset=20\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.shr_u\nlocal.set 13\nlocal.get 10\nlocal.get 13\ni32.lt_u\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 16\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=24\nlocal.set 17\nlocal.get 5\ni32.load offset=16\nlocal.set 18\ni32.const 2\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.shl\nlocal.set 20\nlocal.get 17\nlocal.get 20\ni32.add\nlocal.set 21\nlocal.get 21\ni32.load\nlocal.set 22\nlocal.get 5\ni32.load offset=24\nlocal.set 23\nlocal.get 5\ni32.load offset=16\nlocal.set 24\ni32.const 2\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.shl\nlocal.set 26\nlocal.get 23\nlocal.get 26\ni32.add\nlocal.set 27\nlocal.get 27\ni32.load\nlocal.set 28\nlocal.get 28\ncall 6\nlocal.set 29\ni32.const 1\nlocal.set 30\nlocal.get 29\nlocal.get 30\ni32.sub\nlocal.set 31\nlocal.get 22\nlocal.get 31\ni32.add\nlocal.set 32\ni32.const 0\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.store8\nlocal.get 5\ni32.load offset=28\nlocal.set 34\ni32.const 65542\nlocal.set 35\nlocal.get 34\nlocal.get 35\ncall 3\ndrop\nlocal.get 5\ni32.load offset=28\nlocal.set 36\nlocal.get 5\ni32.load offset=24\nlocal.set 37\nlocal.get 5\ni32.load offset=16\nlocal.set 38\ni32.const 2\nlocal.set 39\nlocal.get 38\nlocal.get 39\ni32.shl\nlocal.set 40\nlocal.get 37\nlocal.get 40\ni32.add\nlocal.set 41\nlocal.get 41\ni32.load\nlocal.set 42\nlocal.get 36\nlocal.get 42\ncall 3\ndrop\nlocal.get 5\ni32.load offset=28\nlocal.set 43\ni32.const 65536\nlocal.set 44\nlocal.get 43\nlocal.get 44\ncall 3\ndrop\nlocal.get 5\ni32.load offset=28\nlocal.set 45\nlocal.get 5\ni32.load offset=24\nlocal.set 46\nlocal.get 5\ni32.load offset=12\nlocal.set 47\ni32.const 2\nlocal.set 48\nlocal.get 47\nlocal.get 48\ni32.shl\nlocal.set 49\nlocal.get 46\nlocal.get 49\ni32.add\nlocal.set 50\nlocal.get 50\ni32.load\nlocal.set 51\nlocal.get 45\nlocal.get 51\ncall 3\ndrop\nlocal.get 5\ni32.load offset=16\nlocal.set 52\ni32.const 1\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.add\nlocal.set 54\nlocal.get 5\nlocal.get 54\ni32.store offset=16\nlocal.get 5\ni32.load offset=12\nlocal.set 55\ni32.const 1\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.add\nlocal.set 57\nlocal.get 5\nlocal.get 57\ni32.store offset=12\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 5\ni32.load offset=12\nlocal.set 58\nlocal.get 5\ni32.load offset=20\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.lt_u\nlocal.set 60\ni32.const 1\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.and\nlocal.set 62\nblock  ;; label = @1\nlocal.get 62\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 5\ni32.load offset=28\nlocal.set 63\ni32.const 65542\nlocal.set 64\nlocal.get 63\nlocal.get 64\ncall 3\ndrop\nlocal.get 5\ni32.load offset=28\nlocal.set 65\nlocal.get 5\ni32.load offset=24\nlocal.set 66\nlocal.get 5\ni32.load offset=12\nlocal.set 67\ni32.const 2\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.shl\nlocal.set 69\nlocal.get 66\nlocal.get 69\ni32.add\nlocal.set 70\nlocal.get 70\ni32.load\nlocal.set 71\nlocal.get 65\nlocal.get 71\ncall 3\ndrop\nend\ni32.const 32\nlocal.set 72\nlocal.get 5\nlocal.get 72\ni32.add\nlocal.set 73\nlocal.get 73\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_415",
        "query_text": "The function accepts an integer input and processes it by consecutively dividing it by a predefined series of numbers. For each divisor in the sequence, the function divides the input repeatedly as long as the division yields no remainder. After iterating through all the specified divisors, the function checks the resulting value: if it has been reduced to 1, the function returns 1; otherwise, it returns 0. The input is an integer, and the output is an integer that indicates whether the input has been entirely factored by the given numbers.",
        "code_id": "c_group_1_id_415",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=8\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 4\ni32.const 53\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.rem_s\nlocal.set 6\nlocal.get 6\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 7\ni32.const 53\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.div_s\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 10\ni32.const 47\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.rem_s\nlocal.set 12\nlocal.get 12\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 13\ni32.const 47\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.div_s\nlocal.set 15\nlocal.get 3\nlocal.get 15\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 16\ni32.const 43\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.rem_s\nlocal.set 18\nlocal.get 18\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 19\ni32.const 43\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.div_s\nlocal.set 21\nlocal.get 3\nlocal.get 21\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 22\ni32.const 41\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.rem_s\nlocal.set 24\nlocal.get 24\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 25\ni32.const 41\nlocal.set 26\nlocal.get 25\nlocal.get 26\ni32.div_s\nlocal.set 27\nlocal.get 3\nlocal.get 27\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 28\ni32.const 37\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.rem_s\nlocal.set 30\nlocal.get 30\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 31\ni32.const 37\nlocal.set 32\nlocal.get 31\nlocal.get 32\ni32.div_s\nlocal.set 33\nlocal.get 3\nlocal.get 33\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 34\ni32.const 31\nlocal.set 35\nlocal.get 34\nlocal.get 35\ni32.rem_s\nlocal.set 36\nlocal.get 36\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 37\ni32.const 31\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.div_s\nlocal.set 39\nlocal.get 3\nlocal.get 39\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 40\ni32.const 29\nlocal.set 41\nlocal.get 40\nlocal.get 41\ni32.rem_s\nlocal.set 42\nlocal.get 42\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 43\ni32.const 29\nlocal.set 44\nlocal.get 43\nlocal.get 44\ni32.div_s\nlocal.set 45\nlocal.get 3\nlocal.get 45\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 46\ni32.const 23\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.rem_s\nlocal.set 48\nlocal.get 48\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 49\ni32.const 23\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.div_s\nlocal.set 51\nlocal.get 3\nlocal.get 51\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 52\ni32.const 17\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.rem_s\nlocal.set 54\nlocal.get 54\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 55\ni32.const 17\nlocal.set 56\nlocal.get 55\nlocal.get 56\ni32.div_s\nlocal.set 57\nlocal.get 3\nlocal.get 57\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 58\ni32.const 13\nlocal.set 59\nlocal.get 58\nlocal.get 59\ni32.rem_s\nlocal.set 60\nlocal.get 60\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 61\ni32.const 13\nlocal.set 62\nlocal.get 61\nlocal.get 62\ni32.div_s\nlocal.set 63\nlocal.get 3\nlocal.get 63\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 64\ni32.const 11\nlocal.set 65\nlocal.get 64\nlocal.get 65\ni32.rem_s\nlocal.set 66\nlocal.get 66\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 67\ni32.const 11\nlocal.set 68\nlocal.get 67\nlocal.get 68\ni32.div_s\nlocal.set 69\nlocal.get 3\nlocal.get 69\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 70\ni32.const 8\nlocal.set 71\nlocal.get 70\nlocal.get 71\ni32.rem_s\nlocal.set 72\nlocal.get 72\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 73\ni32.const 8\nlocal.set 74\nlocal.get 73\nlocal.get 74\ni32.div_s\nlocal.set 75\nlocal.get 3\nlocal.get 75\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 76\ni32.const 7\nlocal.set 77\nlocal.get 76\nlocal.get 77\ni32.rem_s\nlocal.set 78\nlocal.get 78\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 79\ni32.const 7\nlocal.set 80\nlocal.get 79\nlocal.get 80\ni32.div_s\nlocal.set 81\nlocal.get 3\nlocal.get 81\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 82\ni32.const 5\nlocal.set 83\nlocal.get 82\nlocal.get 83\ni32.rem_s\nlocal.set 84\nlocal.get 84\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 85\ni32.const 5\nlocal.set 86\nlocal.get 85\nlocal.get 86\ni32.div_s\nlocal.set 87\nlocal.get 3\nlocal.get 87\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 88\ni32.const 4\nlocal.set 89\nlocal.get 88\nlocal.get 89\ni32.rem_s\nlocal.set 90\nlocal.get 90\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 91\ni32.const 4\nlocal.set 92\nlocal.get 91\nlocal.get 92\ni32.div_s\nlocal.set 93\nlocal.get 3\nlocal.get 93\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 94\ni32.const 3\nlocal.set 95\nlocal.get 94\nlocal.get 95\ni32.rem_s\nlocal.set 96\nlocal.get 96\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 97\ni32.const 3\nlocal.set 98\nlocal.get 97\nlocal.get 98\ni32.div_s\nlocal.set 99\nlocal.get 3\nlocal.get 99\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 100\ni32.const 2\nlocal.set 101\nlocal.get 100\nlocal.get 101\ni32.rem_s\nlocal.set 102\nlocal.get 102\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 103\ni32.const 2\nlocal.set 104\nlocal.get 103\nlocal.get 104\ni32.div_s\nlocal.set 105\nlocal.get 3\nlocal.get 105\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 106\ni32.const 1\nlocal.set 107\nlocal.get 106\nlocal.get 107\ni32.eq\nlocal.set 108\ni32.const 1\nlocal.set 109\nlocal.get 108\nlocal.get 109\ni32.and\nlocal.set 110\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 110\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 1\nlocal.set 111\nlocal.get 3\nlocal.get 111\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 112\nlocal.get 3\nlocal.get 112\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 113\nlocal.get 113\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_417",
        "query_text": "The function accepts an integer input and systematically eliminates all occurrences of the factors 2, 3, 5, and 7. It does so by repeatedly performing integer division on the input with each of these divisors whenever the current value is divisible by them. Ultimately, the function returns the modified integer after all such factor removals have been applied. The input and output are both of type int.",
        "code_id": "c_group_1_id_417",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 5\ni32.const 7\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.rem_s\nlocal.set 7\nlocal.get 7\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 8\ni32.const 7\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.div_s\nlocal.set 10\nlocal.get 3\nlocal.get 10\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 11\ni32.const 3\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.rem_s\nlocal.set 13\nlocal.get 13\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 14\ni32.const 3\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.div_s\nlocal.set 16\nlocal.get 3\nlocal.get 16\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 17\ni32.const 5\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.rem_s\nlocal.set 19\nlocal.get 19\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 20\ni32.const 5\nlocal.set 21\nlocal.get 20\nlocal.get 21\ni32.div_s\nlocal.set 22\nlocal.get 3\nlocal.get 22\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 3\ni32.load offset=8\nlocal.set 23\ni32.const 2\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.rem_s\nlocal.set 25\nlocal.get 25\nbr_if 1 (;@1;)\nlocal.get 3\ni32.load offset=8\nlocal.set 26\ni32.const 2\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.div_s\nlocal.set 28\nlocal.get 3\nlocal.get 28\ni32.store offset=8\nbr 0 (;@2;)\nend\nunreachable\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 29\nlocal.get 29\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_418",
        "query_text": "This function accepts a floating-point number as input and returns an integer representing the rounded value. It adds 0.49999 to the input value, and then converts the result to an integer, which effectively rounds the input to the nearest whole number. The input is of type double, and the output is of type int.",
        "code_id": "c_group_1_id_418",
        "code_text": "(func (;1;) (type 2) (param f64) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f64 f64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf64.store offset=8\nlocal.get 3\nf64.load offset=8\nlocal.set 11\nf64.const 0x1.fffd60e94ee39p-2 (;=0.49999;)\nlocal.set 12\nlocal.get 11\nlocal.get 12\nf64.add\nlocal.set 13\nlocal.get 13\nf64.abs\nlocal.set 14\nf64.const 0x1p+31 (;=2.14748e+09;)\nlocal.set 15\nlocal.get 14\nlocal.get 15\nf64.lt\nlocal.set 4\nlocal.get 4\ni32.eqz\nlocal.set 5\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 5\nbr_if 0 (;@2;)\nlocal.get 13\ni32.trunc_f64_s\nlocal.set 6\nlocal.get 6\nlocal.set 7\nbr 1 (;@1;)\nend\ni32.const -2147483648\nlocal.set 8\nlocal.get 8\nlocal.set 7\nend\nlocal.get 7\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=4\nlocal.get 3\ni32.load offset=4\nlocal.set 10\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_419",
        "query_text": "The function takes no input parameters and consistently returns an integer value of 42. The return type is int, and the function does not perform any operations apart from returning this constant value.",
        "code_id": "c_group_1_id_419",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 42\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_420",
        "query_text": "The function takes no input parameters and directly returns the integer value 42. The output is of type int.",
        "code_id": "c_group_1_id_420",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 42\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_421",
        "query_text": "The function accepts an unsigned integer as input and returns a boolean value. It evaluates whether the input is greater than 15 and less than 272, thereby determining if the value lies within the exclusive range of 16 to 271. If the input satisfies these conditions, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_421",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 15\nlocal.set 5\nlocal.get 5\nlocal.get 4\ni32.lt_u\nlocal.set 6\ni32.const 0\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 6\nlocal.get 8\ni32.and\nlocal.set 9\nlocal.get 7\nlocal.set 10\nblock  ;; label = @1\nlocal.get 9\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 11\ni32.const 272\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.lt_u\nlocal.set 13\nlocal.get 13\nlocal.set 10\nend\nlocal.get 10\nlocal.set 14\ni32.const 1\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\nlocal.get 16\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_422",
        "query_text": "The function is a compile-time evaluable routine that accepts a variable number of arguments, although it does not process them in any way. It simply returns a boolean value of true without performing any computations or modifications based on the input. The routine is designed to be executed during compilation, as suggested by its constant expression attribute, and includes a modifier that may be specific to certain platforms.",
        "code_id": "c_group_1_id_422",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32)\ni32.const 1\nlocal.set 1\ni32.const 1\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.and\nlocal.set 3\nlocal.get 3\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_423",
        "query_text": "The function takes three inputs: a pointer to an array of short integers, a pointer to an array of floats, and an integer representing the number of elements. It processes every element in the input array by dividing each short integer by the constant value 32768.0 (expressed as 0x8000 in hexadecimal) and casting the result to a float. The converted values are then stored sequentially in the output array. The input types are short integers and an int, and the output type is float.",
        "code_id": "c_group_1_id_423",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load\nlocal.set 7\nlocal.get 5\ni32.load offset=4\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.lt_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=12\nlocal.set 12\nlocal.get 5\ni32.load\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 12\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\ni32.load16_s\nlocal.set 17\nlocal.get 17\nf64.convert_i32_s\nlocal.set 26\nf64.const 0x1p+15 (;=32768;)\nlocal.set 27\nlocal.get 26\nlocal.get 27\nf64.div\nlocal.set 28\nlocal.get 28\nf32.demote_f64\nlocal.set 29\nlocal.get 5\ni32.load offset=8\nlocal.set 18\nlocal.get 5\ni32.load\nlocal.set 19\ni32.const 2\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 18\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 22\nlocal.get 29\nf32.store\nlocal.get 5\ni32.load\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 5\nlocal.get 25\ni32.store\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_424",
        "query_text": "The function accepts an array of integers and its length as input, along with an array to store the output. It processes each element by dividing the integer by a constant value (computed as 8.0 multiplied by a large constant) and then casting the result to a floating-point number. The computed float is stored in the output array at the corresponding position. The input consists of an integer array and its length, and the function returns an array of floats after processing every element up to the specified length.",
        "code_id": "c_group_1_id_424",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 f64 f64 f64 f32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\ni32.const 0\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store\nblock  ;; label = @1\nloop  ;; label = @2\nlocal.get 5\ni32.load\nlocal.set 7\nlocal.get 5\ni32.load offset=4\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.lt_s\nlocal.set 9\ni32.const 1\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.and\nlocal.set 11\nlocal.get 11\ni32.eqz\nbr_if 1 (;@1;)\nlocal.get 5\ni32.load offset=12\nlocal.set 12\nlocal.get 5\ni32.load\nlocal.set 13\ni32.const 2\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.shl\nlocal.set 15\nlocal.get 12\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 16\ni32.load\nlocal.set 17\nlocal.get 17\nf64.convert_i32_s\nlocal.set 26\nf64.const 0x1p+31 (;=2.14748e+09;)\nlocal.set 27\nlocal.get 26\nlocal.get 27\nf64.div\nlocal.set 28\nlocal.get 28\nf32.demote_f64\nlocal.set 29\nlocal.get 5\ni32.load offset=8\nlocal.set 18\nlocal.get 5\ni32.load\nlocal.set 19\ni32.const 2\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 18\nlocal.get 21\ni32.add\nlocal.set 22\nlocal.get 22\nlocal.get 29\nf32.store\nlocal.get 5\ni32.load\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.add\nlocal.set 25\nlocal.get 5\nlocal.get 25\ni32.store\nbr 0 (;@2;)\nend\nunreachable\nend\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_425",
        "query_text": "The function accepts three inputs: a pointer to an array of floats, an integer representing the number of elements in the array, and another integer that denotes an expected count of peaks. It returns a double that represents the signal-to-noise ratio (SNR). Instead of processing the inputs, the function immediately provides a constant double value of 200.0, serving as a placeholder or stub.",
        "code_id": "c_group_1_id_425",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32) (result f64)\n(local i32 i32 i32 i32 i32 i32 f64 f64)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\nf64.const 0x1.9p+7 (;=200;)\nlocal.set 9\nlocal.get 5\nlocal.get 9\nf64.store offset=8\nlocal.get 5\ni32.load offset=28\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.store offset=28\nlocal.get 5\ni32.load offset=24\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store offset=24\nlocal.get 5\ni32.load offset=20\nlocal.set 8\nlocal.get 5\nlocal.get 8\ni32.store offset=20\nlocal.get 5\nf64.load offset=8\nlocal.set 10\nlocal.get 10\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_426",
        "query_text": "The function acts as a signal handler that is invoked when a particular signal is received. It accepts an integer input representing the signal number, although this input is not utilized within the function. Upon activation, it immediately prints an error message indicating that a hang has been detected within a callback reading function. Following the message display, the function terminates the program abnormally by calling an exit routine with a status code of 1.\n\n\u2022 Input: An integer representing a signal number (unused within the function).  \n\u2022 Output: None (void function).  \n\u2022 Functionality: The function serves as a signal handler; it outputs an error message alerting of a detected hang in a callback reading process and then forces program termination with an exit status of 1.",
        "code_id": "c_group_1_id_426",
        "code_text": "(func (;3;) (type 2) (param i32)\n(local i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 65590\nlocal.set 4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ncall 9\ndrop\ni32.const 1\nlocal.set 6\nlocal.get 6\ncall 7\nunreachable)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_427",
        "query_text": "The function takes a pointer to an integer and an integer value as inputs. It first retrieves the current value stored at the provided pointer, then adds the provided integer value to it, updating the original value atomically to ensure thread safety. Finally, the function returns the original integer value obtained before the addition.",
        "code_id": "c_group_1_id_427",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 7\nlocal.get 4\ni32.load offset=12\nlocal.set 8\nlocal.get 8\ni32.load\nlocal.set 9\nlocal.get 9\nlocal.get 7\ni32.add\nlocal.set 10\nlocal.get 8\nlocal.get 10\ni32.store\nlocal.get 4\ni32.load offset=4\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_428",
        "query_text": "The function takes two inputs: a pointer to an integer and an integer. It retrieves the current value from the integer pointed to by the pointer, subtracts the given integer from it, and then returns the original value before the subtraction occurred. The function returns an int.",
        "code_id": "c_group_1_id_428",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=4\nlocal.get 4\ni32.load offset=8\nlocal.set 7\nlocal.get 4\ni32.load offset=12\nlocal.set 8\nlocal.get 8\ni32.load\nlocal.set 9\nlocal.get 9\nlocal.get 7\ni32.sub\nlocal.set 10\nlocal.get 8\nlocal.get 10\ni32.store\nlocal.get 4\ni32.load offset=4\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_429",
        "query_text": "The function takes an unsigned long integer as input and returns a constant character pointer (string). It ignores the numerical input and does not use it in any computation. Instead, it logs a debug message to inform the user that it does not provide the name of the function that failed, advising them to consult the debug logs for additional error details. The function always returns an empty string and does not supply any specific error-related information directly.",
        "code_id": "c_group_1_id_429",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 65536\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_430",
        "query_text": "The function is defined as a static inline function that accepts no inputs and returns no output. It performs no operations and serves purely as a placeholder or no-op function, meant to be used in contexts where a function call is required despite no functional action being necessary.",
        "code_id": "c_group_1_id_430",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_431",
        "query_text": "The function accepts three parameters: a pointer to an unsigned character array, an integer representing a size, and an integer representing a type. It ignores the unsigned character array and then prints a formatted message to the console that includes the size and type values, signaling that a specific cache add callback has been triggered. The function does not return any value.",
        "code_id": "c_group_1_id_431",
        "code_text": "(func (;2;) (type 6) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\nlocal.get 5\ni32.load offset=24\nlocal.set 6\nlocal.get 5\ni32.load offset=20\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store offset=4\nlocal.get 5\nlocal.get 6\ni32.store\ni32.const 65590\nlocal.set 8\nlocal.get 8\nlocal.get 5\ncall 12\ndrop\ni32.const 0\nlocal.set 9\nlocal.get 9\ni32.load offset=65640\nlocal.set 10\nlocal.get 10\ncall 6\ndrop\ni32.const 32\nlocal.set 11\nlocal.get 5\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 12\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_432",
        "query_text": "This function tests secure remote password protocol operations in a controlled environment. It is conditionally compiled to run only when both the secure remote password and SHA-512 features are enabled. The function takes no input parameters and returns no value. It first initializes the cryptographic library before sequentially testing various SRP operations such as context initialization, username and parameter setting, and\u2014if SHA is enabled\u2014password configuration, public key generation, shared key computation, and session proof verification. It also tests a callback mechanism for key generation before finally cleaning up the cryptographic library.",
        "code_id": "c_group_1_id_432",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_433",
        "query_text": "The function takes no input arguments and returns an integer value. It immediately outputs a predefined constant that signifies that a particular test or operation has been skipped. The function performs no computations or modifications; its sole purpose is to serve as an indicator for the skipped functionality.",
        "code_id": "c_group_1_id_433",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_434",
        "query_text": "This function takes no input and returns an integer that signifies a test case has been intentionally skipped. It does not perform any operations besides immediately returning a predefined constant representing the skipped test status. The function serves as a marker or placeholder to indicate that the particular test is not executed during a testing run.",
        "code_id": "c_group_1_id_434",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_435",
        "query_text": "The function takes no input arguments and returns an integer indicating the outcome of its test. It conditionally tests the export functionality of TLS sessions by first verifying that the environment is configured to support session export for TLS version 1.2. If these conditions are met, it proceeds to execute tests for TLS 1.2 and, if further configured, for TLS 1.3. The integer output represents whether the tests passed, failed, or were skipped due to unmet preprocessor conditions.",
        "code_id": "c_group_1_id_435",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_436",
        "query_text": "The function takes no explicit inputs and returns an integer representing a test outcome. It begins by initializing internal structures for a random number generator and an elliptic curve cryptography key. The function then validates error handling by invoking the key generation routine with invalid (null) parameters and verifying that the expected error codes are returned. Following these checks, it calls the key generation routine with proper inputs to create an SM2 key pair and confirms that the generated key corresponds to the designated SM2 curve. Finally, it frees the allocated resources and returns an integer result indicating whether the test passed, failed, or was skipped.",
        "code_id": "c_group_1_id_436",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_437",
        "query_text": "This function validates the process of generating a shared secret using an elliptic curve cryptography algorithm based on SM2. It begins by initializing a random number generator alongside two separate elliptic curve key pairs. It then performs key generation for both pairs and proceeds to compute shared secrets for each using the SM2 method. The function confirms that the shared secrets produced by the two key pairs are identical and do not exceed the expected maximum length. Additionally, it rigorously tests the error handling capabilities by providing various invalid input combinations to ensure that improper arguments are correctly rejected. Finally, the function returns a result indicating whether the test passed, failed, or was skipped due to missing dependencies.",
        "code_id": "c_group_1_id_437",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_438",
        "query_text": "The function is a test procedure that returns an integer test result indicating whether the test passed, failed, or was skipped. It operates as follows:\n\n1. Initialization: It sets up an elliptic curve key structure and prepares several input byte arrays, which include a public key, an identifier, and a message. Additionally, it determines the hash algorithm (choosing between two possible types based on compile-time configuration).\n\n2. Error Handling: It deliberately invokes a digest creation routine with various invalid or null inputs\u2014such as null pointers and incorrect buffer sizes\u2014to verify that the routine consistently returns appropriate error codes when supplied with invalid arguments.\n\n3. Digest Creation: It calls the digest creation routine with proper inputs to generate a cryptographic digest (hash). The resulting digest is then compared with a predefined expected hash value to ensure correctness.\n\n4. Cleanup: Any resources allocated during the initialization (such as the elliptic curve structure) are freed before the function returns.\n\nThe overall purpose is to thoroughly test the digest creation functionality under both valid and error conditions, with the function's inputs being byte arrays (for the public key, identifier, and message) plus an enumeration for hash type, and the output being a test result code (integer).",
        "code_id": "c_group_1_id_438",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_439",
        "query_text": "The function takes no arguments and returns an integer status. It checks for a specific compile-time flag, and if present, it performs two cleanup operations: one on a certificate store context and another on a related trusted component. If the flag is defined, the function executes both cleanup routines and returns a success status; otherwise, it skips the operations and returns a skipped status.",
        "code_id": "c_group_1_id_439",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_440",
        "query_text": "The function takes no input parameters and is designed to test an error queue mechanism in a multi-threaded context. It begins by clearing any existing error state and then creates and starts a number of threads that each perform a logging operation. After initializing the threads, the function waits for all of them to complete their execution. Depending on whether certain preprocessor conditions (such as multi-threading, error queue per thread support, and debug options) are met, the function returns an integer value that indicates either a successful test run or that the test was skipped. The output type is int.",
        "code_id": "c_group_1_id_440",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_441",
        "query_text": "The function performs a test to validate macro behavior under certain compile-time conditions. It begins by evaluating whether any of several preprocessor flags are defined. If at least one is active, the function invokes a macro using a predefined constant string. Upon successful execution of the macro call, it returns a code signifying success; otherwise, it returns a code indicating that the test was skipped. The function takes no input parameters and returns an integer representing the outcome of the test.",
        "code_id": "c_group_1_id_441",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_442",
        "query_text": "The function takes no input parameters. It initializes a result variable with a value that indicates the test is skipped. Then, when compiled with certain preprocessor flags defined, it invokes a function that removes or resets an error state and updates the result variable to show that the test was successful. Finally, the function returns the result variable. The primary purpose of the function is to test the removal of an error state under specific compilation conditions.",
        "code_id": "c_group_1_id_442",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_443",
        "query_text": "The function takes no input parameters. It checks a specific compile-time condition: if a certain macro is defined, it calls a routine to load cryptographic error messages and then returns an integer constant representing success; otherwise, it directly returns an integer constant indicating that the operation was skipped. The function thereby returns an integer whose value depends on the defined macro.",
        "code_id": "c_group_1_id_443",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_444",
        "query_text": "The function takes no external inputs and returns an integer indicating the overall test result. It uses a fixed key, an initialization vector, a plaintext message, and additional authenticated data. The procedure is as follows:\n\n1. First, multiple encryption contexts are initialized for a Galois/Counter Mode cipher configured with three different key sizes. For each configuration, the function encrypts the plaintext by processing the additional authenticated data and obtains both the ciphertext and an authentication tag.\n\n2. Next, corresponding decryption contexts are set up. Each decryption process uses the fixed key and initialization vector to recover the original plaintext from the ciphertext while validating the authentication tag. Additionally, the function deliberately alters the authentication tag to verify that decryption fails when the tag is incorrect.\n\n3. Finally, after cleaning up the encryption and decryption contexts, the function returns an integer value representing whether the test passed, failed, or was skipped (e.g., if necessary features were unavailable).\n\nThe overall goal is to validate that the cipher's encryption and decryption operations function correctly and robustly across different configurations.",
        "code_id": "c_group_1_id_444",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_445",
        "query_text": "This function verifies the encryption and decryption processes of an SM4-GCM algorithm when provided with an empty (zero-length) plaintext input. It begins by initializing separate contexts for both encryption and decryption, and it employs predetermined byte arrays for the key and initialization vector (IV). During encryption, the function processes the empty plaintext to produce an empty ciphertext and generates an authentication tag. This tag is then compared to a predefined expected value. In the decryption phase, it takes the empty ciphertext along with the same fixed key and IV, sets the authentication tag, and confirms that the decryption also results in an empty output. The function uses various integer variables to track data sizes and processing results, and finally, it returns a status indicating whether the test passed, was skipped, or failed.",
        "code_id": "c_group_1_id_445",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_446",
        "query_text": "The function takes no explicit input parameters; instead, it utilizes internally defined constants for the encryption key, initialization vector (IV), plaintext, and additional authenticated data. It proceeds through the following steps:\n\n1. Encryption Phase:\n   - Initializes an encryption context for the SM4-GCM algorithm.\n   - Processes the additional authenticated data (AAD) and encrypts the plaintext using the key and IV.\n   - Finalizes the encryption to produce ciphertext and generates an authentication tag for integrity.\n\n2. Decryption Phase:\n   - Initializes a decryption context with the SM4-GCM algorithm.\n   - Uses the same key, IV, and AAD to decrypt the ciphertext.\n   - Verifies the integrity of the decrypted data by applying the authentication tag.\n\n3. Error Handling:\n   - Alters the authentication tag deliberately and attempts decryption again, ensuring the process fails as expected.\n\nThe function returns an integer value indicating the overall result of the performed tests, such as success, failure, or a skipped test. Internal variables include byte arrays for the cryptographic elements (key, IV, plaintext, ciphertext, decrypted text, and tag), various size indicators, and cryptographic context structures for managing encryption and decryption operations.",
        "code_id": "c_group_1_id_446",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_447",
        "query_text": "The function takes no parameters and returns an integer that indicates the test outcome. It first creates an original stack of certificate names and populates it with three entries. It then duplicates this stack using a duplication function and verifies that the duplicated stack has the same size as the original. Additionally, the function tests edge cases by providing null inputs and attempting to pop elements from both a null stack and an empty stack. Finally, it frees all allocated resources and returns an integer value representing success, failure, or skip status.",
        "code_id": "c_group_1_id_447",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_448",
        "query_text": "The function checks if it should run based on a compile-time condition. When the condition is met, it first performs a cleanup by freeing all configuration modules. It then executes three unload operations with different parameter values (0, 1, and -1) to ensure that the modules are fully released. If the compile-time condition is defined and all operations succeed, the function returns a success status; otherwise, it returns a skipped status. The function does not take any inputs and returns an integer indicating the test outcome.",
        "code_id": "c_group_1_id_448",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_449",
        "query_text": "The function tests the mechanism for setting dynamic lock callbacks in a cryptographic context. It only performs its actions when a particular macro is defined. Under that condition, the function assigns three types of dynamic lock callbacks\u2014creation, destruction, and locking\u2014by invoking their respective setter functions twice each: once with a null pointer and once with a non-zero integer cast as a function pointer. If the macro is not defined, the function skips its operations and returns a code indicating that the test was not executed. Otherwise, it returns a code representing success. The function takes no input parameters and returns an integer that indicates the outcome of the test.",
        "code_id": "c_group_1_id_449",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_450",
        "query_text": "The function performs a conditional cleanup operation related to an external module, but only when a specific compile-time macro is defined. It accepts no input parameters and returns an integer status code. Initially, the function sets the status to indicate a skipped operation. If the macro is defined, it invokes a cleanup routine from the module and updates the status to indicate a successful operation. Finally, the function returns the appropriate status, reflecting whether the cleanup was executed.",
        "code_id": "c_group_1_id_450",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_451",
        "query_text": "The function does not accept any parameters and returns an integer value. Its sole operation is to return a predefined constant that signifies that the associated test has been intentionally skipped. The function does not execute any further steps or computations.",
        "code_id": "c_group_1_id_451",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_452",
        "query_text": "The function takes no inputs and returns an integer. It is designed to simply return a predefined constant integer value that indicates a test has been skipped. The function's behavior does not depend on any parameters and does not perform additional operations beyond returning the constant value. The return type is int.",
        "code_id": "c_group_1_id_452",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_453",
        "query_text": "This function takes no input arguments and returns an integer indicating a test status. Specifically, it always returns a predefined constant that signifies the associated test has been skipped. The function does not perform any further processing or calculations, and its return type is an integer.",
        "code_id": "c_group_1_id_453",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_454",
        "query_text": "The function takes no input arguments and returns an integer. It simply returns a constant value that signifies that the associated test is intentionally skipped. The function does not perform any additional operations or computations.",
        "code_id": "c_group_1_id_454",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_455",
        "query_text": "The function takes no input arguments and returns an output of type int. It simply produces a predefined constant value that signifies a skipped test and does not perform any other computations.",
        "code_id": "c_group_1_id_455",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_456",
        "query_text": "The function accepts no input parameters and returns an integer value. It indicates that a specific DTLS (Datagram Transport Layer Security) test within a particular security library is skipped by directly returning a predefined constant that signifies the test is not executed. The function does not perform any internal computations or processing; it simply provides the test's skipped status via its integer return value.",
        "code_id": "c_group_1_id_456",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_457",
        "query_text": "This function returns a fixed integer constant indicating that a particular test has been intentionally skipped. It takes no input arguments and performs no additional processing or computations. The returned value is of type int, serving solely as a marker to bypass the execution of the test scenario.",
        "code_id": "c_group_1_id_457",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_458",
        "query_text": "The function performs a test of a hash algorithm's implementation. It initializes a hashing context, then iteratively updates this context with fixed-size byte array data using varying sizes\u2014including edge cases such as null inputs and zero-length data\u2014and finalizes the hash computation. Throughout the process, it validates error handling and ensures the computed hash matches an expected fixed-size hash value. Additionally, it checks the proper cleanup and deallocation of resources. The procedure returns an integer result that indicates whether the tests passed, failed, or were skipped.",
        "code_id": "c_group_1_id_458",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_459",
        "query_text": "The function takes no input arguments and returns an integer that indicates the outcome of a test. It is intended to verify the mechanism for iterating over all available message digest algorithms from a cryptographic library, but only if a specific conditional compilation macro is defined. In that case, it first invokes a utility to display all message digest algorithms by passing a null callback and a standard error stream as parameters. Next, it repeats the invocation using a particular callback function to list the algorithms. If both iterations succeed, the function produces a success status. If the macro is not defined, it returns a status indicating that the test was skipped.",
        "code_id": "c_group_1_id_459",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_460",
        "query_text": "The function, which takes no parameters, is conditionally compiled to execute only when a specific macro is defined. Initially, it sets a status variable to indicate that the test has been skipped. Within the conditional block, the function invokes an internal operation several times with various combinations of parameters. These invocations include passing predefined constant types, a callback function pointer, a file stream, and sometimes a NULL value to represent an absent callback or stream. If all the intended calls execute properly, the function updates the status to indicate success. Ultimately, the function returns an integer status value reflecting whether the test was skipped or successfully completed, serving as a black-box test for verifying the behavior of the underlying operation across different scenarios.",
        "code_id": "c_group_1_id_460",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 0\ni32.const 16\nlocal.set 1\nlocal.get 0\nlocal.get 1\ni32.sub\nlocal.set 2\ni32.const 3\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.store offset=12\nlocal.get 2\ni32.load offset=12\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_461",
        "query_text": "The function takes no input arguments and returns an integer value. It performs a single operation: returning a predefined constant that signifies a test was skipped. No additional computations or operations are performed.",
        "code_id": "c_group_1_id_461",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_462",
        "query_text": "The function takes no input arguments and returns an integer value. It is a static function that simply returns a predefined constant, which indicates that a particular test or operation has been skipped. No further computations or operations are performed beyond returning this constant value.",
        "code_id": "c_group_1_id_462",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_463",
        "query_text": "The function takes no input arguments and returns an integer value. It unconditionally returns a predefined constant indicating that the associated test is skipped, without performing any additional computations or operations.",
        "code_id": "c_group_1_id_463",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_464",
        "query_text": "The function does not accept any input arguments and returns an integer value. Its only operation is to return a predefined constant that signifies a particular test was skipped. The output is specifically of type int, and the function performs no other computations.",
        "code_id": "c_group_1_id_464",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_465",
        "query_text": "This function takes no input arguments and returns an integer value. Its only operation is to immediately return a predefined constant that indicates a specific test is skipped. There is no further computation, processing, or side effects; the function simply serves to signal that the particular test is not executed.",
        "code_id": "c_group_1_id_465",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_466",
        "query_text": "The function accepts no input parameters and returns an integer. Its sole operation is to immediately return a predefined constant that signifies the associated test has been skipped. No additional computations are performed, and the output solely indicates that the test is inactive.",
        "code_id": "c_group_1_id_466",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_467",
        "query_text": "The function takes no input arguments and returns an integer value. It simply indicates that a certain test is skipped by returning a predefined constant. The function does not perform any processing or computation; its sole purpose is to signal that the test case is not run by returning an integer constant that represents the skipped status.",
        "code_id": "c_group_1_id_467",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_468",
        "query_text": "The function takes no input arguments and returns an integer value. It performs no computations aside from returning a predefined constant that denotes a skipped test or operation.",
        "code_id": "c_group_1_id_468",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_469",
        "query_text": "The function takes no input parameters and returns an integer value. Its sole purpose is to immediately return a predefined constant that indicates a test or operation has been skipped. No additional computations or operations are performed.",
        "code_id": "c_group_1_id_469",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_470",
        "query_text": "This function accepts no input arguments and directly returns a predefined constant (of type int) that signifies a particular test case or operation was skipped. The output is an int representing this status.",
        "code_id": "c_group_1_id_470",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_471",
        "query_text": "The function takes no input arguments and returns a value of type int. It is implemented as a static function whose primary purpose is to indicate that a specific test case has been skipped. Instead of performing any computation or operations, the function directly returns a predetermined constant value that signifies the test was not executed.",
        "code_id": "c_group_1_id_471",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_472",
        "query_text": "The function takes no input arguments and returns an integer value. It serves to indicate that an associated test case is intentionally bypassed. Upon invocation, it simply returns a constant value designated to represent \"skipped,\" without performing any additional operations or computations.",
        "code_id": "c_group_1_id_472",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_473",
        "query_text": "This function does not take any input arguments and returns an integer value. Its only operation is to provide a constant result that signifies that a specific test or operation has been skipped. No additional computations or modifications are performed.",
        "code_id": "c_group_1_id_473",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_474",
        "query_text": "The function takes no input arguments and returns an integer output. Its sole operation is to immediately return a predefined constant that signifies a certain test case is skipped. No additional computations or operations are performed.",
        "code_id": "c_group_1_id_474",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_475",
        "query_text": "The function takes no input arguments and returns an integer value. It simply returns a predefined constant indicating that a test\u2014specifically one related to a DTLS 1.3 configuration using a null cipher\u2014is skipped. No computation or additional processing is performed within the function.",
        "code_id": "c_group_1_id_475",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_476",
        "query_text": "The function takes no inputs and returns an integer value. When invoked, it provides a predefined constant that indicates a specific test case is skipped. Essentially, the function serves as a placeholder to mark that the associated test is intentionally bypassed.",
        "code_id": "c_group_1_id_476",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_477",
        "query_text": "The function takes no input parameters and returns an integer value. It indicates that a specific DTLS over IPv6 test is skipped by immediately returning a predefined constant that represents a skipped state. The output is an integer signaling that the test is not executed.",
        "code_id": "c_group_1_id_477",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_478",
        "query_text": "The function takes no input arguments and returns an integer value. The returned integer represents a predefined constant that indicates a test case is intentionally skipped. Its primary purpose is to serve as a placeholder or marker for a test that is not executed during the testing process.",
        "code_id": "c_group_1_id_478",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_479",
        "query_text": "The function takes no inputs and immediately returns an integer value that corresponds to a predefined constant indicating that a specific test has been skipped. It performs no further operations or computations.",
        "code_id": "c_group_1_id_479",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 3\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_480",
        "query_text": "The function takes no input parameters and returns no value. It is designated as a static, void-returning function primarily intended to perform setup operations for initializing or configuring a test environment or related resources. However, the current implementation is empty, serving merely as a placeholder for potential future setup functionality.",
        "code_id": "c_group_1_id_480",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_481",
        "query_text": "The function is a static void function that takes no input parameters and returns no value. It conditionally clears accumulated error information within a library by invoking an internal error-clearing routine, but only when specific compilation flags are set. If either of these flags is defined during compilation, the error information is cleared; otherwise, the function performs no operations.",
        "code_id": "c_group_1_id_481",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_482",
        "query_text": "The function processes a string to extract an integer version number based on a specific pattern. It begins by searching for a designated substring within the input. Once the substring is found, the pointer is advanced past the pattern, and, if the subsequent character meets certain conditions, it is moved further by a fixed offset. The function then converts the remaining portion of the string to an integer. If the substring is not found, the function returns a predefined error indicator. The input is a string and the output is an integer.",
        "code_id": "c_group_1_id_482",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const -1\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\ni32.const 65536\nlocal.set 5\nlocal.get 3\nlocal.get 5\ni32.store offset=4\nlocal.get 3\ni32.load offset=12\nlocal.set 6\nlocal.get 3\ni32.load offset=4\nlocal.set 7\nlocal.get 6\nlocal.get 7\ncall 2\nlocal.set 8\nlocal.get 3\nlocal.get 8\ni32.store\nlocal.get 3\ni32.load\nlocal.set 9\ni32.const 0\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.ne\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @1\nlocal.get 13\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load\nlocal.set 14\ni32.const 3\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.add\nlocal.set 16\nlocal.get 3\nlocal.get 16\ni32.store\nlocal.get 3\ni32.load\nlocal.set 17\nlocal.get 17\ni32.load8_u\nlocal.set 18\ni32.const 24\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.shl\nlocal.set 20\nlocal.get 20\nlocal.get 19\ni32.shr_s\nlocal.set 21\ni32.const 100\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.eq\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 25\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load\nlocal.set 26\nlocal.get 26\ni32.load8_u\nlocal.set 27\ni32.const 24\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.shl\nlocal.set 29\nlocal.get 29\nlocal.get 28\ni32.shr_s\nlocal.set 30\ni32.const 101\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.eq\nlocal.set 32\ni32.const 1\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.and\nlocal.set 34\nlocal.get 34\ni32.eqz\nbr_if 1 (;@2;)\nend\nlocal.get 3\ni32.load\nlocal.set 35\ni32.const 2\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.add\nlocal.set 37\nlocal.get 3\nlocal.get 37\ni32.store\nend\nlocal.get 3\ni32.load\nlocal.set 38\nlocal.get 38\ncall 4\nlocal.set 39\nlocal.get 3\nlocal.get 39\ni32.store offset=8\nend\nlocal.get 3\ni32.load offset=8\nlocal.set 40\ni32.const 16\nlocal.set 41\nlocal.get 3\nlocal.get 41\ni32.add\nlocal.set 42\nlocal.get 42\nglobal.set 0\nlocal.get 40\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_483",
        "query_text": "The function accepts a pointer to a time value and returns a time value. If the pointer is not NULL, it sets the time value at the pointed memory location to 99. Regardless of whether the pointer is NULL or not, the function always returns 99.",
        "code_id": "c_group_1_id_483",
        "code_text": "(func (;1;) (type 2) (param i32) (result i64)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i64 i64)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.ne\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nblock  ;; label = @1\nlocal.get 8\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 3\ni32.load offset=12\nlocal.set 9\ni64.const 99\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni64.store\nend\ni64.const 99\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_484",
        "query_text": "The function takes six parameters: a pointer to an integer, a pointer to a void type, an integer, a pointer to an integer, another integer, and a second pointer to an integer. It explicitly casts all these inputs to void to indicate they are unused. Independently of the provided arguments, the function always returns the integer value 1. The output is of type int.",
        "code_id": "c_group_1_id_484",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 6\ni32.const 32\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.sub\nlocal.set 8\nlocal.get 8\nlocal.get 0\ni32.store offset=28\nlocal.get 8\nlocal.get 1\ni32.store offset=24\nlocal.get 8\nlocal.get 2\ni32.store offset=20\nlocal.get 8\nlocal.get 3\ni32.store offset=16\nlocal.get 8\nlocal.get 4\ni32.store offset=12\nlocal.get 8\nlocal.get 5\ni32.store offset=8\ni32.const 1\nlocal.set 9\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_485",
        "query_text": "The function accepts five inputs: a pointer to an integer, a pointer to a void type, an integer, and two additional pointers to integers. It disregards the second, third, and fifth inputs by casting them to void. The function evaluates whether the value referenced by the first pointer is non-negative. If so, it increments the value referenced by the fourth pointer and returns 1; if not, it returns 0. The output is of type int, reflecting the result of this check.",
        "code_id": "c_group_1_id_485",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32 i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 5\ni32.const 32\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.sub\nlocal.set 7\nlocal.get 7\nlocal.get 0\ni32.store offset=24\nlocal.get 7\nlocal.get 1\ni32.store offset=20\nlocal.get 7\nlocal.get 2\ni32.store offset=16\nlocal.get 7\nlocal.get 3\ni32.store offset=12\nlocal.get 7\nlocal.get 4\ni32.store offset=8\nlocal.get 7\ni32.load offset=24\nlocal.set 8\nlocal.get 8\ni32.load\nlocal.set 9\ni32.const 0\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.ge_s\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 13\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 7\ni32.load offset=12\nlocal.set 14\nlocal.get 14\ni32.load\nlocal.set 15\ni32.const 1\nlocal.set 16\nlocal.get 15\nlocal.get 16\ni32.add\nlocal.set 17\nlocal.get 14\nlocal.get 17\ni32.store\ni32.const 1\nlocal.set 18\nlocal.get 7\nlocal.get 18\ni32.store offset=28\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 19\nlocal.get 7\nlocal.get 19\ni32.store offset=28\nend\nlocal.get 7\ni32.load offset=28\nlocal.set 20\nlocal.get 20\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_486",
        "query_text": "The function receives a size_t value as its input and outputs a pointer to a constant character string. It treats the input as an index into a pre-constructed string containing every two-digit combination from \"00\" to \"99\". By multiplying the input by 2, it determines the correct starting position of the desired pair of digits within the string. Finally, the function returns a pointer to that specific two-character substring.",
        "code_id": "c_group_1_id_486",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.shl\nlocal.set 6\ni32.const 65536\nlocal.set 7\nlocal.get 7\nlocal.get 6\ni32.add\nlocal.set 8\nlocal.get 8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_487",
        "query_text": "The function takes a structure representing time (with an hour component) as input and determines whether the time is in the \"AM\" or \"PM\" period. It evaluates the hour field: if it is 12 or greater, the function returns the constant string \"PM\"; otherwise, it returns \"AM\". The input is a time structure, and the output is a pointer to a constant character string.",
        "code_id": "c_group_1_id_487",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 12\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.ge_s\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 65536\nlocal.set 10\nlocal.get 10\nlocal.set 11\nbr 1 (;@1;)\nend\ni32.const 65539\nlocal.set 12\nlocal.get 12\nlocal.set 11\nend\nlocal.get 11\nlocal.set 13\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_488",
        "query_text": "The function converts a 24-hour format time into a 12-hour format based solely on the hour field from a time structure. Initially, it examines the hour value stored within the structure. If the hour is greater than 12, the function subtracts 12 to effectively convert the value from 24-hour to 12-hour notation; otherwise, it leaves the hour unchanged. The function then returns this final hour as an integer.",
        "code_id": "c_group_1_id_488",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ni32.load offset=8\nlocal.set 5\ni32.const 12\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.gt_s\nlocal.set 7\ni32.const 1\nlocal.set 8\nlocal.get 7\nlocal.get 8\ni32.and\nlocal.set 9\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 9\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\ni32.load offset=12\nlocal.set 10\nlocal.get 10\ni32.load offset=8\nlocal.set 11\ni32.const 12\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.sub\nlocal.set 13\nlocal.get 13\nlocal.set 14\nbr 1 (;@1;)\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 15\nlocal.get 15\ni32.load offset=8\nlocal.set 16\nlocal.get 16\nlocal.set 14\nend\nlocal.get 14\nlocal.set 17\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_489",
        "query_text": "The function takes a boolean value as input and returns that same value without any modifications. The input and output are of type bool.",
        "code_id": "c_group_1_id_489",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 0\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store8 offset=15\nlocal.get 3\ni32.load8_u offset=15\nlocal.set 5\ni32.const 1\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.and\nlocal.set 7\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_490",
        "query_text": "This function accepts a single parameter of type std::nullptr_t and returns a value of the same type. Its operation is straightforward: regardless of the input, it always returns a constant null pointer value (nullptr). Essentially, the function serves as a no-operation wrapper for null pointer values, ensuring that the null pointer is passed through unchanged.",
        "code_id": "c_group_1_id_490",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 0\nlocal.set 4\nlocal.get 4\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_491",
        "query_text": "The function takes a single character as input and outputs its string representation. It first checks if the character is one of the special control characters (specifically carriage return, form feed, newline, or tab) and, if so, returns a string containing the corresponding escape sequence. If the character is another non-printable control character (with an ASCII value between 0 and 31, excluding the aforementioned cases), the function converts it to an unsigned integer and recursively processes it to obtain its string representation. For all other printable characters, it returns a string that encloses the character within single quotes.",
        "code_id": "c_group_1_id_491",
        "code_text": "(func (;2;) (type 4) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store8 offset=11\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 5\ni32.const 24\nlocal.set 6\nlocal.get 5\nlocal.get 6\ni32.shl\nlocal.set 7\nlocal.get 7\nlocal.get 6\ni32.shr_s\nlocal.set 8\ni32.const 13\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.eq\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 12\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 65554\nlocal.set 13\nlocal.get 0\nlocal.get 13\ncall 3\ndrop\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 14\ni32.const 24\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 16\nlocal.get 15\ni32.shr_s\nlocal.set 17\ni32.const 12\nlocal.set 18\nlocal.get 17\nlocal.get 18\ni32.eq\nlocal.set 19\ni32.const 1\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.and\nlocal.set 21\nblock  ;; label = @2\nlocal.get 21\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 65564\nlocal.set 22\nlocal.get 0\nlocal.get 22\ncall 3\ndrop\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 23\ni32.const 24\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.shl\nlocal.set 25\nlocal.get 25\nlocal.get 24\ni32.shr_s\nlocal.set 26\ni32.const 10\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.eq\nlocal.set 28\ni32.const 1\nlocal.set 29\nlocal.get 28\nlocal.get 29\ni32.and\nlocal.set 30\nblock  ;; label = @2\nlocal.get 30\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 65559\nlocal.set 31\nlocal.get 0\nlocal.get 31\ncall 3\ndrop\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 32\ni32.const 24\nlocal.set 33\nlocal.get 32\nlocal.get 33\ni32.shl\nlocal.set 34\nlocal.get 34\nlocal.get 33\ni32.shr_s\nlocal.set 35\ni32.const 9\nlocal.set 36\nlocal.get 35\nlocal.get 36\ni32.eq\nlocal.set 37\ni32.const 1\nlocal.set 38\nlocal.get 37\nlocal.get 38\ni32.and\nlocal.set 39\nblock  ;; label = @2\nlocal.get 39\ni32.eqz\nbr_if 0 (;@2;)\ni32.const 65549\nlocal.set 40\nlocal.get 0\nlocal.get 40\ncall 3\ndrop\nbr 1 (;@1;)\nend\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 41\ni32.const 24\nlocal.set 42\nlocal.get 41\nlocal.get 42\ni32.shl\nlocal.set 43\nlocal.get 43\nlocal.get 42\ni32.shr_s\nlocal.set 44\ni32.const 0\nlocal.set 45\nlocal.get 45\nlocal.get 44\ni32.le_s\nlocal.set 46\ni32.const 1\nlocal.set 47\nlocal.get 46\nlocal.get 47\ni32.and\nlocal.set 48\nblock  ;; label = @2\nlocal.get 48\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 49\ni32.const 24\nlocal.set 50\nlocal.get 49\nlocal.get 50\ni32.shl\nlocal.set 51\nlocal.get 51\nlocal.get 50\ni32.shr_s\nlocal.set 52\ni32.const 32\nlocal.set 53\nlocal.get 52\nlocal.get 53\ni32.lt_s\nlocal.set 54\ni32.const 1\nlocal.set 55\nlocal.get 54\nlocal.get 55\ni32.and\nlocal.set 56\nlocal.get 56\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 57\ni32.const 24\nlocal.set 58\nlocal.get 57\nlocal.get 58\ni32.shl\nlocal.set 59\nlocal.get 59\nlocal.get 58\ni32.shr_s\nlocal.set 60\ni32.const 24\nlocal.set 61\nlocal.get 60\nlocal.get 61\ni32.shl\nlocal.set 62\nlocal.get 62\nlocal.get 61\ni32.shr_s\nlocal.set 63\nlocal.get 0\nlocal.get 63\ncall 2\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 64\nlocal.get 64\ni32.load offset=65569 align=1\nlocal.set 65\nlocal.get 4\nlocal.get 65\ni32.store offset=4\nlocal.get 4\ni32.load8_u offset=11\nlocal.set 66\nlocal.get 4\nlocal.get 66\ni32.store8 offset=5\ni32.const 4\nlocal.set 67\nlocal.get 4\nlocal.get 67\ni32.add\nlocal.set 68\nlocal.get 68\nlocal.set 69\nlocal.get 0\nlocal.get 69\ncall 3\ndrop\nend\ni32.const 16\nlocal.set 70\nlocal.get 4\nlocal.get 70\ni32.add\nlocal.set 71\nlocal.get 71\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_492",
        "query_text": "The function accepts a single input of type std::nullptr_t, representing a null pointer literal. It returns a std::string that contains the text \"nullptr\", effectively converting the null pointer literal into its string representation. The input type is std::nullptr_t, while the output type is std::string.",
        "code_id": "c_group_1_id_492",
        "code_text": "(func (;2;) (type 4) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\ni32.const 65536\nlocal.set 5\nlocal.get 0\nlocal.get 5\ncall 3\ndrop\ni32.const 16\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_493",
        "query_text": "The function accepts two strings as inputs: one provided as a constant reference, representing the source string, and the other as a modifiable reference, representing the destination string. It copies the entire content of the source string into the destination string. The function does not return a value; its purpose is solely to replicate the source content into the destination.",
        "code_id": "c_group_1_id_493",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 6\nlocal.get 5\ncall 3\ndrop\ni32.const 16\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_494",
        "query_text": "The function accepts no input parameters and returns no value. It is designed to initialize or configure global settings, but its current implementation is empty and does not perform any operations.",
        "code_id": "c_group_1_id_494",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_495",
        "query_text": "The function accepts three parameters: a pointer to a character array allocated dynamically, and two pointers to constant characters representing other strings. It first checks whether the dynamically allocated string is not the same as either of the constant strings. If this condition is met, it frees the memory associated with the dynamically allocated string. The function does not return a value (void) and is designed solely to conditionally release memory based on the relationship between the inputs.",
        "code_id": "c_group_1_id_495",
        "code_text": "(func (;1;) (type 3) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 16\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nglobal.set 0\nlocal.get 5\nlocal.get 0\ni32.store offset=12\nlocal.get 5\nlocal.get 1\ni32.store offset=8\nlocal.get 5\nlocal.get 2\ni32.store offset=4\nlocal.get 5\ni32.load offset=8\nlocal.set 6\nlocal.get 5\ni32.load offset=12\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nblock  ;; label = @1\nlocal.get 10\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 5\ni32.load offset=4\nlocal.set 11\nlocal.get 5\ni32.load offset=12\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.ne\nlocal.set 13\ni32.const 1\nlocal.set 14\nlocal.get 13\nlocal.get 14\ni32.and\nlocal.set 15\nlocal.get 15\ni32.eqz\nbr_if 0 (;@1;)\nlocal.get 5\ni32.load offset=12\nlocal.set 16\nlocal.get 16\ncall 3\nend\ni32.const 16\nlocal.set 17\nlocal.get 5\nlocal.get 17\ni32.add\nlocal.set 18\nlocal.get 18\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_496",
        "query_text": "The function accepts three pointers: two that may reference integer values (or be null) and one that designates the destination for storing an integer result. It first verifies whether each of the first two pointers is non-null, in which case it retrieves the integer value pointed to; if a pointer is null, it substitutes a value of 0. It then adds the two integer values and stores the sum in the memory location indicated by the third pointer. The function does not return any value, with the computed sum being stored directly via the result pointer.",
        "code_id": "c_group_1_id_496",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\nlocal.get 5\ni32.load offset=28\nlocal.set 6\ni32.const 0\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.ne\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 10\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 5\ni32.load offset=28\nlocal.set 11\nlocal.get 11\ni32.load\nlocal.set 12\nlocal.get 12\nlocal.set 13\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 14\nlocal.get 14\nlocal.set 13\nend\nlocal.get 13\nlocal.set 15\nlocal.get 5\nlocal.get 15\ni32.store offset=16\nlocal.get 5\ni32.load offset=24\nlocal.set 16\ni32.const 0\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.ne\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 20\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 5\ni32.load offset=24\nlocal.set 21\nlocal.get 21\ni32.load\nlocal.set 22\nlocal.get 22\nlocal.set 23\nbr 1 (;@1;)\nend\ni32.const 0\nlocal.set 24\nlocal.get 24\nlocal.set 23\nend\nlocal.get 23\nlocal.set 25\nlocal.get 5\nlocal.get 25\ni32.store offset=12\nlocal.get 5\ni32.load offset=16\nlocal.set 26\nlocal.get 5\ni32.load offset=12\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.add\nlocal.set 28\nlocal.get 5\ni32.load offset=20\nlocal.set 29\nlocal.get 29\nlocal.get 28\ni32.store\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_497",
        "query_text": "The function takes a pointer to an integer as input. It retrieves the integer value stored at the referenced memory location, multiplies it by 2, and updates that same location with the computed result. The function does not return any value, as it performs the operation in-place. The input is a pointer to an integer, and there is no explicit output value.",
        "code_id": "c_group_1_id_497",
        "code_text": "(func (;1;) (type 2) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 5\nlocal.get 5\ni32.load\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.shl\nlocal.set 8\nlocal.get 3\ni32.load offset=8\nlocal.set 9\nlocal.get 9\nlocal.get 8\ni32.store\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_498",
        "query_text": "This function accepts three pointer arguments referring to memory locations. The first two pointers supply integer values, which are retrieved by dereferencing. The function then computes the sum of these integers and writes the result into the memory location indicated by the third pointer. No value is returned by the function, as the computed sum is stored directly via the provided output pointer.",
        "code_id": "c_group_1_id_498",
        "code_text": "(func (;1;) (type 2) (param i32 i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 3\ni32.const 32\nlocal.set 4\nlocal.get 3\nlocal.get 4\ni32.sub\nlocal.set 5\nlocal.get 5\nlocal.get 0\ni32.store offset=28\nlocal.get 5\nlocal.get 1\ni32.store offset=24\nlocal.get 5\nlocal.get 2\ni32.store offset=20\nlocal.get 5\ni32.load offset=28\nlocal.set 6\nlocal.get 6\ni32.load\nlocal.set 7\nlocal.get 5\nlocal.get 7\ni32.store offset=16\nlocal.get 5\ni32.load offset=24\nlocal.set 8\nlocal.get 8\ni32.load\nlocal.set 9\nlocal.get 5\nlocal.get 9\ni32.store offset=12\nlocal.get 5\ni32.load offset=16\nlocal.set 10\nlocal.get 5\ni32.load offset=12\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.add\nlocal.set 12\nlocal.get 5\ni32.load offset=20\nlocal.set 13\nlocal.get 13\nlocal.get 12\ni32.store\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_499",
        "query_text": "The function accepts two constant void pointers as inputs and treats them as pointers to character arrays. It compares these arrays byte by byte over a fixed length of 28 bytes (equivalent to 7 times the size of an int). During this process, if any byte differs between the two arrays, the function returns 1, indicating inequality. If all 28 bytes match exactly, it returns 0, signifying that the memory regions are identical. The function operates solely by checking the specified range without modifying any input data and returns an integer result that reflects the outcome of the comparison.",
        "code_id": "c_group_1_id_499",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 32\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=24\nlocal.get 4\nlocal.get 1\ni32.store offset=20\nlocal.get 4\ni32.load offset=24\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store offset=16\nlocal.get 4\ni32.load offset=20\nlocal.set 6\nlocal.get 4\nlocal.get 6\ni32.store offset=12\ni32.const 0\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.store offset=8\nblock  ;; label = @1\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 4\ni32.load offset=8\nlocal.set 8\ni32.const 28\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.lt_u\nlocal.set 10\ni32.const 1\nlocal.set 11\nlocal.get 10\nlocal.get 11\ni32.and\nlocal.set 12\nlocal.get 12\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 4\ni32.load offset=16\nlocal.set 13\nlocal.get 13\ni32.load8_u\nlocal.set 14\ni32.const 24\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.shl\nlocal.set 16\nlocal.get 16\nlocal.get 15\ni32.shr_s\nlocal.set 17\nlocal.get 4\ni32.load offset=12\nlocal.set 18\nlocal.get 18\ni32.load8_u\nlocal.set 19\ni32.const 24\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.shl\nlocal.set 21\nlocal.get 21\nlocal.get 20\ni32.shr_s\nlocal.set 22\nlocal.get 17\nlocal.get 22\ni32.ne\nlocal.set 23\ni32.const 1\nlocal.set 24\nlocal.get 23\nlocal.get 24\ni32.and\nlocal.set 25\nblock  ;; label = @4\nlocal.get 25\ni32.eqz\nbr_if 0 (;@4;)\ni32.const 1\nlocal.set 26\nlocal.get 4\nlocal.get 26\ni32.store offset=28\nbr 3 (;@1;)\nend\nlocal.get 4\ni32.load offset=16\nlocal.set 27\ni32.const 1\nlocal.set 28\nlocal.get 27\nlocal.get 28\ni32.add\nlocal.set 29\nlocal.get 4\nlocal.get 29\ni32.store offset=16\nlocal.get 4\ni32.load offset=12\nlocal.set 30\ni32.const 1\nlocal.set 31\nlocal.get 30\nlocal.get 31\ni32.add\nlocal.set 32\nlocal.get 4\nlocal.get 32\ni32.store offset=12\nlocal.get 4\ni32.load offset=8\nlocal.set 33\ni32.const 1\nlocal.set 34\nlocal.get 33\nlocal.get 34\ni32.add\nlocal.set 35\nlocal.get 4\nlocal.get 35\ni32.store offset=8\nbr 0 (;@3;)\nend\nunreachable\nend\ni32.const 0\nlocal.set 36\nlocal.get 4\nlocal.get 36\ni32.store offset=28\nend\nlocal.get 4\ni32.load offset=28\nlocal.set 37\nlocal.get 37\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_500",
        "query_text": "The function accepts two inputs: a pointer to an array of unsigned 8-bit integers and a size indicator that specifies the number of elements in the array. It sequentially examines each element in the array, checking whether the value of the current byte exceeds 127. If it finds a byte with a value greater than 127, the function immediately returns the index of that byte. If no byte exceeding 127 is encountered after traversing the entire array, the function returns the total size of the array. The output is of type size_t, which represents either the index of the first byte exceeding 127 or the array's length if all bytes are within the limit.",
        "code_id": "c_group_1_id_500",
        "code_text": "(func (;1;) (type 2) (param i32 i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nlocal.get 0\ni32.store offset=8\nlocal.get 4\nlocal.get 1\ni32.store offset=4\ni32.const 0\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.store\nblock  ;; label = @1\nblock  ;; label = @2\nloop  ;; label = @3\nlocal.get 4\ni32.load\nlocal.set 6\nlocal.get 4\ni32.load offset=4\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.lt_u\nlocal.set 8\ni32.const 1\nlocal.set 9\nlocal.get 8\nlocal.get 9\ni32.and\nlocal.set 10\nlocal.get 10\ni32.eqz\nbr_if 1 (;@2;)\nlocal.get 4\ni32.load offset=8\nlocal.set 11\nlocal.get 4\ni32.load\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.add\nlocal.set 13\nlocal.get 13\ni32.load8_u\nlocal.set 14\ni32.const 255\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.and\nlocal.set 16\ni32.const 127\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.gt_s\nlocal.set 18\ni32.const 1\nlocal.set 19\nlocal.get 18\nlocal.get 19\ni32.and\nlocal.set 20\nblock  ;; label = @4\nlocal.get 20\ni32.eqz\nbr_if 0 (;@4;)\nlocal.get 4\ni32.load\nlocal.set 21\nlocal.get 4\nlocal.get 21\ni32.store offset=12\nbr 3 (;@1;)\nend\nlocal.get 4\ni32.load\nlocal.set 22\ni32.const 1\nlocal.set 23\nlocal.get 22\nlocal.get 23\ni32.add\nlocal.set 24\nlocal.get 4\nlocal.get 24\ni32.store\nbr 0 (;@3;)\nend\nunreachable\nend\nlocal.get 4\ni32.load offset=4\nlocal.set 25\nlocal.get 4\nlocal.get 25\ni32.store offset=12\nend\nlocal.get 4\ni32.load offset=12\nlocal.set 26\nlocal.get 26\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_501",
        "query_text": "The function accepts no input arguments. It returns an integer value of 0, using this value to indicate a successful or default initialization state. The function does not perform any additional computations or operations.",
        "code_id": "c_group_1_id_501",
        "code_text": "(func (;1;) (type 0) (result i32)\n(local i32)\ni32.const 0\nlocal.set 0\nlocal.get 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_502",
        "query_text": "The function takes no input parameters and returns no value. It is a no-operation (no-op) function that does not perform any actions or modifications when invoked.",
        "code_id": "c_group_1_id_502",
        "code_text": "(func (;1;) (type 1)\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_503",
        "query_text": "The function takes a constant string reference as its input and copies its content to another string reference provided as the output. It effectively performs a direct assignment, duplicating the input string without modification. The input is a constant string (std::string) and the output is also a string (std::string).",
        "code_id": "c_group_1_id_503",
        "code_text": "(func (;2;) (type 3) (param i32 i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 2\ni32.const 16\nlocal.set 3\nlocal.get 2\nlocal.get 3\ni32.sub\nlocal.set 4\nlocal.get 4\nglobal.set 0\nlocal.get 4\nlocal.get 0\ni32.store offset=12\nlocal.get 4\nlocal.get 1\ni32.store offset=8\nlocal.get 4\ni32.load offset=12\nlocal.set 5\nlocal.get 4\ni32.load offset=8\nlocal.set 6\nlocal.get 6\nlocal.get 5\ncall 3\ndrop\ni32.const 16\nlocal.set 7\nlocal.get 4\nlocal.get 7\ni32.add\nlocal.set 8\nlocal.get 8\nglobal.set 0\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_504",
        "query_text": "The function takes one input of type const char pointer. It performs no operations or computations on the input and does not produce any output or return any value. The parameter is explicitly marked as unused, indicating that the function serves as a no-op (no operation) placeholder across translation units.",
        "code_id": "c_group_1_id_504",
        "code_text": "(func (;1;) (type 2) (param i32)\n(local i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_505",
        "query_text": "The function accepts an integer as input and returns an integer as output. It operates by comparing the input value against a predefined set of constants. If the input matches any one of these constants, the function returns 0; if no match is found, it returns 1.",
        "code_id": "c_group_1_id_505",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store offset=8\nlocal.get 3\ni32.load offset=8\nlocal.set 4\ni32.const 128\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.eq\nlocal.set 6\ni32.const 1\nlocal.set 7\nlocal.get 6\nlocal.get 7\ni32.and\nlocal.set 8\nblock  ;; label = @1\nblock  ;; label = @2\nblock  ;; label = @3\nlocal.get 8\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load offset=8\nlocal.set 9\ni32.const 256\nlocal.set 10\nlocal.get 9\nlocal.get 10\ni32.eq\nlocal.set 11\ni32.const 1\nlocal.set 12\nlocal.get 11\nlocal.get 12\ni32.and\nlocal.set 13\nlocal.get 13\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load offset=8\nlocal.set 14\ni32.const 512\nlocal.set 15\nlocal.get 14\nlocal.get 15\ni32.eq\nlocal.set 16\ni32.const 1\nlocal.set 17\nlocal.get 16\nlocal.get 17\ni32.and\nlocal.set 18\nlocal.get 18\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load offset=8\nlocal.set 19\ni32.const 1\nlocal.set 20\nlocal.get 19\nlocal.get 20\ni32.eq\nlocal.set 21\ni32.const 1\nlocal.set 22\nlocal.get 21\nlocal.get 22\ni32.and\nlocal.set 23\nlocal.get 23\nbr_if 0 (;@3;)\nlocal.get 3\ni32.load offset=8\nlocal.set 24\ni32.const 2\nlocal.set 25\nlocal.get 24\nlocal.get 25\ni32.eq\nlocal.set 26\ni32.const 1\nlocal.set 27\nlocal.get 26\nlocal.get 27\ni32.and\nlocal.set 28\nlocal.get 28\ni32.eqz\nbr_if 1 (;@2;)\nend\ni32.const 0\nlocal.set 29\nlocal.get 3\nlocal.get 29\ni32.store offset=12\nbr 1 (;@1;)\nend\ni32.const 1\nlocal.set 30\nlocal.get 3\nlocal.get 30\ni32.store offset=12\nend\nlocal.get 3\ni32.load offset=12\nlocal.set 31\nlocal.get 31\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_506",
        "query_text": "The function takes a single integer input that represents a file descriptor. It then determines whether this descriptor is associated with a terminal device by calling a standard library function. The function immediately returns a result that is non-zero if the descriptor refers to a terminal, or zero if it does not.",
        "code_id": "c_group_1_id_506",
        "code_text": "(func (;2;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\nlocal.get 3\ni32.load offset=12\nlocal.set 4\nlocal.get 4\ncall 5\nlocal.set 5\ni32.const 16\nlocal.set 6\nlocal.get 3\nlocal.get 6\ni32.add\nlocal.set 7\nlocal.get 7\nglobal.set 0\nlocal.get 5\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_508",
        "query_text": "The function takes a 16-bit unsigned integer as input and counts the number of trailing zeros in its binary representation. It returns a 32-bit unsigned integer that represents the count of the least significant bits set to zero. The implementation utilizes platform-specific optimizations\u2014such as compiler intrinsics or inline assembly instructions\u2014when available for improved performance and falls back to a bitwise shift-and-check approach otherwise.",
        "code_id": "c_group_1_id_508",
        "code_text": "(func (;1;) (type 2) (param i32) (result i32)\n(local i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\ni32.store16 offset=14\nlocal.get 3\ni32.load16_u offset=14\nlocal.set 4\ni32.const 65535\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nlocal.get 6\ni32.ctz\nlocal.set 7\nlocal.get 7\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_509",
        "query_text": "The function accepts a floating-point value as its input and returns a floating-point number as output. It calculates the output by squaring the input value, thereby implementing a quadratic ease-in effect. This produces a smooth, accelerating progression beginning from zero, with the intensity increasing quadratically as the input value grows.",
        "code_id": "c_group_1_id_509",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nlocal.get 3\nf32.load offset=12\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf32.mul\nlocal.set 6\nlocal.get 6\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_510",
        "query_text": "This function accepts a floating-point input that is expected to be within a normalized range (e.g., [0, 1]). It returns a floating-point result obtained by applying a quadratic easing-out transformation\u2014a process where the change is initially rapid and then gradually decelerates as the value approaches its maximum. The operation is purely mathematical and independent of any external state or supplementary parameters.",
        "code_id": "c_group_1_id_510",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nlocal.get 3\nf32.load offset=12\nlocal.set 5\nf32.const 0x1p+1 (;=2;)\nlocal.set 6\nlocal.get 5\nlocal.get 6\nf32.sub\nlocal.set 7\nlocal.get 4\nlocal.get 7\nf32.mul\nlocal.set 8\nlocal.get 8\nf32.neg\nlocal.set 9\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_511",
        "query_text": "This function takes a floating-point input that is expected to be between 0 and 1 and computes a quadratic easing effect with distinct accelerating and decelerating phases. For values less than 0.5, it applies an accelerating quadratic transformation; for values 0.5 or greater, it applies a decelerating quadratic transformation. The design guarantees a smooth, continuous transition at the midpoint, and the function returns a floating-point result that remains within the 0 to 1 range.",
        "code_id": "c_group_1_id_511",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 7\nlocal.get 3\nf32.load offset=8\nlocal.set 8\nlocal.get 7\nlocal.get 8\nf32.mul\nlocal.set 9\nlocal.get 3\nlocal.get 9\nf32.store offset=4\nlocal.get 3\nf32.load offset=8\nlocal.set 10\nf32.const 0x1p-1 (;=0.5;)\nlocal.set 11\nlocal.get 10\nlocal.get 11\nf32.lt\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 6\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\nf32.load offset=4\nlocal.set 12\nf32.const 0x1p+1 (;=2;)\nlocal.set 13\nlocal.get 13\nlocal.get 12\nf32.mul\nlocal.set 14\nlocal.get 3\nlocal.get 14\nf32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\nf32.load offset=4\nlocal.set 15\nlocal.get 3\nf32.load offset=8\nlocal.set 16\nf32.const 0x1p+2 (;=4;)\nlocal.set 17\nlocal.get 17\nlocal.get 16\nf32.mul\nlocal.set 18\nlocal.get 15\nlocal.get 15\nf32.add\nlocal.set 19\nlocal.get 18\nlocal.get 19\nf32.sub\nlocal.set 20\nf32.const 0x1p+0 (;=1;)\nlocal.set 21\nlocal.get 20\nlocal.get 21\nf32.sub\nlocal.set 22\nlocal.get 3\nlocal.get 22\nf32.store offset=12\nend\nlocal.get 3\nf32.load offset=12\nlocal.set 23\nlocal.get 23\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_512",
        "query_text": "The function takes a floating-point input and returns the cubic easing result for that value. It calculates a smooth acceleration effect by computing the cube of the input. The output is of type float, and the function operates purely in a mathematical context without relying on any external state.",
        "code_id": "c_group_1_id_512",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nlocal.get 3\nf32.load offset=12\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf32.mul\nlocal.set 6\nlocal.get 3\nf32.load offset=12\nlocal.set 7\nlocal.get 6\nlocal.get 7\nf32.mul\nlocal.set 8\nlocal.get 8\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_513",
        "query_text": "The function takes a floating-point number as input and computes a result based on a cubic easing operation. It first shifts the input by subtracting 1.0, then raises the resulting value to the power of three, and finally adds 1.0 to obtain the output. Designed to provide a smooth deceleration effect for animations or transitions, the function expects an input typically in the range of 0 to 1 and returns a value that usually remains within this range, although a slight overshoot is possible due to the cubic calculation.",
        "code_id": "c_group_1_id_513",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nf32.const 0x1p+0 (;=1;)\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf32.sub\nlocal.set 6\nlocal.get 3\nlocal.get 6\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 7\nlocal.get 3\nf32.load offset=8\nlocal.set 8\nlocal.get 7\nlocal.get 8\nf32.mul\nlocal.set 9\nlocal.get 3\nf32.load offset=8\nlocal.set 10\nlocal.get 9\nlocal.get 10\nf32.mul\nlocal.set 11\nf32.const 0x1p+0 (;=1;)\nlocal.set 12\nlocal.get 11\nlocal.get 12\nf32.add\nlocal.set 13\nlocal.get 13\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_514",
        "query_text": "The function takes a floating-point input (ranging from 0.0 to 1.0) that represents the progress of a transition. It employs a cubic easing algorithm to compute a smooth in-out motion. Specifically, it accelerates the transition for progress values below 0.5 and decelerates for values of 0.5 or greater, ensuring a gradual start and finish. The computed value is also a floating-point number normalized within the range 0.0 to 1.0.",
        "code_id": "c_group_1_id_514",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 7\nf32.const 0x1p-1 (;=0.5;)\nlocal.set 8\nlocal.get 7\nlocal.get 8\nf32.lt\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 6\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\nf32.load offset=8\nlocal.set 9\nf32.const 0x1p+2 (;=4;)\nlocal.set 10\nlocal.get 10\nlocal.get 9\nf32.mul\nlocal.set 11\nlocal.get 3\nf32.load offset=8\nlocal.set 12\nlocal.get 11\nlocal.get 12\nf32.mul\nlocal.set 13\nlocal.get 3\nf32.load offset=8\nlocal.set 14\nlocal.get 13\nlocal.get 14\nf32.mul\nlocal.set 15\nlocal.get 3\nlocal.get 15\nf32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\nf32.load offset=8\nlocal.set 16\nlocal.get 16\nlocal.get 16\nf32.add\nlocal.set 17\nf32.const -0x1p+1 (;=-2;)\nlocal.set 18\nlocal.get 17\nlocal.get 18\nf32.add\nlocal.set 19\nlocal.get 3\nlocal.get 19\nf32.store offset=4\nlocal.get 3\nf32.load offset=4\nlocal.set 20\nf32.const 0x1p-1 (;=0.5;)\nlocal.set 21\nlocal.get 21\nlocal.get 20\nf32.mul\nlocal.set 22\nlocal.get 3\nf32.load offset=4\nlocal.set 23\nlocal.get 22\nlocal.get 23\nf32.mul\nlocal.set 24\nlocal.get 3\nf32.load offset=4\nlocal.set 25\nlocal.get 24\nlocal.get 25\nf32.mul\nlocal.set 26\nf32.const 0x1p+0 (;=1;)\nlocal.set 27\nlocal.get 26\nlocal.get 27\nf32.add\nlocal.set 28\nlocal.get 3\nlocal.get 28\nf32.store offset=12\nend\nlocal.get 3\nf32.load offset=12\nlocal.set 29\nlocal.get 29\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_515",
        "query_text": "The function accepts a single floating-point value as input and applies a quart-in easing operation by computing its fourth power. It begins by squaring the input value to produce an intermediate result, and then squares that intermediate result to achieve the final output. The function returns the resulting floating-point value after performing this computation.",
        "code_id": "c_group_1_id_515",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nlocal.get 3\nf32.load offset=12\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf32.mul\nlocal.set 6\nlocal.get 3\nlocal.get 6\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 7\nlocal.get 3\nf32.load offset=8\nlocal.set 8\nlocal.get 7\nlocal.get 8\nf32.mul\nlocal.set 9\nlocal.get 9\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_516",
        "query_text": "The function accepts a single floating-point value as an input, typically within the interval [0.0, 1.0], and applies a quartic easing transformation that decelerates smoothly toward the endpoint. Internally, it subtracts one from the input, raises the result to the third power, multiplies it by the complement of the original input, and finally adds one to produce a transformed value. This effect is commonly used in animations or transitions to create a smooth slowdown. The function returns the computed floating-point result without modifying the original input.",
        "code_id": "c_group_1_id_516",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nf32.const 0x1p+0 (;=1;)\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf32.sub\nlocal.set 6\nlocal.get 3\nlocal.get 6\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 7\nlocal.get 3\nf32.load offset=8\nlocal.set 8\nlocal.get 7\nlocal.get 8\nf32.mul\nlocal.set 9\nlocal.get 3\nf32.load offset=8\nlocal.set 10\nlocal.get 9\nlocal.get 10\nf32.mul\nlocal.set 11\nlocal.get 3\nf32.load offset=12\nlocal.set 12\nf32.const 0x1p+0 (;=1;)\nlocal.set 13\nlocal.get 13\nlocal.get 12\nf32.sub\nlocal.set 14\nlocal.get 11\nlocal.get 14\nf32.mul\nlocal.set 15\nf32.const 0x1p+0 (;=1;)\nlocal.set 16\nlocal.get 15\nlocal.get 16\nf32.add\nlocal.set 17\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_517",
        "query_text": "The function takes a single floating-point input, which is expected to be in the range of 0 to 1, and applies a smooth quartic easing transition. It first checks whether the input is in the first half (less than 0.5) or the second half (0.5 or greater) of the progression. For inputs below 0.5, it computes an accelerated, quartic-in easing; for inputs of 0.5 or more, it computes a decelerated, quartic-out easing. The function returns a floating-point output\u2014also in the range of 0 to 1\u2014that reflects this symmetric easing effect. Additionally, the logic implicitly clamps the input to ensure a smooth and valid result even if the provided value is outside the expected range.",
        "code_id": "c_group_1_id_517",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 7\nf32.const 0x1p-1 (;=0.5;)\nlocal.set 8\nlocal.get 7\nlocal.get 8\nf32.lt\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 6\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\nf32.load offset=8\nlocal.set 9\nlocal.get 3\nf32.load offset=8\nlocal.set 10\nlocal.get 9\nlocal.get 10\nf32.mul\nlocal.set 11\nlocal.get 3\nlocal.get 11\nf32.store offset=4\nlocal.get 3\nf32.load offset=4\nlocal.set 12\nf32.const 0x1p+3 (;=8;)\nlocal.set 13\nlocal.get 13\nlocal.get 12\nf32.mul\nlocal.set 14\nlocal.get 3\nf32.load offset=4\nlocal.set 15\nlocal.get 14\nlocal.get 15\nf32.mul\nlocal.set 16\nlocal.get 3\nlocal.get 16\nf32.store offset=12\nbr 1 (;@1;)\nend\nlocal.get 3\nf32.load offset=8\nlocal.set 17\nf32.const 0x1p+0 (;=1;)\nlocal.set 18\nlocal.get 17\nlocal.get 18\nf32.sub\nlocal.set 19\nlocal.get 3\nlocal.get 19\nf32.store offset=4\nlocal.get 3\nf32.load offset=4\nlocal.set 20\nlocal.get 3\nf32.load offset=4\nlocal.set 21\nlocal.get 20\nlocal.get 21\nf32.mul\nlocal.set 22\nlocal.get 3\nlocal.get 22\nf32.store\nlocal.get 3\nf32.load\nlocal.set 23\nf32.const -0x1p+3 (;=-8;)\nlocal.set 24\nlocal.get 24\nlocal.get 23\nf32.mul\nlocal.set 25\nlocal.get 3\nf32.load\nlocal.set 26\nlocal.get 25\nlocal.get 26\nf32.mul\nlocal.set 27\nf32.const 0x1p+0 (;=1;)\nlocal.set 28\nlocal.get 27\nlocal.get 28\nf32.add\nlocal.set 29\nlocal.get 3\nlocal.get 29\nf32.store offset=12\nend\nlocal.get 3\nf32.load offset=12\nlocal.set 30\nlocal.get 30\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_518",
        "query_text": "This function takes a floating-point value as its input and returns a floating-point value representing the result of applying a quintic easing-in transformation. It internally computes the square of the input, then multiplies that squared value by itself and by the original input, effectively raising the input to the fifth power. This produces an easing effect where the progression starts slowly and accelerates sharply, yielding a smooth, non-linear transition.",
        "code_id": "c_group_1_id_518",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nlocal.get 3\nf32.load offset=12\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf32.mul\nlocal.set 6\nlocal.get 3\nlocal.get 6\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 7\nlocal.get 3\nf32.load offset=8\nlocal.set 8\nlocal.get 7\nlocal.get 8\nf32.mul\nlocal.set 9\nlocal.get 3\nf32.load offset=12\nlocal.set 10\nlocal.get 9\nlocal.get 10\nf32.mul\nlocal.set 11\nlocal.get 11\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_519",
        "query_text": "The function takes a single floating-point value as input and produces a floating-point value as output. It applies a quintic easing-out transformation to the input, calculated by subtracting one from the input, squaring the result, and using this squared value repeatedly to compute a fifth-power term before adding one. Consequently, when the input is within the range [0, 1], the output is also guaranteed to be within [0, 1]. This easing operation is typically used in animations and transitions to create a smooth deceleration effect toward the end of a movement or change.",
        "code_id": "c_group_1_id_519",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 4\nf32.const 0x1p+0 (;=1;)\nlocal.set 5\nlocal.get 4\nlocal.get 5\nf32.sub\nlocal.set 6\nlocal.get 3\nlocal.get 6\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 7\nlocal.get 3\nf32.load offset=8\nlocal.set 8\nlocal.get 7\nlocal.get 8\nf32.mul\nlocal.set 9\nlocal.get 3\nlocal.get 9\nf32.store offset=4\nlocal.get 3\nf32.load offset=4\nlocal.set 10\nlocal.get 3\nf32.load offset=4\nlocal.set 11\nlocal.get 10\nlocal.get 11\nf32.mul\nlocal.set 12\nlocal.get 3\nf32.load offset=8\nlocal.set 13\nlocal.get 12\nlocal.get 13\nf32.mul\nlocal.set 14\nf32.const 0x1p+0 (;=1;)\nlocal.set 15\nlocal.get 14\nlocal.get 15\nf32.add\nlocal.set 16\nlocal.get 16\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_520",
        "query_text": "The function accepts a floating-point input representing a normalized value (typically within the range [0, 1]) used to indicate progress, time, or an interpolation factor. It computes a transformation that simulates a \u201cback-in\u201d easing effect\u2014initiating motion gradually, overshooting the target slightly, and then settling towards the final value. The function returns a float that embodies this modified progress, making it useful for creating smooth animations or transitions. Both the input and output are of type float.",
        "code_id": "c_group_1_id_520",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nf32.const 0x1.b39acp+0 (;=1.70158;)\nlocal.set 4\nlocal.get 3\nlocal.get 4\nf32.store offset=8\nlocal.get 3\nf32.load offset=8\nlocal.set 5\nf32.const 0x1p+0 (;=1;)\nlocal.set 6\nlocal.get 5\nlocal.get 6\nf32.add\nlocal.set 7\nlocal.get 3\nf32.load offset=12\nlocal.set 8\nlocal.get 3\nf32.load offset=8\nlocal.set 9\nlocal.get 9\nf32.neg\nlocal.set 10\nlocal.get 7\nlocal.get 8\nf32.mul\nlocal.set 11\nlocal.get 11\nlocal.get 10\nf32.add\nlocal.set 12\nlocal.get 3\nlocal.get 12\nf32.store offset=4\nlocal.get 3\nf32.load offset=12\nlocal.set 13\nlocal.get 3\nf32.load offset=12\nlocal.set 14\nlocal.get 13\nlocal.get 14\nf32.mul\nlocal.set 15\nlocal.get 3\nf32.load offset=4\nlocal.set 16\nlocal.get 15\nlocal.get 16\nf32.mul\nlocal.set 17\nlocal.get 17\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_521",
        "query_text": "The function accepts one input of type float and returns a float value. It processes the input by applying an easing transformation that produces a smooth animation effect with a slight overshoot before settling. Essentially, the transformation modifies the input value\u2014assumed to typically lie within the range [0, 1]\u2014to create a more natural motion, where the output may temporarily exceed 1 due to the overshooting. No checks are performed to constrain the input value within any specific bounds.",
        "code_id": "c_group_1_id_521",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=12\nf32.const 0x1.b39acp+0 (;=1.70158;)\nlocal.set 4\nlocal.get 3\nlocal.get 4\nf32.store offset=8\nlocal.get 3\nf32.load offset=12\nlocal.set 5\nf32.const 0x1p+0 (;=1;)\nlocal.set 6\nlocal.get 5\nlocal.get 6\nf32.sub\nlocal.set 7\nlocal.get 3\nlocal.get 7\nf32.store\nlocal.get 3\nf32.load offset=8\nlocal.set 8\nf32.const 0x1p+0 (;=1;)\nlocal.set 9\nlocal.get 8\nlocal.get 9\nf32.add\nlocal.set 10\nlocal.get 3\nf32.load\nlocal.set 11\nlocal.get 3\nf32.load offset=8\nlocal.set 12\nlocal.get 10\nlocal.get 11\nf32.mul\nlocal.set 13\nlocal.get 13\nlocal.get 12\nf32.add\nlocal.set 14\nlocal.get 3\nlocal.get 14\nf32.store offset=4\nlocal.get 3\nf32.load\nlocal.set 15\nlocal.get 3\nf32.load\nlocal.set 16\nlocal.get 15\nlocal.get 16\nf32.mul\nlocal.set 17\nlocal.get 3\nf32.load offset=4\nlocal.set 18\nlocal.get 17\nlocal.get 18\nf32.mul\nlocal.set 19\nf32.const 0x1p+0 (;=1;)\nlocal.set 20\nlocal.get 19\nlocal.get 20\nf32.add\nlocal.set 21\nlocal.get 21\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_522",
        "query_text": "The function takes a single floating-point number as input, which represents a normalized progress value typically ranging from 0 to 1. It computes an eased output value by applying a symmetric easing effect that combines both an initial \"back-in\" motion and a final \"back-out\" motion, creating a smooth transition with slight overshoots at both ends. The function returns the computed floating-point value to be used for animations or interpolations, while implicitly handling inputs outside the standard range.",
        "code_id": "c_group_1_id_522",
        "code_text": "(func (;1;) (type 2) (param f32) (result f32)\n(local i32 i32 i32 i32 i32 i32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32 f32)\nglobal.get 0\nlocal.set 1\ni32.const 32\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nlocal.get 0\nf32.store offset=24\nf32.const 0x1.b39acp+0 (;=1.70158;)\nlocal.set 7\nlocal.get 3\nlocal.get 7\nf32.store offset=20\nlocal.get 3\nf32.load offset=20\nlocal.set 8\nf32.const 0x1.866666p+0 (;=1.525;)\nlocal.set 9\nlocal.get 8\nlocal.get 9\nf32.mul\nlocal.set 10\nlocal.get 3\nlocal.get 10\nf32.store offset=4\nf32.const 0x1p-1 (;=0.5;)\nlocal.set 11\nlocal.get 3\nlocal.get 11\nf32.store\nlocal.get 3\nf32.load offset=24\nlocal.set 12\nf32.const 0x1p-1 (;=0.5;)\nlocal.set 13\nlocal.get 12\nlocal.get 13\nf32.div\nlocal.set 14\nlocal.get 3\nlocal.get 14\nf32.store offset=12\nlocal.get 3\nf32.load offset=12\nlocal.set 15\nf32.const 0x1p+0 (;=1;)\nlocal.set 16\nlocal.get 15\nlocal.get 16\nf32.lt\nlocal.set 4\ni32.const 1\nlocal.set 5\nlocal.get 4\nlocal.get 5\ni32.and\nlocal.set 6\nblock  ;; label = @1\nblock  ;; label = @2\nlocal.get 6\ni32.eqz\nbr_if 0 (;@2;)\nlocal.get 3\nf32.load offset=4\nlocal.set 17\nf32.const 0x1p+0 (;=1;)\nlocal.set 18\nlocal.get 17\nlocal.get 18\nf32.add\nlocal.set 19\nlocal.get 3\nf32.load offset=12\nlocal.set 20\nlocal.get 3\nf32.load offset=4\nlocal.set 21\nlocal.get 21\nf32.neg\nlocal.set 22\nlocal.get 19\nlocal.get 20\nf32.mul\nlocal.set 23\nlocal.get 23\nlocal.get 22\nf32.add\nlocal.set 24\nlocal.get 3\nlocal.get 24\nf32.store offset=16\nlocal.get 3\nf32.load offset=12\nlocal.set 25\nlocal.get 3\nf32.load offset=12\nlocal.set 26\nlocal.get 25\nlocal.get 26\nf32.mul\nlocal.set 27\nlocal.get 3\nf32.load offset=16\nlocal.set 28\nlocal.get 27\nlocal.get 28\nf32.mul\nlocal.set 29\nlocal.get 3\nlocal.get 29\nf32.store offset=8\nlocal.get 3\nf32.load\nlocal.set 30\nlocal.get 3\nf32.load offset=8\nlocal.set 31\nlocal.get 30\nlocal.get 31\nf32.mul\nlocal.set 32\nlocal.get 3\nlocal.get 32\nf32.store offset=28\nbr 1 (;@1;)\nend\nlocal.get 3\nf32.load offset=12\nlocal.set 33\nf32.const 0x1p+1 (;=2;)\nlocal.set 34\nlocal.get 33\nlocal.get 34\nf32.sub\nlocal.set 35\nlocal.get 3\nlocal.get 35\nf32.store offset=12\nlocal.get 3\nf32.load offset=4\nlocal.set 36\nf32.const 0x1p+0 (;=1;)\nlocal.set 37\nlocal.get 36\nlocal.get 37\nf32.add\nlocal.set 38\nlocal.get 3\nf32.load offset=12\nlocal.set 39\nlocal.get 3\nf32.load offset=4\nlocal.set 40\nlocal.get 38\nlocal.get 39\nf32.mul\nlocal.set 41\nlocal.get 41\nlocal.get 40\nf32.add\nlocal.set 42\nlocal.get 3\nlocal.get 42\nf32.store offset=16\nlocal.get 3\nf32.load offset=12\nlocal.set 43\nlocal.get 3\nf32.load offset=12\nlocal.set 44\nlocal.get 43\nlocal.get 44\nf32.mul\nlocal.set 45\nlocal.get 3\nf32.load offset=16\nlocal.set 46\nlocal.get 45\nlocal.get 46\nf32.mul\nlocal.set 47\nf32.const 0x1p+1 (;=2;)\nlocal.set 48\nlocal.get 47\nlocal.get 48\nf32.add\nlocal.set 49\nlocal.get 3\nlocal.get 49\nf32.store offset=8\nlocal.get 3\nf32.load\nlocal.set 50\nlocal.get 3\nf32.load offset=8\nlocal.set 51\nlocal.get 50\nlocal.get 51\nf32.mul\nlocal.set 52\nlocal.get 3\nlocal.get 52\nf32.store offset=28\nend\nlocal.get 3\nf32.load offset=28\nlocal.set 53\nlocal.get 53\nreturn)",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_523",
        "query_text": "The function accepts an error description as a string input (represented as a constant character pointer). It then prints this error message\u2014supplemented by the corresponding system error description if available\u2014to the standard error stream. Following this, the function terminates the program execution with a failure status and does not return any value. Although some behavior may differ slightly depending on platform-specific configurations or compiler attributes, the primary functionality remains consistent. The input is of type const char*, and there is no output since the function exits the program (void).",
        "code_id": "c_group_1_id_523",
        "code_text": "(func (;5;) (type 2) (param i32)\n(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)\nglobal.get 0\nlocal.set 1\ni32.const 16\nlocal.set 2\nlocal.get 1\nlocal.get 2\ni32.sub\nlocal.set 3\nlocal.get 3\nglobal.set 0\nlocal.get 3\nlocal.get 0\ni32.store offset=12\ni32.const 0\nlocal.set 4\nlocal.get 4\ni32.load offset=65616\nlocal.set 5\nlocal.get 3\ni32.load offset=12\nlocal.set 6\ncall 11\nlocal.set 7\nlocal.get 7\ni32.load\nlocal.set 8\nlocal.get 8\ncall 27\nlocal.set 9\nlocal.get 3\nlocal.get 9\ni32.store offset=4\nlocal.get 3\nlocal.get 6\ni32.store\ni32.const 65590\nlocal.set 10\nlocal.get 5\nlocal.get 10\nlocal.get 3\ncall 12\ndrop\ni32.const 1\nlocal.set 11\nlocal.get 11\ncall 9\nunreachable)",
        "relevance": 2
    }
]