[
    {
        "query_id": "q_group_1_id_70",
        "query_text": "The function accepts an integer as its input and determines whether the provided value is greater than or equal to zero. It returns a boolean value: if the input is non-negative, the function produces true; otherwise, it produces false. This behavior can be evaluated at compile time due to its constexpr designation. The input is of type int, and the output is of type bool.",
        "code_id": "c_group_1_id_70",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nnot    %eax\nshr    $0x1f,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x68\ncmpl   $0xffff,-0x8(%rbp)\njne    0x68\nlea    0x0(%rip),%rax        # 0x3d\nmov    %rax,%rdi\ncall   0x45\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x56\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdi\ncall   0x68\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x15\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_6",
        "query_text": "The function accepts a file pointer (of type FILE*) as input and returns an integer (of type int) that identifies the corresponding file descriptor. This integer is a unique identifier assigned by the operating system to the open file. Implemented as an inline function, it expands directly at the call site for enhanced efficiency.",
        "code_id": "c_group_1_id_6",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x71\ncmpl   $0xffff,-0x8(%rbp)\njne    0x71\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdi\ncall   0x4e\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_111",
        "query_text": "The function accepts two parameters: a pointer to an array of unsigned characters (representing a series of bytes) and a corresponding non-negative integer indicating the number of bytes to process. It sets up platform-specific constant values based on whether it is running on a 32-bit or 64-bit system. The function iterates over each byte in the sequence, performing bitwise XOR operations followed by multiplications with a predefined constant. The outcome is an integer value (of type size_t) that represents the computed hash for the input sequence.",
        "code_id": "c_group_1_id_111",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovabs $0xcbf29ce484222325,%rax\n\nmov    %rax,-0x10(%rbp)\nmovabs $0x100000001b3,%rcx\n\nmov    %rcx,-0x8(%rbp)\nmov    %rax,-0x20(%rbp)\nmovq   $0x0,-0x18(%rbp)\n\njmp    0x6a\nmov    -0x28(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nxor    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmovabs $0x100000001b3,%rdx\n\nimul   %rdx,%rax\nmov    %rax,-0x20(%rbp)\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     0x3a\nmov    -0x20(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xcd\ncmpl   $0xffff,-0x8(%rbp)\njne    0xcd\nlea    0x0(%rip),%rax        # 0xa2\nmov    %rax,%rdi\ncall   0xaa\nlea    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xbb\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xc5\nmov    %rax,%rdi\ncall   0xcd\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_69",
        "query_text": "The function takes two unsigned integers as input and returns an unsigned integer. It extracts the lower 4 bits from the first input, shifts them left by 6 positions, and combines them with the lower 6 bits of the second input using a bitwise OR operation. This process produces a single unsigned integer that merges the relevant bits from both inputs.",
        "code_id": "c_group_1_id_69",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nshl    $0x6,%eax\nand    $0x3c0,%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nand    $0x3f,%eax\nor     %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x78\ncmpl   $0xffff,-0x8(%rbp)\njne    0x78\nlea    0x0(%rip),%rax        # 0x4d\nmov    %rax,%rdi\ncall   0x55\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x66\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x70\nmov    %rax,%rdi\ncall   0x78\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x25\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_90",
        "query_text": "This function returns a string representing the version of a library. It constructs the version string by concatenating the major, minor, and patch version numbers using the format \"X.Y.Z\". The function does not accept any input parameters and outputs a pointer to a constant character string that reflects the library's version.\n\n",
        "code_id": "c_group_1_id_90",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x64\ncmpl   $0xffff,-0x8(%rbp)\njne    0x64\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_91",
        "query_text": "The function takes no input arguments and returns a pointer to a constant character string. It simply provides the Unicode version information supported by the library\u2014specifically \"16.0.0\"\u2014without performing any additional processing.",
        "code_id": "c_group_1_id_91",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x64\ncmpl   $0xffff,-0x8(%rbp)\njne    0x64\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_15",
        "query_text": "The function receives three inputs. The first input is an integer representing a file descriptor. The second input is a pointer to a buffer (of type const void*), and the third input is an unsigned integer that indicates the number of bytes to write. It acts as a wrapper around a system call to write the data from the buffer to the file associated with the file descriptor. The function returns an integer representing the number of bytes successfully written, or -1 if an error occurs.",
        "code_id": "c_group_1_id_15",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x8(%rbp)\nmov    -0x8(%rbp),%edx\nmov    -0x10(%rbp),%rcx\nmov    -0x4(%rbp),%eax\nmov    %rcx,%rsi\nmov    %eax,%edi\ncall   0x2a\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7f\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rdi\ncall   0x5c\nlea    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x77\nmov    %rax,%rdi\ncall   0x7f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_46",
        "query_text": "The function accepts an unsigned 64-bit integer as its sole parameter. It calculates and returns an integer that represents the number of consecutive zero bits starting from the least significant bit of the input's binary representation. Note that if the input is zero, the behavior is undefined.",
        "code_id": "c_group_1_id_46",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nxor    %eax,%eax\ntzcnt  -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x69\ncmpl   $0xffff,-0x8(%rbp)\njne    0x69\nlea    0x0(%rip),%rax        # 0x3e\nmov    %rax,%rdi\ncall   0x46\nlea    0x0(%rip),%rax        # 0x4d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdi\ncall   0x69\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x16\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_17",
        "query_text": "The function takes an integer input that represents an error code and returns a string describing the associated error. The function internally serves as a wrapper for the standard library function that converts error codes into their corresponding error messages. The input is of type int, and the output is a pointer to a constant character string (const char*).",
        "code_id": "c_group_1_id_17",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   0x19\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6e\nlea    0x0(%rip),%rax        # 0x43\nmov    %rax,%rdi\ncall   0x4b\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdi\ncall   0x6e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_16",
        "query_text": "The function accepts an integer representing a file descriptor associated with an open resource and returns an integer indicating the result of the closure operation. It operates as a simple wrapper around the system call that performs the actual closing. A return value of 0 signifies a successful closure, while a return value of -1 indicates a failure.",
        "code_id": "c_group_1_id_16",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   0x19\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6e\nlea    0x0(%rip),%rax        # 0x43\nmov    %rax,%rdi\ncall   0x4b\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdi\ncall   0x6e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_12",
        "query_text": "This function reopens an existing file stream using a new file path and mode. It takes three parameters: a constant string representing the file path, a constant string defining the mode for opening the file, and a pointer to a file stream. Internally, it utilizes a standard C library call that reassigns the provided stream to the new file specified by the input path and mode. The function returns a pointer to the updated file stream\u2014if the underlying library call fails, it returns a null pointer.",
        "code_id": "c_group_1_id_12",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x84\ncmpl   $0xffff,-0x8(%rbp)\njne    0x84\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rdi\ncall   0x84\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x31\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_13",
        "query_text": "The function takes two inputs: an integer representing a file descriptor and a string indicating the file mode. It returns a pointer to a file stream object, which allows the use of standard file operations on the opened file. Internally, it associates the given file descriptor with a file stream by invoking a system library routine designed for this purpose.",
        "code_id": "c_group_1_id_13",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x4(%rbp),%eax\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   0x24\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_112",
        "query_text": "The function takes no input arguments and returns a reference to a constant pointer to a stream buffer object. Internally, the function utilizes a static variable to ensure that the pointer, which is initially set to point to the stream buffer of the standard logging stream, remains consistent across multiple invocations. This design guarantees that the same stream buffer is reused whenever the function is called.",
        "code_id": "c_group_1_id_112",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax        # 0x22\nmov    %rax,%rdi\ncall   0x2a\nmov    %rax,-0x10(%rbp)\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x47\ncall   0x47\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9c\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nlea    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x94\nmov    %rax,%rdi\ncall   0x9c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x49\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_95",
        "query_text": "The function takes a single input of type char. It verifies whether the input character is a numeric digit by checking if it lies between '0' and '9' (inclusive). If the input character meets this condition, the function returns true; otherwise, it returns false. The output of the function is of type bool.",
        "code_id": "c_group_1_id_95",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x2f,-0x4(%rbp)\njle    0x20\ncmpb   $0x39,-0x4(%rbp)\njg     0x20\nmov    $0x1,%eax\njmp    0x25\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7a\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdi\ncall   0x57\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x27\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_18",
        "query_text": "The function takes no input parameters and returns no value (void). It is an inline function that, when called, immediately terminates the program by invoking the standard library routine to abort execution, resulting in abnormal termination.",
        "code_id": "c_group_1_id_18",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\ncall   0xd\nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x60\ncmpl   $0xffff,-0x8(%rbp)\njne    0x60\nlea    0x0(%rip),%rax        # 0x35\nmov    %rax,%rdi\ncall   0x3d\nlea    0x0(%rip),%rax        # 0x44\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x58\nmov    %rax,%rdi\ncall   0x60\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xd\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_7",
        "query_text": "The function accepts an integer representing a file descriptor and determines whether it is associated with a terminal device. It returns a non-zero integer if the file descriptor is connected to a terminal and zero otherwise. The function serves as a lightweight wrapper around an underlying system call that performs this check.",
        "code_id": "c_group_1_id_7",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   0x19\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6e\nlea    0x0(%rip),%rax        # 0x43\nmov    %rax,%rdi\ncall   0x4b\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdi\ncall   0x6e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_10",
        "query_text": "The function accepts a single character string input that specifies a directory path. Its role is to delete the specified directory by calling the underlying system removal operation. After attempting the deletion, it returns an integer where a value of 0 indicates that the directory was removed successfully, while any non-zero value signals an error occurred during the operation.",
        "code_id": "c_group_1_id_10",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x71\ncmpl   $0xffff,-0x8(%rbp)\njne    0x71\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdi\ncall   0x4e\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_66",
        "query_text": "This function receives two arrays of doubles representing approximation and detail coefficients, two filter arrays (one low-pass and one high-pass), and several integer parameters defining the lengths of the coefficient and filter arrays as well as input and output stride values. It reconstructs the original signal by iterating over a calculated range and computing paired output values at each step. For each iteration, the function applies the filter coefficients to a subset of the approximation and detail arrays, multiplying the values accordingly and summing them into two output positions while accounting for the provided strides. The function also handles boundary conditions by wrapping around the coefficient arrays when necessary. The resulting reconstructed signal is written directly into the output array without returning any value.",
        "code_id": "c_group_1_id_66",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %rcx,-0x50(%rbp)\nmov    %r8,-0x58(%rbp)\nmov    %r9d,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x14(%rbp)\nmovl   $0xfffffffe,-0x20(%rbp)\nmovl   $0xffffffff,-0x1c(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    0x547\naddl   $0x2,-0x20(%rbp)\naddl   $0x2,-0x1c(%rbp)\nmov    -0x20(%rbp),%eax\nimul   0x20(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nimul   0x20(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x0,-0x24(%rbp)\njmp    0x537\nmov    -0x24(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x28(%rbp),%eax\nsub    -0x24(%rbp),%eax\ntest   %eax,%eax\njs     0x22f\nmov    -0x28(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncmp    %eax,-0x3c(%rbp)\njle    0x22f\nmov    -0x28(%rbp),%eax\nsub    -0x24(%rbp),%eax\nmov    0x18(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm0,%xmm2\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm3\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm3,%xmm0\naddsd  %xmm2,%xmm0\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x8(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm0,%xmm2\nmov    -0x8(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm3\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm3,%xmm0\naddsd  %xmm2,%xmm0\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x533\nmov    -0x28(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncmp    %eax,-0x3c(%rbp)\njg     0x3b6\nmov    -0x28(%rbp),%eax\nsub    -0x24(%rbp),%eax\nmov    -0x3c(%rbp),%ecx\nmov    -0x18(%rbp),%edx\nadd    %ecx,%edx\nsub    $0x1,%edx\ncmp    %edx,%eax\njge    0x3b6\nmov    -0x28(%rbp),%eax\nsub    -0x24(%rbp),%eax\nsub    -0x3c(%rbp),%eax\nmov    0x18(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm0,%xmm2\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm3\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm3,%xmm0\naddsd  %xmm2,%xmm0\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x8(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm0,%xmm2\nmov    -0x8(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm3\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm3,%xmm0\naddsd  %xmm2,%xmm0\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x533\nmov    -0x28(%rbp),%eax\nsub    -0x24(%rbp),%eax\ntest   %eax,%eax\njns    0x533\nmov    -0x28(%rbp),%eax\nsub    -0x24(%rbp),%eax\nmov    -0x14(%rbp),%edx\nneg    %edx\ncmp    %edx,%eax\njle    0x533\nmov    -0x3c(%rbp),%edx\nmov    -0x28(%rbp),%eax\nadd    %edx,%eax\nsub    -0x24(%rbp),%eax\nmov    0x18(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm0,%xmm2\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm3\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm3,%xmm0\naddsd  %xmm2,%xmm0\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x8(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm0,%xmm2\nmov    -0x8(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm3\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm3,%xmm0\naddsd  %xmm2,%xmm0\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     0xae\naddl   $0x1,-0x28(%rbp)\nmov    -0x3c(%rbp),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nsub    $0x1,%eax\ncmp    %eax,-0x28(%rbp)\njl     0x4e\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5b2\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5b2\nlea    0x0(%rip),%rax        # 0x587\nmov    %rax,%rdi\ncall   0x58f\nlea    0x0(%rip),%rax        # 0x596\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5a0\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5aa\nmov    %rax,%rdi\ncall   0x5b2\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x55f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_4",
        "query_text": "This function is intended to write output to the standard error stream. It accepts no input parameters and does not return any value. However, its current implementation features an empty body, so it does not perform any logging or output operations.",
        "code_id": "c_group_1_id_4",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_113",
        "query_text": "The function returns a unique integer value that serves as an index for an input/output stream. It accepts no arguments and produces an integer output. Internally, it uses a static variable to store the index, ensuring that the same value is returned on every call. Its inline definition contributes to minimal overhead and efficient performance.",
        "code_id": "c_group_1_id_113",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\ncall   0x11\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6c\nlea    0x0(%rip),%rax        # 0x41\nmov    %rax,%rdi\ncall   0x49\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdi\ncall   0x6c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x19\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_14",
        "query_text": "The function accepts a pointer to a file stream (of type FILE*), and it returns an integer. It closes the file stream by invoking the standard library's function for closing file streams. The returned integer indicates whether the operation was successful (with 0 denoting success and any non-zero value indicating failure).",
        "code_id": "c_group_1_id_14",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x71\ncmpl   $0xffff,-0x8(%rbp)\njne    0x71\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdi\ncall   0x4e\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_26",
        "query_text": "The function takes a wide character (wchar_t) as input and returns a boolean value. It checks whether the input character is a printable ASCII character by verifying if its value lies within the range of 0x20 to 0x7E. If the character falls within this range, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_26",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x1f,-0x4(%rbp)\njle    0x1e\ncmpl   $0x7e,-0x4(%rbp)\njg     0x1e\nmov    $0x1,%eax\njmp    0x23\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x78\ncmpl   $0xffff,-0x8(%rbp)\njne    0x78\nlea    0x0(%rip),%rax        # 0x4d\nmov    %rax,%rdi\ncall   0x55\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x66\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x70\nmov    %rax,%rdi\ncall   0x78\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x25\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_5",
        "query_text": "This function accepts a file pointer as input and returns the file's size in bytes as an unsigned integer type. It determines the size by repositioning the stream's pointer to the end of the file and then retrieving the current pointer position, which corresponds to the file size.",
        "code_id": "c_group_1_id_5",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x2,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x26\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x32\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x87\ncmpl   $0xffff,-0x8(%rbp)\njne    0x87\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nlea    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x75\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7f\nmov    %rax,%rdi\ncall   0x87\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x34\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_9",
        "query_text": "The function takes a constant character pointer as input (representing a C-style null-terminated string) and uses a standard library routine to create a duplicate of that string. It returns a pointer to the newly allocated duplicate, and the caller is responsible for freeing the allocated memory to prevent memory leaks.",
        "code_id": "c_group_1_id_9",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x71\ncmpl   $0xffff,-0x8(%rbp)\njne    0x71\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdi\ncall   0x4e\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_11",
        "query_text": "The function accepts a single input, a string (type const char*), representing a directory path. It then passes this string to a system-level operation to update the program's current working directory to the specified location. The function returns an integer that indicates the outcome of this change: 0 signifies a successful update, while a non-zero value indicates an error occurred.",
        "code_id": "c_group_1_id_11",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x71\ncmpl   $0xffff,-0x8(%rbp)\njne    0x71\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdi\ncall   0x4e\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_81",
        "query_text": "This function takes an unsigned integer, a string, and a pair of double values as inputs. It computes the average time per operation by dividing the first double value by the unsigned integer, and calculates the relative error percentage using the difference between the two doubles. These computed values, along with the string (displayed left-aligned), are formatted and printed in a human-readable summary. The function does not return any value (void).",
        "code_id": "c_group_1_id_81",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   %xmm0,%rcx\nmovapd %xmm1,%xmm0\nmov    $0x0,%eax\nmov    $0x0,%edx\nmov    %rcx,%rax\nmovq   %xmm0,%rdx\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovsd  -0x28(%rbp),%xmm0\nmovsd  -0x30(%rbp),%xmm2\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x52\n\nmulsd  %xmm1,%xmm0\nmovsd  -0x28(%rbp),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  -0x30(%rbp),%xmm1\nmov    -0x18(%rbp),%rax\ntest   %rax,%rax\njs     0x7d\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    0x96\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\ndivsd  %xmm0,%xmm1\nmovq   %xmm1,%rbx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0xab\nmovsd  -0x38(%rbp),%xmm1\nmovq   %rbx,%xmm0\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0xbf\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   0xcc\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x126\ncmpl   $0xffff,-0x8(%rbp)\njne    0x126\nlea    0x0(%rip),%rax        # 0xfb\nmov    %rax,%rdi\ncall   0x103\nlea    0x0(%rip),%rax        # 0x10a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x114\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x11e\nmov    %rax,%rdi\ncall   0x126\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xd3\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_27",
        "query_text": "The function accepts an 8-bit unsigned integer as input and returns a boolean value. It checks if the provided value is between 0x80 and 0xbf (inclusive). If the value satisfies this condition, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_27",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\ntest   %al,%al\njns    0x22\ncmpb   $0xbf,-0x4(%rbp)\nja     0x22\nmov    $0x1,%eax\njmp    0x27\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7c\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,%rdi\ncall   0x59\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdi\ncall   0x7c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x29\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_21",
        "query_text": "The function takes a boolean input and writes its corresponding string representation (\"true\" or \"false\") to an output stream. It employs a conditional operator to determine the appropriate string based on the input value, and then outputs this string to a stream of type std::ostream. The function does not return any value.",
        "code_id": "c_group_1_id_21",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %rsi,-0x10(%rbp)\nmov    %al,-0x4(%rbp)\ncmpb   $0x0,-0x4(%rbp)\nje     0x24\nlea    0x0(%rip),%rax        # 0x22\njmp    0x2b\nlea    0x0(%rip),%rax        # 0x2b\nmov    -0x10(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x3a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x90\ncmpl   $0xffff,-0x8(%rbp)\njne    0x90\nlea    0x0(%rip),%rax        # 0x65\nmov    %rax,%rdi\ncall   0x6d\nlea    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x88\nmov    %rax,%rdi\ncall   0x90\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_94",
        "query_text": "The function accepts three parameters: an integer value representing a character or digit, an integer representing the radix (base) of a numeral system, and a character that serves as the starting point for additional alphabetic digits (for numeral systems with bases higher than 10). It first checks if the radix is greater than 10. If so, the function verifies whether the integer falls within a continuous range beginning at the provided character and extending for (radix \u2013 10) positions. The function returns a boolean value: true if the integer represents a valid digit character for the given radix; otherwise, it returns false.",
        "code_id": "c_group_1_id_94",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %edx,%eax\nmov    %al,-0xc(%rbp)\ncmpl   $0xa,-0x8(%rbp)\njle    0x3a\nmovsbl -0xc(%rbp),%eax\ncmp    %eax,-0x4(%rbp)\njl     0x3a\nmovsbl -0xc(%rbp),%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\nsub    $0xa,%eax\ncmp    %eax,-0x4(%rbp)\njge    0x3a\nmov    $0x1,%eax\njmp    0x3f\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x94\ncmpl   $0xffff,-0x8(%rbp)\njne    0x94\nlea    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nlea    0x0(%rip),%rax        # 0x78\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x82\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8c\nmov    %rax,%rdi\ncall   0x94\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x41\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_82",
        "query_text": "The function takes five inputs: a double-precision floating-point number, an integer representing the desired precision, a boolean flag to determine if scientific notation is permitted, a character buffer to hold the formatted string, and the size of that buffer. It formats the floating-point number into the buffer using a fixed-point or scientific format based on the boolean flag. If the formatted string includes scientific notation (for instance, \"1.23e-4\"), the function terminates further processing. Otherwise, it checks for the presence of a decimal point and, if missing, appends \".0\" to the string. If a decimal point is present, the function removes any unnecessary trailing zeros following it, thereby simplifying the representation. The final formatted string is stored directly in the provided buffer, and no value is returned.",
        "code_id": "c_group_1_id_82",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovsd  %xmm0,-0x28(%rbp)\nmov    %edi,-0x2c(%rbp)\nmov    %esi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\ncmpl   $0x0,-0x30(%rbp)\nje     0x2e\nlea    0x0(%rip),%rax        # 0x2c\njmp    0x35\nlea    0x0(%rip),%rax        # 0x35\nmov    %rax,-0x10(%rbp)\nmov    -0x40(%rbp),%rax\nlea    -0x3(%rax),%rdi\nmov    -0x28(%rbp),%rsi\nmov    -0x2c(%rbp),%ecx\nmov    -0x10(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmovq   %rsi,%xmm0\nmov    %rdi,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x65\nmov    -0x38(%rbp),%rax\nmov    $0x65,%esi\nmov    %rax,%rdi\ncall   0x76\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    0x106\nmov    -0x38(%rbp),%rax\nmov    $0x2e,%esi\nmov    %rax,%rdi\ncall   0x96\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    0xc2\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0xad\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovw   $0x302e,(%rax)\nmovb   $0x0,0x2(%rax)\njmp    0x10a\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0xce\nlea    -0x1(%rax),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x18(%rbp)\njmp    0xf6\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    0x109\nmov    -0x18(%rbp),%rax\nmovb   $0x0,(%rax)\nsubq   $0x1,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\ncmp    %rax,-0x18(%rbp)\nja     0xdf\njmp    0x10a\nnop\njmp    0x10a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x15f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x15f\nlea    0x0(%rip),%rax        # 0x134\nmov    %rax,%rdi\ncall   0x13c\nlea    0x0(%rip),%rax        # 0x143\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x14d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x157\nmov    %rax,%rdi\ncall   0x15f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x10c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_67",
        "query_text": "The function takes three inputs: a pointer to a double array, an integer indicating the length of that array, and an additional integer that controls processing behavior. If the integer is negative, the function returns an error code (-1). When the integer is zero, the function directly copies the input array into an output double array and returns the original length. For a positive integer, the function performs an upsampling process on the input array by inserting zeros between its elements\u2014the number of inserted zeros is determined by the integer parameter. The function then returns the length of the newly constructed, upsampled output array. The inputs are a double pointer and two integers, and the output consists of a double array along with an integer representing its length (or an error code).",
        "code_id": "c_group_1_id_67",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    %rcx,-0x28(%rbp)\ncmpl   $0x0,-0x20(%rbp)\njns    0x26\nmov    $0xffffffff,%eax\njmp    0x10f\ncmpl   $0x0,-0x20(%rbp)\njne    0x79\nmovl   $0x0,-0x10(%rbp)\njmp    0x69\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x35\nmov    -0x1c(%rbp),%eax\njmp    0x10f\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nimul   -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    0x104\nsubl   $0x1,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\ncmpl   $0x0,-0xc(%rbp)\njne    0x100\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,-0xc(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     0xa0\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x164\ncmpl   $0xffff,-0x8(%rbp)\njne    0x164\nlea    0x0(%rip),%rax        # 0x139\nmov    %rax,%rdi\ncall   0x141\nlea    0x0(%rip),%rax        # 0x148\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x152\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x15c\nmov    %rax,%rdi\ncall   0x164\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x111\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_83",
        "query_text": "The function accepts a single integer input that represents a type identifier. It evaluates whether this identifier falls within an inclusive range defined by two predetermined constants. If the identifier lies within this range, the function returns a non-zero integer (indicating a true value); if not, it returns zero (indicating false). Its primary purpose is to determine if the provided type identifier corresponds to a scalar type.",
        "code_id": "c_group_1_id_83",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njle    0x1e\ncmpl   $0x6,-0x4(%rbp)\njg     0x1e\nmov    $0x1,%eax\njmp    0x23\nmov    $0x0,%eax\nmovzbl %al,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7b\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdi\ncall   0x58\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x69\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x73\nmov    %rax,%rdi\ncall   0x7b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x28\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_84",
        "query_text": "The function checks whether a string input meets specific validation criteria. It first verifies that the string is not empty; if it is, the string is deemed invalid. Next, it ensures that the first character is either a letter or an asterisk. Finally, it confirms that every subsequent character is either a letter, a digit, or one of the following allowed special characters: asterisk, underscore, or hyphen. Based on these checks, the function returns an integer indicating whether the string is valid or not.",
        "code_id": "c_group_1_id_84",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x2d\nmov    $0x0,%eax\njmp    0x101\ncall   0x32\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\njne    0x6a\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x2a,%al\nje     0x6a\nmov    $0x0,%eax\njmp    0x101\naddq   $0x1,-0x8(%rbp)\njmp    0xed\ncall   0x76\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\njne    0xe8\ncall   0x9e\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x800,%eax\ntest   %eax,%eax\njne    0xe8\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x0(%rip),%rax        # 0xd4\nmov    %rax,%rdi\ncall   0xdc\ntest   %rax,%rax\njne    0xe8\nmov    $0x0,%eax\njmp    0x101\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x71\nmov    $0x1,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x156\ncmpl   $0xffff,-0x8(%rbp)\njne    0x156\nlea    0x0(%rip),%rax        # 0x12b\nmov    %rax,%rdi\ncall   0x133\nlea    0x0(%rip),%rax        # 0x13a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x144\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x14e\nmov    %rax,%rdi\ncall   0x156\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x103\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_114",
        "query_text": "This function computes the population count of an unsigned 32-bit integer by determining the number of binary ones in its representation. It takes an unsigned 32-bit integer as input, applies a built-in compiler helper to efficiently count the ones, and returns the resulting count as an unsigned 32-bit integer. The input is an unsigned 32-bit integer, and the output represents the number of ones present in the binary form of the input.",
        "code_id": "c_group_1_id_114",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %rax,%rdi\ncall   0x1a\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6f\nlea    0x0(%rip),%rax        # 0x44\nmov    %rax,%rdi\ncall   0x4c\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x67\nmov    %rax,%rdi\ncall   0x6f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_1",
        "query_text": "The function accepts a constant character string as its sole input and immediately returns the integer value 0. It does not perform any operations or checks on the input; instead, the parameter is explicitly cast to void to indicate that it is unused. The input type is a pointer to a constant character, and the output type is an integer.",
        "code_id": "c_group_1_id_1",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x66\ncmpl   $0xffff,-0x8(%rbp)\njne    0x66\nlea    0x0(%rip),%rax        # 0x3b\nmov    %rax,%rdi\ncall   0x43\nlea    0x0(%rip),%rax        # 0x4a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x13\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_65",
        "query_text": "The function takes no input arguments and returns a double-precision floating-point value. It uses a standard library function to generate a random integer, then scales and converts this value to produce a number in the inclusive range from 1 to 100. The input is absent, and the output is of type double.",
        "code_id": "c_group_1_id_65",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\ncall   0x11\nmovslq %eax,%rdx\nimul   $0x51eb851f,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x5,%edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nimul   $0x64,%edx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\nlea    0x1(%rdx),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa4\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa4\nlea    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdi\ncall   0x81\nlea    0x0(%rip),%rax        # 0x88\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x92\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9c\nmov    %rax,%rdi\ncall   0xa4\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x51\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_2",
        "query_text": "The function takes a wide character string as input and immediately returns the integer 0. It does not perform any operations on the input string.",
        "code_id": "c_group_1_id_2",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x66\ncmpl   $0xffff,-0x8(%rbp)\njne    0x66\nlea    0x0(%rip),%rax        # 0x3b\nmov    %rax,%rdi\ncall   0x43\nlea    0x0(%rip),%rax        # 0x4a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x13\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_55",
        "query_text": "The function accepts an integer input representing a month index and returns a string containing the full name of that month. Internally, it uses a static lookup table that maps indices 0 through 11 to month names (from January to December). If the input is outside this valid range, the function returns a placeholder string, \"?\". The function is designed to take an input type of int and output a pointer to a constant character array (const char*).",
        "code_id": "c_group_1_id_55",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %edi,-0x74(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax        # 0x25\nmov    %rax,-0x70(%rbp)\nlea    0x0(%rip),%rax        # 0x30\nmov    %rax,-0x68(%rbp)\nlea    0x0(%rip),%rax        # 0x3b\nmov    %rax,-0x60(%rbp)\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,-0x58(%rbp)\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,-0x50(%rbp)\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,-0x48(%rbp)\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,-0x40(%rbp)\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,-0x38(%rbp)\nlea    0x0(%rip),%rax        # 0x7d\nmov    %rax,-0x30(%rbp)\nlea    0x0(%rip),%rax        # 0x88\nmov    %rax,-0x28(%rbp)\nlea    0x0(%rip),%rax        # 0x93\nmov    %rax,-0x20(%rbp)\nlea    0x0(%rip),%rax        # 0x9e\nmov    %rax,-0x18(%rbp)\ncmpl   $0x0,-0x74(%rbp)\njs     0xba\ncmpl   $0xb,-0x74(%rbp)\njg     0xba\nmov    -0x74(%rbp),%eax\ncltq   \nmov    -0x70(%rbp,%rax,8),%rax\njmp    0xc1\nlea    0x0(%rip),%rax        # 0xc1\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xd5\ncall   0xd5\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x12a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x12a\nlea    0x0(%rip),%rax        # 0xff\nmov    %rax,%rdi\ncall   0x107\nlea    0x0(%rip),%rax        # 0x10e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x118\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x122\nmov    %rax,%rdi\ncall   0x12a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xd7\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_80",
        "query_text": "The function accepts a pointer to a constant void type as input and returns a boolean value. Internally, it casts the input pointer to an integer pointer and retrieves the integer value it points to. The function then checks if this integer value is zero; if so, it returns true, otherwise false.",
        "code_id": "c_group_1_id_80",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6c\nlea    0x0(%rip),%rax        # 0x41\nmov    %rax,%rdi\ncall   0x49\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdi\ncall   0x6c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x19\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_93",
        "query_text": "The function accepts two integers as input and returns a boolean value. It evaluates whether the first integer qualifies as a valid digit within a numeral system defined by the second input (radix). The function checks three possible conditions: first, it verifies if the input falls within the numeric digit range ('0' to '9') and is valid for the given radix; second, for radices greater than 10, it checks if the input is a lowercase alphabetic digit (from 'a' onward) that represents a valid digit; and third, under the same condition (radix > 10), it verifies if the input is an uppercase alphabetic digit (from 'A' onward) corresponding to a valid digit. If any of these checks succeed, the function returns true, otherwise false.",
        "code_id": "c_group_1_id_93",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x2f,-0x4(%rbp)\njle    0x25\ncmpl   $0x39,-0x4(%rbp)\njg     0x25\nmov    -0x8(%rbp),%eax\nadd    $0x2f,%eax\ncmp    %eax,-0x4(%rbp)\njle    0x53\ncmpl   $0xa,-0x8(%rbp)\njle    0x3c\ncmpl   $0x60,-0x4(%rbp)\njle    0x3c\nmov    -0x8(%rbp),%eax\nadd    $0x56,%eax\ncmp    %eax,-0x4(%rbp)\njle    0x53\ncmpl   $0xa,-0x8(%rbp)\njle    0x5a\ncmpl   $0x40,-0x4(%rbp)\njle    0x5a\nmov    -0x8(%rbp),%eax\nadd    $0x36,%eax\ncmp    %eax,-0x4(%rbp)\njg     0x5a\nmov    $0x1,%eax\njmp    0x5f\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb4\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb4\nlea    0x0(%rip),%rax        # 0x89\nmov    %rax,%rdi\ncall   0x91\nlea    0x0(%rip),%rax        # 0x98\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa2\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xac\nmov    %rax,%rdi\ncall   0xb4\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x61\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_68",
        "query_text": "The function takes a string as input and iterates through each character to determine if it is not a UTF-8 continuation byte. For each character that is not a continuation byte, the function increments a counter. Once all characters are processed, it returns the total count, which represents the number of glyphs (logical characters) in the string. The input is of type std::string, and the output is of type std::string::size_type.",
        "code_id": "c_group_1_id_68",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x18(%rbp)\n\nmov    -0x38(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nmov    %rax,-0x28(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x4b\nmov    %rax,-0x20(%rbp)\njmp    0x84\nlea    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x5d\nmovzbl (%rax),%eax\nmov    %al,-0x29(%rbp)\nmovsbl -0x29(%rbp),%eax\nand    $0xc0,%eax\ncmp    $0x80,%eax\nje     0x78\naddq   $0x1,-0x18(%rbp)\nlea    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x84\nlea    -0x20(%rbp),%rdx\nlea    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x97\ntest   %al,%al\njne    0x51\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xb3\ncall   0xb3\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x108\ncmpl   $0xffff,-0x8(%rbp)\njne    0x108\nlea    0x0(%rip),%rax        # 0xdd\nmov    %rax,%rdi\ncall   0xe5\nlea    0x0(%rip),%rax        # 0xec\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xf6\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x100\nmov    %rax,%rdi\ncall   0x108\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb5\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x21\nmov    (%rax),%rbx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmov    (%rax),%rax\ncmp    %rax,%rbx\nsetne  %al\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_20",
        "query_text": "The function accepts a C-style string as input. It searches the string for the first occurrence of a comma and returns a std::string containing the characters from the beginning of the string up to, but not including, that comma. If the comma is not found, it returns the entire input string as a std::string. The input is of type const char*, and the output is of type std::string.",
        "code_id": "c_group_1_id_20",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x28(%rbp)\nxor    %eax,%eax\nmov    -0x50(%rbp),%rax\nmov    $0x2c,%esi\nmov    %rax,%rdi\ncall   0x39\nmov    %rax,-0x30(%rbp)\nmov    $0x0,%ebx\nmov    $0x0,%r12d\ncmpq   $0x0,-0x30(%rbp)\njne    0x79\nlea    -0x31(%rbp),%rax\nmov    %rax,%rdi\ncall   0x5b\nmov    $0x1,%ebx\nlea    -0x31(%rbp),%rdx\nmov    -0x50(%rbp),%rcx\nmov    -0x48(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x77\njmp    0xa3\nlea    -0x32(%rbp),%rax\nmov    %rax,%rdi\ncall   0x85\nmov    $0x1,%r12d\nlea    -0x32(%rbp),%rcx\nmov    -0x30(%rbp),%rdx\nmov    -0x50(%rbp),%rsi\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncall   0xa3\ntest   %r12b,%r12b\nje     0xb4\nlea    -0x32(%rbp),%rax\nmov    %rax,%rdi\ncall   0xb4\ntest   %bl,%bl\nje     0xfc\nlea    -0x31(%rbp),%rax\nmov    %rax,%rdi\ncall   0xc4\njmp    0xfc\nendbr64 \nmov    %rax,%r13\ntest   %r12b,%r12b\nje     0xde\nlea    -0x32(%rbp),%rax\nmov    %rax,%rdi\ncall   0xde\nmov    %r13,%r12\ntest   %bl,%bl\nje     0xf1\nlea    -0x31(%rbp),%rax\nmov    %rax,%rdi\ncall   0xf1\nmov    %r12,%rax\nmov    %rax,%rdi\ncall   0xfc\nmov    -0x28(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x110\ncall   0x110\nmov    -0x48(%rbp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x172\ncmpl   $0xffff,-0x8(%rbp)\njne    0x172\nlea    0x0(%rip),%rax        # 0x147\nmov    %rax,%rdi\ncall   0x14f\nlea    0x0(%rip),%rax        # 0x156\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x160\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x16a\nmov    %rax,%rdi\ncall   0x172\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11f\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    -0x18(%rbp),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\nmov    %rax,%rcx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x42\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x59\njmp    0x79\nendbr64 \nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x6e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x79\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x3e\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x53\ncall   0x53\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_3",
        "query_text": "The function accepts a boolean input and immediately returns that identical boolean value. It performs no additional processing or transformation, effectively serving as a simple pass-through.",
        "code_id": "c_group_1_id_3",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x66\ncmpl   $0xffff,-0x8(%rbp)\njne    0x66\nlea    0x0(%rip),%rax        # 0x3b\nmov    %rax,%rdi\ncall   0x43\nlea    0x0(%rip),%rax        # 0x4a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x13\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_88",
        "query_text": "The function accepts two pointers to constant memory areas representing a source string and a set of accepted characters. It processes the source as a UTF-8 encoded string, reading each character (or multi-byte sequence) and verifying if it exists within the accepted set. The function counts, in sequence, the number of characters from the source that are also found in the accepted set. It terminates the count when encountering the first character that does not match any in the accepted set or when the end of the source string is reached. The result, a count of type size_t, is returned as output.",
        "code_id": "c_group_1_id_88",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmovq   $0x0,-0x18(%rbp)\n\njmp    0xc7\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmovq   $0x0,-0x8(%rbp)\n\njmp    0xab\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nand    $0xc0,%eax\ncmp    $0x80,%eax\nje     0x63\ncmpq   $0x0,-0x8(%rbp)\nje     0x63\naddq   $0x1,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nadd    %rax,-0x20(%rbp)\njmp    0xb6\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x20(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    0x88\naddq   $0x1,-0x8(%rbp)\naddq   $0x1,-0x10(%rbp)\njmp    0xab\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nand    $0xc0,%eax\ncmp    $0x80,%eax\nje     0x88\nmovq   $0x0,-0x8(%rbp)\n\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x37\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0xc7\nmov    -0x18(%rbp),%rax\njmp    0xda\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x25\nmov    -0x18(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x12f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x12f\nlea    0x0(%rip),%rax        # 0x104\nmov    %rax,%rdi\ncall   0x10c\nlea    0x0(%rip),%rax        # 0x113\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x11d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x127\nmov    %rax,%rdi\ncall   0x12f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xdc\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_89",
        "query_text": "The function accepts three inputs: a constant string, a separator character, and a non-negative integer. It searches the string for the nth occurrence of the separator character and returns a pointer to the beginning of the substring immediately following that occurrence. If the string is null, the separator character does not appear, or the nth occurrence is not found, the function returns a null pointer. The output is of type pointer to constant character.",
        "code_id": "c_group_1_id_89",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %rdx,-0x18(%rbp)\nmov    %al,-0xc(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    0x27\nmov    $0x0,%eax\njmp    0x9d\ncmpq   $0x0,-0x18(%rbp)\njne    0x34\nmov    -0x8(%rbp),%rax\njmp    0x9d\nmovsbl -0xc(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x46\nmov    %rax,-0x8(%rbp)\nsubq   $0x1,-0x18(%rbp)\njmp    0x7f\ncmpq   $0x0,-0x8(%rbp)\njne    0x5f\nmov    $0x0,%eax\njmp    0x9d\nsubq   $0x1,-0x18(%rbp)\naddq   $0x1,-0x8(%rbp)\nmovsbl -0xc(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x7b\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    0x51\ncmpq   $0x0,-0x8(%rbp)\nje     0x97\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\njmp    0x9c\nmov    $0x0,%eax\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xf2\ncmpl   $0xffff,-0x8(%rbp)\njne    0xf2\nlea    0x0(%rip),%rax        # 0xc7\nmov    %rax,%rdi\ncall   0xcf\nlea    0x0(%rip),%rax        # 0xd6\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xe0\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xea\nmov    %rax,%rdi\ncall   0xf2\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x9f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_25",
        "query_text": "The function accepts two inputs: a pointer to a null-terminated constant character array and an integer specifying the maximum number of characters allowed in the output. It processes the string by printing it on a single line to the standard output. During this process, any newline characters found within the string are substituted with the literal characters \"\\\" followed by \"n\". If the count of printed characters reaches the specified maximum length before the entire string is processed, the function stops printing further characters and appends an ellipsis (\"...\") to indicate that the string has been truncated. The function does not produce a return value and its primary role is to output a processed version of the input string directly to the standard output.",
        "code_id": "c_group_1_id_25",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     0x8c\nmovl   $0x0,-0x4(%rbp)\njmp    0x81\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x42\nlea    0x0(%rip),%rax        # 0x32\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x3f\nnop\njmp    0x8c\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xa,%al\njne    0x67\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x61\naddl   $0x2,-0x4(%rbp)\njmp    0x7c\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   0x78\naddl   $0x1,-0x4(%rbp)\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x23\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xe2\ncmpl   $0xffff,-0x8(%rbp)\njne    0xe2\nlea    0x0(%rip),%rax        # 0xb7\nmov    %rax,%rdi\ncall   0xbf\nlea    0x0(%rip),%rax        # 0xc6\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xd0\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xda\nmov    %rax,%rdi\ncall   0xe2\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x8f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_24",
        "query_text": "The function takes an input of type int, where the value determines the number of space characters. It then returns a std::string that consists precisely of that many spaces.",
        "code_id": "c_group_1_id_24",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2f\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rsi\nlea    -0x19(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rcx\nmov    $0x20,%edx\nmov    %rax,%rdi\ncall   0x4d\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x59\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x8d\njmp    0x88\nendbr64 \nmov    %rax,%rbx\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x7d\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x88\ncall   0x8d\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xea\ncmpl   $0xffff,-0x8(%rbp)\njne    0xea\nlea    0x0(%rip),%rax        # 0xbf\nmov    %rax,%rdi\ncall   0xc7\nlea    0x0(%rip),%rax        # 0xce\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xd8\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xe2\nmov    %rax,%rdi\ncall   0xea\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x97\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,%eax\nmov    %rcx,-0x30(%rbp)\nmov    %al,-0x24(%rbp)\nmov    -0x18(%rbp),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2e\nmov    %rax,%rcx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x43\nmovsbl -0x24(%rbp),%edx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x5a\njmp    0x7a\nendbr64 \nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x6f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x7a\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_121",
        "query_text": "The function takes a floating-point input and returns a floating-point output. It computes a smooth interpolation by applying a cubic easing transformation based on the input, specifically through a quadratic combination that clamps the output between 0 and 1 when the input is within that range. This behavior is ideal for generating smooth transitions or easing effects in animations and interpolations.",
        "code_id": "c_group_1_id_121",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  %xmm0,%xmm1\nmovss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm2\naddss  %xmm0,%xmm2\nmovss  0x0(%rip),%xmm0        # 0x2d\n\nsubss  %xmm2,%xmm0\nmulss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8a\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x78\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x82\nmov    %rax,%rdi\ncall   0x8a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x37\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_23",
        "query_text": "The function receives two inputs, each of type const wchar_t* (wide-character strings). It first checks if either string is NULL and, if so, returns a bool value that is true only when both inputs are NULL. If neither input is NULL, the function uses a standard library routine to determine whether the first string is a substring of the second. It then returns true if the substring is found, and false otherwise.",
        "code_id": "c_group_1_id_23",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     0x22\ncmpq   $0x0,-0x10(%rbp)\njne    0x2f\nmov    -0x8(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nsete   %al\njmp    0x48\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x42\ntest   %rax,%rax\nsetne  %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9d\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nlea    0x0(%rip),%rax        # 0x81\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x95\nmov    %rax,%rdi\ncall   0x9d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x4a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_61",
        "query_text": "The function takes one input: a floating-point value representing an angle in degrees. It computes the equivalent angle in radians by multiplying the input by the constant factor \u03c0/180. The function then returns the calculated floating-point value, performing the unit conversion directly on the provided argument.",
        "code_id": "c_group_1_id_61",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x1a\n\nmulss  %xmm1,%xmm0\nmovss  0x0(%rip),%xmm1        # 0x26\n\ndivss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7f\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rdi\ncall   0x5c\nlea    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x77\nmov    %rax,%rdi\ncall   0x7f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_79",
        "query_text": "The function takes no input arguments. It immediately returns a boolean value of true without performing any calculation or condition checks. This constant behavior ensures that the output is always true, regardless of any external factors. The return type of the function is bool.",
        "code_id": "c_group_1_id_79",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_138",
        "query_text": "The function takes an integer as input and returns an integer. It prints a usage message to the standard error stream, which provides guidance on how to execute a program. The message details optional arguments, including options for specific directives and control over execution flow, as well as the possibility of specifying an input file. After displaying the message, the function returns the provided integer value. The input is of type int, and the output is of type int.",
        "code_id": "c_group_1_id_138",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    0x0(%rip),%rax        # 0x16\nmov    %rax,%rcx\nmov    $0x5c,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x2a\nmov    %rax,%rdi\ncall   0x32\nmov    -0x4(%rbp),%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8a\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x78\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x82\nmov    %rax,%rdi\ncall   0x8a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x37\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_19",
        "query_text": "This function converts the content of a string stream into a standard string. It processes each character from the string stream one at a time and checks whether it is a null character. If a null character is detected, it appends the escape sequence \"\\0\" to the output string; all other characters are directly copied. The function also reserves extra capacity in the output string to accommodate the potential increase in size due to the replacement of null characters. The input is a pointer to a string stream, and the output is a standard string containing the transformed content.",
        "code_id": "c_group_1_id_19",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %rsi,-0x70(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x40(%rbp),%rax\nmov    -0x70(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x37\nlea    -0x40(%rbp),%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   0x4b\nmov    %rax,-0x50(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   0x5b\nmov    -0x50(%rbp),%rdx\nadd    %rdx,%rax\nmov    %rax,-0x48(%rbp)\nmov    -0x68(%rbp),%rax\nmov    %rax,%rdi\ncall   0x72\nmov    -0x48(%rbp),%rax\nsub    -0x50(%rbp),%rax\nadd    %rax,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x8f\nmov    -0x50(%rbp),%rax\nmov    %rax,-0x60(%rbp)\njmp    0xd9\nmov    -0x60(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0xbc\nmov    -0x68(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0xaf\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xba\njmp    0xd4\nmov    -0x60(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x68(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0xd4\naddq   $0x1,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\ncmp    -0x48(%rbp),%rax\njne    0x99\nnop\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0xf0\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x131\njmp    0x12c\nendbr64 \nmov    %rax,%rbx\nmov    -0x68(%rbp),%rax\nmov    %rax,%rdi\ncall   0x115\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x121\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x12c\ncall   0x131\nmov    -0x68(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x18e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x18e\nlea    0x0(%rip),%rax        # 0x163\nmov    %rax,%rdi\ncall   0x16b\nlea    0x0(%rip),%rax        # 0x172\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x17c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x186\nmov    %rax,%rdi\ncall   0x18e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x13b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_155",
        "query_text": "The function takes three unsigned integers as input. It shifts the first input left by 12 bits, shifts the lower 6 bits of the second integer left by 6 bits, and then combines these results with the lower 6 bits of the third input using bitwise OR operations. The function returns a single unsigned integer encapsulating the combined bit pattern from the three inputs.",
        "code_id": "c_group_1_id_155",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %edx,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nshl    $0xc,%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nshl    $0x6,%eax\nand    $0xfc0,%eax\nor     %eax,%edx\nmov    -0xc(%rbp),%eax\nand    $0x3f,%eax\nor     %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x83\ncmpl   $0xffff,-0x8(%rbp)\njne    0x83\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rdi\ncall   0x60\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rdi\ncall   0x83\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x30\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_144",
        "query_text": "The function takes three parameters: a pointer to an array of double-precision floating-point numbers, an integer specifying the number of elements in the array, and another pointer to an array of doubles where the result will be stored. It reverses the order of the elements from the input array such that the first element in the output array is the last element from the input array, the second element is the second-to-last, and so on. The function processes exactly the number of elements specified by the integer parameter and returns no value.",
        "code_id": "c_group_1_id_144",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x5a\nmov    -0x1c(%rbp),%eax\nsub    -0x4(%rbp),%eax\ncltq   \nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x23\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb9\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb9\nlea    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdi\ncall   0x96\nlea    0x0(%rip),%rax        # 0x9d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa7\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdi\ncall   0xb9\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x66\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_62",
        "query_text": "The function takes two integer inputs. It compares these values and, if the first integer is less than the second, returns the first; otherwise, it returns the second integer. The function\u2019s return type is an integer.",
        "code_id": "c_group_1_id_62",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    0x1b\nmov    -0x4(%rbp),%eax\njmp    0x1e\nmov    -0x8(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x73\ncmpl   $0xffff,-0x8(%rbp)\njne    0x73\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdi\ncall   0x50\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdi\ncall   0x73\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x20\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_142",
        "query_text": "The function accepts two input arrays along with their respective lengths and an output array intended to hold the convolution result, which has a length equal to the sum of the input lengths minus one. It computes a direct convolution by iterating through one array and, for each element, multiplying it by corresponding elements from the other array while accumulating the products. The function accounts for two scenarios: one where the first input array is at least as long as the second, and another where the second input array is longer. In each case, it processes the elements appropriately and stores the final accumulated sums directly into the output array. No value is returned, as the computation modifies the supplied output array in place.",
        "code_id": "c_group_1_id_142",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %ecx,-0x30(%rbp)\nmov    %r8,-0x40(%rbp)\nmov    -0x2c(%rbp),%edx\nmov    -0x30(%rbp),%eax\nadd    %edx,%eax\nsub    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     0x1fc\nmovl   $0x0,-0x20(%rbp)\njmp    0xe7\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x0,-0x1c(%rbp)\njmp    0xdb\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njle    0x6c\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     0x47\nmov    -0x30(%rbp),%eax\nmov    %eax,-0x20(%rbp)\njmp    0x1eb\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x30(%rbp),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x2c(%rbp),%xmm0\ncomisd -0x10(%rbp),%xmm0\njbe    0x14a\nmovsd  -0x10(%rbp),%xmm0\njmp    0x153\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x2c(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\njmp    0x1cf\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x1c(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x1c(%rbp),%xmm1\nmovsd  -0x8(%rbp),%xmm0\ncomisd %xmm1,%xmm0\nja     0x160\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     0xfe\njmp    0x3b8\nmovl   $0x0,-0x20(%rbp)\njmp    0x2a8\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x0,-0x1c(%rbp)\njmp    0x29c\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njle    0x22d\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     0x208\nmov    -0x2c(%rbp),%eax\nmov    %eax,-0x20(%rbp)\njmp    0x3ac\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x2c(%rbp),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x30(%rbp),%xmm0\ncomisd -0x10(%rbp),%xmm0\njbe    0x30b\nmovsd  -0x10(%rbp),%xmm0\njmp    0x314\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x30(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\njmp    0x390\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x1c(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x1c(%rbp),%xmm1\nmovsd  -0x8(%rbp),%xmm0\ncomisd %xmm1,%xmm0\nja     0x321\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     0x2bf\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x40e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x40e\nlea    0x0(%rip),%rax        # 0x3e3\nmov    %rax,%rdi\ncall   0x3eb\nlea    0x0(%rip),%rax        # 0x3f2\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x3fc\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x406\nmov    %rax,%rdi\ncall   0x40e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3bb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_123",
        "query_text": "The function accepts a single floating-point parameter. It applies a linear transformation by simply returning the input value unchanged, thereby preserving a direct one-to-one relationship between input and output. Both the input and output are of type float, and the function does not modify or scale the value in any way.",
        "code_id": "c_group_1_id_123",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_148",
        "query_text": "The function takes an input array of double values and an integer indicating its length, along with an integer offset and an output array for storing results. It first copies the input array into the output array starting at the specified offset. If the length of the input array is odd, it duplicates the last element to ensure an even count. The function then extends the section of the output array by mirroring the copied values to both the beginning (before the offset) and the end (after the extended segment), thereby creating a symmetric, periodic repetition of the signal. Finally, the function returns an integer representing the length of the extended signal, which is either equal to the original length or incremented by one if the input length was odd.",
        "code_id": "c_group_1_id_148",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %edx,-0x30(%rbp)\nmov    %rcx,-0x38(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    0x58\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x30(%rbp),%ecx\nmov    -0x18(%rbp),%eax\nadd    %ecx,%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     0x1f\nmov    -0x2c(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x2c(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     0xae\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq   \nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x30(%rbp),%ecx\nmov    -0x2c(%rbp),%eax\nadd    %ecx,%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x0,-0x18(%rbp)\njmp    0x152\nmov    -0x30(%rbp),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x30(%rbp),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nsub    $0x1,%eax\nsub    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x30(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x14(%rbp),%edx\nmov    -0x30(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     0xba\nmov    -0x14(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x1b6\ncmpl   $0xffff,-0x8(%rbp)\njne    0x1b6\nlea    0x0(%rip),%rax        # 0x18b\nmov    %rax,%rdi\ncall   0x193\nlea    0x0(%rip),%rax        # 0x19a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x1a4\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x1ae\nmov    %rax,%rdi\ncall   0x1b6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x163\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_146",
        "query_text": "The function takes several inputs: a pointer to an array of double-precision floating-point numbers, an integer representing the array's length, two pointers to arrays containing filter coefficients (one for low-pass and one for high-pass), an integer specifying the number of filter coefficients, a pointer to an output array for the approximation coefficients, an integer indicating the length of this output, a pointer to an output array for the detail coefficients, and two integers that define the stride for reading input and writing output. The function processes the input array by sliding a window\u2014with a center offset derived from the filter length\u2014across the data. For each position, it computes two weighted sums: one using the low-pass coefficients to produce an approximation coefficient and the other using the high-pass coefficients to produce a detail coefficient. If the filter window reaches beyond the bounds of the input array, the function handles the situation by wrapping or mirroring the input, depending on whether the length of the input array is even or odd. The computed values are then stored directly into the provided output arrays.",
        "code_id": "c_group_1_id_146",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\nmov    %r8d,-0x30(%rbp)\nmov    %r9,-0x48(%rbp)\nmov    -0x30(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x14(%rbp)\nmov    -0x2c(%rbp),%eax\ncltd   \nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nmov    %eax,-0x10(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    0x8b5\nmov    -0x1c(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x1c(%rbp),%eax\nimul   0x28(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x0,-0x20(%rbp)\njmp    0x8a5\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\ncmp    %eax,-0x14(%rbp)\njg     0x1af\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\ncmp    %eax,-0x2c(%rbp)\njle    0x1af\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\nmov    0x20(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x8a1\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\ncmp    %eax,-0x14(%rbp)\njle    0x2b0\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\ntest   %eax,%eax\njs     0x2b0\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\nmov    0x20(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x8a1\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\ntest   %eax,%eax\njns    0x3b3\ncmpl   $0x0,-0x10(%rbp)\njne    0x3b3\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\nmov    %eax,%edx\nmov    -0x2c(%rbp),%eax\nadd    %eax,%edx\nmov    0x20(%rbp),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x8a1\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\ntest   %eax,%eax\njns    0x5ac\ncmpl   $0x1,-0x10(%rbp)\njne    0x5ac\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\ncmp    $0xffffffff,%eax\nje     0x4c8\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\nmov    %eax,%edx\nmov    -0x2c(%rbp),%eax\nadd    %edx,%eax\nlea    0x1(%rax),%edx\nmov    0x20(%rbp),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x8a1\nmov    -0x2c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    0x20(%rbp),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x8a1\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\ncmp    %eax,-0x2c(%rbp)\njg     0x6ac\ncmpl   $0x0,-0x10(%rbp)\njne    0x6ac\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\nsub    -0x2c(%rbp),%eax\nmov    0x20(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x8a1\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\ncmp    %eax,-0x2c(%rbp)\njg     0x8a1\ncmpl   $0x1,-0x10(%rbp)\njne    0x8a1\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\nmov    -0x2c(%rbp),%edx\nlea    0x1(%rdx),%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    0x20(%rbp),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\nsub    -0x20(%rbp),%eax\ncmp    %eax,-0x2c(%rbp)\nje     0x7c2\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x8a1\nmov    -0x2c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    0x20(%rbp),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     0xad\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    0x10(%rbp),%eax\njl     0x51\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x918\ncmpl   $0xffff,-0x8(%rbp)\njne    0x918\nlea    0x0(%rip),%rax        # 0x8ed\nmov    %rax,%rdi\ncall   0x8f5\nlea    0x0(%rip),%rax        # 0x8fc\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x906\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x910\nmov    %rax,%rdi\ncall   0x918\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x8c5\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_137",
        "query_text": "The function receives four inputs: a pointer to a character array representing a file path, a pointer to an unsigned character array serving as a byte buffer, a size value indicating the number of bytes in the buffer, and an integer representing a count. Initially, it checks whether the integer is non-negative and, if so, prints a failure message along with the corresponding document number. The function then opens the file specified by the path in binary read mode and proceeds to read its contents in fixed-size chunks. As each chunk is read, it is written to the standard output while simultaneously accumulating the total number of bytes processed. Once the entire file is read, the file is closed, and the function prints the total size of the file data followed by the contents of the provided byte buffer along with its size. Finally, the function returns a value of 0, indicating successful completion.",
        "code_id": "c_group_1_id_137",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    -0x10000(%rsp),%r11\n\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    0x10\nsub    $0x50,%rsp\nmov    %rdi,-0x10038(%rbp)\nmov    %rsi,-0x10040(%rbp)\nmov    %rdx,-0x10048(%rbp)\nmov    %ecx,-0x1004c(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x1,-0x10028(%rbp)\n\nmovq   $0x0,-0x10020(%rbp)\n\ncmpl   $0x0,-0x1004c(%rbp)\njs     0x8d\nmov    -0x1004c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%esi\nlea    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x8d\nmov    -0x10038(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x9b\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xa6\nmov    %rax,-0x10018(%rbp)\ncmpq   $0x0,-0x10018(%rbp)\n\njne    0x1d9\nlea    0x0(%rip),%rax        # 0xc2\nmov    %rax,%rcx\nmov    $0x17,%edx\nlea    0x0(%rip),%rax        # 0xd1\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0xdb\nmov    %rax,%rdi\ncall   0xe3\nmov    -0x10018(%rbp),%rdx\nlea    -0x10010(%rbp),%rax\nmov    %rdx,%rcx\nmov    $0x10000,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   0x106\nmov    %rax,-0x10028(%rbp)\nmov    -0x10018(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11c\ntest   %eax,%eax\nsete   %al\ntest   %al,%al\njne    0x14d\nlea    0x0(%rip),%rax        # 0x12c\nmov    %rax,%rcx\nmov    $0x1a,%edx\nlea    0x0(%rip),%rax        # 0x13b\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x145\nmov    %rax,%rdi\ncall   0x14d\ncmpq   $0x0,-0x10028(%rbp)\n\nje     0x1e9\nmov    0x0(%rip),%rcx        # 0x162\nmov    -0x10028(%rbp),%rdx\nlea    -0x10010(%rbp),%rax\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   0x17d\ncmp    %rax,-0x10028(%rbp)\nsete   %al\ntest   %al,%al\njne    0x1b3\nlea    0x0(%rip),%rax        # 0x192\nmov    %rax,%rcx\nmov    $0x1c,%edx\nlea    0x0(%rip),%rax        # 0x1a1\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x1ab\nmov    %rax,%rdi\ncall   0x1b3\nmov    -0x10028(%rbp),%rax\nadd    %rax,-0x10020(%rbp)\nmov    -0x10018(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1d0\ntest   %eax,%eax\nsetne  %al\ntest   %al,%al\njne    0x1ec\ncmpq   $0x0,-0x10028(%rbp)\n\njne    0xe3\njmp    0x1ed\nnop\njmp    0x1ed\nnop\nmov    -0x10018(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1fc\nmov    -0x10020(%rbp),%rax\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x20d\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x21a\nmov    -0x10048(%rbp),%rdx\nmov    -0x10040(%rbp),%rax\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x232\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x23f\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x258\ncall   0x258\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x2ad\ncmpl   $0xffff,-0x8(%rbp)\njne    0x2ad\nlea    0x0(%rip),%rax        # 0x282\nmov    %rax,%rdi\ncall   0x28a\nlea    0x0(%rip),%rax        # 0x291\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x29b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x2a5\nmov    %rax,%rdi\ncall   0x2ad\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x25a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_143",
        "query_text": "The function accepts five parameters: two pointers to numeric arrays (one for each input array) along with two integers that specify the sizes of these arrays, as well as a pointer to a numeric array intended to store the convolution result. It first calculates the size of the output array as the sum of the two input sizes minus one, and then initializes each element of this output array to zero. The function proceeds to iterate over the range of the output array, and for each position, it sums the products of appropriate elements from the two input arrays\u2014ensuring that the indices used strictly fall within the limits of the second input array. The function does not return a value; instead, it directly modifies the output array in place.",
        "code_id": "c_group_1_id_143",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x20(%rbp)\nmov    %r8,-0x30(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x20(%rbp),%eax\nadd    %edx,%eax\nsub    $0x1,%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    0xf0\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x0,-0x8(%rbp)\njmp    0xe0\nmov    -0xc(%rbp),%eax\nsub    -0x8(%rbp),%eax\ntest   %eax,%eax\njs     0xdc\nmov    -0xc(%rbp),%eax\nsub    -0x8(%rbp),%eax\ncmp    %eax,-0x20(%rbp)\njle    0xdc\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0xc(%rbp),%eax\nsub    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x5c\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     0x34\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x153\ncmpl   $0xffff,-0x8(%rbp)\njne    0x153\nlea    0x0(%rip),%rax        # 0x128\nmov    %rax,%rdi\ncall   0x130\nlea    0x0(%rip),%rax        # 0x137\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x141\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x14b\nmov    %rax,%rdi\ncall   0x153\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x100\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_156",
        "query_text": "The function takes no input arguments and returns a pointer to a statically allocated constant character array. This array holds a concatenated sequence of two-digit numbers in ascending order from \"00\" to \"99\". The function is declared as inline and guarantees no exceptions, with the return type being const char*. Its purpose is to provide quick access to a precomputed lookup table that can be utilized for efficient string formatting or similar operations.",
        "code_id": "c_group_1_id_156",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0xe0,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x3330323031303030,%rax\n\nmovabs $0x3730363035303430,%rdx\n\nmov    %rax,-0xe0(%rbp)\nmov    %rdx,-0xd8(%rbp)\nmovabs $0x3131303139303830,%rax\n\nmovabs $0x3531343133313231,%rdx\n\nmov    %rax,-0xd0(%rbp)\nmov    %rdx,-0xc8(%rbp)\nmovabs $0x3931383137313631,%rax\n\nmovabs $0x3332323231323032,%rdx\n\nmov    %rax,-0xc0(%rbp)\nmov    %rdx,-0xb8(%rbp)\nmovabs $0x3732363235323432,%rax\n\nmovabs $0x3133303339323832,%rdx\n\nmov    %rax,-0xb0(%rbp)\nmov    %rdx,-0xa8(%rbp)\nmovabs $0x3533343333333233,%rax\n\nmovabs $0x3933383337333633,%rdx\n\nmov    %rax,-0xa0(%rbp)\nmov    %rdx,-0x98(%rbp)\nmovabs $0x3334323431343034,%rax\n\nmovabs $0x3734363435343434,%rdx\n\nmov    %rax,-0x90(%rbp)\nmov    %rdx,-0x88(%rbp)\nmovabs $0x3135303539343834,%rax\n\nmovabs $0x3535343533353235,%rdx\n\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmovabs $0x3935383537353635,%rax\n\nmovabs $0x3336323631363036,%rdx\n\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmovabs $0x3736363635363436,%rax\n\nmovabs $0x3137303739363836,%rdx\n\nmov    %rax,-0x60(%rbp)\nmov    %rdx,-0x58(%rbp)\nmovabs $0x3537343733373237,%rax\n\nmovabs $0x3937383737373637,%rdx\n\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmovabs $0x3338323831383038,%rax\n\nmovabs $0x3738363835383438,%rdx\n\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovabs $0x3139303939383838,%rax\n\nmovabs $0x3539343933393239,%rdx\n\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovabs $0x3939383937393639,%rax\n\nmov    %rax,-0x20(%rbp)\nmovb   $0x0,-0x18(%rbp)\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x1bd\ncall   0x1bd\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x212\ncmpl   $0xffff,-0x8(%rbp)\njne    0x212\nlea    0x0(%rip),%rax        # 0x1e7\nmov    %rax,%rdi\ncall   0x1ef\nlea    0x0(%rip),%rax        # 0x1f6\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x200\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x20a\nmov    %rax,%rdi\ncall   0x212\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1bf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_147",
        "query_text": "This function processes an array of double-precision floating-point numbers to produce a downsampled version of the array. It takes as inputs a pointer to a floating-point array, the length of that array, an integer specifying the sampling interval, and a pointer to an output array. If the sampling interval is negative, the function immediately returns an error code (-1). When the interval is zero, the function copies each element from the input array to the output array and returns the original array length. For a positive interval, it calculates the length of the resulting downsampled array, then selects elements from the input array at positions determined by the interval, storing them in the output array. Finally, it returns the length of the downsampled array.",
        "code_id": "c_group_1_id_147",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    %rcx,-0x28(%rbp)\ncmpl   $0x0,-0x20(%rbp)\njns    0x26\nmov    $0xffffffff,%eax\njmp    0xd2\ncmpl   $0x0,-0x20(%rbp)\njne    0x76\nmovl   $0x0,-0x8(%rbp)\njmp    0x69\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x35\nmov    -0x1c(%rbp),%eax\njmp    0xd2\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\ncltd   \nidivl  -0x20(%rbp)\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    0xc7\nmov    -0x8(%rbp),%eax\nimul   -0x20(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     0x8f\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x127\ncmpl   $0xffff,-0x8(%rbp)\njne    0x127\nlea    0x0(%rip),%rax        # 0xfc\nmov    %rax,%rdi\ncall   0x104\nlea    0x0(%rip),%rax        # 0x10b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x115\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x11f\nmov    %rax,%rdi\ncall   0x127\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xd4\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_120",
        "query_text": "The function takes three inputs, all of type float. The first two floats represent the starting and ending values for interpolation, while the third float specifies the interpolation factor. The function computes the result by adding the product of the interpolation factor and the difference between the ending and starting values to the starting value. If the interpolation factor is 0, the output is the starting value; if it is 1, the output is the ending value; intermediate values yield a proportional blend of the two. The function returns a float representing the interpolated value.",
        "code_id": "c_group_1_id_120",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  %xmm1,-0x8(%rbp)\nmovss  %xmm2,-0xc(%rbp)\nmovss  -0x8(%rbp),%xmm0\nsubss  -0x4(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  -0x4(%rbp),%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x80\ncmpl   $0xffff,-0x8(%rbp)\njne    0x80\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdi\ncall   0x5d\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x78\nmov    %rax,%rdi\ncall   0x80\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_119",
        "query_text": "The function takes a single floating-point input representing a numerical value and computes its square. It does this by multiplying the input by itself, returning the result as a floating-point value. The operation effectively calculates the square of the given number.",
        "code_id": "c_group_1_id_119",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  %xmm0,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6b\nlea    0x0(%rip),%rax        # 0x40\nmov    %rax,%rdi\ncall   0x48\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdi\ncall   0x6b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x18\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_50",
        "query_text": "The function takes two inputs, both of type unsigned. It modifies the first input in place by appending the second value using bitwise operations. Specifically, if the first input is non-zero, the second input is shifted left by 8 bits before being combined; otherwise, it is appended as is. Additionally, the function increments a counter stored in the higher bits of the first input. This counter is increased by a base value of 1, with an extra increment if the second input exceeds a certain threshold. The final result is an updated unsigned integer that reflects both the appended value and the incremented counter.",
        "code_id": "c_group_1_id_50",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\nje     0x27\nmov    -0xc(%rbp),%eax\nshl    $0x8,%eax\njmp    0x2a\nmov    -0xc(%rbp),%eax\nor     %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmpl   $0xff,-0xc(%rbp)\njbe    0x48\nmov    $0x2000000,%edx\njmp    0x4d\nmov    $0x1000000,%edx\nadd    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xab\ncmpl   $0xffff,-0x8(%rbp)\njne    0xab\nlea    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdi\ncall   0x88\nlea    0x0(%rip),%rax        # 0x8f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x99\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xa3\nmov    %rax,%rdi\ncall   0xab\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x58\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_149",
        "query_text": "The function takes four inputs: a double-precision floating-point array containing the original data, an integer denoting the number of elements in this array, an integer that specifies a position index used for the symmetric extension, and another double-precision floating-point array designated for the output. The function first copies the elements of the original array into a specific segment of the output array starting at the given index. It then mirrors these copied elements around this segment to achieve a symmetric extension of the input data. Finally, the function returns an integer corresponding to the length of the original input array.",
        "code_id": "c_group_1_id_149",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %edx,-0x30(%rbp)\nmov    %rcx,-0x38(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    0x58\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x30(%rbp),%ecx\nmov    -0x18(%rbp),%eax\nadd    %ecx,%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     0x1f\nmov    -0x2c(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    0x10a\nmov    -0x30(%rbp),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x30(%rbp),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nsub    $0x1,%eax\nsub    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x30(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x14(%rbp),%edx\nmov    -0x30(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     0x72\nmov    -0x14(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x16e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x16e\nlea    0x0(%rip),%rax        # 0x143\nmov    %rax,%rdi\ncall   0x14b\nlea    0x0(%rip),%rax        # 0x152\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x15c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x166\nmov    %rax,%rdi\ncall   0x16e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_153",
        "query_text": "The function takes an unsigned 64-bit integer as input and returns an integer representing the number of contiguous zero bits at the least significant end of its binary representation. It is marked as noexcept, ensuring that no exceptions are thrown during execution. Internally, the function leverages a compiler-specific intrinsic to efficiently perform the bit-counting operation. It is important to note that if the input is zero, the behavior is undefined.",
        "code_id": "c_group_1_id_153",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nxor    %eax,%eax\ntzcnt  -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x69\ncmpl   $0xffff,-0x8(%rbp)\njne    0x69\nlea    0x0(%rip),%rax        # 0x3e\nmov    %rax,%rdi\ncall   0x46\nlea    0x0(%rip),%rax        # 0x4d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdi\ncall   0x69\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x16\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_139",
        "query_text": "The function accepts a single integer input representing a value N and returns an integer. It computes the result by first calculating the logarithm of N divided by 2 with a base of 2, then dividing this value by a fixed constant factor (0.4875). The intermediate result is then cast to an integer to obtain the final output. The primary purpose of the function is to perform a scaled logarithmic transformation of the input value.",
        "code_id": "c_group_1_id_139",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmovsd  0x0(%rip),%xmm0        # 0x17\n\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x24(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x2d\n\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   0x40\nmovq   %xmm0,%rax\nmovsd  0x0(%rip),%xmm1        # 0x4d\n\nmovq   %rax,%xmm0\ndivsd  %xmm1,%xmm0\ndivsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\ncvttsd2si %xmm0,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc4\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc4\nlea    0x0(%rip),%rax        # 0x99\nmov    %rax,%rdi\ncall   0xa1\nlea    0x0(%rip),%rax        # 0xa8\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xb2\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xbc\nmov    %rax,%rdi\ncall   0xc4\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x71\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_141",
        "query_text": "The function accepts two integer inputs. It repeatedly performs integer division of the first input by the second input as long as the division results in a zero remainder. If the first input reduces to 1 after these successive divisions, the function returns 1, indicating that the original value is a complete power of the second input. Otherwise, it returns 0, signifying that such repeated division did not yield 1.",
        "code_id": "c_group_1_id_141",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\njmp    0x1a\nmov    -0x4(%rbp),%eax\ncltd   \nidivl  -0x8(%rbp)\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltd   \nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\nje     0x10\ncmpl   $0x1,-0x4(%rbp)\njne    0x34\nmov    $0x1,%eax\njmp    0x39\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8e\nlea    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdi\ncall   0x6b\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x86\nmov    %rax,%rdi\ncall   0x8e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_118",
        "query_text": "The function takes a floating-point value as its input and evaluates its sign. It determines whether the input is positive, negative, or zero by comparing the value to zero. If the input is greater than zero, the function returns a positive floating-point value; if less than zero, it returns a negative floating-point value; and if equal to zero, it returns zero. The primary purpose of the function is to indicate the sign of the input float using these comparisons.",
        "code_id": "c_group_1_id_118",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncomiss %xmm1,%xmm0\nseta   %al\nmovzbl %al,%eax\npxor   %xmm0,%xmm0\ncomiss -0x4(%rbp),%xmm0\nseta   %dl\nmovzbl %dl,%edx\nsub    %edx,%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8c\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdi\ncall   0x69\nlea    0x0(%rip),%rax        # 0x70\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x84\nmov    %rax,%rdi\ncall   0x8c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x39\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_145",
        "query_text": "This function accepts three parameters: an input array of type double, an integer representing the number of elements to process, and an output array of type double. The function iterates through the input array up to the specified count, copying each element into the output array so that its contents exactly mirror the input array for that range. It does not return a value.",
        "code_id": "c_group_1_id_145",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x57\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x23\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb6\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb6\nlea    0x0(%rip),%rax        # 0x8b\nmov    %rax,%rdi\ncall   0x93\nlea    0x0(%rip),%rax        # 0x9a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa4\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xae\nmov    %rax,%rdi\ncall   0xb6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x63\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_122",
        "query_text": "The function takes two pointers to floating-point numbers as input and swaps the values stored at those memory locations. It operates by temporarily storing the value from the first pointer, replacing that slot with the value from the second pointer, and finally assigning the stored value to the second pointer. The function does not return any value; it modifies the floating-point numbers in place.",
        "code_id": "c_group_1_id_122",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x20(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x90\ncmpl   $0xffff,-0x8(%rbp)\njne    0x90\nlea    0x0(%rip),%rax        # 0x65\nmov    %rax,%rdi\ncall   0x6d\nlea    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x88\nmov    %rax,%rdi\ncall   0x90\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_154",
        "query_text": "This function accepts a 64\u2011bit unsigned integer as input and returns an integer value between 0 and 64. It examines the binary representation of the input and counts the number of leading zero bits before the first set bit. If the input is zero (all bits zero), the function returns 64. Otherwise, it uses a sequence of nested conditional checks to efficiently locate the most significant set bit and calculates the count of zeros preceding it. Additionally, the function is declared as a compile\u2011time constant expression, allowing its evaluation during compilation when provided with constant expressions.",
        "code_id": "c_group_1_id_154",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    $0xffffffff,%eax\ncmp    %rax,-0x8(%rbp)\nja     0x29a\ncmpq   $0xffff,-0x8(%rbp)\n\nja     0x15f\ncmpq   $0xff,-0x8(%rbp)\n\nja     0xc9\ncmpq   $0xf,-0x8(%rbp)\nja     0x8c\ncmpq   $0x3,-0x8(%rbp)\nja     0x71\ncmpq   $0x0,-0x8(%rbp)\njne    0x56\nmov    $0x40,%eax\njmp    0x5b6\ncmpq   $0x1,-0x8(%rbp)\nja     0x67\nmov    $0x3f,%eax\njmp    0x5b6\nmov    $0x3e,%eax\njmp    0x5b6\ncmpq   $0x7,-0x8(%rbp)\nja     0x82\nmov    $0x3d,%eax\njmp    0x5b6\nmov    $0x3c,%eax\njmp    0x5b6\ncmpq   $0x3f,-0x8(%rbp)\nja     0xae\ncmpq   $0x1f,-0x8(%rbp)\nja     0xa4\nmov    $0x3b,%eax\njmp    0x5b6\nmov    $0x3a,%eax\njmp    0x5b6\ncmpq   $0x7f,-0x8(%rbp)\nja     0xbf\nmov    $0x39,%eax\njmp    0x5b6\nmov    $0x38,%eax\njmp    0x5b6\ncmpq   $0xfff,-0x8(%rbp)\n\nja     0x119\ncmpq   $0x3ff,-0x8(%rbp)\n\nja     0xfb\ncmpq   $0x1ff,-0x8(%rbp)\n\nja     0xf1\nmov    $0x37,%eax\njmp    0x5b6\nmov    $0x36,%eax\njmp    0x5b6\ncmpq   $0x7ff,-0x8(%rbp)\n\nja     0x10f\nmov    $0x35,%eax\njmp    0x5b6\nmov    $0x34,%eax\njmp    0x5b6\ncmpq   $0x3fff,-0x8(%rbp)\n\nja     0x141\ncmpq   $0x1fff,-0x8(%rbp)\n\nja     0x137\nmov    $0x33,%eax\njmp    0x5b6\nmov    $0x32,%eax\njmp    0x5b6\ncmpq   $0x7fff,-0x8(%rbp)\n\nja     0x155\nmov    $0x31,%eax\njmp    0x5b6\nmov    $0x30,%eax\njmp    0x5b6\ncmpq   $0xffffff,-0x8(%rbp)\n\nja     0x203\ncmpq   $0xfffff,-0x8(%rbp)\n\nja     0x1bd\ncmpq   $0x3ffff,-0x8(%rbp)\n\nja     0x19f\ncmpq   $0x1ffff,-0x8(%rbp)\n\nja     0x195\nmov    $0x2f,%eax\njmp    0x5b6\nmov    $0x2e,%eax\njmp    0x5b6\ncmpq   $0x7ffff,-0x8(%rbp)\n\nja     0x1b3\nmov    $0x2d,%eax\njmp    0x5b6\nmov    $0x2c,%eax\njmp    0x5b6\ncmpq   $0x3fffff,-0x8(%rbp)\n\nja     0x1e5\ncmpq   $0x1fffff,-0x8(%rbp)\n\nja     0x1db\nmov    $0x2b,%eax\njmp    0x5b6\nmov    $0x2a,%eax\njmp    0x5b6\ncmpq   $0x7fffff,-0x8(%rbp)\n\nja     0x1f9\nmov    $0x29,%eax\njmp    0x5b6\nmov    $0x28,%eax\njmp    0x5b6\ncmpq   $0xfffffff,-0x8(%rbp)\n\nja     0x253\ncmpq   $0x3ffffff,-0x8(%rbp)\n\nja     0x235\ncmpq   $0x1ffffff,-0x8(%rbp)\n\nja     0x22b\nmov    $0x27,%eax\njmp    0x5b6\nmov    $0x26,%eax\njmp    0x5b6\ncmpq   $0x7ffffff,-0x8(%rbp)\n\nja     0x249\nmov    $0x25,%eax\njmp    0x5b6\nmov    $0x24,%eax\njmp    0x5b6\ncmpq   $0x3fffffff,-0x8(%rbp)\n\nja     0x27b\ncmpq   $0x1fffffff,-0x8(%rbp)\n\nja     0x271\nmov    $0x23,%eax\njmp    0x5b6\nmov    $0x22,%eax\njmp    0x5b6\nmov    $0x80000000,%eax\ncmp    %rax,-0x8(%rbp)\njae    0x290\nmov    $0x21,%eax\njmp    0x5b6\nmov    $0x20,%eax\njmp    0x5b6\nmovabs $0xffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x442\nmovabs $0xffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x382\nmovabs $0xfffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x32a\nmovabs $0x3ffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x306\nmovabs $0x1ffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x2fc\nmov    $0x1f,%eax\njmp    0x5b6\nmov    $0x1e,%eax\njmp    0x5b6\nmovabs $0x7ffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x320\nmov    $0x1d,%eax\njmp    0x5b6\nmov    $0x1c,%eax\njmp    0x5b6\nmovabs $0x3fffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x35e\nmovabs $0x1fffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x354\nmov    $0x1b,%eax\njmp    0x5b6\nmov    $0x1a,%eax\njmp    0x5b6\nmovabs $0x7fffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x378\nmov    $0x19,%eax\njmp    0x5b6\nmov    $0x18,%eax\njmp    0x5b6\nmovabs $0xfffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x3ea\nmovabs $0x3ffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x3c6\nmovabs $0x1ffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x3bc\nmov    $0x17,%eax\njmp    0x5b6\nmov    $0x16,%eax\njmp    0x5b6\nmovabs $0x7ffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x3e0\nmov    $0x15,%eax\njmp    0x5b6\nmov    $0x14,%eax\njmp    0x5b6\nmovabs $0x3fffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x41e\nmovabs $0x1fffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x414\nmov    $0x13,%eax\njmp    0x5b6\nmov    $0x12,%eax\njmp    0x5b6\nmovabs $0x7fffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x438\nmov    $0x11,%eax\njmp    0x5b6\nmov    $0x10,%eax\njmp    0x5b6\nmovabs $0xffffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x516\nmovabs $0xfffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x4be\nmovabs $0x3ffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x49a\nmovabs $0x1ffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x490\nmov    $0xf,%eax\njmp    0x5b6\nmov    $0xe,%eax\njmp    0x5b6\nmovabs $0x7ffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x4b4\nmov    $0xd,%eax\njmp    0x5b6\nmov    $0xc,%eax\njmp    0x5b6\nmovabs $0x3fffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x4f2\nmovabs $0x1fffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x4e8\nmov    $0xb,%eax\njmp    0x5b6\nmov    $0xa,%eax\njmp    0x5b6\nmovabs $0x7fffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x50c\nmov    $0x9,%eax\njmp    0x5b6\nmov    $0x8,%eax\njmp    0x5b6\nmovabs $0xfffffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x572\nmovabs $0x3ffffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x554\nmovabs $0x1ffffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x54d\nmov    $0x7,%eax\njmp    0x5b6\nmov    $0x6,%eax\njmp    0x5b6\nmovabs $0x7ffffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x56b\nmov    $0x5,%eax\njmp    0x5b6\nmov    $0x4,%eax\njmp    0x5b6\nmovabs $0x3fffffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x5a0\nmovabs $0x1fffffffffffffff,%rax\n\ncmp    %rax,-0x8(%rbp)\nja     0x599\nmov    $0x3,%eax\njmp    0x5b6\nmov    $0x2,%eax\njmp    0x5b6\nmov    -0x8(%rbp),%rax\ntest   %rax,%rax\njs     0x5b0\nmov    $0x1,%eax\njmp    0x5b5\nmov    $0x0,%eax\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x60b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x60b\nlea    0x0(%rip),%rax        # 0x5e0\nmov    %rax,%rdi\ncall   0x5e8\nlea    0x0(%rip),%rax        # 0x5ef\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f9\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x603\nmov    %rax,%rdi\ncall   0x60b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x5b8\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_86",
        "query_text": "The function takes a single character as input and returns an integer representing the number of bytes needed to encode that character using UTF-8 encoding. It evaluates the high-order bits of the unsigned version of the input character to determine the appropriate byte sequence. Specifically, it returns 1 for characters fitting the one-byte pattern, 2 for those matching the two-byte sequence, 3 for the three-byte pattern, and 4 for the four-byte sequence. If the character does not conform to any valid UTF-8 leading byte pattern, the function returns -1 to signal an invalid or unsupported character.",
        "code_id": "c_group_1_id_86",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x14(%rbp)\nmovzbl -0x14(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nsar    $0x4,%eax\ncmp    $0xf,%eax\nje     0x5b\ncmp    $0xf,%eax\njg     0x62\ncmp    $0xe,%eax\nje     0x54\ncmp    $0xe,%eax\njg     0x62\ncmp    $0x7,%eax\njg     0x3c\ntest   %eax,%eax\njns    0x46\njmp    0x62\nsub    $0xc,%eax\ncmp    $0x1,%eax\nja     0x62\njmp    0x4d\nmov    $0x1,%eax\njmp    0x67\nmov    $0x2,%eax\njmp    0x67\nmov    $0x3,%eax\njmp    0x67\nmov    $0x4,%eax\njmp    0x67\nmov    $0xffffffff,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xbc\ncmpl   $0xffff,-0x8(%rbp)\njne    0xbc\nlea    0x0(%rip),%rax        # 0x91\nmov    %rax,%rdi\ncall   0x99\nlea    0x0(%rip),%rax        # 0xa0\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xaa\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb4\nmov    %rax,%rdi\ncall   0xbc\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x69\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_157",
        "query_text": "This function takes a single character input and determines whether it represents a numerical digit. The input, of type char, is examined to see if it lies between the characters '0' and '9' inclusive. If the character is within this range, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_157",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x2f,-0x4(%rbp)\njle    0x20\ncmpb   $0x39,-0x4(%rbp)\njg     0x20\nmov    $0x1,%eax\njmp    0x25\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7a\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdi\ncall   0x57\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x27\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_125",
        "query_text": "The function is a static void procedure that takes no inputs and does not return any value. Its purpose is to display a comprehensive help message on the standard output, guiding the user on how to use a string sorting program. The message outlines various command-line options such as validating output, controlling performance monitoring through file descriptors, enabling specific profiling tools, listing available algorithms both in descriptive and script-friendly formats, and directing the sorted output to a specified file. It also illustrates the use of suffix sorting and supports alternative output formats like XML or human-readable statistics. Additionally, the help message provides several usage examples to assist the user in correctly invoking different functionalities of the program.",
        "code_id": "c_group_1_id_125",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\nmov    %rax,%rdi\ncall   0x17\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6d\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdi\ncall   0x4a\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x65\nmov    %rax,%rdi\ncall   0x6d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_151",
        "query_text": "The function takes an integer as its input and produces an integer as its output. It computes 2 raised to the power specified by the input by initializing a base value to 1 and then multiplying it by 2 iteratively for a number of times equal to the input value. The final computed value is eventually returned as the output.",
        "code_id": "c_group_1_id_151",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x22\nshll   -0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     0x1b\nmov    -0x8(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x82\ncmpl   $0xffff,-0x8(%rbp)\njne    0x82\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rdi\ncall   0x5f\nlea    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x70\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7a\nmov    %rax,%rdi\ncall   0x82\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_159",
        "query_text": "The function accepts a 64-bit unsigned integer as input and returns a 64-bit unsigned integer as output. It processes the input through multiple stages of transformation. Initially, the function applies a bitwise XOR combined with a right-shift operation. It then multiplies the intermediate value by a predefined constant. This sequence is repeated: after a second XOR shift, another multiplication with a different constant is performed, followed by a final XOR shift. The resulting value from these operations is returned as the function's output.",
        "code_id": "c_group_1_id_159",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshr    $0x21,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovabs $0xff51afd7ed558ccd,%rdx\n\nimul   %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshr    $0x21,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovabs $0xc4ceb9fe1a85ec53,%rdx\n\nimul   %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshr    $0x21,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb5\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb5\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rdi\ncall   0x92\nlea    0x0(%rip),%rax        # 0x99\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa3\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xad\nmov    %rax,%rdi\ncall   0xb5\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x62\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_63",
        "query_text": "The function accepts two inputs: an array of unsigned character pointers and a size parameter of type size_t. It processes the array by scanning through consecutive pairs of pointers and evaluates three possible issues. First, it counts how many consecutive pairs are identical. Second, it checks for pairs where at least one pointer is NULL. Third, for pairs where both pointers are valid, it compares the strings they reference and counts how many pairs are not in ascending order. If any of these conditions are met, the function outputs warning messages to the standard error stream that detail the number of identical pointers, invalid pointers, and incorrectly ordered pairs. Finally, the function returns an integer value\u2014returning 1 if any of the issues are detected, otherwise returning 0.",
        "code_id": "c_group_1_id_63",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovq   $0x0,-0x20(%rbp)\n\nmovq   $0x0,-0x18(%rbp)\n\nmovq   $0x0,-0x10(%rbp)\n\nmovq   $0x0,-0x8(%rbp)\n\njmp    0xfd\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rcx\n\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\njne    0x73\naddq   $0x1,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\ntest   %rax,%rax\nje     0xad\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    0xb4\naddq   $0x1,-0x10(%rbp)\njmp    0xf8\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rcx\n\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xef\ntest   %eax,%eax\njle    0xf8\naddq   $0x1,-0x20(%rbp)\naddq   $0x1,-0x8(%rbp)\nmov    -0x30(%rbp),%rax\nsub    $0x1,%rax\ncmp    %rax,-0x8(%rbp)\njb     0x39\ncmpq   $0x0,-0x18(%rbp)\nje     0x138\nmov    0x0(%rip),%rax        # 0x11d\nmov    -0x18(%rbp),%rdx\nlea    0x0(%rip),%rcx        # 0x128\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x138\ncmpq   $0x0,-0x20(%rbp)\nje     0x161\nmov    0x0(%rip),%rax        # 0x146\nmov    -0x20(%rbp),%rdx\nlea    0x0(%rip),%rcx        # 0x151\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x161\ncmpq   $0x0,-0x10(%rbp)\nje     0x18a\nmov    0x0(%rip),%rax        # 0x16f\nmov    -0x10(%rbp),%rdx\nlea    0x0(%rip),%rcx        # 0x17a\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x18a\ncmpq   $0x0,-0x18(%rbp)\njne    0x19f\ncmpq   $0x0,-0x20(%rbp)\njne    0x19f\ncmpq   $0x0,-0x10(%rbp)\nje     0x1a6\nmov    $0x1,%eax\njmp    0x1ab\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x200\ncmpl   $0xffff,-0x8(%rbp)\njne    0x200\nlea    0x0(%rip),%rax        # 0x1d5\nmov    %rax,%rdi\ncall   0x1dd\nlea    0x0(%rip),%rax        # 0x1e4\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x1ee\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x1f8\nmov    %rax,%rdi\ncall   0x200\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1ad\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_48",
        "query_text": "The function takes no input arguments. It evaluates the system's byte order to determine if it is big-endian. Depending on the platform, the function uses a combination of predefined macros and a runtime check. On one platform, it directly returns false, assuming little-endian ordering; on others, it first checks for compile-time macros that indicate big-endian order, and if they are not available, it performs a runtime check by examining the byte representation of a numeric value. Ultimately, the function returns a boolean value: true if the system is big-endian, and false otherwise.",
        "code_id": "c_group_1_id_48",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_126",
        "query_text": "The function accepts three parameters: an integer representing the count of command-line arguments, an array of character pointers holding the arguments, and a pointer to a file stream where output should be directed. It first checks if the file stream pointer is valid; if it is not, the function terminates without performing any output. If the stream is valid, the function writes a fixed prefix (\"Command line:\") to the stream, then iterates over the array of arguments\u2014writing each argument preceded by a space\u2014and finally outputs a newline character. The function does not return any value.",
        "code_id": "c_group_1_id_126",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\ncmpq   $0x0,-0x28(%rbp)\nje     0x98\nmov    -0x28(%rbp),%rax\nmov    %rax,%rcx\nmov    $0xd,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x36\nmov    %rax,%rdi\ncall   0x3e\nmovl   $0x0,-0x4(%rbp)\njmp    0x7d\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x28(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x69\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x79\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     0x47\nmov    -0x28(%rbp),%rax\nmov    %rax,%rsi\nmov    $0xa,%edi\ncall   0x96\njmp    0x99\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xee\ncmpl   $0xffff,-0x8(%rbp)\njne    0xee\nlea    0x0(%rip),%rax        # 0xc3\nmov    %rax,%rdi\ncall   0xcb\nlea    0x0(%rip),%rax        # 0xd2\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xdc\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xe6\nmov    %rax,%rdi\ncall   0xee\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x9b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_140",
        "query_text": "The function takes three inputs: a pointer to an array of doubles, an integer indicating the total number of elements in the array, and another integer used as a control parameter. It iterates over the array starting at the index computed by doubling the control parameter, and for every element from that starting point, it multiplies the element with the one located a fixed offset earlier in the array (offset equal to twice the control parameter). These products are added together to form a cumulative sum, which is returned as a double-precision value representing the overall computed result.",
        "code_id": "c_group_1_id_140",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,-0xc(%rbp)\njmp    0x73\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0xc(%rbp),%eax\nsub    %edx,%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x25\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xdf\ncmpl   $0xffff,-0x8(%rbp)\njne    0xdf\nlea    0x0(%rip),%rax        # 0xb4\nmov    %rax,%rdi\ncall   0xbc\nlea    0x0(%rip),%rax        # 0xc3\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xcd\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xd7\nmov    %rax,%rdi\ncall   0xdf\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x8c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_124",
        "query_text": "The function accepts two inputs: a pointer to an unsigned character array and a size value representing the length of the memory region. It then releases the allocated memory block by invoking the system's memory unmapping operation. This effectively frees up the memory for future use. The function does not produce any output.",
        "code_id": "c_group_1_id_124",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7d\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdi\ncall   0x5a\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x75\nmov    %rax,%rdi\ncall   0x7d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_49",
        "query_text": "The function receives an unsigned 32-bit integer (of type uint32_t) and returns an integer representing the number of digits in the input. It calculates this digit count by employing a precomputed table alongside bitwise operations to avoid explicitly iterating through each digit. The design emphasizes performance by leveraging built-in compiler optimizations.",
        "code_id": "c_group_1_id_49",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x130,%rsp\nmov    %edi,-0x124(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x100000000,%rax\n\nmov    %rax,-0x110(%rbp)\nmov    %rax,-0x108(%rbp)\nmov    %rax,-0x100(%rbp)\nmovabs $0x1fffffff6,%rax\n\nmov    %rax,-0xf8(%rbp)\nmov    %rax,-0xf0(%rbp)\nmov    %rax,-0xe8(%rbp)\nmovabs $0x2ffffff9c,%rax\n\nmov    %rax,-0xe0(%rbp)\nmov    %rax,-0xd8(%rbp)\nmov    %rax,-0xd0(%rbp)\nmovabs $0x3fffffc18,%rax\n\nmov    %rax,-0xc8(%rbp)\nmov    %rax,-0xc0(%rbp)\nmov    %rax,-0xb8(%rbp)\nmovabs $0x4ffffd8f0,%rax\n\nmov    %rax,-0xb0(%rbp)\nmov    %rax,-0xa8(%rbp)\nmov    %rax,-0xa0(%rbp)\nmovabs $0x5fffe7960,%rax\n\nmov    %rax,-0x98(%rbp)\nmov    %rax,-0x90(%rbp)\nmov    %rax,-0x88(%rbp)\nmovabs $0x6fff0bdc0,%rax\n\nmov    %rax,-0x80(%rbp)\nmov    %rax,-0x78(%rbp)\nmov    %rax,-0x70(%rbp)\nmovabs $0x7ff676980,%rax\n\nmov    %rax,-0x68(%rbp)\nmov    %rax,-0x60(%rbp)\nmov    %rax,-0x58(%rbp)\nmovabs $0x8fa0a1f00,%rax\n\nmov    %rax,-0x50(%rbp)\nmov    %rax,-0x48(%rbp)\nmov    %rax,-0x40(%rbp)\nmovabs $0x9c4653600,%rax\n\nmov    %rax,-0x38(%rbp)\nmov    %rax,-0x30(%rbp)\nmov    %rax,-0x28(%rbp)\nmov    %rax,-0x20(%rbp)\nmov    %rax,-0x18(%rbp)\nmov    -0x124(%rbp),%eax\nor     $0x1,%eax\nbsr    %eax,%eax\nxor    $0x1f,%eax\nxor    $0x1f,%eax\ncltq   \nmov    -0x110(%rbp,%rax,8),%rax\n\nmov    %rax,-0x118(%rbp)\nmov    -0x124(%rbp),%edx\nmov    -0x118(%rbp),%rax\nadd    %rdx,%rax\nshr    $0x20,%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x189\ncall   0x189\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x1de\ncmpl   $0xffff,-0x8(%rbp)\njne    0x1de\nlea    0x0(%rip),%rax        # 0x1b3\nmov    %rax,%rdi\ncall   0x1bb\nlea    0x0(%rip),%rax        # 0x1c2\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x1cc\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x1d6\nmov    %rax,%rdi\ncall   0x1de\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x18b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_158",
        "query_text": "The function accepts two inputs: a constant character pointer representing the input string, and a pointer to a double where the parsed floating-point value will be stored. It converts the numeric portion of the input string to a double-precision floating-point number, employing platform-specific variants that utilize appropriate locale settings for accurate parsing. If the conversion succeeds and the resulting value is finite (i.e., not infinity or NaN), the function returns a pointer to the character immediately following the parsed number in the input string; otherwise, it returns a null pointer.",
        "code_id": "c_group_1_id_158",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x0,%edx\nlea    0x0(%rip),%rax        # 0x2f\nmov    %rax,%rsi\nmov    $0x1fbf,%edi\ncall   0x3c\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nlea    -0x18(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x57\nmovq   %xmm0,%rax\nmov    -0x30(%rbp),%rdx\nmov    %rax,(%rdx)\nmov    -0x30(%rbp),%rax\nmov    (%rax),%rax\nmovq   %rax,%xmm0\ncall   0x74\nxor    $0x1,%eax\ntest   %al,%al\nje     0x82\nmov    $0x0,%eax\njmp    0x86\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x9a\ncall   0x9a\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xef\ncmpl   $0xffff,-0x8(%rbp)\njne    0xef\nlea    0x0(%rip),%rax        # 0xc4\nmov    %rax,%rdi\ncall   0xcc\nlea    0x0(%rip),%rax        # 0xd3\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xdd\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xe7\nmov    %rax,%rdi\ncall   0xef\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x9c\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   0x0(%rip),%xmm1        # 0x1a\n\nandpd  %xmm0,%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x26\n\nucomisd %xmm1,%xmm0\nsetb   %al\nxor    $0x1,%eax\nmovzbl %al,%eax\ntest   %eax,%eax\nsetne  %al\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_150",
        "query_text": "This function reconstructs signal coefficients from a set of wavelet coefficients using either periodic or symmetric signal extension methods. It accepts as input an array of wavelet coefficients along with their corresponding lengths for various levels of decomposition, a string indicating whether the coefficients represent approximations or details, and another string specifying the extension method. Additional inputs include the level of decomposition, parameters related to the filter such as the low-pass and high-pass coefficients and the filter length, and the overall signal length. The function iteratively processes the coefficients through successive filtering operations, performing computations that adjust the coefficients based on the selected extension method. Memory is dynamically allocated for intermediate buffers during these computations, and proper cleanup is ensured before the function outputs the final array of reconstructed coefficients.",
        "code_id": "c_group_1_id_150",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    %rcx,-0x70(%rbp)\nmov    %r8d,-0x74(%rbp)\nmov    %r9d,-0x78(%rbp)\nmov    0x28(%rbp),%eax\nadd    $0x1,%eax\ncltq   \nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,-0x10(%rbp)\nmov    0x20(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x24(%rbp)\nmovl   $0xfffffffe,-0x30(%rbp)\nmovl   $0xffffffff,-0x2c(%rbp)\nmov    -0x70(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x64\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x6f\ntest   %eax,%eax\njne    0x5de\nmov    -0x68(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x82\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x8d\ntest   %eax,%eax\njne    0x9c\nmov    -0x60(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x38(%rbp)\njmp    0xbc\nmov    -0x78(%rbp),%eax\nsub    -0x74(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x38(%rbp)\nmov    -0x78(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,%eax\nmov    %eax,-0x20(%rbp)\nmov    0x20(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x20(%rbp),%eax\nadd    %edx,%eax\nsub    $0x1,%eax\ncltq   \nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   0xf3\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x44(%rbp)\njmp    0x134\nmov    -0x44(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x58(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x44(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x10(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x38(%rbp),%eax\njl     0x100\nmov    -0x74(%rbp),%eax\nmov    %eax,-0x40(%rbp)\njmp    0x5c3\nmov    -0x68(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x152\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x15d\ntest   %eax,%eax\njne    0x173\nmov    -0x40(%rbp),%eax\ncmp    -0x74(%rbp),%eax\njne    0x173\nmov    0x18(%rbp),%rax\nmov    %rax,-0x18(%rbp)\njmp    0x17b\nmov    0x10(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0xfffffffe,-0x30(%rbp)\nmovl   $0xffffffff,-0x2c(%rbp)\nmovl   $0x0,-0x44(%rbp)\njmp    0x50b\naddl   $0x2,-0x30(%rbp)\naddl   $0x2,-0x2c(%rbp)\nmov    -0x30(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x2c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x0,-0x34(%rbp)\njmp    0x4fb\nmov    -0x34(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\ntest   %eax,%eax\njs     0x2e5\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncmp    %eax,-0x38(%rbp)\njle    0x2e5\nmov    -0x30(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x30(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x2c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x2c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x4f7\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncmp    %eax,-0x38(%rbp)\njg     0x3f2\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\nmov    -0x38(%rbp),%ecx\nmov    0x20(%rbp),%edx\nadd    %ecx,%edx\nsub    $0x1,%edx\ncmp    %edx,%eax\njge    0x3f2\nmov    -0x30(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\nsub    -0x38(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x30(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x2c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\nsub    -0x38(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x2c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x4f7\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\ntest   %eax,%eax\njns    0x4f7\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\nmov    -0x24(%rbp),%edx\nneg    %edx\ncmp    %edx,%eax\njle    0x4f7\nmov    -0x30(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x38(%rbp),%edx\nmov    -0x44(%rbp),%eax\nadd    %edx,%eax\nsub    -0x34(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x30(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x2c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x38(%rbp),%edx\nmov    -0x44(%rbp),%eax\nadd    %edx,%eax\nsub    -0x34(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x2c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     0x1e1\naddl   $0x1,-0x44(%rbp)\nmov    -0x38(%rbp),%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nsub    $0x1,%eax\ncmp    %eax,-0x44(%rbp)\njl     0x195\nmov    0x20(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nsub    $0x1,%eax\nmov    %eax,-0x3c(%rbp)\njmp    0x57d\nmov    -0x3c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    0x20(%rbp),%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nneg    %eax\nmov    %eax,%ecx\nmov    -0x3c(%rbp),%eax\nadd    %ecx,%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rcx\n\nmov    -0x10(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x3c(%rbp)\nmov    -0x38(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    0x20(%rbp),%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nadd    %edx,%eax\nsub    $0x1,%eax\ncmp    %eax,-0x3c(%rbp)\njl     0x533\ncmpl   $0x1,-0x40(%rbp)\nje     0x5bf\nmov    -0x78(%rbp),%eax\nsub    -0x40(%rbp),%eax\ncltq   \nadd    $0x2,%rax\nlea    0x0(,%rax,4),%rdx\n\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x38(%rbp)\nsubl   $0x1,-0x40(%rbp)\ncmpl   $0x0,-0x40(%rbp)\njg     0x147\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x5d9\njmp    0x947\nmov    -0x70(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x5e9\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x5f4\ntest   %eax,%eax\njne    0x929\nmov    -0x68(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x607\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x612\ntest   %eax,%eax\njne    0x621\nmov    -0x60(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x38(%rbp)\njmp    0x641\nmov    -0x78(%rbp),%eax\nsub    -0x74(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x38(%rbp)\nmov    -0x78(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,%eax\nsub    $0x1,%eax\nmov    %eax,-0x20(%rbp)\nmov    0x20(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x20(%rbp),%eax\nadd    %edx,%eax\nsub    $0x1,%eax\ncltq   \nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   0x67b\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x44(%rbp)\njmp    0x6bc\nmov    -0x44(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x58(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x44(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x10(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x38(%rbp),%eax\njl     0x688\nmov    -0x74(%rbp),%eax\nmov    %eax,-0x40(%rbp)\njmp    0x911\nmov    -0x68(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x6da\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x6e5\ntest   %eax,%eax\njne    0x6fb\nmov    -0x40(%rbp),%eax\ncmp    -0x74(%rbp),%eax\njne    0x6fb\nmov    0x18(%rbp),%rax\nmov    %rax,-0x18(%rbp)\njmp    0x703\nmov    0x10(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0xfffffffe,-0x30(%rbp)\nmovl   $0xffffffff,-0x2c(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    0x88b\nmov    -0x28(%rbp),%eax\nmov    %eax,-0x44(%rbp)\naddl   $0x2,-0x30(%rbp)\naddl   $0x2,-0x2c(%rbp)\nmov    -0x30(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x2c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x0,-0x34(%rbp)\njmp    0x872\nmov    -0x34(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\ntest   %eax,%eax\njs     0x86e\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncmp    %eax,-0x38(%rbp)\njle    0x86e\nmov    -0x30(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x30(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x2c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\ncltq   \nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x44(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x2c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x34(%rbp)\nmov    0x20(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x34(%rbp)\njl     0x76f\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x38(%rbp),%eax\njl     0x71d\nmov    0x20(%rbp),%eax\nsub    $0x2,%eax\nmov    %eax,-0x3c(%rbp)\njmp    0x8dd\nmov    -0x3c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x3c(%rbp),%eax\nsub    0x20(%rbp),%eax\ncltq   \nadd    $0x2,%rax\nlea    0x0(,%rax,8),%rcx\n\nmov    -0x10(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x3c(%rbp)\nmov    -0x38(%rbp),%eax\nadd    %eax,%eax\ncmp    %eax,-0x3c(%rbp)\njl     0x8a2\ncmpl   $0x1,-0x40(%rbp)\nje     0x90d\nmov    -0x78(%rbp),%eax\nsub    -0x40(%rbp),%eax\ncltq   \nadd    $0x2,%rax\nlea    0x0(,%rax,4),%rdx\n\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x38(%rbp)\nsubl   $0x1,-0x40(%rbp)\ncmpl   $0x0,-0x40(%rbp)\njg     0x6cf\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x927\njmp    0x947\nlea    0x0(%rip),%rax        # 0x930\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x93d\nmov    $0xffffffff,%edi\ncall   0x947\nmovl   $0x0,-0x44(%rbp)\njmp    0x984\nmov    -0x44(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x44(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    0x30(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    0x28(%rbp),%eax\njl     0x950\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x998\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9ee\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9ee\nlea    0x0(%rip),%rax        # 0x9c3\nmov    %rax,%rdi\ncall   0x9cb\nlea    0x0(%rip),%rax        # 0x9d2\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x9dc\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9e6\nmov    %rax,%rdi\ncall   0x9ee\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x99b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_96",
        "query_text": "The function accepts a pointer to a UTF-8 encoded character array as its input. It decodes the first UTF-8 sequence found in the string and outputs two values: a 32-bit unsigned integer representing the resulting Unicode code point and an integer error code that indicates whether the sequence was valid. The function returns a pointer to the character immediately following the decoded sequence, enabling sequential processing of subsequent UTF-8 characters. The input is a pointer to a UTF-8 encoded string, while the outputs are the decoded Unicode code point and an error status indicator.",
        "code_id": "c_group_1_id_96",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0x98(%rbp)\nmov    %rsi,-0xa0(%rbp)\nmov    %rdx,-0xa8(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x80(%rbp)\nmovl   $0x7f,-0x7c(%rbp)\nmovl   $0x1f,-0x78(%rbp)\nmovl   $0xf,-0x74(%rbp)\nmovl   $0x7,-0x70(%rbp)\nmovl   $0x400000,-0x60(%rbp)\nmovl   $0x0,-0x5c(%rbp)\nmovl   $0x80,-0x58(%rbp)\nmovl   $0x800,-0x54(%rbp)\nmovl   $0x10000,-0x50(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmovl   $0x12,-0x3c(%rbp)\nmovl   $0xc,-0x38(%rbp)\nmovl   $0x6,-0x34(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x6,-0x1c(%rbp)\nmovl   $0x4,-0x18(%rbp)\nmovl   $0x2,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmov    -0x98(%rbp),%rax\nmovzbl (%rax),%eax\nshr    $0x3,%al\nmovzbl %al,%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0xd8\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nmov    %eax,-0x8c(%rbp)\nmov    -0x8c(%rbp),%eax\nmovslq %eax,%rdx\ncmpl   $0x0,-0x8c(%rbp)\nsete   %al\nmovzbl %al,%eax\nadd    %rax,%rdx\nmov    -0x98(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x88(%rbp)\nmov    -0x98(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%edx\nmov    -0x8c(%rbp),%eax\ncltq   \nmov    -0x80(%rbp,%rax,4),%eax\nand    %edx,%eax\nshl    $0x12,%eax\nmov    %eax,%edx\nmov    -0xa0(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0xc,%eax\nand    $0x3f000,%eax\nor     %eax,%edx\nmov    -0xa0(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0x6,%eax\nand    $0xfc0,%eax\nor     %eax,%edx\nmov    -0xa0(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x3,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nand    $0x3f,%eax\nor     %eax,%edx\nmov    -0xa0(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8c(%rbp),%eax\ncltq   \nmov    -0x40(%rbp,%rax,4),%eax\nmov    %eax,%ecx\nshr    %cl,%edx\nmov    -0xa0(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8c(%rbp),%eax\ncltq   \nmov    -0x60(%rbp,%rax,4),%eax\ncmp    %eax,%edx\njae    0x1fc\nmov    $0x40,%edx\njmp    0x201\nmov    $0x0,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%eax\nshr    $0xb,%eax\ncmp    $0x1b,%eax\njne    0x22b\nmov    $0x80,%eax\njmp    0x230\nmov    $0x0,%eax\nor     %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%eax\ncmp    $0x10ffff,%eax\njbe    0x25b\nmov    $0x100,%eax\njmp    0x260\nmov    $0x0,%eax\nor     %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nshr    $0x2,%al\nmovzbl %al,%eax\nand    $0x30,%eax\nor     %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%eax\nshr    $0x4,%al\nmovzbl %al,%eax\nand    $0xc,%eax\nor     %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x3,%rax\nmovzbl (%rax),%eax\nshr    $0x6,%al\nmovzbl %al,%eax\nor     %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%eax\nxor    $0x2a,%eax\nmov    %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8c(%rbp),%eax\ncltq   \nmov    -0x20(%rbp,%rax,4),%eax\nmov    %eax,%ecx\nsar    %cl,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x88(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x33d\ncall   0x33d\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x392\ncmpl   $0xffff,-0x8(%rbp)\njne    0x392\nlea    0x0(%rip),%rax        # 0x367\nmov    %rax,%rdi\ncall   0x36f\nlea    0x0(%rip),%rax        # 0x376\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x380\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x38a\nmov    %rax,%rdi\ncall   0x392\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x33f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_51",
        "query_text": "The function takes an integer as input and returns a 32-bit unsigned integer. It uses the input value as an index to retrieve a corresponding element from a fixed array of eight predefined 32-bit unsigned integer values that are encoded within Unicode string literals. The function essentially acts as a lookup table, returning the element associated with the provided index.",
        "code_id": "c_group_1_id_51",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nlea    0x0(%rip),%rax        # 0x1f\nmov    (%rdx,%rax,1),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x77\ncmpl   $0xffff,-0x8(%rbp)\njne    0x77\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rdi\ncall   0x54\nlea    0x0(%rip),%rax        # 0x5b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x65\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rdi\ncall   0x77\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x24\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_87",
        "query_text": "The function accepts three parameters: a pointer to a character array representing a string, an unsigned integer indicating the string's size, and a boolean flag that determines whether non-ASCII characters should trigger a validation failure. It iterates over each character in the string checking two conditions: if the boolean flag is set, it verifies that no character has a value equal to or exceeding 0x80 (thus ensuring all characters are ASCII), and it confirms that the string does not contain any newline characters. The function returns a boolean value\u2014true if all characters meet the specified criteria, or false otherwise.",
        "code_id": "c_group_1_id_87",
        "code_text": "push   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %al,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     0x1e\ncmpb   $0x0,-0xc(%rbp)\njs     0x24\ncmpb   $0xa,-0xc(%rbp)\njne    0x2b\nmov    $0x1,%eax\njmp    0x30\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,%eax\nmov    %al,-0x14(%rbp)\nmovzbl -0x14(%rbp),%edx\nmov    -0x8(%rbp),%rcx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x6b\nleave  \nret    \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %dl,-0x11(%rbp)\nmovzbl -0x11(%rbp),%edx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9e\ncmp    %rax,-0x10(%rbp)\nsete   %al\nleave  \nret    \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %dl,-0x11(%rbp)\nmovzbl -0x11(%rbp),%eax\nmov    %eax,%edi\ncall   0xd3\nmov    %eax,%edx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x126\nleave  \nret    \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %dil,-0x11(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x11(%rbp),%rax\nmov    %rax,%rdi\ncall   0x15e\nmov    %rax,%rdx\nlea    -0x9(%rbp),%rax\nmovzbl (%rdx),%esi\nmov    %rax,%rdi\ncall   0x16c\nmovzbl -0x9(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x124\ncall   0x124\nleave  \nret    \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %dl,-0x11(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x145\nmov    -0x8(%rbp),%rax\nmovzbl -0x11(%rbp),%edx\nmov    -0x10(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x194\nleave  \nret    \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %sil,-0x9(%rbp)\nlea    -0x9(%rbp),%rax\nmov    %rax,%rdi\ncall   0x15e\nmov    -0x8(%rbp),%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %dl,-0x21(%rbp)\nmov    -0x20(%rbp),%rax\nsub    -0x18(%rbp),%rax\nsar    $0x2,%rax\nmov    %rax,-0x8(%rbp)\njmp    0x259\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2f2\ntest   %al,%al\nje     0x1e0\nmov    -0x18(%rbp),%rax\njmp    0x2f0\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2f2\ntest   %al,%al\nje     0x205\nmov    -0x18(%rbp),%rax\njmp    0x2f0\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2f2\ntest   %al,%al\nje     0x22a\nmov    -0x18(%rbp),%rax\njmp    0x2f0\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2f2\ntest   %al,%al\nje     0x24f\nmov    -0x18(%rbp),%rax\njmp    0x2f0\naddq   $0x1,-0x18(%rbp)\nsubq   $0x1,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njg     0x1c0\nmov    -0x20(%rbp),%rax\nsub    -0x18(%rbp),%rax\ncmp    $0x3,%rax\nje     0x286\ncmp    $0x3,%rax\njg     0x2ec\ncmp    $0x1,%rax\nje     0x2ca\ncmp    $0x2,%rax\nje     0x2a8\njmp    0x2ec\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2f2\ntest   %al,%al\nje     0x2a3\nmov    -0x18(%rbp),%rax\njmp    0x2f0\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2f2\ntest   %al,%al\nje     0x2c5\nmov    -0x18(%rbp),%rax\njmp    0x2f0\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2f2\ntest   %al,%al\nje     0x2e7\nmov    -0x18(%rbp),%rax\njmp    0x2f0\naddq   $0x1,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nleave  \nret    \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmovzbl (%rdx),%edx\nmovsbl %dl,%edx\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x0\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x36f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x36f\nlea    0x0(%rip),%rax        # 0x344\nmov    %rax,%rdi\ncall   0x34c\nlea    0x0(%rip),%rax        # 0x353\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x35d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x367\nmov    %rax,%rdi\ncall   0x36f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x31c\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_136",
        "query_text": "The function accepts two integer inputs and returns an integer that indicates their relative ordering. Specifically, it returns \u20131 if the first input is less than the second, 1 if the first input is greater than the second, and 0 if the two inputs are equal. The function uses simple conditional checks to determine the relationship between the two integers.",
        "code_id": "c_group_1_id_136",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    0x1d\nmov    $0xffffffff,%eax\njmp    0x31\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njle    0x2c\nmov    $0x1,%eax\njmp    0x31\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x86\ncmpl   $0xffff,-0x8(%rbp)\njne    0x86\nlea    0x0(%rip),%rax        # 0x5b\nmov    %rax,%rdi\ncall   0x63\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x74\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rdi\ncall   0x86\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x33\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_134",
        "query_text": "The function accepts four parameters: three pointers to pointers of an unsigned byte and an integer representing the depth for comparison. It first extracts an integer value from each of the three pointer targets using an external helper function (assumed to retrieve the corresponding value at the specified depth). If the two values from the first and second pointers are equal, it immediately returns the first pointer. Otherwise, if the value from the third pointer matches either of the first two values, it returns the third pointer. If no matches are found, it returns the pointer corresponding to the median value among the three. The result is a pointer to a pointer of unsigned byte.",
        "code_id": "c_group_1_id_134",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x2c(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq   \nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq   \nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\nsete   %al\ntest   %al,%al\nje     0x5d\nmov    -0x18(%rbp),%rax\njmp    0xe6\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq   \nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0xc(%rbp),%eax\nje     0x85\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njne    0x8c\nmov    $0x1,%eax\njmp    0x91\nmov    $0x0,%eax\ntest   %al,%al\nje     0x9b\nmov    -0x28(%rbp),%rax\njmp    0xe6\nmov    -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    0xc5\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     0xbf\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    0xb9\nmov    -0x28(%rbp),%rax\njmp    0xe5\nmov    -0x18(%rbp),%rax\njmp    0xe5\nmov    -0x20(%rbp),%rax\njmp    0xe5\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     0xe1\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    0xdb\nmov    -0x18(%rbp),%rax\njmp    0xe5\nmov    -0x28(%rbp),%rax\njmp    0xe5\nmov    -0x20(%rbp),%rax\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x13b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x13b\nlea    0x0(%rip),%rax        # 0x110\nmov    %rax,%rdi\ncall   0x118\nlea    0x0(%rip),%rax        # 0x11f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x129\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x133\nmov    %rax,%rdi\ncall   0x13b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xe8\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_132",
        "query_text": "The function accepts two inputs: pointers to unsigned characters (commonly representing strings). It compares the characters of the two strings sequentially until it encounters a mismatched character or reaches the terminating null character in either string. The function then returns an integer that represents the difference between the ASCII values of the first pair of characters that do not match. If the strings are identical, it returns 0.",
        "code_id": "c_group_1_id_132",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\njmp    0x1c\naddq   $0x1,-0x8(%rbp)\naddq   $0x1,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     0x39\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     0x12\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa6\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa6\nlea    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rdi\ncall   0x83\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x94\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9e\nmov    %rax,%rdi\ncall   0xa6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x53\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_115",
        "query_text": "This function operates on a mutable C-style string provided as a null-terminated character array. It processes the string in place to remove extraneous spaces. Specifically, during its iteration, it skips any space character that immediately follows a specific marker (the '@' character) or that is immediately succeeded by another space, the marker, or the end of the string. The function ensures that the modified string remains null-terminated and does not return any value.",
        "code_id": "c_group_1_id_115",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0xa(%rbp)\nmovb   $0x0,-0x9(%rbp)\nmov    -0x18(%rbp),%rax\nmovb   $0x0,(%rax)\ncmpb   $0x0,-0xa(%rbp)\nje     0x99\ncmpb   $0x20,-0xa(%rbp)\njne    0x68\ncmpb   $0x40,-0x9(%rbp)\nje     0x81\nmov    -0x18(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     0x81\nmov    -0x18(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x40,%al\nje     0x81\nmov    -0x18(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     0x81\nmovzbl -0xa(%rbp),%edx\nmov    -0x8(%rbp),%rax\nlea    0x1(%rax),%rcx\nmov    %rcx,-0x8(%rbp)\nmov    %dl,(%rax)\nmovzbl -0xa(%rbp),%eax\nmov    %al,-0x9(%rbp)\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0xa(%rbp)\nmov    -0x18(%rbp),%rax\nmovb   $0x0,(%rax)\njmp    0x29\nnop\nmov    -0x8(%rbp),%rax\nmovb   $0x0,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xf7\ncmpl   $0xffff,-0x8(%rbp)\njne    0xf7\nlea    0x0(%rip),%rax        # 0xcc\nmov    %rax,%rdi\ncall   0xd4\nlea    0x0(%rip),%rax        # 0xdb\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xe5\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xef\nmov    %rax,%rdi\ncall   0xf7\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xa4\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_47",
        "query_text": "The function accepts three inputs: a string representing a file name, an integer representing a line number, and another string representing an error message. It prints a formatted error message to the standard error stream that includes the file name, line number, and error message, and then terminates the program by invoking an abort function. The function does not return any value.",
        "code_id": "c_group_1_id_47",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    0x0(%rip),%rax        # 0x1e\nmov    -0x18(%rbp),%rsi\nmov    -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rdx\nmov    %rsi,%r8\nlea    0x0(%rip),%rsi        # 0x33\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x40\ncall   0x45\nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x98\ncmpl   $0xffff,-0x8(%rbp)\njne    0x98\nlea    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rdi\ncall   0x75\nlea    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x86\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x90\nmov    %rax,%rdi\ncall   0x98\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x45\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_130",
        "query_text": "This function accepts a single character input. It then checks if the input represents a valid hexadecimal digit by determining whether it falls within the range of numeric digits or lowercase alphabetical characters corresponding to hexadecimal values. The output is an integer value, where 1 indicates a valid hexadecimal digit and 0 indicates an invalid one.",
        "code_id": "c_group_1_id_130",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x2f,-0x4(%rbp)\njle    0x19\ncmpb   $0x39,-0x4(%rbp)\njle    0x25\ncmpb   $0x60,-0x4(%rbp)\njle    0x2c\ncmpb   $0x66,-0x4(%rbp)\njg     0x2c\nmov    $0x1,%eax\njmp    0x31\nmov    $0x0,%eax\nmovzbl %al,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x89\ncmpl   $0xffff,-0x8(%rbp)\njne    0x89\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nlea    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x77\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x81\nmov    %rax,%rdi\ncall   0x89\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x36\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_135",
        "query_text": "The function sorts an array of strings in place using the insertion sort algorithm. It takes as input an array of strings (pointers to unsigned characters), an integer representing the number of strings in the array, and a size_t value specifying the depth from which to begin comparing the strings lexicographically. The function modifies the input array directly and does not return any value.",
        "code_id": "c_group_1_id_135",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    %rax,-0x28(%rbp)\njmp    0xca\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\njmp    0xad\nmov    -0x20(%rbp),%rax\nsub    $0x8,%rax\nmov    (%rax),%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\njmp    0x6a\naddq   $0x1,-0x18(%rbp)\naddq   $0x1,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    0x87\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x60\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njbe    0xb9\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rax),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,(%rax)\nsubq   $0x8,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nja     0x39\njmp    0xba\nnop\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\naddq   $0x8,-0x28(%rbp)\nsubl   $0x1,-0x3c(%rbp)\ncmpl   $0x0,-0x3c(%rbp)\nsetg   %al\ntest   %al,%al\njne    0x24\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x134\ncmpl   $0xffff,-0x8(%rbp)\njne    0x134\nlea    0x0(%rip),%rax        # 0x109\nmov    %rax,%rdi\ncall   0x111\nlea    0x0(%rip),%rax        # 0x118\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x122\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x12c\nmov    %rax,%rdi\ncall   0x134\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xe1\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_129",
        "query_text": "This function accepts a 16-bit unsigned integer as its parameter and returns a string representation of the input. It operates by dividing the input into two 8-bit segments: one corresponding to the upper half and the other to the lower half of the original value. Each segment is individually converted to a string via a helper conversion method, after which the two strings are concatenated. The final result is the combined string that reflects the original 16-bit integer.",
        "code_id": "c_group_1_id_129",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %esi,%eax\nmov    %ax,-0x6c(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovzwl -0x6c(%rbp),%eax\nmovzbl %al,%edx\nlea    -0x40(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x3b\nmovzwl -0x6c(%rbp),%eax\nshr    $0x8,%ax\nmovzbl %al,%edx\nlea    -0x60(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x54\nmov    -0x68(%rbp),%rax\nlea    -0x40(%rbp),%rdx\nlea    -0x60(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x6b\nnop\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   0x78\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x84\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xce\njmp    0xc9\nendbr64 \nmov    %rax,%rbx\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   0xa9\njmp    0xb2\nendbr64 \nmov    %rax,%rbx\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0xbe\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xc9\ncall   0xce\nmov    -0x68(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x12b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x12b\nlea    0x0(%rip),%rax        # 0x100\nmov    %rax,%rdi\ncall   0x108\nlea    0x0(%rip),%rax        # 0x10f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x119\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x123\nmov    %rax,%rdi\ncall   0x12b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xd8\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovb   $0x0,-0x19(%rbp)\nmovb   $0x1,-0x19(%rbp)\ncmpb   $0x0,-0x19(%rbp)\nje     0xb2\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x37\nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x46\nadd    %rbx,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x59\ncmp    %rax,-0x18(%rbp)\njbe    0x78\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x6b\ncmp    %rax,-0x18(%rbp)\nja     0x78\nmov    $0x1,%eax\njmp    0x7d\nmov    $0x0,%eax\ntest   %al,%al\nje     0xb2\nmov    -0x30(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x96\nmov    %rax,%rdi\ncall   0x9e\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xb0\njmp    0xdf\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xc5\nmov    %rax,%rdi\ncall   0xcd\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xdf\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_41",
        "query_text": "The function accepts no input arguments and returns a constant string literal. Its return type is a pointer to constant characters (const char*), ensuring that the returned string cannot be altered. The function\u2019s primary purpose is to provide a fixed immutable string without performing any additional operations.",
        "code_id": "c_group_1_id_41",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x64\ncmpl   $0xffff,-0x8(%rbp)\njne    0x64\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_164",
        "query_text": "The function takes a single integer input that acts as a reset flag and returns an integer output corresponding to a block length. It maintains an internal state representing a fixed sequence of block lengths. When the reset flag is non-zero, the internal state is reinitialized so that the next output comes from the start of the sequence. When the reset flag is zero, the function outputs the subsequent block length in the sequence, wrapping around to the beginning once the end is reached.",
        "code_id": "c_group_1_id_164",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x5,-0x30(%rbp)\nmovl   $0x190,-0x2c(%rbp)\nmovl   $0xa,-0x28(%rbp)\nmovl   $0x12c,-0x24(%rbp)\nmovl   $0x14,-0x20(%rbp)\nmovl   $0xc8,-0x1c(%rbp)\nmovl   $0x32,-0x18(%rbp)\nmovl   $0x64,-0x14(%rbp)\nmovl   $0x46,-0x10(%rbp)\nmovl   $0x0,-0x34(%rbp)\ncmpl   $0x0,-0x44(%rbp)\nje     0x73\nmovl   $0x0,-0x34(%rbp)\njmp    0xa2\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdx\nimul   $0x38e38e39,%rdx,%rdx\nshr    $0x20,%rdx\nsar    %edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nmov    %edx,-0x34(%rbp)\nmov    -0x34(%rbp),%ecx\nmov    %ecx,%edx\nshl    $0x3,%edx\nadd    %ecx,%edx\nsub    %edx,%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq   \nmov    -0x30(%rbp,%rax,4),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xbf\ncall   0xbf\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x114\ncmpl   $0xffff,-0x8(%rbp)\njne    0x114\nlea    0x0(%rip),%rax        # 0xe9\nmov    %rax,%rdi\ncall   0xf1\nlea    0x0(%rip),%rax        # 0xf8\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x102\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x10c\nmov    %rax,%rdi\ncall   0x114\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xc1\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_127",
        "query_text": "This function performs a lexicographical comparison between two null-terminated arrays of bytes. It takes two inputs, each being a pointer to an unsigned character array, and uses assertions to ensure neither pointer is null. It then converts the input arrays to C-style strings and calls the standard string comparison function to determine their relative ordering, returning an integer result that indicates whether the first array is less than, equal to, or greater than the second array.",
        "code_id": "c_group_1_id_127",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    0x43\nlea    0x0(%rip),%rax        # 0x22\nmov    %rax,%rcx\nmov    $0x10,%edx\nlea    0x0(%rip),%rax        # 0x31\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x3b\nmov    %rax,%rdi\ncall   0x43\ncmpq   $0x0,-0x10(%rbp)\njne    0x72\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,%rcx\nmov    $0x11,%edx\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdi\ncall   0x72\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x85\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xda\ncmpl   $0xffff,-0x8(%rbp)\njne    0xda\nlea    0x0(%rip),%rax        # 0xaf\nmov    %rax,%rdi\ncall   0xb7\nlea    0x0(%rip),%rax        # 0xbe\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xc8\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xd2\nmov    %rax,%rdi\ncall   0xda\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x87\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_44",
        "query_text": "The function generates and returns a string that represents the current date and time formatted according to the ISO 8601 standard in UTC. It accepts no input parameters and outputs a string. Internally, it obtains the current system time, converts it to Coordinated Universal Time (UTC), and then formats it into a character array following the pattern \"YYYY-MM-DDTHH:MM:SSZ\". The implementation also manages platform-specific differences in time retrieval and formatting to ensure consistent behavior across various environments.",
        "code_id": "c_group_1_id_44",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2c\nmovq   $0x15,-0x48(%rbp)\n\nlea    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   0x40\nmov    %rax,-0x40(%rbp)\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,-0x38(%rbp)\nmov    -0x40(%rbp),%rdx\nlea    -0x30(%rbp),%rax\nmov    %rdx,%rcx\nlea    0x0(%rip),%rdx        # 0x61\nmov    $0x15,%esi\nmov    %rax,%rdi\ncall   0x6e\nlea    -0x51(%rbp),%rax\nmov    %rax,%rdi\ncall   0x7a\nlea    -0x51(%rbp),%rdx\nlea    -0x30(%rbp),%rsi\nmov    -0x68(%rbp),%rax\nmov    %rdx,%rcx\nmov    $0x14,%edx\nmov    %rax,%rdi\ncall   0x96\nlea    -0x51(%rbp),%rax\nmov    %rax,%rdi\ncall   0xa2\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xd6\njmp    0xd1\nendbr64 \nmov    %rax,%rbx\nlea    -0x51(%rbp),%rax\nmov    %rax,%rdi\ncall   0xc6\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xd1\ncall   0xd6\nmov    -0x68(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x133\ncmpl   $0xffff,-0x8(%rbp)\njne    0x133\nlea    0x0(%rip),%rax        # 0x108\nmov    %rax,%rdi\ncall   0x110\nlea    0x0(%rip),%rax        # 0x117\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x121\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x12b\nmov    %rax,%rdi\ncall   0x133\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xe0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_128",
        "query_text": "The function takes an unsigned 8-bit integer representing a character as input and returns a string representing that character. If the input is a displayable character, it is directly converted to its string equivalent; otherwise, the function produces a string in which the integer value of the non-printable character is enclosed in angle brackets. The resulting string is returned as the output.",
        "code_id": "c_group_1_id_128",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x198,%rsp\nmov    %rdi,-0x198(%rbp)\nmov    %esi,%eax\nmov    %al,-0x19c(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x190(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3d\nmovzbl -0x19c(%rbp),%eax\nmov    %eax,%edi\ncall   0x4b\ntest   %eax,%eax\nje     0x69\nmovzbl -0x19c(%rbp),%edx\nlea    -0x190(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x67\njmp    0x9e\nlea    -0x190(%rbp),%rax\nmov    $0x3c,%esi\nmov    %rax,%rdi\ncall   0x7d\nmov    %rax,%rdx\nmovzbl -0x19c(%rbp),%eax\nmov    %eax,%esi\nmov    %rdx,%rdi\ncall   0x91\nmov    $0x3e,%esi\nmov    %rax,%rdi\ncall   0x9e\nmov    -0x198(%rbp),%rax\nlea    -0x190(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xb7\nnop\nlea    -0x190(%rbp),%rax\nmov    %rax,%rdi\ncall   0xc7\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xff\njmp    0xfa\nendbr64 \nmov    %rax,%rbx\nlea    -0x190(%rbp),%rax\nmov    %rax,%rdi\ncall   0xef\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xfa\ncall   0xff\nmov    -0x198(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x15f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x15f\nlea    0x0(%rip),%rax        # 0x134\nmov    %rax,%rdi\ncall   0x13c\nlea    0x0(%rip),%rax        # 0x143\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x14d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x157\nmov    %rax,%rdi\ncall   0x15f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x10c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_131",
        "query_text": "The function takes three inputs: a pointer to an array of null-terminated strings (each string represented as an array of unsigned characters), an integer indicating the total number of strings, and an integer specifying the starting index for character comparison. It implements an insertion sort algorithm to reorder the strings in ascending order based on their characters starting from the given index. During the sorting process, each string is compared to the ones preceding it, and inserted in its appropriate position within the array. The function does not produce a return value, as it directly modifies the order of the strings in the input array.",
        "code_id": "c_group_1_id_131",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    %edx,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    %rax,-0x28(%rbp)\njmp    0xd0\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x20(%rbp)\njmp    0xaf\nmov    -0x20(%rbp),%rax\nsub    $0x8,%rax\nmov    (%rax),%rdx\nmov    -0x40(%rbp),%eax\ncltq   \nadd    %rdx,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\njmp    0x6c\naddq   $0x1,-0x18(%rbp)\naddq   $0x1,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    0x89\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x62\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njbe    0xbf\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rax),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,(%rax)\nsubq   $0x8,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nja     0x38\njmp    0xc0\nnop\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\naddq   $0x8,-0x28(%rbp)\nsubl   $0x1,-0x3c(%rbp)\ncmpl   $0x0,-0x3c(%rbp)\nsetg   %al\ntest   %al,%al\njne    0x23\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x13a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x13a\nlea    0x0(%rip),%rax        # 0x10f\nmov    %rax,%rdi\ncall   0x117\nlea    0x0(%rip),%rax        # 0x11e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x128\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x132\nmov    %rax,%rdi\ncall   0x13a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xe7\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_56",
        "query_text": "The function takes an unsigned 32-bit integer, interpreted as a non-negative exponent, and returns a 64-bit signed integer representing 10 raised to that exponent. It employs recursion by checking if the input is zero\u2014in which case it returns 1\u2014and otherwise recursively calls itself with the exponent decremented by 1, multiplying the outcome by 10. The primary purpose of the function is to compute the power of 10 for the given exponent efficiently using recursive calls.",
        "code_id": "c_group_1_id_56",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\nje     0x34\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%edi\ncall   0x22\nmov    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\njmp    0x39\nmov    $0x1,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8e\nlea    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdi\ncall   0x6b\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x86\nmov    %rax,%rdi\ncall   0x8e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_64",
        "query_text": "The function takes two 16-bit unsigned integers as input and returns an unsigned integer as output. It first verifies through an assertion that the two input values are not equal. It then isolates the higher 8 bits of each input value by applying a bitmask. The function checks if these isolated higher 8 bits are equal and non-zero; if both conditions are met, it returns 1, otherwise it returns 0.",
        "code_id": "c_group_1_id_64",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,%edx\nmov    %esi,%eax\nmov    %dx,-0x14(%rbp)\nmov    %ax,-0x18(%rbp)\nmovzwl -0x14(%rbp),%eax\ncmp    -0x18(%rbp),%ax\njne    0x4a\nlea    0x0(%rip),%rax        # 0x29\nmov    %rax,%rcx\nmov    $0xf,%edx\nlea    0x0(%rip),%rax        # 0x38\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdi\ncall   0x4a\nmovzwl -0x14(%rbp),%eax\nand    $0xff00,%eax\nmov    %eax,-0x8(%rbp)\nmovzwl -0x18(%rbp),%eax\nand    $0xff00,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x8(%rbp)\nje     0x70\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\nje     0x77\nmov    $0x0,%eax\njmp    0x7c\nmov    $0x1,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd1\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd1\nlea    0x0(%rip),%rax        # 0xa6\nmov    %rax,%rdi\ncall   0xae\nlea    0x0(%rip),%rax        # 0xb5\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xbf\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xc9\nmov    %rax,%rdi\ncall   0xd1\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_185",
        "query_text": "The function takes no input and returns a boolean value. It verifies whether the system or compiler correctly encodes a particular Unicode character in UTF-8 format. To do so, the function first checks if the byte-length of a string literal representing the character is three, which is the expected length for its UTF-8 encoding. It then confirms that the first two bytes of the string match the predetermined values required for the proper UTF-8 representation of the character. Based on these checks, the function returns true if both conditions are met, indicating that UTF-8 encoding is supported; otherwise, it returns false.",
        "code_id": "c_group_1_id_185",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffffffc2,%eax\ncmp    $0xc2,%al\njne    0x21\nmov    $0xffffffa7,%eax\ncmp    $0xa7,%al\njne    0x21\nmov    $0x1,%eax\njmp    0x26\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7b\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdi\ncall   0x58\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x69\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x73\nmov    %rax,%rdi\ncall   0x7b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x28\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_85",
        "query_text": "The function accepts a single string as input and returns a boolean value. It checks whether the input string is equal to one of three specific literal values \u2013 \".nan\", \".NaN\", or \".NAN\". If the input matches any of these values, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_85",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x1b\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x26\ntest   %al,%al\njne    0x5e\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x35\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x40\ntest   %al,%al\njne    0x5e\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x4f\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x5a\ntest   %al,%al\nje     0x65\nmov    $0x1,%eax\njmp    0x6a\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xbf\ncmpl   $0xffff,-0x8(%rbp)\njne    0xbf\nlea    0x0(%rip),%rax        # 0x94\nmov    %rax,%rdi\ncall   0x9c\nlea    0x0(%rip),%rax        # 0xa3\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xad\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb7\nmov    %rax,%rdi\ncall   0xbf\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x6c\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\ntest   %eax,%eax\nsete   %al\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_163",
        "query_text": "The function accepts two integer parameters: the first is a non-negative integer, and the second is a positive integer. It calculates the ceiling of the division of the first parameter by the second, ensuring that any fractional result is rounded up to the next whole number. The function returns the computed result as an integer.",
        "code_id": "c_group_1_id_163",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njs     0x1e\ncmpl   $0x0,-0x8(%rbp)\njg     0x46\nlea    0x0(%rip),%rax        # 0x25\nmov    %rax,%rcx\nmov    $0xf,%edx\nlea    0x0(%rip),%rax        # 0x34\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x3e\nmov    %rax,%rdi\ncall   0x46\nmov    -0x8(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x4(%rbp),%eax\nadd    %edx,%eax\ncltd   \nidivl  -0x8(%rbp)\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xaa\ncmpl   $0xffff,-0x8(%rbp)\njne    0xaa\nlea    0x0(%rip),%rax        # 0x7f\nmov    %rax,%rdi\ncall   0x87\nlea    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x98\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xa2\nmov    %rax,%rdi\ncall   0xaa\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x57\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_39",
        "query_text": "The function accepts a reference to an output stream and an unsigned character as input. It formats the unsigned character into a hexadecimal escape sequence, outputting the literal \"\\x\" followed by the two-digit uppercase hexadecimal representation of the character. After writing the formatted output, the function restores the original state of the output stream\u2019s formatting flags to prevent side effects on any subsequent output operations. The input is an output stream and an unsigned character, while the output consists of the hexadecimal escape sequence written to the provided stream.",
        "code_id": "c_group_1_id_39",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,%eax\nmov    %al,-0x2c(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nsub    $0x18,%rax\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,%rdi\ncall   0x36\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x44\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x4f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x64\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x79\nmov    %rax,%rbx\nmov    $0x30,%edi\ncall   0x86\nmov    %eax,%esi\nmov    %rbx,%rdi\ncall   0x90\nmov    %rax,%rbx\nmov    $0x2,%edi\ncall   0x9d\nmov    %eax,%esi\nmov    %rbx,%rdi\ncall   0xa7\nmov    %rax,%rdx\nmovzbl -0x2c(%rbp),%eax\nmov    %eax,%esi\nmov    %rdx,%rdi\ncall   0xb8\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nsub    $0x18,%rax\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,%esi\nmov    %rdx,%rdi\ncall   0xdd\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x137\ncmpl   $0xffff,-0x8(%rbp)\njne    0x137\nlea    0x0(%rip),%rax        # 0x10c\nmov    %rax,%rdi\ncall   0x114\nlea    0x0(%rip),%rax        # 0x11b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x125\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x12f\nmov    %rax,%rdi\ncall   0x137\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xe4\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nand    -0x8(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nor     -0x8(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nnot    %eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    -0xc(%rbp),%edx\nmov    %edx,%esi\nmov    %eax,%edi\ncall   0x25\nmov    -0x8(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    -0xc(%rbp),%edx\nmov    %edx,%esi\nmov    %eax,%edi\ncall   0x25\nmov    -0x8(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x18(%rax),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x18(%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%edx\nmov    %edx,0x18(%rax)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x18(%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,%esi\nmov    %rdx,%rdi\ncall   0x32\nmov    -0x4(%rbp),%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x18(%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,%edi\ncall   0x2a\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x3e\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   0x4d\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x61\nmov    -0x4(%rbp),%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x4000,%esi\nmov    %rax,%rdi\ncall   0x21\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x4a,%edx\nmov    $0x8,%esi\nmov    %rax,%rdi\ncall   0x26\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_36",
        "query_text": "The function takes a single floating-point value as input and returns a 32-bit integer as its output. It operates by directly copying the binary representation of the input float into the memory space of a 32-bit integer. This technique ensures that the integer holds exactly the same bit pattern as the original floating-point value, without performing any arithmetic conversion. An internal check confirms that the size of the floating-point type matches the size of the 32-bit integer type, as required by the implementation.",
        "code_id": "c_group_1_id_36",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovss  %xmm0,-0x14(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x14(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x3d\ncall   0x3d\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x92\ncmpl   $0xffff,-0x8(%rbp)\njne    0x92\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rdi\ncall   0x6f\nlea    0x0(%rip),%rax        # 0x76\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x80\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rdi\ncall   0x92\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_40",
        "query_text": "The function takes no input arguments and returns a fixed, immutable string literal. Specifically, it outputs a pointer to a constant character array containing a predefined failure message. No modifications can be made to this string, and the primary purpose of the function is to provide a standard error indicator.",
        "code_id": "c_group_1_id_40",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x64\ncmpl   $0xffff,-0x8(%rbp)\njne    0x64\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_29",
        "query_text": "This function retrieves the standard error output stream by returning a reference to the underlying error stream object. It does not require any input arguments and outputs a reference to an object of type std::ostream. This returned stream is generally used for printing error messages or diagnostic information during program execution.",
        "code_id": "c_group_1_id_29",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x64\ncmpl   $0xffff,-0x8(%rbp)\njne    0x64\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_165",
        "query_text": "This function provides a static buffer of floats and its size to the caller. It takes two inputs: a generic pointer (unused) and a pointer to a pointer to a float. The function assigns the static float buffer to the provided pointer-to-pointer, enabling external access to the buffer. Finally, it returns the number of elements in the buffer as a long integer.",
        "code_id": "c_group_1_id_165",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %rsi,-0x70(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x70(%rbp),%rax\nlea    -0x60(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    $0x14,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x47\ncall   0x47\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9c\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nlea    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x94\nmov    %rax,%rdi\ncall   0x9c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x49\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_133",
        "query_text": "The function takes two pointer-to-pointer parameters that reference memory blocks of unsigned characters and an integer specifying the number of iterations. In each iteration, it swaps the memory locations pointed to by the two pointer parameters and then increments both pointers. This process is repeated until the specified number of swaps is completed. The function performs the operations in place and does not return any value (void).",
        "code_id": "c_group_1_id_133",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\njmp    0x49\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nlea    0x8(%rax),%rcx\nmov    %rcx,-0x18(%rbp)\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nlea    0x8(%rax),%rcx\nmov    %rcx,-0x20(%rbp)\nmov    %rdx,(%rax)\nmov    -0x24(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x24(%rbp)\ntest   %eax,%eax\nsetg   %al\ntest   %al,%al\njne    0x15\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb2\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb2\nlea    0x0(%rip),%rax        # 0x87\nmov    %rax,%rdi\ncall   0x8f\nlea    0x0(%rip),%rax        # 0x96\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa0\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xaa\nmov    %rax,%rdi\ncall   0xb2\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x5f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_197",
        "query_text": "The function takes a pointer to a null-terminated character array (string) as input. It iterates over the characters in the string, searching for the first occurrence of either a newline or a carriage return character. Once one of these characters is found, it is replaced with a null terminator, thereby truncating the string at that point. If no newline or carriage return is encountered, the string remains unmodified. The function does not return any value.",
        "code_id": "c_group_1_id_197",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\njmp    0x32\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xa,%al\nje     0x24\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xd,%al\njne    0x2d\nmov    -0x8(%rbp),%rax\nmovb   $0x0,(%rax)\njmp    0x44\naddq   $0x1,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     0x44\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0xe\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x99\ncmpl   $0xffff,-0x8(%rbp)\njne    0x99\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rdi\ncall   0x76\nlea    0x0(%rip),%rax        # 0x7d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x87\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x91\nmov    %rax,%rdi\ncall   0x99\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x46\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_53",
        "query_text": "The function accepts two inputs: the first is a 32-bit unsigned integer and the second is a 64-bit unsigned integer. It multiplies these values together and returns the lower 64 bits of the resultant product as a 64-bit unsigned integer. The implementation is optimized for performance, being defined as inline and marked as noexcept, ensuring that it does not throw exceptions.",
        "code_id": "c_group_1_id_53",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x4(%rbp),%eax\nimul   -0x10(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6c\nlea    0x0(%rip),%rax        # 0x41\nmov    %rax,%rdi\ncall   0x49\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdi\ncall   0x6c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x19\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_31",
        "query_text": "The function takes no input arguments. It retrieves the current system time with high precision by utilizing a high-resolution clock, then computes the elapsed time in nanoseconds since the Unix epoch (typically January 1, 1970). Finally, it returns the resulting value as a 64-bit unsigned integer representing the nanoseconds count.",
        "code_id": "c_group_1_id_31",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\ncall   0x20\nmov    %rax,-0x20(%rbp)\nlea    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmov    %rax,-0x18(%rbp)\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x40\nmov    %rax,-0x10(%rbp)\nlea    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x50\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x64\ncall   0x64\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb9\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb9\nlea    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdi\ncall   0x96\nlea    0x0(%rip),%rax        # 0x9d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa7\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdi\ncall   0xb9\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x66\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2b\nmov    %rax,-0x18(%rbp)\nlea    -0x18(%rbp),%rdx\nlea    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x42\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x5a\ncall   0x5a\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_32",
        "query_text": "The function accepts three parameters: a reference to a modifiable string and two constant strings representing the target substring and the replacement substring, respectively. It scans the string for occurrences of the target substring and replaces each found instance with the replacement substring, modifying the string in-place. The function returns a boolean value\u2014true if at least one replacement was made and false if none were found.",
        "code_id": "c_group_1_id_32",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0xc8,%rsp\nmov    %rdi,-0xb8(%rbp)\nmov    %rsi,-0xc0(%rbp)\nmov    %rdx,-0xc8(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovb   $0x0,-0xa9(%rbp)\nmov    -0xc0(%rbp),%rcx\nmov    -0xb8(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x59\nmov    %rax,-0xa8(%rbp)\njmp    0x1bf\nmovb   $0x1,-0xa9(%rbp)\nmov    -0xc0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x7b\nmov    -0xa8(%rbp),%rdx\nadd    %rax,%rdx\nlea    -0x60(%rbp),%rax\nmov    -0xb8(%rbp),%rsi\nmov    $0xffffffffffffffff,%rcx\nmov    %rax,%rdi\ncall   0x9f\nlea    -0xa0(%rbp),%rax\nmov    -0xa8(%rbp),%rdx\nmov    -0xb8(%rbp),%rsi\nmov    %rdx,%rcx\nmov    $0x0,%edx\nmov    %rax,%rdi\ncall   0xc4\nlea    -0x80(%rbp),%rax\nmov    -0xc8(%rbp),%rdx\nlea    -0xa0(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0xe1\nlea    -0x40(%rbp),%rax\nlea    -0x60(%rbp),%rdx\nlea    -0x80(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0xf8\nlea    -0x40(%rbp),%rdx\nmov    -0xb8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x10e\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11a\nlea    -0x80(%rbp),%rax\nmov    %rax,%rdi\ncall   0x126\nlea    -0xa0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x135\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   0x141\nmov    -0xb8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x150\nmov    %rax,%rbx\nmov    -0xc8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x162\nmov    %rax,%rdx\nmov    %rbx,%rax\nsub    %rdx,%rax\ncmp    %rax,-0xa8(%rbp)\nsetb   %al\ntest   %al,%al\nje     0x1b4\nmov    -0xc8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x188\nmov    -0xa8(%rbp),%rdx\nadd    %rax,%rdx\nmov    -0xc0(%rbp),%rcx\nmov    -0xb8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x1ab\nmov    %rax,-0xa8(%rbp)\njmp    0x1bf\nmovq   $0xffffffffffffffff,-0xa8(%rbp)\n\ncmpq   $0xffffffffffffffff,-0xa8(%rbp)\n\njne    0x65\nmovzbl -0xa9(%rbp),%eax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x235\njmp    0x230\nendbr64 \nmov    %rax,%rbx\nlea    -0x80(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1f8\njmp    0x201\nendbr64 \nmov    %rax,%rbx\nlea    -0xa0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x210\njmp    0x219\nendbr64 \nmov    %rax,%rbx\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   0x225\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x230\ncall   0x235\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x28e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x28e\nlea    0x0(%rip),%rax        # 0x263\nmov    %rax,%rdi\ncall   0x26b\nlea    0x0(%rip),%rax        # 0x272\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x27c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x286\nmov    %rax,%rdi\ncall   0x28e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x23b\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovb   $0x0,-0x19(%rbp)\nmovb   $0x1,-0x19(%rbp)\ncmpb   $0x0,-0x19(%rbp)\nje     0xb2\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x37\nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x46\nadd    %rbx,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x59\ncmp    %rax,-0x18(%rbp)\njbe    0x78\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x6b\ncmp    %rax,-0x18(%rbp)\nja     0x78\nmov    $0x1,%eax\njmp    0x7d\nmov    $0x0,%eax\ntest   %al,%al\nje     0xb2\nmov    -0x30(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x96\nmov    %rax,%rdi\ncall   0x9e\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xb0\njmp    0xdf\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xc5\nmov    %rax,%rdi\ncall   0xcd\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xdf\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2b\nmov    %rax,%rdi\ncall   0x33\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x45\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_30",
        "query_text": "The function returns a reference to the program\u2019s standard logging stream. It takes no input parameters and outputs an object of type std::ostream that is used for logging and diagnostic messages. This function essentially provides access to the global logging utility in C++ programs by wrapping the standard logging stream.",
        "code_id": "c_group_1_id_30",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x64\ncmpl   $0xffff,-0x8(%rbp)\njne    0x64\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_52",
        "query_text": "The function accepts two 32-bit unsigned integers. The first is treated as the value to be rotated, and the second as the number of positions to rotate that value to the right. Initially, it ensures that the rotation count is within the valid range (0 to 31) by applying a mask. The function then shifts the input value to the right by the specified count and combines it with the value shifted to the left by the complement (32 minus the rotation count). Ultimately, it returns a 32-bit unsigned integer that represents the value after the rotation operation.",
        "code_id": "c_group_1_id_52",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nandl   $0x1f,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nmov    -0x4(%rbp),%edx\nmov    %eax,%ecx\nror    %cl,%edx\nmov    %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x73\ncmpl   $0xffff,-0x8(%rbp)\njne    0x73\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdi\ncall   0x50\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdi\ncall   0x73\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x20\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_54",
        "query_text": "The function accepts a 32-bit unsigned integer as input. It first converts the input to a 64-bit value to ensure accuracy during the ensuing arithmetic operation. It then multiplies this value by a predetermined constant (1374389535) and subsequently shifts the result to the right by 37 bits. Finally, the result is cast back to a 32-bit unsigned integer and returned. This sequence of operations is designed to be efficient and is implemented in a way that guarantees no exceptions are thrown.",
        "code_id": "c_group_1_id_54",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   $0x51eb851f,%rax,%rax\nshr    $0x25,%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6e\nlea    0x0(%rip),%rax        # 0x43\nmov    %rax,%rdi\ncall   0x4b\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdi\ncall   0x6e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_117",
        "query_text": "The function takes no input arguments and returns a boolean value indicating whether a particular system feature is supported. On one operating system with a non-standard architecture, it immediately returns true. On the same operating system but with a different architecture, it checks the system's kernel version; if the kernel version meets a specified minimum, it returns true, otherwise false, with the result cached for subsequent calls. On all other systems, it returns false. The output is of type bool.",
        "code_id": "c_group_1_id_117",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_186",
        "query_text": "The function takes three pointer parameters. The first parameter is a pointer to a UTF-8 encoded character array, the second is a pointer to an unsigned 32-bit integer that will hold the decoded Unicode code point, and the third is a pointer to an integer used to store error flags. The function begins by determining the byte-length of the current UTF-8 character, then decodes the character by applying bit masks and shifts to combine up to four bytes into a single Unicode code point. As it decodes, it also checks for several error conditions\u2014such as values below a minimum threshold, excessively large values, or improperly encoded continuation bytes\u2014by setting corresponding error flags. Finally, it returns a pointer to the next character in the input string, while updating the provided outputs with the decoded code point and any detected encoding errors.",
        "code_id": "c_group_1_id_186",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0x98(%rbp)\nmov    %rsi,-0xa0(%rbp)\nmov    %rdx,-0xa8(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x80(%rbp)\nmovl   $0x7f,-0x7c(%rbp)\nmovl   $0x1f,-0x78(%rbp)\nmovl   $0xf,-0x74(%rbp)\nmovl   $0x7,-0x70(%rbp)\nmovl   $0x400000,-0x60(%rbp)\nmovl   $0x0,-0x5c(%rbp)\nmovl   $0x80,-0x58(%rbp)\nmovl   $0x800,-0x54(%rbp)\nmovl   $0x10000,-0x50(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmovl   $0x12,-0x3c(%rbp)\nmovl   $0xc,-0x38(%rbp)\nmovl   $0x6,-0x34(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x6,-0x1c(%rbp)\nmovl   $0x4,-0x18(%rbp)\nmovl   $0x2,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmov    -0x98(%rbp),%rax\nmovzbl (%rax),%eax\nshr    $0x3,%al\nmovzbl %al,%eax\ncltq   \nlea    0x0(%rip),%rdx        # 0xd8\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nmov    %eax,-0x8c(%rbp)\nmov    -0x8c(%rbp),%eax\nmovslq %eax,%rdx\ncmpl   $0x0,-0x8c(%rbp)\nsete   %al\nmovzbl %al,%eax\nadd    %rax,%rdx\nmov    -0x98(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x88(%rbp)\nmov    -0x98(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%edx\nmov    -0x8c(%rbp),%eax\ncltq   \nmov    -0x80(%rbp,%rax,4),%eax\nand    %edx,%eax\nshl    $0x12,%eax\nmov    %eax,%edx\nmov    -0xa0(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0xc,%eax\nand    $0x3f000,%eax\nor     %eax,%edx\nmov    -0xa0(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0x6,%eax\nand    $0xfc0,%eax\nor     %eax,%edx\nmov    -0xa0(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x3,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nand    $0x3f,%eax\nor     %eax,%edx\nmov    -0xa0(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8c(%rbp),%eax\ncltq   \nmov    -0x40(%rbp,%rax,4),%eax\nmov    %eax,%ecx\nshr    %cl,%edx\nmov    -0xa0(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8c(%rbp),%eax\ncltq   \nmov    -0x60(%rbp,%rax,4),%eax\ncmp    %eax,%edx\njae    0x1fc\nmov    $0x40,%edx\njmp    0x201\nmov    $0x0,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%eax\nshr    $0xb,%eax\ncmp    $0x1b,%eax\njne    0x22b\nmov    $0x80,%eax\njmp    0x230\nmov    $0x0,%eax\nor     %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0xa0(%rbp),%rax\nmov    (%rax),%eax\ncmp    $0x10ffff,%eax\njbe    0x25b\nmov    $0x100,%eax\njmp    0x260\nmov    $0x0,%eax\nor     %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nshr    $0x2,%al\nmovzbl %al,%eax\nand    $0x30,%eax\nor     %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%eax\nshr    $0x4,%al\nmovzbl %al,%eax\nand    $0xc,%eax\nor     %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x98(%rbp),%rax\nadd    $0x3,%rax\nmovzbl (%rax),%eax\nshr    $0x6,%al\nmovzbl %al,%eax\nor     %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%eax\nxor    $0x2a,%eax\nmov    %eax,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0xa8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8c(%rbp),%eax\ncltq   \nmov    -0x20(%rbp,%rax,4),%eax\nmov    %eax,%ecx\nsar    %cl,%edx\nmov    -0xa8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x88(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x33d\ncall   0x33d\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x392\ncmpl   $0xffff,-0x8(%rbp)\njne    0x392\nlea    0x0(%rip),%rax        # 0x367\nmov    %rax,%rdi\ncall   0x36f\nlea    0x0(%rip),%rax        # 0x376\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x380\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x38a\nmov    %rax,%rdi\ncall   0x392\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x33f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_99",
        "query_text": "The function receives a single character of type char and returns a boolean value. It first casts the input to an unsigned char to ensure compatibility with a standard library function that checks for lowercase characters. It then evaluates the input using this function and produces a boolean result: true if the character is lowercase, or false otherwise.",
        "code_id": "c_group_1_id_99",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   0x1f\ntest   %eax,%eax\nsetne  %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_75",
        "query_text": "The function takes no input parameters and returns an integer representing the outcome of a test. It verifies the correctness of an elliptic curve digital signature verification process using SM2. The function performs the following steps:\n\n1. It initializes a key structure for an elliptic curve and two multi-precision integers that represent the signature components.\n2. It sets up fixed test data, including data for a public key, a message hash, and two signature components (one valid and one modified to simulate a failure scenario).\n3. It runs multiple verification tests:\n   - It first attempts to verify the signature using valid inputs.\n   - It then tests error handling by calling the verification routine with various combinations of invalid or missing parameters.\n   - Finally, it verifies that a signature check fails when a signature component is altered.\n4. It cleans up all allocated resources, freeing the multi-precision integers and the key structure.\n\nThe input is nonexistent, and the output is an integer indicating success, failure, or a skipped test result.",
        "code_id": "c_group_1_id_75",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_42",
        "query_text": "The function accepts two unsigned integer inputs representing a part and a whole. It begins by checking whether the whole is nonzero; if it is, the function scales the part by a predefined constant and divides the product by the whole to compute a ratio. If the whole is zero, the function avoids division by zero by immediately returning zero. Additionally, if the computed ratio is zero even though the part is nonzero, the function adjusts the result to be at least one. The final output is an unsigned integer representing the computed, scaled ratio.",
        "code_id": "c_group_1_id_42",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\ncmpq   $0x0,-0x20(%rbp)\nje     0x34\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x4,%rax\nmov    $0x0,%edx\ndivq   -0x20(%rbp)\njmp    0x39\nmov    $0x0,%eax\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    0x4b\ncmpq   $0x0,-0x18(%rbp)\njne    0x51\nmov    -0x8(%rbp),%rax\njmp    0x56\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xab\ncmpl   $0xffff,-0x8(%rbp)\njne    0xab\nlea    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdi\ncall   0x88\nlea    0x0(%rip),%rax        # 0x8f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x99\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xa3\nmov    %rax,%rdi\ncall   0xab\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x58\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_43",
        "query_text": "The function accepts three input parameters, each being a reference to an unsigned integer, and it determines which of these values is the largest. It performs comparisons among the three inputs: if the first value exceeds both the second and third, it returns a reference to the first; if not, it checks whether the second value is greater than the third and returns a reference to the second if true; otherwise, it returns a reference to the third value. The function does not modify any of the input values but provides direct access to the maximum value via the returned reference.",
        "code_id": "c_group_1_id_43",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\njbe    0x40\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\njbe    0x40\nmov    -0x8(%rbp),%rax\njmp    0x5d\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\njbe    0x59\nmov    -0x10(%rbp),%rax\njmp    0x5d\nmov    -0x18(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb2\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb2\nlea    0x0(%rip),%rax        # 0x87\nmov    %rax,%rdi\ncall   0x8f\nlea    0x0(%rip),%rax        # 0x96\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa0\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xaa\nmov    %rax,%rdi\ncall   0xb2\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x5f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_45",
        "query_text": "The function accepts a constant reference to a vector of strings and returns a string. It iterates over the vector to locate the first element that begins with the '#' character. If such an element is identified, the function extracts a substring from this element starting from the second character and returns it. If none of the strings in the vector satisfy the condition, the function returns an empty string.",
        "code_id": "c_group_1_id_45",
        "code_text": "push   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nmovzbl (%rax),%eax\ncmp    $0x23,%al\nsete   %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x56\nmov    %rax,%rbx\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x65\nmov    %rbx,%rsi\nmov    %rax,%rdi\ncall   0xee\nmov    %rax,-0x28(%rbp)\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x80\nmov    %rax,-0x20(%rbp)\nlea    -0x20(%rbp),%rdx\nlea    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x97\ntest   %al,%al\nje     0xc4\nlea    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xa7\nmov    %rax,%rsi\nmov    -0x38(%rbp),%rax\nmov    $0xffffffffffffffff,%rcx\nmov    $0x1,%edx\nmov    %rax,%rdi\ncall   0xc2\njmp    0xd0\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0xd0\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xe4\ncall   0xe4\nmov    -0x38(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\ncall   0x118\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x165\nleave  \nret    \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x21(%rbp),%rax\nmov    %rax,%rdi\ncall   0x196\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1a4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x15d\ncall   0x15d\nmov    %ebx,%eax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x181\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x1bf\nleave  \nret    \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    -0x9(%rbp),%rax\nmov    %rax,%rdi\ncall   0x196\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nlea    -0x18(%rbp),%rdx\nlea    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x1e6\nsar    $0x2,%rax\nmov    %rax,-0x8(%rbp)\njmp    0x2a8\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x366\ntest   %al,%al\nje     0x213\nmov    -0x18(%rbp),%rax\njmp    0x363\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x21f\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x366\ntest   %al,%al\nje     0x23f\nmov    -0x18(%rbp),%rax\njmp    0x363\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x24b\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x366\ntest   %al,%al\nje     0x26b\nmov    -0x18(%rbp),%rax\njmp    0x363\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x277\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x366\ntest   %al,%al\nje     0x297\nmov    -0x18(%rbp),%rax\njmp    0x363\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2a3\nsubq   $0x1,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njg     0x1f3\nlea    -0x18(%rbp),%rdx\nlea    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2c6\ncmp    $0x3,%rax\nje     0x2e4\ncmp    $0x3,%rax\njg     0x35f\ncmp    $0x1,%rax\nje     0x336\ncmp    $0x2,%rax\nje     0x30d\njmp    0x35f\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x366\ntest   %al,%al\nje     0x301\nmov    -0x18(%rbp),%rax\njmp    0x363\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30d\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x366\ntest   %al,%al\nje     0x32a\nmov    -0x18(%rbp),%rax\njmp    0x363\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x336\nmov    -0x18(%rbp),%rdx\nlea    -0x21(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x366\ntest   %al,%al\nje     0x353\nmov    -0x18(%rbp),%rax\njmp    0x363\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x35f\nmov    -0x20(%rbp),%rax\nleave  \nret    \nnop\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rbx\nlea    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x387\nmov    %rax,%rsi\nmov    %rbx,%rdi\ncall   0x0\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x3eb\ncmpl   $0xffff,-0x8(%rbp)\njne    0x3eb\nlea    0x0(%rip),%rax        # 0x3c0\nmov    %rax,%rdi\ncall   0x3c8\nlea    0x0(%rip),%rax        # 0x3cf\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x3d9\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x3e3\nmov    %rax,%rdi\ncall   0x3eb\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x398\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x18(%rbp),%rax\nlea    0x8(%rax),%rdx\nlea    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x36\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x4e\ncall   0x4e\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x21\nmov    (%rax),%rbx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmov    (%rax),%rax\ncmp    %rax,%rbx\nsetne  %al\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x18(%rbp),%rdx\nlea    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x32\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x4a\ncall   0x4a\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x21\nmov    (%rax),%rbx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmov    (%rax),%rdx\nmov    %rbx,%rax\nsub    %rdx,%rax\nsar    $0x5,%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nlea    0x20(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_37",
        "query_text": "The function accepts a double-precision floating-point value as input and returns a 64-bit integer. It performs the conversion by directly copying the binary representation of the floating-point value into a 64-bit integer variable, effectively reinterpreting the bits without modifying them. The function also enforces an assumption that the size of the floating-point type is equal to the size of the 64-bit integer type.",
        "code_id": "c_group_1_id_37",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovsd  %xmm0,-0x18(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x40\ncall   0x40\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x95\ncmpl   $0xffff,-0x8(%rbp)\njne    0x95\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdi\ncall   0x72\nlea    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x83\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8d\nmov    %rax,%rdi\ncall   0x95\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x42\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_34",
        "query_text": "The function accepts a string input provided as a constant reference and returns a string. On Windows platforms, if the first character of the input string is a forward slash ('/'), it returns a modified string where the initial forward slash is replaced with a hyphen ('-'). For non-Windows platforms or if the input string does not start with a forward slash, it returns the original string unchanged.",
        "code_id": "c_group_1_id_34",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x80\ncmpl   $0xffff,-0x8(%rbp)\njne    0x80\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdi\ncall   0x5d\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x78\nmov    %rax,%rdi\ncall   0x80\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_28",
        "query_text": "This function takes no input parameters and returns a reference to a stream used for standard output operations. Specifically, the output is an object of type std::ostream that enables printing messages to the console.",
        "code_id": "c_group_1_id_28",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x64\ncmpl   $0xffff,-0x8(%rbp)\njne    0x64\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_57",
        "query_text": "The function takes no input parameters and returns a boolean value. It is implemented as a constexpr function that always returns the constant value true. Its primary purpose is to serve as an indicator that the functionality is deprecated, with a suggestion to use an alternative implementation instead. This function does not involve any complex operations or computations.",
        "code_id": "c_group_1_id_57",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_0",
        "query_text": "The function receives a constant reference to a string as input. It checks whether the input string is equal to one of several predefined representations that denote an infinity value. Specifically, the function determines if the string matches any of the designated patterns (such as those beginning with an optional plus sign followed by \".inf\" in various cases). If a match is found, it returns a boolean true; otherwise, it returns false. The input is of type std::string, and the output is a bool.",
        "code_id": "c_group_1_id_0",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x1b\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x26\ntest   %al,%al\njne    0xb0\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x39\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x44\ntest   %al,%al\njne    0xb0\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x53\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x5e\ntest   %al,%al\njne    0xb0\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x6d\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x78\ntest   %al,%al\njne    0xb0\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x87\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x92\ntest   %al,%al\njne    0xb0\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0xa1\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\ntest   %al,%al\nje     0xb7\nmov    $0x1,%eax\njmp    0xbc\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x111\ncmpl   $0xffff,-0x8(%rbp)\njne    0x111\nlea    0x0(%rip),%rax        # 0xe6\nmov    %rax,%rdi\ncall   0xee\nlea    0x0(%rip),%rax        # 0xf5\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xff\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x109\nmov    %rax,%rdi\ncall   0x111\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xbe\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\ntest   %eax,%eax\nsete   %al\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_116",
        "query_text": "The function takes no input arguments and returns a boolean value. It first checks if the code is running on a specific operating system and architecture (macOS with ARM64), in which case it immediately returns true. On other platforms, it attempts to allocate a memory page with read, write, and execute permissions. If the allocation fails, the function concludes that a hardened security feature is enabled and returns true; if the allocation succeeds, it returns false. The result of this check is cached for future calls using atomic operations to ensure thread safety.",
        "code_id": "c_group_1_id_116",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x5,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    $0xffff,%esi\nmov    %eax,%edi\ncall   0x31\nmov    %eax,-0x28(%rbp)\nlea    -0x34(%rbp),%rax\nmov    (%rax),%eax\nnop\nmov    %eax,-0x30(%rbp)\ncmpl   $0x0,-0x30(%rbp)\njne    0xd1\ncall   0x4d\ncltq   \nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    $0x0,%r9d\nmov    $0xffffffff,%r8d\nmov    $0x22,%ecx\nmov    $0x7,%edx\nmov    %rax,%rsi\nmov    $0x0,%edi\ncall   0x7a\nmov    %rax,-0x10(%rbp)\ncmpq   $0xffffffffffffffff,-0x10(%rbp)\njne    0x8e\nmovl   $0x2,-0x30(%rbp)\njmp    0xa8\nmovl   $0x1,-0x30(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xa8\nmov    -0x30(%rbp),%eax\nmov    %eax,-0x24(%rbp)\nmovl   $0x5,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    $0xffff,%esi\nmov    %eax,%edi\ncall   0xc4\nmov    %eax,-0x1c(%rbp)\nlea    -0x34(%rbp),%rax\nmov    -0x24(%rbp),%edx\nxchg   %edx,(%rax)\nnop\ncmpl   $0x2,-0x30(%rbp)\nsete   %al\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xec\ncall   0xec\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x141\ncmpl   $0xffff,-0x8(%rbp)\njne    0x141\nlea    0x0(%rip),%rax        # 0x116\nmov    %rax,%rdi\ncall   0x11e\nlea    0x0(%rip),%rax        # 0x125\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x12f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x139\nmov    %rax,%rdi\ncall   0x141\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xee\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%edx\nmov    -0x8(%rbp),%eax\nand    %edx,%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_77",
        "query_text": "The function performs a self-contained test of an encryption algorithm operating in ECB mode using a cryptography library. It follows these steps:\n\n1. Initialization: The function creates and configures a context for both encryption and decryption. A key is set up (initialized to zero) and a fixed-size block of plaintext is defined.\n2. Encryption: It encrypts the plaintext using the specified algorithm and key, storing the resulting ciphertext in a dedicated buffer.\n3. Decryption: The function then decrypts the ciphertext using the same key, placing the resultant plaintext in another buffer.\n4. Validation: It compares the decrypted data against the original plaintext to ensure that the encryption and decryption processes function correctly.\n5. Cleanup: The function releases the allocated resources associated with the encryption/decryption context.\n\nThe output is an integer that indicates the test result\u2014success, failure, or skipped (in case necessary features are not enabled). No external inputs are required as the function operates on fixed-size byte arrays for the key, plaintext, ciphertext, and decrypted text.",
        "code_id": "c_group_1_id_77",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_100",
        "query_text": "The function accepts a single input of type char and returns an output of the same type. It first converts the input character to an unsigned char to safely handle potential negative values. Then, it applies the standard library function for case conversion to transform the character into its lowercase equivalent. Finally, the result is cast back to a char before being returned.",
        "code_id": "c_group_1_id_100",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   0x1f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x74\ncmpl   $0xffff,-0x8(%rbp)\njne    0x74\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rdi\ncall   0x51\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rdi\ncall   0x74\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x21\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_73",
        "query_text": "The function is designed to perform a series of tests on an encryption algorithm operating in Electronic Codebook mode. It begins by initializing an encryption context and setting a key, then proceeds to evaluate correct responses when invalid arguments (such as null pointers) are supplied. The function also performs encryption and decryption on provided data buffers, including in-place operations, and compares resulting outputs to verify consistency across multiple calls. It covers various edge cases, including operations with differing data lengths, to ensure that both encryption and decryption behave as expected. Finally, the function returns a value indicating whether the tests passed, failed, or were skipped.",
        "code_id": "c_group_1_id_73",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_72",
        "query_text": "The function takes no explicit input. It is a test routine that validates the proper initialization, configuration, and cleanup of a cryptographic algorithm implementation. It first verifies that the algorithm\u2019s context initialization properly handles invalid parameters by expecting specific error codes, and then confirms a successful initialization under valid conditions. If encryption modes (such as ECB, CBC, CTR, or CCM) are enabled, the function proceeds to test key configuration by invoking the key-setting routine with both valid data and a variety of invalid scenarios\u2014including null pointers, incorrect key sizes, and other improper parameters\u2014to ensure robust error handling. For modes that require an initialization vector, the function similarly tests setting the IV, checking for proper error responses on invalid inputs and success when given valid data. Finally, the routine cleans up any allocated resources and returns an integer value that indicates the overall success or failure of these tests.",
        "code_id": "c_group_1_id_72",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_33",
        "query_text": "The function takes a single input\u2014a character of type char. It then checks whether this character is a member of a specific set of symbols, which includes closing brackets, punctuation marks, and various mathematical operators. If the character is found within the set, the function returns a boolean value of true; otherwise, it returns false.",
        "code_id": "c_group_1_id_33",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x58,%rsp\nmov    %edi,%eax\nmov    %al,-0x54(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\nlea    -0x41(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x3c\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x47\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0x53\nmovsbl -0x54(%rbp),%ecx\nlea    -0x40(%rbp),%rax\nmov    $0x0,%edx\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   0x6a\ncmp    $0xffffffffffffffff,%rax\nsetne  %bl\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x7d\nmov    %ebx,%eax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xb3\njmp    0xae\nendbr64 \nmov    %rax,%rbx\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0xa3\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xae\ncall   0xb3\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x10c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x10c\nlea    0x0(%rip),%rax        # 0xe1\nmov    %rax,%rdi\ncall   0xe9\nlea    0x0(%rip),%rax        # 0xf0\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xfa\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x104\nmov    %rax,%rdi\ncall   0x10c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb9\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_78",
        "query_text": "The function tests the encryption and decryption processes for a symmetric algorithm when provided with an empty plaintext. It sets up separate encryption and decryption contexts using predefined byte arrays for a key and an initialization vector. The process unfolds as follows:\n\n1. It initializes the encryption context, setting the IV length and then attempts to encrypt an empty plaintext. During encryption, it produces a ciphertext (which is expected to be empty) and an authentication tag.\n2. The decryption context is then initialized using the same key and IV. It attempts to decrypt the empty ciphertext while verifying the authentication tag, expecting to recover an empty plaintext.\n3. Finally, the function cleans up by freeing the resources used by both contexts and returns an integer status that indicates whether the test passed, failed, or was skipped.",
        "code_id": "c_group_1_id_78",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_35",
        "query_text": "The function takes no input and returns a boolean value. It determines whether color output should be enabled by verifying environmental conditions. Specifically, on certain platforms such as macOS or iOS, it checks that a debugger is not active. It also verifies that the standard output is connected to a terminal (using an isatty-like check), unless the platform enforces strict ANSI compliance (as in some DJGPP environments). If these conditions are not met, the function returns false, indicating that color output should not be used.",
        "code_id": "c_group_1_id_35",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x1,%edi\ncall   0x12\ntest   %eax,%eax\nsetne  %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6c\nlea    0x0(%rip),%rax        # 0x41\nmov    %rax,%rdi\ncall   0x49\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdi\ncall   0x6c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x19\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_188",
        "query_text": "The function takes a modifiable string as input and removes any leading and trailing whitespace characters, including spaces, newline characters, carriage returns, and tabs. The operation alters the input string directly and returns the modified string. Both the input and output are of type std::string.",
        "code_id": "c_group_1_id_188",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0x0(%rip),%rax        # 0x17\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    $0xffffffffffffffff,%rdx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x35\nlea    0x1(%rax),%rcx\nmov    -0x18(%rbp),%rax\nmov    $0xffffffffffffffff,%rdx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x4f\nmov    -0x8(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x67\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x7b\nmov    -0x18(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd4\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd4\nlea    0x0(%rip),%rax        # 0xa9\nmov    %rax,%rdi\ncall   0xb1\nlea    0x0(%rip),%rax        # 0xb8\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xc2\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xcc\nmov    %rax,%rdi\ncall   0xd4\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x81\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_71",
        "query_text": "The function takes no input arguments and performs a compile-time check to determine whether two specific preprocessor macros are defined. If both macros are present, the function returns an integer value indicating success; otherwise, it returns an integer value indicating that the test was skipped.",
        "code_id": "c_group_1_id_71",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_8",
        "query_text": "The function takes two input parameters, both of which are pointers to constant characters (C-style strings). It compares the two strings in a case-insensitive manner using an internal library function. If the strings are identical in a case-insensitive comparison, it returns 0; if the first string is lexicographically greater, it returns a positive value; and if it is lexicographically smaller, it returns a negative value. The input parameters are two pointers to constant characters, and the output is an integer representing the comparison result.",
        "code_id": "c_group_1_id_8",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7c\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,%rdi\ncall   0x59\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdi\ncall   0x7c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x29\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_98",
        "query_text": "The function takes a single character as input and determines whether it represents a numeric digit (0-9). Internally, it casts the input to an unsigned character and uses a standard library routine to perform the check. Based on this evaluation, the function returns a boolean value: true if the character is a decimal digit, and false otherwise. The input is of type char, while the output is of type bool.",
        "code_id": "c_group_1_id_98",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nsub    $0x30,%eax\ncmp    $0x9,%eax\nsetbe  %al\nmovzbl %al,%eax\ntest   %eax,%eax\nsetne  %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7a\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdi\ncall   0x57\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x27\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_205",
        "query_text": "This function receives a pointer to a character string as its input and processes the string by sequentially scanning numeric characters. It converts the sequence of digit characters into an integer value while advancing the pointer to the first non-digit character. The input is a pointer to a character string assumed to have valid numeric digits starting at the current position, and the output is an integer representing the parsed number.",
        "code_id": "c_group_1_id_205",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x4a\nmov    -0x4(%rbp),%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    0x66\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njle    0x15\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xbe\ncmpl   $0xffff,-0x8(%rbp)\njne    0xbe\nlea    0x0(%rip),%rax        # 0x93\nmov    %rax,%rdi\ncall   0x9b\nlea    0x0(%rip),%rax        # 0xa2\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xac\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb6\nmov    %rax,%rdi\ncall   0xbe\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x6b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_74",
        "query_text": "The function performs a series of tests to validate a block cipher\u2019s encryption and decryption routines using Galois/Counter Mode (GCM). It starts by initializing an encryption context and setting up necessary buffers for keys, nonces, plaintext/ciphertext, additional authenticated data (AAD), and authentication tags. The test sequence first checks for proper error handling by calling the encryption and decryption routines with various invalid arguments (such as null pointers, incorrect key sizes, unsuitable nonce lengths, and improperly sized authentication tags). It then proceeds to verify that valid inputs produce consistent outcomes by encrypting a data block and subsequently decrypting it to recover the original data. The function also examines edge cases including empty inputs, single and multiple data blocks, and large buffers. Throughout the tests, comparisons are made between expected and actual outputs to ensure that both encryption and decryption behave correctly under different scenarios. Finally, a status result is returned to indicate whether the tests passed, failed, or were skipped.",
        "code_id": "c_group_1_id_74",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_76",
        "query_text": "The function is a test routine that validates the process of signing a hash using an elliptic curve cryptography algorithm based on the SM2 specification. It begins by initializing and configuring essential cryptographic components such as a random number generator, an elliptic curve key structure, and multi-precision integers to hold signature elements. Initially, it generates a random hash and attempts to invoke the signing operation with various deliberately faulty or null parameters to ensure that the signing routine properly returns error codes when provided with invalid inputs. The test also involves setting up the elliptic curve parameters and, in certain cases, intentionally supplying incorrectly sized mathematical structures to trigger error conditions. After these edge-case verifications, the function performs a valid signing operation and subsequently verifies the correctness of the resulting signature against the original hash using a separate verification routine. Throughout the process, it manages resource allocation and cleanup appropriately. The function ultimately returns an integer test result indicating success, failure, or if the test was skipped.",
        "code_id": "c_group_1_id_76",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_202",
        "query_text": "The function accepts two constant void pointers as input. It first compares the two pointers to determine whether they refer to the same memory location. If the pointers are equal, it returns 0; if not, it returns 1. The return value is of type int.",
        "code_id": "c_group_1_id_202",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nsetne  %al\nmovzbl %al,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x73\ncmpl   $0xffff,-0x8(%rbp)\njne    0x73\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdi\ncall   0x50\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdi\ncall   0x73\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x20\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_218",
        "query_text": "The function takes two inputs: a pointer to an IPv6 address structure and a pointer to an IPv4 address structure. It first initializes the IPv4 address structure to zero. Then, it maps the lower 32 bits of the IPv6 address by copying the last four bytes from the IPv6 address into the corresponding bytes of the IPv4 address structure. The function does not return a value but modifies the IPv4 address structure directly.",
        "code_id": "c_group_1_id_218",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    $0x4,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x2a\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmovzbl 0xc(%rdx),%edx\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovzbl 0xd(%rax),%eax\nmov    %al,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x2(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovzbl 0xe(%rax),%eax\nmov    %al,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x3(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovzbl 0xf(%rax),%eax\nmov    %al,(%rdx)\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc4\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc4\nlea    0x0(%rip),%rax        # 0x99\nmov    %rax,%rdi\ncall   0xa1\nlea    0x0(%rip),%rax        # 0xa8\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xb2\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xbc\nmov    %rax,%rdi\ncall   0xc4\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x71\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_198",
        "query_text": "This function accepts a single input of type FILE*, representing a file stream. It begins by verifying that the input is valid (i.e., non-null). If the file pointer is valid, the function duplicates the current standard error file descriptor to preserve its original state. It then retrieves the file descriptor associated with the provided file stream and uses it to replace the standard error output via a redirection call. If the file descriptor retrieval fails (for example, if the file descriptor is -1), the function terminates the process immediately. Finally, it returns the saved original file descriptor for standard error. Conversely, if the input file pointer is null, the function returns -1, indicating an error condition.",
        "code_id": "c_group_1_id_198",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     0x60\nmov    $0x2,%edi\ncall   0x21\nmov    %eax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmov    %eax,-0x4(%rbp)\ncmpl   $0xffffffff,-0x4(%rbp)\nsete   %al\nmovzbl %al,%eax\ntest   %rax,%rax\nje     0x4c\nmov    $0x1,%edi\ncall   0x4c\nmov    -0x4(%rbp),%eax\nmov    $0x2,%esi\nmov    %eax,%edi\ncall   0x5b\nmov    -0x8(%rbp),%eax\njmp    0x65\nmov    $0xffffffff,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xba\ncmpl   $0xffff,-0x8(%rbp)\njne    0xba\nlea    0x0(%rip),%rax        # 0x8f\nmov    %rax,%rdi\ncall   0x97\nlea    0x0(%rip),%rax        # 0x9e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa8\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb2\nmov    %rax,%rdi\ncall   0xba\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x67\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_213",
        "query_text": "The function takes three inputs: a pointer to an array of pointers representing a hash table, an integer indicating the number of elements in the table, and a pointer representing a key. It computes a hash value from the key using bitwise operations and arithmetic, then uses this value to determine an initial index in the table. By employing a linear probing strategy, the function searches for an available slot to insert the key. If an empty position is found, the key is inserted and the function returns true. If the key is already present or the table is full, it returns false (with an assertion triggered in the event the table is full). The input consists of a pointer to a hash table, a non-negative integer, and a pointer, while the output is of type bool.",
        "code_id": "c_group_1_id_213",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\ncmpq   $0x0,-0x38(%rbp)\njne    0x47\nlea    0x0(%rip),%rax        # 0x26\nmov    %rax,%rcx\nmov    $0xf,%edx\nlea    0x0(%rip),%rax        # 0x35\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x3f\nmov    %rax,%rdi\ncall   0x47\nmov    -0x38(%rbp),%rax\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nshr    $0x10,%eax\nxor    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nimul   $0x85ebca6b,%eax,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nshr    $0xd,%eax\nxor    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nimul   $0xc2b2ae35,%eax,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nshr    $0x10,%eax\nxor    %eax,-0x1c(%rbp)\nmov    -0x30(%rbp),%rax\nsub    $0x1,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nand    -0x8(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x11d\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    0xde\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%rax\nmov    %rax,(%rdx)\nmov    $0x1,%eax\njmp    0x153\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\ncmp    %rax,-0x38(%rbp)\njne    0x101\nmov    $0x0,%eax\njmp    0x153\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nadd    $0x1,%rax\nand    -0x8(%rbp),%rax\nmov    %rax,-0x18(%rbp)\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njbe    0xa2\nlea    0x0(%rip),%rax        # 0x132\nmov    %rax,%rcx\nmov    $0x2c,%edx\nlea    0x0(%rip),%rax        # 0x141\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x14b\nmov    %rax,%rdi\ncall   0x153\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x1a8\ncmpl   $0xffff,-0x8(%rbp)\njne    0x1a8\nlea    0x0(%rip),%rax        # 0x17d\nmov    %rax,%rdi\ncall   0x185\nlea    0x0(%rip),%rax        # 0x18c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x196\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x1a0\nmov    %rax,%rdi\ncall   0x1a8\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x155\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_109",
        "query_text": "The function takes two inputs: a string (passed by constant reference) and a pointer to an output stream. It checks that the string is non-empty and that the output stream pointer is not null. If both conditions are met, the function appends the string to the output stream, preceded by a comma and a space. The function returns no value.",
        "code_id": "c_group_1_id_109",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x1f\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2a\ntest   %al,%al\nje     0x3c\ncmpq   $0x0,-0x10(%rbp)\nje     0x3c\nmov    $0x1,%eax\njmp    0x41\nmov    $0x0,%eax\ntest   %al,%al\nje     0x6d\nmov    -0x10(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x50\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x5b\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x6d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc3\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc3\nlea    0x0(%rip),%rax        # 0x98\nmov    %rax,%rdi\ncall   0xa0\nlea    0x0(%rip),%rax        # 0xa7\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xbb\nmov    %rax,%rdi\ncall   0xc3\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x70\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nxor    $0x1,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\ntest   %eax,%eax\nsete   %al\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_207",
        "query_text": "The function accepts a single input, a non-negative integer representing the size of a memory block to be allocated. It allocates a memory block of the given size using a standard memory allocation mechanism, and returns a pointer referencing the beginning of the allocated block. If the allocation is unsuccessful, the function returns a null pointer.",
        "code_id": "c_group_1_id_207",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x71\ncmpl   $0xffff,-0x8(%rbp)\njne    0x71\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdi\ncall   0x4e\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_211",
        "query_text": "The function accepts a pointer to a file stream object as input and calls the standard routine to close the associated file. It ensures that any buffered data is flushed to the file and that the file is no longer available for further operations. The function does not return any value.",
        "code_id": "c_group_1_id_211",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x72\ncmpl   $0xffff,-0x8(%rbp)\njne    0x72\nlea    0x0(%rip),%rax        # 0x47\nmov    %rax,%rdi\ncall   0x4f\nlea    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdi\ncall   0x72\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_201",
        "query_text": "The function accepts two inputs of type constant void pointer, each expected to reference an integer value. It retrieves the integer values and compares them. It returns an integer: -1 if the first value is less than the second, 0 if they are equal, and 1 if the first value is greater than the second. This comparator function is commonly used in sorting and searching algorithms to determine the order between elements.",
        "code_id": "c_group_1_id_201",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    0x31\nmov    $0xffffffff,%eax\njmp    0x45\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njne    0x40\nmov    $0x0,%eax\njmp    0x45\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9a\nlea    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rdi\ncall   0x77\nlea    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x88\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x92\nmov    %rax,%rdi\ncall   0x9a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x47\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_216",
        "query_text": "The function accepts a double-precision floating-point number as input and returns a double-precision floating-point number that represents the nearest integer value to the input. It computes this result by adding 0.5 to the given value and then applying the floor operation to round down to the nearest integer.",
        "code_id": "c_group_1_id_216",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x1e\n\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   0x31\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x90\ncmpl   $0xffff,-0x8(%rbp)\njne    0x90\nlea    0x0(%rip),%rax        # 0x65\nmov    %rax,%rdi\ncall   0x6d\nlea    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x88\nmov    %rax,%rdi\ncall   0x90\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_209",
        "query_text": "The function takes a 16-bit unsigned integer as input and returns a 16-bit unsigned integer with its byte order reversed. It swaps the two constituent bytes so that the least significant byte becomes the most significant and vice versa, which is useful for converting between big-endian and little-endian data formats.",
        "code_id": "c_group_1_id_209",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %ax,-0x4(%rbp)\nmovzwl -0x4(%rbp),%eax\nshl    $0x8,%eax\nmov    %eax,%edx\nmovzwl -0x4(%rbp),%eax\nshr    $0x8,%ax\nor     %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x76\ncmpl   $0xffff,-0x8(%rbp)\njne    0x76\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdi\ncall   0x53\nlea    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rdi\ncall   0x76\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x23\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_104",
        "query_text": "The function accepts a volatile constant pointer to a void type as input. It converts this pointer by removing the volatile qualifier while preserving the constant qualifier, and then returns the resulting constant pointer. This enables use of the pointer in scenarios where a non-volatile pointer is required without modifying the underlying data.",
        "code_id": "c_group_1_id_104",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x65\ncmpl   $0xffff,-0x8(%rbp)\njne    0x65\nlea    0x0(%rip),%rax        # 0x3a\nmov    %rax,%rdi\ncall   0x42\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdi\ncall   0x65\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x12\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_208",
        "query_text": "The function accepts a pointer to a memory block (expressed as a void pointer) and frees the allocated memory so that it can be reused in the future. It does not return any value.",
        "code_id": "c_group_1_id_208",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x72\ncmpl   $0xffff,-0x8(%rbp)\njne    0x72\nlea    0x0(%rip),%rax        # 0x47\nmov    %rax,%rdi\ncall   0x4f\nlea    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdi\ncall   0x72\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_97",
        "query_text": "The function takes a single character as input and determines whether it is alphanumeric\u2014that is, whether it is a letter (uppercase or lowercase) or a digit (0\u20139). If the character is alphanumeric, the function returns true; otherwise, it returns false. The input type is char, and the output is a boolean value.",
        "code_id": "c_group_1_id_97",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   0x1f\ntest   %eax,%eax\nsetne  %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_214",
        "query_text": "The function accepts a floating-point input of type double and returns a boolean value. It determines whether the input is \u201cNot a Number\u201d (NaN) by using a platform-dependent strategy. Initially, the function checks for compiler-specific conditions: in certain environments (such as specific Microsoft or Borland compiler versions), it directly calls a built-in function to test for NaN. In other cases, it utilizes a classification method (comparing against a constant that denotes NaN) if such macros are available. As a final fallback, the function takes advantage of the fact that a NaN value does not compare equal to itself. If any of these methods confirm that the value is NaN, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_214",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovsd  -0x8(%rbp),%xmm1\nucomisd %xmm1,%xmm0\nsetp   %al\nmov    $0x1,%edx\nucomisd %xmm1,%xmm0\ncmovne %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x89\ncmpl   $0xffff,-0x8(%rbp)\njne    0x89\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nlea    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x77\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x81\nmov    %rax,%rdi\ncall   0x89\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x36\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_203",
        "query_text": "The function accepts three pointer parameters. Two of these pointers reference boolean values, and the third points to a memory location where the result is to be stored. It performs a logical AND operation on the two boolean values and writes the resulting boolean value to the output memory location. The function does not return any value.",
        "code_id": "c_group_1_id_203",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0x2(%rbp)\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\ncmpb   $0x0,-0x2(%rbp)\nje     0x3b\ncmpb   $0x0,-0x1(%rbp)\nje     0x3b\nmov    $0x1,%edx\njmp    0x40\nmov    $0x0,%edx\nmov    -0x28(%rbp),%rax\nmov    %dl,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9c\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nlea    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x94\nmov    %rax,%rdi\ncall   0x9c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x49\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_58",
        "query_text": "The function takes no input parameters and returns a boolean value. It is declared as a constant expression function (constexpr), allowing its return value to be determined at compile time. The constant output is the boolean value true, which serves as a marker to signal that a particular feature is deprecated.",
        "code_id": "c_group_1_id_58",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_187",
        "query_text": "The function receives three inputs: a pointer to a memory location, a size indicating the number of bytes to write, and a file pointer. It writes the specified number of bytes from the memory location to the file using a file-writing mechanism determined by the platform and configuration. The function then returns a boolean (true or false) indicating whether the exact number of bytes were successfully written. Internally, it utilizes a platform-specific or standard file writing routine depending on the compilation environment.",
        "code_id": "c_group_1_id_187",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rcx\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   0x31\ncmp    %rax,-0x10(%rbp)\nsete   %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8d\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdi\ncall   0x6a\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x85\nmov    %rax,%rdi\ncall   0x8d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_199",
        "query_text": "The function takes an integer input that represents a file descriptor. If this input is valid (i.e., not -1), the function directs the standard error stream back to its original destination by duplicating this descriptor to the standard error output and subsequently closing the original descriptor. It returns no value, as its primary purpose is to restore the standard error stream to its prior state.",
        "code_id": "c_group_1_id_199",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\ncmpl   $0xffffffff,-0x4(%rbp)\nje     0x2e\nmov    -0x4(%rbp),%eax\nmov    $0x2,%esi\nmov    %eax,%edi\ncall   0x24\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   0x2e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x84\ncmpl   $0xffff,-0x8(%rbp)\njne    0x84\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rdi\ncall   0x84\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x31\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_102",
        "query_text": "The function takes two string inputs: one specifying a file path and the other specifying a file-mode indicator (such as \"r\" for read or \"w\" for write). On Windows systems (when not using a specific alternative compiler), it first converts these strings into wide-character format before attempting to open the file. On other systems, it directly opens the file using the provided strings. It returns a pointer to the opened file for later use.",
        "code_id": "c_group_1_id_102",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7c\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,%rdi\ncall   0x59\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdi\ncall   0x7c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x29\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_200",
        "query_text": "The function takes a pointer (of generic type, expected to reference an integer) as input and returns a pointer to a newly allocated integer. It first allocates dynamic memory for an integer and then, if both the allocation succeeds and the input pointer is not null, it copies the value from the referenced integer to the allocated location. Finally, it returns the pointer to this newly created integer.",
        "code_id": "c_group_1_id_200",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    $0x4,%edi\ncall   0x1a\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     0x38\ncmpq   $0x0,-0x18(%rbp)\nje     0x38\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x91\ncmpl   $0xffff,-0x8(%rbp)\njne    0x91\nlea    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdi\ncall   0x6e\nlea    0x0(%rip),%rax        # 0x75\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x89\nmov    %rax,%rdi\ncall   0x91\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_210",
        "query_text": "The function takes no input parameters and determines the system's byte order. It initializes an integer with the value 1, then inspects the first byte of its memory representation. If that byte equals 1, the function concludes that the system is using little-endian byte ordering and returns true; otherwise, it returns false. The output is a boolean value.",
        "code_id": "c_group_1_id_210",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x1,-0xc(%rbp)\nlea    -0xc(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x1,%al\nsete   %al\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x42\ncall   0x42\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x97\ncmpl   $0xffff,-0x8(%rbp)\njne    0x97\nlea    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rdi\ncall   0x74\nlea    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x85\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8f\nmov    %rax,%rdi\ncall   0x97\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x44\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_215",
        "query_text": "The function takes two pointers that specify the bounds of a character array: one for the beginning and one for the end. It then iterates backwards from the end pointer, decrementing it as long as it has not reached the beginning and the character immediately before the end is a '0'. Once a character other than '0' is found (or the beginning is reached), the function writes a null character at the current end pointer position to mark the new end of the array. This process effectively removes any trailing '0' characters from the array.",
        "code_id": "c_group_1_id_215",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\njmp    0x17\nsubq   $0x1,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nje     0x30\nmov    -0x10(%rbp),%rax\nsub    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\nje     0x12\nmov    -0x10(%rbp),%rax\nmovb   $0x0,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8d\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdi\ncall   0x6a\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x85\nmov    %rax,%rdi\ncall   0x8d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_206",
        "query_text": "The function accepts an output stream reference and a pointer to a format string as its inputs. It iterates through the string character by character, writing the processed segment to the output stream. When the function encounters the null terminator (which marks the end of the string), it writes out the accumulated portion and returns a pointer to the end of the string. Alternatively, if it encounters a '%' character that is not immediately followed by another '%', it writes the processed portion up to that point and returns a pointer to the '%' character. In cases where the '%' is immediately followed by another '%', the function treats this as an escape sequence and continues processing the remaining characters.",
        "code_id": "c_group_1_id_206",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x4b\nmov    -0x8(%rbp),%rax\nsub    -0x20(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x45\nmov    -0x8(%rbp),%rax\njmp    0xa0\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x25,%al\njne    0x96\nmov    -0x8(%rbp),%rax\nsub    -0x20(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x25,%al\nje     0x89\nmov    -0x8(%rbp),%rax\njmp    0xa0\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x20(%rbp)\naddq   $0x1,-0x8(%rbp)\njmp    0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xf5\ncmpl   $0xffff,-0x8(%rbp)\njne    0xf5\nlea    0x0(%rip),%rax        # 0xca\nmov    %rax,%rdi\ncall   0xd2\nlea    0x0(%rip),%rax        # 0xd9\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xe3\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xed\nmov    %rax,%rdi\ncall   0xf5\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xa2\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_212",
        "query_text": "The function takes two string inputs: one representing the file path and the other indicating the file open mode (for example, \"r\" for read or \"w\" for write). It returns a pointer to a file object, which signifies that the file has been successfully opened. The function employs a platform-specific implementation: on certain platforms that support a secure file-opening method, it uses that for additional safety; on other platforms, it uses the standard file-opening routine. If the file cannot be opened, the function returns NULL.",
        "code_id": "c_group_1_id_212",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7c\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,%rdi\ncall   0x59\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdi\ncall   0x7c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x29\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_204",
        "query_text": "The function takes two generic pointer inputs and compares the integer values they reference by subtracting the second from the first. It returns an int that is negative if the referenced value of the first pointer is smaller, zero if they are equal, and positive if the first value is larger. This design makes it suitable for use as a comparator in standard sorting routines.",
        "code_id": "c_group_1_id_204",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x75\ncmpl   $0xffff,-0x8(%rbp)\njne    0x75\nlea    0x0(%rip),%rax        # 0x4a\nmov    %rax,%rdi\ncall   0x52\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x63\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rdi\ncall   0x75\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x22\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_217",
        "query_text": "The function receives a double-precision floating-point number as input and produces an output of type double. It evaluates the received value to determine if it falls between -0.5 and 0 (inclusive). If the value is within this range, the function rounds it towards zero using a ceiling operation; otherwise, it rounds the value to the nearest integer by applying a floor operation to the input value after adding an offset of 0.5. The final result, in double-precision, is then returned.",
        "code_id": "c_group_1_id_217",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\ncomisd 0x0(%rip),%xmm0        # 0x1e\n\njb     0x40\npxor   %xmm0,%xmm0\ncomisd -0x8(%rbp),%xmm0\njb     0x40\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   0x39\nmovq   %xmm0,%rax\njmp    0x65\nmovsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x4d\n\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   0x60\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xbf\ncmpl   $0xffff,-0x8(%rbp)\njne    0xbf\nlea    0x0(%rip),%rax        # 0x94\nmov    %rax,%rdi\ncall   0x9c\nlea    0x0(%rip),%rax        # 0xa3\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xad\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb7\nmov    %rax,%rdi\ncall   0xbf\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x6c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_101",
        "query_text": "The function takes a char as input and returns a char as output. It converts the provided character to its uppercase equivalent by first casting it to an unsigned type to prevent issues with negative values, then applying a standard uppercase conversion operation, and finally casting the result back to a char before returning it.",
        "code_id": "c_group_1_id_101",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   0x1f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x74\ncmpl   $0xffff,-0x8(%rbp)\njne    0x74\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rdi\ncall   0x51\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rdi\ncall   0x74\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x21\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_110",
        "query_text": "The function accepts a single integer input and returns a string that represents the frequency of an occurrence. When the input is 1, the function returns the string \"once\"; when the input is 2, it returns \"twice\". For any other integer value, the function constructs a string by concatenating the input value with the literal \" times\". The input parameter is of type int, and the output is of type std::string.",
        "code_id": "c_group_1_id_110",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x1b8,%rsp\nmov    %rdi,-0x1b8(%rbp)\nmov    %esi,-0x1bc(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\ncmpl   $0x1,-0x1bc(%rbp)\njne    0x78\nlea    -0x1a1(%rbp),%rax\nmov    %rax,%rdi\ncall   0x44\nlea    -0x1a1(%rbp),%rdx\nmov    -0x1b8(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x59\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x64\nlea    -0x1a1(%rbp),%rax\nmov    %rax,%rdi\ncall   0x73\njmp    0x191\ncmpl   $0x2,-0x1bc(%rbp)\njne    0xc4\nlea    -0x1a1(%rbp),%rax\nmov    %rax,%rdi\ncall   0x90\nlea    -0x1a1(%rbp),%rdx\nmov    -0x1b8(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0xa5\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0xb0\nlea    -0x1a1(%rbp),%rax\nmov    %rax,%rdi\ncall   0xbf\njmp    0x191\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rdi\ncall   0xd3\nmov    -0x1bc(%rbp),%eax\nlea    -0x1a0(%rbp),%rdx\nadd    $0x10,%rdx\nmov    %eax,%esi\nmov    %rdx,%rdi\ncall   0xee\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xf8\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x103\nmov    -0x1b8(%rbp),%rax\nlea    -0x1a0(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x11c\nnop\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x12c\njmp    0x191\nendbr64 \nmov    %rax,%rbx\nlea    -0x1a1(%rbp),%rax\nmov    %rax,%rdi\ncall   0x144\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x14f\nendbr64 \nmov    %rax,%rbx\nlea    -0x1a1(%rbp),%rax\nmov    %rax,%rdi\ncall   0x165\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x170\nendbr64 \nmov    %rax,%rbx\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x186\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x191\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x1a5\ncall   0x1a5\nmov    -0x1b8(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x205\ncmpl   $0xffff,-0x8(%rbp)\njne    0x205\nlea    0x0(%rip),%rax        # 0x1da\nmov    %rax,%rdi\ncall   0x1e2\nlea    0x0(%rip),%rax        # 0x1e9\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x1f3\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x1fd\nmov    %rax,%rdi\ncall   0x205\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b2\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_228",
        "query_text": "The function accepts a single character as input and returns a boolean value indicating whether the character represents a non-zero digit. It does so by verifying if the character falls within the ASCII range corresponding to the digits 1 through 9. If the character meets this criterion, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_228",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x30,-0x4(%rbp)\njle    0x20\ncmpb   $0x39,-0x4(%rbp)\njg     0x20\nmov    $0x1,%eax\njmp    0x25\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7a\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdi\ncall   0x57\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x27\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_237",
        "query_text": "The function accepts an array of double values along with several integer parameters that define the lengths of both the input and output arrays as well as stride values for indexing. It also receives two separate arrays of double filter coefficients for low-pass and high-pass filtering. The function iterates over the specified indices of the output arrays and, for each position, computes weighted sums by applying both filters to the appropriately indexed elements of the input array. Special care is taken to handle boundary conditions, ensuring proper indexing even when the computed positions fall outside the usual range (by wrapping around or applying conditional adjustments). The computed values are stored in the output arrays in place, with no value returned by the function. The primary purpose of the function is to perform dual filtering on an input array and output the resulting low-pass and high-pass filtered arrays using the provided stride and boundary management.",
        "code_id": "c_group_1_id_237",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x34(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %edx,-0x38(%rbp)\nmov    %rcx,-0x48(%rbp)\nmov    %r8,-0x50(%rbp)\nmov    %r9d,-0x54(%rbp)\nmov    -0x34(%rbp),%eax\nimul   -0x54(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x14(%rbp)\nmov    -0x38(%rbp),%eax\ncltd   \nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nmov    %eax,-0x10(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    0x6cf\nmov    -0x20(%rbp),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x20(%rbp),%eax\nimul   0x30(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0xffffffff,-0x24(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    0x6bf\naddl   $0x1,-0x24(%rbp)\njmp    0xc0\nmov    0x18(%rbp),%eax\nsub    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    0x18(%rbp),%eax\njge    0xba\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncmp    %eax,-0x14(%rbp)\njg     0x1ca\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncmp    %eax,-0x38(%rbp)\njle    0x1ca\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\nmov    0x28(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x6b9\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncmp    %eax,-0x14(%rbp)\njle    0x2cb\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ntest   %eax,%eax\njs     0x2cb\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\nmov    0x28(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x6b9\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ntest   %eax,%eax\njns    0x3c4\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\nmov    %eax,%edx\nmov    -0x38(%rbp),%eax\nadd    %eax,%edx\nmov    0x28(%rbp),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x6b9\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncmp    %eax,-0x38(%rbp)\njg     0x4c4\ncmpl   $0x0,-0x10(%rbp)\njne    0x4c4\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\nsub    -0x38(%rbp),%eax\nmov    0x28(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x6b9\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncmp    %eax,-0x38(%rbp)\njg     0x6b9\ncmpl   $0x1,-0x10(%rbp)\njne    0x6b9\nmov    -0xc(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncmp    %eax,-0x38(%rbp)\nje     0x5da\nmov    -0xc(%rbp),%eax\nsub    -0x1c(%rbp),%eax\nmov    -0x38(%rbp),%edx\nlea    0x1(%rdx),%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    0x28(%rbp),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x6b9\nmov    -0x38(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    0x28(%rbp),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x38(%rbp),%eax\ncltq   \nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x20(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x34(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     0xb4\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    0x18(%rbp),%eax\njl     0x54\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x732\ncmpl   $0xffff,-0x8(%rbp)\njne    0x732\nlea    0x0(%rip),%rax        # 0x707\nmov    %rax,%rdi\ncall   0x70f\nlea    0x0(%rip),%rax        # 0x716\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x720\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x72a\nmov    %rax,%rdi\ncall   0x732\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x6df\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_59",
        "query_text": "The function accepts a single parameter\u2014a 16-bit character value\u2014and returns a constant pointer to a null-terminated string. Regardless of the input value, it consistently returns the string \"u\". The function performs no additional operations or conditional logic, making its behavior invariant to the provided input.",
        "code_id": "c_group_1_id_59",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %ax,-0x4(%rbp)\nlea    0x0(%rip),%rax        # 0x15\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6a\nlea    0x0(%rip),%rax        # 0x3f\nmov    %rax,%rdi\ncall   0x47\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdi\ncall   0x6a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x17\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_235",
        "query_text": "The function accepts three parameters: a pointer to a constant array of double-precision floating-point numbers, an integer representing the number of elements in the array, and a pointer to an array of doubles for the output. It iterates through the input array in reverse order, copying each element to the corresponding position in the output array; additionally, if the current index is odd, the function negates the copied value. The output array maintains the same size as the input array, and the function itself does not alter the original input array.",
        "code_id": "c_group_1_id_235",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0xa0\nmov    -0x1c(%rbp),%eax\nsub    -0x4(%rbp),%eax\ncltq   \nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rcx\n\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     0x9c\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovq   0x0(%rip),%xmm1        # 0x94\n\nxorpd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x23\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x103\ncmpl   $0xffff,-0x8(%rbp)\njne    0x103\nlea    0x0(%rip),%rax        # 0xd8\nmov    %rax,%rdi\ncall   0xe0\nlea    0x0(%rip),%rax        # 0xe7\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xf1\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xfb\nmov    %rax,%rdi\ncall   0x103\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_106",
        "query_text": "The function accepts two parameters: one is a pointer to a constant character array, and the other is also a pointer to a constant character array. It first checks whether either pointer is NULL; if so, it returns true only if both pointers are NULL. Otherwise, it employs a string search function to determine if the first string exists within the second string. If the specified substring is found, it returns true; if not, it returns false.",
        "code_id": "c_group_1_id_106",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     0x22\ncmpq   $0x0,-0x10(%rbp)\njne    0x2f\nmov    -0x8(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nsete   %al\njmp    0x48\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x42\ntest   %rax,%rax\nsetne  %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9d\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nlea    0x0(%rip),%rax        # 0x81\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x95\nmov    %rax,%rdi\ncall   0x9d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x4a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_240",
        "query_text": "The function takes an integer input and returns its absolute value as an integer. It first checks if the input is non-negative; if so, it returns the input directly. Otherwise, it returns the negated value, effectively converting any negative number into a positive one.",
        "code_id": "c_group_1_id_240",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njs     0x16\nmov    -0x4(%rbp),%eax\njmp    0x1b\nmov    -0x4(%rbp),%eax\nneg    %eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x70\ncmpl   $0xffff,-0x8(%rbp)\njne    0x70\nlea    0x0(%rip),%rax        # 0x45\nmov    %rax,%rdi\ncall   0x4d\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x68\nmov    %rax,%rdi\ncall   0x70\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_238",
        "query_text": "The function takes several inputs that include two arrays of double-precision floating-point numbers and a filter array, along with various integer parameters to control stride and length. It processes the two input arrays by computing a weighted sum of their elements using the provided filter values, where the weights for the two arrays are taken from different segments of the filter array. The computation is performed using designated input and output strides, and the algorithm employs circular indexing to wrap around the input arrays as needed. The result of the transformation is stored in an output array of double-precision floating-point numbers. \n\nInputs:\n- An integer used as a multiplier for index transformation.\n- Two arrays of double-precision floating-point numbers for coefficients and details.\n- An integer representing the length of the first array.\n- An array of double-precision floating-point numbers representing filter weights.\n- An integer indicating the length of the filter array.\n- Two integers specifying the input and output strides.\n\nOutput:\n- An array of double-precision floating-point numbers containing the computed results.\n\nThe function serves as a black box to perform the transformation of the input arrays into an output array by applying the filter weights in a cyclic manner, without requiring knowledge of the underlying algorithm details.",
        "code_id": "c_group_1_id_238",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x28(%rbp)\nmov    %rcx,-0x38(%rbp)\nmov    %r8,-0x40(%rbp)\nmov    %r9d,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    0x1b1\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x18(%rbp),%eax\nimul   0x20(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\nimul   0x18(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x40(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x1,-0x14(%rbp)\njmp    0x1a1\nmov    -0x24(%rbp),%eax\nadd    %eax,-0x10(%rbp)\njmp    0xd8\nmov    -0x28(%rbp),%eax\nsub    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x28(%rbp),%eax\njge    0xd2\njmp    0xe8\nmov    -0x28(%rbp),%eax\nadd    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njs     0xe2\nmov    -0x10(%rbp),%eax\nimul   0x18(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm0,%xmm2\nmov    -0xc(%rbp),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm3\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm3,%xmm0\naddsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x10(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     0xca\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x28(%rbp),%eax\njl     0x30\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x214\ncmpl   $0xffff,-0x8(%rbp)\njne    0x214\nlea    0x0(%rip),%rax        # 0x1e9\nmov    %rax,%rdi\ncall   0x1f1\nlea    0x0(%rip),%rax        # 0x1f8\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x202\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x20c\nmov    %rax,%rdi\ncall   0x214\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1c1\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_239",
        "query_text": "The function accepts an integer as input and returns an integer as output. It evaluates whether the provided integer is non-negative or negative. If the input is non-negative, the function returns 1, and if negative, it returns -1. Its primary purpose is to determine and output the sign of the input integer.",
        "code_id": "c_group_1_id_239",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njs     0x1a\nmovl   $0x1,-0x4(%rbp)\njmp    0x21\nmovl   $0xffffffff,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_236",
        "query_text": "The function accepts an array of double precision numbers along with two filter arrays used for transformation, as well as stride values for indexing. It processes the input array in discrete steps, computing two output arrays: one that represents a smoothed (averaged) version of the input and another that captures finer, detailed variations. For each step, the function multiplies elements from the input by corresponding filter coefficients, summing the results into the respective outputs. To correctly handle the boundaries of the input array, it employs modular arithmetic, ensuring indices wrap around as needed. The overall inputs include the input array's length, the filter arrays partitioned appropriately, and stride parameters, while the outputs are the two resulting arrays of double precision numbers.",
        "code_id": "c_group_1_id_236",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x28(%rbp)\nmov    %rcx,-0x38(%rbp)\nmov    %r8d,-0x3c(%rbp)\nmov    %r9,-0x48(%rbp)\nmov    -0x3c(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    0x1ff\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x14(%rbp),%eax\nimul   0x28(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\nimul   0x20(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x1,-0x18(%rbp)\njmp    0x1ef\nmov    -0x24(%rbp),%eax\nsub    %eax,-0x10(%rbp)\njmp    0xec\nmov    0x10(%rbp),%eax\nsub    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    0x10(%rbp),%eax\njge    0xe6\njmp    0xfc\nmov    0x10(%rbp),%eax\nadd    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njs     0xf6\nmov    -0x14(%rbp),%eax\nimul   0x28(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\nimul   0x20(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0xc(%rbp),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     0xde\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    0x10(%rbp),%eax\njl     0x30\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x262\ncmpl   $0xffff,-0x8(%rbp)\njne    0x262\nlea    0x0(%rip),%rax        # 0x237\nmov    %rax,%rdi\ncall   0x23f\nlea    0x0(%rip),%rax        # 0x246\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x250\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x25a\nmov    %rax,%rdi\ncall   0x262\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x20f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_261",
        "query_text": "The function receives an unsigned integer and a boolean as inputs and returns a boolean value. It starts by checking if the boolean input is true; if so, it returns true immediately. If not, the function shifts the unsigned integer right by 5 bits and compares this result with the value 0x1B. If the shifted value is not equal to 0x1B, it returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_261",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,%eax\nmov    %al,-0x8(%rbp)\ncmpb   $0x0,-0x8(%rbp)\njne    0x21\nmov    -0x4(%rbp),%eax\nshr    $0x5,%eax\ncmp    $0x1b,%eax\nje     0x28\nmov    $0x1,%eax\njmp    0x2d\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x82\ncmpl   $0xffff,-0x8(%rbp)\njne    0x82\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rdi\ncall   0x5f\nlea    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x70\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7a\nmov    %rax,%rdi\ncall   0x82\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_108",
        "query_text": "The function accepts three parameters: a pointer to a constant character array representing a string, a pointer to a constant character array representing a flag name, and a boolean value indicating whether an associated value with the flag is optional. It first constructs a flag pattern by concatenating a predefined prefix with the provided flag name, then checks if the input string starts with this pattern. If the string does not begin with the expected flag pattern, the function returns a null pointer. Once the pattern is matched, the function examines the character immediately following the flag pattern. If the flag value is optional and the flag pattern is immediately followed by the end of the string, it returns a pointer to that position. Otherwise, it checks whether the character following the flag pattern is an equals sign; if it is, the pointer is advanced past the equals sign and returned as the position where the flag value starts, and if not, a null pointer is returned.",
        "code_id": "c_group_1_id_108",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0xb8,%rsp\nmov    %rdi,-0xa8(%rbp)\nmov    %rsi,-0xb0(%rbp)\nmov    %edx,%eax\nmov    %al,-0xb4(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\ncmpq   $0x0,-0xa8(%rbp)\n\nje     0x49\ncmpq   $0x0,-0xb0(%rbp)\n\njne    0x53\nmov    $0x0,%ebx\njmp    0x189\nlea    -0x91(%rbp),%rax\nmov    %rax,%rdi\ncall   0x62\nlea    -0x91(%rbp),%rdx\nlea    -0x60(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x74\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x7f\nlea    -0x40(%rbp),%rax\nlea    -0x60(%rbp),%rcx\nlea    0x0(%rip),%rdx        # 0x8e\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x99\nlea    -0x80(%rbp),%rax\nmov    -0xb0(%rbp),%rdx\nlea    -0x40(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0xb3\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0xbf\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nlea    -0x91(%rbp),%rax\nmov    %rax,%rdi\ncall   0xda\nlea    -0x80(%rbp),%rax\nmov    %rax,%rdi\ncall   0xe6\nmov    %rax,-0x90(%rbp)\nlea    -0x80(%rbp),%rax\nmov    %rax,%rdi\ncall   0xf9\nmov    %rax,%rcx\nmov    -0x90(%rbp),%rdx\nmov    -0xa8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x115\ntest   %eax,%eax\nsetne  %al\ntest   %al,%al\nje     0x125\nmov    $0x0,%ebx\njmp    0x17d\nmov    -0xa8(%rbp),%rdx\nmov    -0x90(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x88(%rbp)\ncmpb   $0x0,-0xb4(%rbp)\nje     0x15d\nmov    -0x88(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x15d\nmov    -0x88(%rbp),%rbx\njmp    0x17d\nmov    -0x88(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x3d,%al\nje     0x172\nmov    $0x0,%ebx\njmp    0x17d\nmov    -0x88(%rbp),%rax\nlea    0x1(%rax),%rbx\nlea    -0x80(%rbp),%rax\nmov    %rax,%rdi\ncall   0x189\nmov    %rbx,%rax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x1ed\njmp    0x1e8\nendbr64 \nmov    %rax,%rbx\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1b0\njmp    0x1b9\nendbr64 \nmov    %rax,%rbx\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c5\njmp    0x1ce\nendbr64 \nmov    %rax,%rbx\nlea    -0x91(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1dd\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x1e8\ncall   0x1ed\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x246\ncmpl   $0xffff,-0x8(%rbp)\njne    0x246\nlea    0x0(%rip),%rax        # 0x21b\nmov    %rax,%rdi\ncall   0x223\nlea    0x0(%rip),%rax        # 0x22a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x234\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x23e\nmov    %rax,%rdi\ncall   0x246\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1f3\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2b\nmov    %rax,%rdi\ncall   0x33\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x45\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_166",
        "query_text": "The function takes no arguments and returns no value. It conditionally disables logging by checking for a specific preprocessor directive. If the directive is defined, the function sets a flag to 0 to turn off logging; otherwise, it leaves the logging functionality unchanged.",
        "code_id": "c_group_1_id_166",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_256",
        "query_text": "The function accepts an array of character pointers and two integers marking a range within the array. It reverses the order of the elements in the specified subarray (starting at the first index and ending just before the second index), by swapping elements symmetrically from the ends toward the center. The operation is performed in place, modifying the original array without returning any value.",
        "code_id": "c_group_1_id_256",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\njmp    0x81\nmov    -0x1c(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x20(%rbp),%eax\ncltq   \nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\nmov    -0x20(%rbp),%eax\ncltq   \nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nsubl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncmp    $0x1,%eax\njg     0x14\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xe3\ncmpl   $0xffff,-0x8(%rbp)\njne    0xe3\nlea    0x0(%rip),%rax        # 0xb8\nmov    %rax,%rdi\ncall   0xc0\nlea    0x0(%rip),%rax        # 0xc7\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xd1\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xdb\nmov    %rax,%rdi\ncall   0xe3\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x90\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_105",
        "query_text": "The function takes three parameters: a string-like container, a pointer to a character array representing a pattern, and a pointer marking the end of the pattern. It checks whether the string conforms to the pattern using wildcard matching. The pattern may include two wildcards: one that matches any single character and another that matches zero or more characters. The function iterates through both the string and the pattern, comparing characters and applying the wildcard rules. If the entire string successfully matches the pattern, it returns a boolean true; if not, it returns false.",
        "code_id": "c_group_1_id_105",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x24\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3c\nmov    -0x28(%rbp),%rdx\nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x40(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x18(%rbp)\njmp    0x104\nmov    -0x40(%rbp),%rax\ncmp    -0x48(%rbp),%rax\njae    0xd7\nmov    -0x40(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncmp    $0x2a,%eax\nje     0xb8\ncmp    $0x3f,%eax\nje     0xa2\nmov    -0x28(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njae    0xd3\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x40(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    0xd3\naddq   $0x1,-0x40(%rbp)\naddq   $0x1,-0x28(%rbp)\njmp    0x104\nmov    -0x28(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njae    0xd6\naddq   $0x1,-0x40(%rbp)\naddq   $0x1,-0x28(%rbp)\njmp    0x104\nmov    -0x40(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x18(%rbp)\naddq   $0x1,-0x40(%rbp)\njmp    0x104\nnop\njmp    0xd7\nnop\nmov    -0x10(%rbp),%rax\ncmp    -0x18(%rbp),%rax\njae    0xfd\nmov    -0x18(%rbp),%rax\ncmp    -0x8(%rbp),%rax\nja     0xfd\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x28(%rbp)\njmp    0x104\nmov    $0x0,%eax\njmp    0x125\nmov    -0x40(%rbp),%rax\ncmp    -0x48(%rbp),%rax\njb     0x5c\nmov    -0x28(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njb     0x5c\nmov    $0x1,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x17a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x17a\nlea    0x0(%rip),%rax        # 0x14f\nmov    %rax,%rdi\ncall   0x157\nlea    0x0(%rip),%rax        # 0x15e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x168\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x172\nmov    %rax,%rdi\ncall   0x17a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x127\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_241",
        "query_text": "The function accepts two inputs: pointers to double values provided via generic pointer types. It compares the underlying double values and returns an integer indicating their ordering. Specifically, it returns -1 if the first value is smaller than the second, 1 if the first value is larger, and 0 if the two values are equal. This comparator is typically used for sorting or searching operations.",
        "code_id": "c_group_1_id_241",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\ncomisd -0x10(%rbp),%xmm0\njbe    0x3d\nmov    $0xffffffff,%eax\njmp    0x55\nmovsd  -0x10(%rbp),%xmm0\ncomisd -0x8(%rbp),%xmm0\njbe    0x50\nmov    $0x1,%eax\njmp    0x55\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xaa\ncmpl   $0xffff,-0x8(%rbp)\njne    0xaa\nlea    0x0(%rip),%rax        # 0x7f\nmov    %rax,%rdi\ncall   0x87\nlea    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x98\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xa2\nmov    %rax,%rdi\ncall   0xaa\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x57\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_167",
        "query_text": "The function takes a constant character string as input and, when a specific debugging flag is enabled, assigns the input string to an internal logging prefix used for debug output. If the debugging flag is not enabled, the input is disregarded and no action is taken. The function does not produce a return value.",
        "code_id": "c_group_1_id_167",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_250",
        "query_text": "The function resets the locale settings for the calling thread to a default or global state, adapting its approach based on the system capabilities. On Windows platforms (excluding certain environments like MinGW), it disables per-thread locale settings, thereby reverting to the global locale. On POSIX-compliant systems that support specific locale APIs, it switches the thread's locale to the global one and then releases the associated locale object. If neither mechanism is available, it outputs a warning that the thread's locale cannot be modified. The function neither accepts parameters nor returns a value.",
        "code_id": "c_group_1_id_250",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0xffffffffffffffff,%rdi\ncall   0x18\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x28\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7e\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rdi\ncall   0x5b\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x76\nmov    %rax,%rdi\ncall   0x7e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_242",
        "query_text": "The function takes two inputs: a pointer to an array of double-precision floating-point values and an integer representing the count of elements in the array. It iterates over the array, summing all the values, and then divides the total by the number of elements, thereby computing the arithmetic mean. The result is returned as a double-precision floating-point number.",
        "code_id": "c_group_1_id_242",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    0x4b\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x21\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x1c(%rbp),%xmm1\nmovsd  -0x8(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xce\ncmpl   $0xffff,-0x8(%rbp)\njne    0xce\nlea    0x0(%rip),%rax        # 0xa3\nmov    %rax,%rdi\ncall   0xab\nlea    0x0(%rip),%rax        # 0xb2\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xbc\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xc6\nmov    %rax,%rdi\ncall   0xce\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_103",
        "query_text": "The function takes a Unicode character (of type char32_t) as input and writes its hexadecimal Unicode code point representation to an output stream (of type ::std::ostream*). It formats the output as \"U+XXXX\"\u2014where \"XXXX\" is the character's 4-digit uppercase hexadecimal value, padded with leading zeros if necessary\u2014and writes this formatted string to the provided stream.",
        "code_id": "c_group_1_id_103",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x1f\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x34\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x3f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x54\nmov    %rax,%rbx\nmov    $0x30,%edi\ncall   0x61\nmov    %eax,%esi\nmov    %rbx,%rdi\ncall   0x6b\nmov    %rax,%rbx\nmov    $0x4,%edi\ncall   0x78\nmov    %eax,%esi\nmov    %rbx,%rdi\ncall   0x82\nmov    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,%esi\nmov    %rdx,%rdi\ncall   0x92\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xec\ncmpl   $0xffff,-0x8(%rbp)\njne    0xec\nlea    0x0(%rip),%rax        # 0xc1\nmov    %rax,%rdi\ncall   0xc9\nlea    0x0(%rip),%rax        # 0xd0\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xda\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xe4\nmov    %rax,%rdi\ncall   0xec\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x99\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nand    -0x8(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nor     -0x8(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nnot    %eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    -0xc(%rbp),%edx\nmov    %edx,%esi\nmov    %eax,%edi\ncall   0x25\nmov    -0x8(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    -0xc(%rbp),%edx\nmov    %edx,%esi\nmov    %eax,%edi\ncall   0x25\nmov    -0x8(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x18(%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,%esi\nmov    %rdx,%rdi\ncall   0x32\nmov    -0x4(%rbp),%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x18(%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,%edi\ncall   0x2a\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x3e\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   0x4d\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x18,%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x61\nmov    -0x4(%rbp),%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x4000,%esi\nmov    %rax,%rdi\ncall   0x21\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x4a,%edx\nmov    $0x8,%esi\nmov    %rax,%rdi\ncall   0x26\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_196",
        "query_text": "This function accepts two string inputs and produces a string output. It first checks whether the second input is either empty or represents an empty string (i.e., a string containing two double quotes). When this condition is met, it simply returns the first input. Otherwise, it concatenates the first input with a comma and a space followed by the second input, and then returns this concatenated string.",
        "code_id": "c_group_1_id_196",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %rdx,-0x58(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    $0x0,%ebx\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\ntest   %al,%al\njne    0x59\nmov    -0x58(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x4a\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x55\ntest   %al,%al\nje     0x6e\nmov    -0x50(%rbp),%rdx\nmov    -0x48(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x6c\njmp    0xa4\nlea    -0x40(%rbp),%rax\nmov    -0x50(%rbp),%rcx\nlea    0x0(%rip),%rdx        # 0x7d\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x88\nmov    $0x1,%ebx\nmov    -0x48(%rbp),%rax\nmov    -0x58(%rbp),%rdx\nlea    -0x40(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0xa4\ntest   %bl,%bl\nje     0xd8\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0xb4\njmp    0xd8\nendbr64 \nmov    %rax,%r12\ntest   %bl,%bl\nje     0xcd\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcd\nmov    %r12,%rax\nmov    %rax,%rdi\ncall   0xd8\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xed\ncall   0xed\nmov    -0x48(%rbp),%rax\nadd    $0x50,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x14d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x14d\nlea    0x0(%rip),%rax        # 0x122\nmov    %rax,%rdi\ncall   0x12a\nlea    0x0(%rip),%rax        # 0x131\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x13b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x145\nmov    %rax,%rdi\ncall   0x14d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xfa\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2c\nmov    -0x28(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x3f\njmp    0x5f\nendbr64 \nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x54\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x5f\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\ntest   %eax,%eax\nsete   %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2b\nmov    %rax,%rdi\ncall   0x33\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x45\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_161",
        "query_text": "The function accepts a double-precision floating-point number (type double) as input and returns a 32-bit signed integer (type int) as output. Internally, it leverages hardware-accelerated SIMD instructions available in the SSE2 instruction set to load the input value and directly convert it to an integer with accurate rounding to the nearest whole number. This efficient use of SIMD instructions ensures high-performance processing of the floating-point to integer conversion.",
        "code_id": "c_group_1_id_161",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x28(%rbp)\nlea    -0x28(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  -0x18(%rbp),%xmm0\nmovq   %xmm0,%xmm0\nnop\nmovaps %xmm0,-0x10(%rbp)\ncvtsd2si -0x10(%rbp),%eax\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8b\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdi\ncall   0x68\nlea    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x79\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x83\nmov    %rax,%rdi\ncall   0x8b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x38\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_162",
        "query_text": "The function takes a double-precision floating-point number as input and returns an integer. It verifies whether the input lies within a valid range defined by a predetermined constant. Specifically, the function checks if the input is less than the reciprocal of this constant or greater than the constant itself. If the input falls outside this range, the function returns a non-zero value to indicate an invalid condition; otherwise, it returns zero, signifying that the input is within the acceptable bounds.",
        "code_id": "c_group_1_id_162",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  0x0(%rip),%xmm0        # 0x15\n\ncomisd -0x8(%rbp),%xmm0\nja     0x2b\nmovsd  -0x8(%rbp),%xmm0\ncomisd 0x0(%rip),%xmm0        # 0x29\n\njbe    0x32\nmov    $0x1,%eax\njmp    0x37\nmov    $0x0,%eax\nmovzbl %al,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8f\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdi\ncall   0x6c\nlea    0x0(%rip),%rax        # 0x73\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x87\nmov    %rax,%rdi\ncall   0x8f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_220",
        "query_text": "The function accepts an integer as input, representing an error code, and checks it against a predefined set of error conditions that require additional parameters. It employs a switch mechanism: if the input error code matches any of these specific conditions, the function returns 1, indicating that further context is needed; if not, the function returns 0, signifying no additional parameters are required. The input is of type int, and the output is an int flag.",
        "code_id": "c_group_1_id_220",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0xffffff21,-0x4(%rbp)\nje     0x2a\ncmpl   $0xffffff21,-0x4(%rbp)\njl     0x31\nmov    -0x4(%rbp),%eax\nadd    $0xdc,%eax\ncmp    $0x5,%eax\nja     0x31\nmov    $0x1,%eax\njmp    0x36\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8b\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdi\ncall   0x68\nlea    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x79\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x83\nmov    %rax,%rdi\ncall   0x8b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x38\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_195",
        "query_text": "The function converts an array of C-style strings (typically used for command-line arguments) into a vector of strings. It accepts two parameters: an integer representing the number of elements and a pointer to an array of constant C-style strings. The function begins by initializing a vector of strings sized according to the provided integer. It then iterates over the C-style string array, copying each string into the corresponding index of the vector. Finally, the function returns the completed vector of strings.",
        "code_id": "c_group_1_id_195",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x21(%rbp),%rax\nmov    %rax,%rdi\ncall   0x33\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rcx\nlea    -0x21(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x4c\nlea    -0x21(%rbp),%rax\nmov    %rax,%rdi\ncall   0x58\nmovq   $0x0,-0x20(%rbp)\n\njmp    0x9b\nmov    -0x20(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rbx\nmov    -0x20(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x8b\nmov    %rbx,%rsi\nmov    %rax,%rdi\ncall   0x96\naddq   $0x1,-0x20(%rbp)\nmov    -0x3c(%rbp),%eax\ncltq   \ncmp    %rax,-0x20(%rbp)\njb     0x62\njmp    0xe4\nendbr64 \nmov    %rax,%rbx\nlea    -0x21(%rbp),%rax\nmov    %rax,%rdi\ncall   0xbb\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xc6\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0xd9\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xe4\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xf8\ncall   0xf8\nmov    -0x38(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x155\ncmpl   $0xffff,-0x8(%rbp)\njne    0x155\nlea    0x0(%rip),%rax        # 0x12a\nmov    %rax,%rdi\ncall   0x132\nlea    0x0(%rip),%rax        # 0x139\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x143\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x14d\nmov    %rax,%rdi\ncall   0x155\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x102\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\njae    0x29\nmov    -0x10(%rbp),%rax\njmp    0x2d\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rbx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x30\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x45\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x58\njmp    0x78\nendbr64 \nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x6d\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x78\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x39\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x45\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nshl    $0x5,%rax\nadd    %rdx,%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rcx\nmov    %rdx,%rax\nsub    %rcx,%rax\nsar    $0x5,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x42\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x4e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rdx\nlea    -0x19(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x37\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x43\ncmp    %rax,-0x28(%rbp)\nseta   %bl\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x56\ntest   %bl,%bl\nje     0x69\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdi\ncall   0x69\nmov    -0x28(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x81\ncall   0x81\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2c\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x3f\njmp    0x5f\nendbr64 \nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x54\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x5f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x39\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x8(%rdx)\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\ncmpq   $0x0,-0x10(%rbp)\nje     0x36\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x36\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x3ffffffffffffff,%rax\n\nmov    %rax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x39\nmov    %rax,-0x10(%rbp)\nlea    -0x10(%rbp),%rdx\nlea    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x50\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x67\ncall   0x67\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x33\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nmov    -0x8(%rbp),%rdx\nmov    %rax,(%rdx)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nshl    $0x5,%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x10(%rax)\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\n\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x10(%rax)\n\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\nje     0x30\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2e\njmp    0x35\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovb   $0x1,-0x1(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\njmp    0x2f\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x22\nmov    %rax,%rdi\ncall   0x2a\naddq   $0x20,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x10(%rbp),%rax\njne    0x16\nnop\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x32\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    0x3c\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2a\nmov    %rax,%rdi\ncall   0x32\nsubq   $0x1,-0x20(%rbp)\naddq   $0x20,-0x8(%rbp)\ncmpq   $0x0,-0x20(%rbp)\njne    0x1e\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovabs $0x3ffffffffffffff,%rax\n\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x24\ncmp    %rax,-0x10(%rbp)\nseta   %al\nmovzbl %al,%eax\ntest   %rax,%rax\nsetne  %al\ntest   %al,%al\nje     0x52\nmovabs $0x7ffffffffffffff,%rax\n\ncmp    %rax,-0x10(%rbp)\njbe    0x4d\ncall   0x4d\ncall   0x52\nmov    -0x10(%rbp),%rax\nshl    $0x5,%rax\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nmov    $0x20,%edi\ncall   0x21\nmov    %rax,%rdi\ncall   0x29\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_260",
        "query_text": "The function takes a boolean value as input and returns no value (void). It checks if the provided boolean is false; if so, it throws a runtime exception with the message \"bug\". Otherwise, if the boolean is true, it performs no action and simply returns. This design serves primarily as a debugging or assertion tool during program execution.",
        "code_id": "c_group_1_id_260",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x14(%rbp)\nmovzbl -0x14(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\nje     0x74\nmov    $0x10,%edi\ncall   0x29\nmov    %rax,%rbx\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rsi\nmov    %rbx,%rdi\ncall   0x3e\nmov    0x0(%rip),%rax        # 0x45\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rsi\nmov    %rbx,%rdi\ncall   0x5a\nendbr64 \nmov    %rax,%r12\nmov    %rbx,%rdi\ncall   0x69\nmov    %r12,%rax\nmov    %rax,%rdi\ncall   0x74\nnop\nadd    $0x10,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd1\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd1\nlea    0x0(%rip),%rax        # 0xa6\nmov    %rax,%rdi\ncall   0xae\nlea    0x0(%rip),%rax        # 0xb5\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xbf\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xc9\nmov    %rax,%rdi\ncall   0xd1\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_160",
        "query_text": "The function receives a single-precision floating-point value as its input and returns a 32-bit integer. It performs the conversion by loading the input into a SIMD register and then using a dedicated SSE2 instruction to round the floating-point value to the nearest integer efficiently. The input is of type float, and the output is of type int.",
        "code_id": "c_group_1_id_160",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x24(%rbp)\nlea    -0x24(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmovd   %eax,%xmm0\nnop\nmovaps %xmm0,-0x10(%rbp)\ncvtss2si -0x10(%rbp),%eax\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x89\ncmpl   $0xffff,-0x8(%rbp)\njne    0x89\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nlea    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x77\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x81\nmov    %rax,%rdi\ncall   0x89\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x36\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_168",
        "query_text": "The function accepts one input: a character. It outputs a signed 8-bit integer, representing the corresponding numeric value of the input if it is a valid hexadecimal digit (i.e. '0'-'9', 'A'-'F', or 'a'-'f'). If the character is not a valid hexadecimal digit, the function returns -1. The input type is char, while the output type is a signed char.",
        "code_id": "c_group_1_id_168",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x14(%rbp)\nmovzbl -0x14(%rbp),%eax\nmov    %al,-0x1(%rbp)\ncmpb   $0x2f,-0x1(%rbp)\njle    0x2c\ncmpb   $0x39,-0x1(%rbp)\njg     0x2c\nmovzbl -0x1(%rbp),%eax\nsub    $0x30,%eax\nmov    %al,-0x1(%rbp)\njmp    0x60\ncmpb   $0x40,-0x1(%rbp)\njle    0x44\ncmpb   $0x46,-0x1(%rbp)\njg     0x44\nmovzbl -0x1(%rbp),%eax\nsub    $0x37,%eax\nmov    %al,-0x1(%rbp)\njmp    0x60\ncmpb   $0x60,-0x1(%rbp)\njle    0x5c\ncmpb   $0x66,-0x1(%rbp)\njg     0x5c\nmovzbl -0x1(%rbp),%eax\nsub    $0x57,%eax\nmov    %al,-0x1(%rbp)\njmp    0x60\nmovb   $0xff,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb9\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb9\nlea    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdi\ncall   0x96\nlea    0x0(%rip),%rax        # 0x9d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa7\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdi\ncall   0xb9\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x66\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_243",
        "query_text": "The function accepts an array of double-precision floating-point numbers along with an integer indicating the array's size. It iterates through the array to find the smallest element, tracking the first occurrence in case of duplicate minimal values. After the traversal, the function returns an integer representing the index of this smallest element.",
        "code_id": "c_group_1_id_243",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovsd  0x0(%rip),%xmm0        # 0x17\n\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    0x76\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x8(%rbp),%xmm0\ncomisd %xmm1,%xmm0\njbe    0x72\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x2c\nmov    -0x10(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd6\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd6\nlea    0x0(%rip),%rax        # 0xab\nmov    %rax,%rdi\ncall   0xb3\nlea    0x0(%rip),%rax        # 0xba\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xc4\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xce\nmov    %rax,%rdi\ncall   0xd6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x83\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_251",
        "query_text": "This function computes the number of leading zero bits in a 64-bit unsigned integer. It accepts a single unsigned integer input and returns an integer result reflecting the count of zeros preceding the first set bit. On Windows, the function branches into different implementations based on the system architecture, employing one intrinsic function for 64-bit builds and another for 32-bit builds. In contrast, on other platforms, it directly uses a compiler-provided intrinsic. The result is an integer in the range from 0 to 64, corresponding to the number of leading zeros in the input value.",
        "code_id": "c_group_1_id_251",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nbsr    -0x8(%rbp),%rax\nxor    $0x3f,%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6a\nlea    0x0(%rip),%rax        # 0x3f\nmov    %rax,%rdi\ncall   0x47\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdi\ncall   0x6a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x17\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_222",
        "query_text": "The function takes three inputs: a pointer to an input character array, a pointer to an output character array (which is modified in place), and an integer representing the length of the input array. It processes the input array in pairs of characters. For each pair, the function first examines the initial character. If this character is null (0), it then considers the second character. If this second character is either a non-printable ASCII character, a backslash, or a double quote, it encodes the character as an octal escape sequence (for example, \"\\123\") into the output array; otherwise, it copies the character directly. If the first character in the pair is not null, both characters are encoded as octal escape sequences and written to the output array. After processing all character pairs, the function appends a null terminator to the output array. The primary purpose of the function is to convert characters from the input into either their direct representation or an octal escape sequence in the output, following specific encoding rules.",
        "code_id": "c_group_1_id_222",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    0x123\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xd(%rbp)\ncmpb   $0x0,-0xd(%rbp)\njne    0xc1\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xd(%rbp)\ncmpb   $0x1f,-0xd(%rbp)\njbe    0x72\ncmpb   $0x7e,-0xd(%rbp)\nja     0x72\ncmpb   $0x5c,-0xd(%rbp)\nje     0x72\ncmpb   $0x22,-0xd(%rbp)\njne    0x9b\nmovzbl -0xd(%rbp),%edx\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x81\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x91\naddq   $0x4,-0x8(%rbp)\njmp    0x11f\nmovzbl -0xd(%rbp),%edx\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0xaa\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xba\naddq   $0x1,-0x8(%rbp)\njmp    0x11f\nmovzbl -0xd(%rbp),%edx\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0xd0\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xe0\naddq   $0x4,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xd(%rbp)\nmovzbl -0xd(%rbp),%edx\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x10a\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x11a\naddq   $0x4,-0x8(%rbp)\naddl   $0x2,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     0x2b\nmov    -0x8(%rbp),%rax\nmovb   $0x0,(%rax)\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x18c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x18c\nlea    0x0(%rip),%rax        # 0x161\nmov    %rax,%rdi\ncall   0x169\nlea    0x0(%rip),%rax        # 0x170\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x17a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x184\nmov    %rax,%rdi\ncall   0x18c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x139\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_254",
        "query_text": "The function writes indentation to a file stream based on the provided depth and width parameters. It takes three inputs: a file stream, an integer representing the indentation depth, and an unsigned short representing the indentation width. If the width is non-zero, the function prints spaces to the file stream, where the number of spaces is computed as (depth - 1) times the width. If the width is zero, it prints tab characters instead, outputting one tab for each level of indentation (depth - 1). The function does not return a value; it directly modifies the file stream by outputting the appropriate indentation.",
        "code_id": "c_group_1_id_254",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,%eax\nmov    %ax,-0x20(%rbp)\ncmpw   $0x0,-0x20(%rbp)\nje     0x4e\nmov    -0x1c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmovzwl -0x20(%rbp),%eax\nimul   %eax,%edx\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x38\nlea    0x0(%rip),%rsi        # 0x3f\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x4c\njmp    0x77\nmovl   $0x0,-0x4(%rbp)\njmp    0x6c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nmov    $0x9,%edi\ncall   0x68\naddl   $0x1,-0x4(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x4(%rbp)\njl     0x57\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xcd\ncmpl   $0xffff,-0x8(%rbp)\njne    0xcd\nlea    0x0(%rip),%rax        # 0xa2\nmov    %rax,%rdi\ncall   0xaa\nlea    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xbb\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xc5\nmov    %rax,%rdi\ncall   0xcd\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_226",
        "query_text": "The function takes a pointer to an unsigned character as input and returns a pointer to a character. It uses a reinterpret cast to convert the pointer to the unsigned character buffer into a pointer to a character buffer, effectively allowing the same underlying data to be accessed as a sequence of characters. The input type is unsigned char*, and the output type is char*.",
        "code_id": "c_group_1_id_226",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x65\ncmpl   $0xffff,-0x8(%rbp)\njne    0x65\nlea    0x0(%rip),%rax        # 0x3a\nmov    %rax,%rdi\ncall   0x42\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdi\ncall   0x65\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x12\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_221",
        "query_text": "The function accepts two integer inputs representing positive numbers, and it returns their product as an integer. Initially, if either input is zero, the function immediately returns zero. Otherwise, it checks whether multiplying the two inputs would result in a value no greater than the maximum integer value. If the product is within this limit, it returns the product; if not, it returns -1 to indicate that an overflow would occur.",
        "code_id": "c_group_1_id_221",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x0,-0x4(%rbp)\nje     0x1a\ncmpl   $0x0,-0x8(%rbp)\njne    0x21\nmov    $0x0,%eax\njmp    0x3d\nmov    $0x7fffffff,%eax\ncltd   \nidivl  -0x8(%rbp)\ncmp    %eax,-0x4(%rbp)\njge    0x38\nmov    -0x4(%rbp),%eax\nimul   -0x8(%rbp),%eax\njmp    0x3d\nmov    $0xffffffff,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x92\ncmpl   $0xffff,-0x8(%rbp)\njne    0x92\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rdi\ncall   0x6f\nlea    0x0(%rip),%rax        # 0x76\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x80\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rdi\ncall   0x92\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_175",
        "query_text": "The function takes two inputs: an integer representing an error value and a socket descriptor (which is often unused). It returns an integer that represents the last error code for a socket operation, following the platform-specific error retrieval mechanism. If the input error value is positive, the function returns 0 to indicate the absence of an error. Otherwise, it determines and returns the appropriate error code based on the current platform's implementation (such as for Windows, Linux kernel mode, or various embedded systems).",
        "code_id": "c_group_1_id_175",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njle    0x1f\nmov    $0x0,%eax\njmp    0x26\ncall   0x24\nmov    (%rax),%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7b\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdi\ncall   0x58\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x69\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x73\nmov    %rax,%rdi\ncall   0x7b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x28\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_107",
        "query_text": "The function accepts a pointer to an unsigned 32-bit integer and an integer specifying the number of bits to operate on. It extracts the lower bits from the unsigned 32-bit integer by applying a bit mask defined by the number of bits, then shifts the original integer right by that many bits to remove the extracted portion. Finally, it returns the extracted bits as an unsigned 32-bit integer. The input types are a pointer to an unsigned 32-bit integer and an integer, and the output type is an unsigned 32-bit integer.",
        "code_id": "c_group_1_id_107",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nmov    $0xffffffff,%esi\nmov    %eax,%ecx\nshl    %cl,%esi\nmov    %esi,%eax\nnot    %eax\nand    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nmov    %eax,%ecx\nshr    %cl,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x95\ncmpl   $0xffff,-0x8(%rbp)\njne    0x95\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdi\ncall   0x72\nlea    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x83\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8d\nmov    %rax,%rdi\ncall   0x95\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x42\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_170",
        "query_text": "The function accepts an array of unsigned characters, represented by a pointer, along with an integer that specifies the length of this array. It checks whether the provided pointer is NULL; if it is, the function immediately terminates without making any modifications. Otherwise, it reverses the elements in the array in place by swapping the first element with the last, the second element with the second-to-last, and continuing this process until the entire array is reversed. The function does not return any value.",
        "code_id": "c_group_1_id_170",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     0x7f\nmovl   $0x0,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    0x75\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x9(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x8(%rbp)\nsubl   $0x1,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     0x28\njmp    0x80\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd5\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd5\nlea    0x0(%rip),%rax        # 0xaa\nmov    %rax,%rdi\ncall   0xb2\nlea    0x0(%rip),%rax        # 0xb9\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xc3\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xcd\nmov    %rax,%rdi\ncall   0xd5\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x82\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_298",
        "query_text": "The function returns a reference to a constant pointer to a stream buffer linked to the standard output stream. It takes no input arguments and employs a static variable to ensure the same pointer is reused on every call, thereby providing consistent access to the output stream's buffer.",
        "code_id": "c_group_1_id_298",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax        # 0x22\nmov    %rax,%rdi\ncall   0x2a\nmov    %rax,-0x10(%rbp)\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x47\ncall   0x47\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9c\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nlea    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x94\nmov    %rax,%rdi\ncall   0x9c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x49\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_257",
        "query_text": "The function compares two integers indirectly through pointer dereferencing. It takes two inputs of type const void*, each expected to point to an int pointer. After dereferencing, the function compares the integer values: it returns -1 if the first integer is less than the second, 1 if it is greater, and 0 if both are equal. This comparison mechanism is designed for use in sorting or searching algorithms that require a callback for comparing elements.",
        "code_id": "c_group_1_id_257",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    0x3d\nmov    $0xffffffff,%eax\njmp    0x59\nmov    -0x10(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    0x54\nmov    $0x1,%eax\njmp    0x59\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xae\ncmpl   $0xffff,-0x8(%rbp)\njne    0xae\nlea    0x0(%rip),%rax        # 0x83\nmov    %rax,%rdi\ncall   0x8b\nlea    0x0(%rip),%rax        # 0x92\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x9c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xa6\nmov    %rax,%rdi\ncall   0xae\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x5b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_180",
        "query_text": "The function takes a pointer to an integer as input. It begins by checking if the integer value is not equal to -1. If this condition is met, the function closes the resource associated with this value (such as a file descriptor or socket) and then resets the value to -1 to indicate the resource is no longer active. The function does not return a value.",
        "code_id": "c_group_1_id_180",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    $0xffffffff,%eax\nje     0x32\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,%edi\ncall   0x28\nmov    -0x8(%rbp),%rax\nmovl   $0xffffffff,(%rax)\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x88\ncmpl   $0xffff,-0x8(%rbp)\njne    0x88\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdi\ncall   0x65\nlea    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x76\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdi\ncall   0x88\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x35\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_224",
        "query_text": "The function takes three inputs: an integer representing the count of elements in an array, and two arrays of character pointers. It begins by copying each element from the first array into the corresponding position of the second array. Then, the function shuffles the elements of the second array using a random swapping mechanism: it iterates backwards from the last element, and for each position, it selects a random index within the unshuffled portion of the array and swaps the element at the current position with the one at the random index, ensuring that every position is equally likely to be occupied by any element. The function performs this shuffling operation in-place and does not return any value.",
        "code_id": "c_group_1_id_224",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    0x53\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     0x20\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    0xe0\ncall   0x6b\nmov    -0x10(%rbp),%edx\nlea    0x1(%rdx),%ecx\ncltd   \nidiv   %ecx\nmov    %edx,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nsubl   $0x1,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njg     0x66\nnop\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x13d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x13d\nlea    0x0(%rip),%rax        # 0x112\nmov    %rax,%rdi\ncall   0x11a\nlea    0x0(%rip),%rax        # 0x121\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x12b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x135\nmov    %rax,%rdi\ncall   0x13d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xea\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_173",
        "query_text": "The function accepts two pointer inputs: one pointing to the start of a character array and the other pointing to its end. It sequentially examines each character from the beginning, skipping any occurrence of carriage return ('\\r') or newline ('\\n'). The function returns the pointer to the first character that is not a line-ending character.",
        "code_id": "c_group_1_id_173",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\njmp    0x17\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x10(%rbp),%rax\njae    0x37\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xd,%al\nje     0x12\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0xa,%al\nje     0x12\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x90\ncmpl   $0xffff,-0x8(%rbp)\njne    0x90\nlea    0x0(%rip),%rax        # 0x65\nmov    %rax,%rdi\ncall   0x6d\nlea    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x88\nmov    %rax,%rdi\ncall   0x90\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_169",
        "query_text": "This function examines an input character to determine if it qualifies as a whitespace character. It accepts a character (of type char) and checks if it is either a space, a tab, or a newline. If the character matches any of these, the function returns an integer value of 1; otherwise, it returns 0. The output is of type int, signifying a boolean-like indicator for whitespace detection.",
        "code_id": "c_group_1_id_169",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovsbl -0x4(%rbp),%eax\ncmp    $0xa,%eax\njg     0x1d\ncmp    $0x9,%eax\njge    0x22\njmp    0x29\ncmp    $0x20,%eax\njne    0x29\nmov    $0x1,%eax\njmp    0x2e\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x83\ncmpl   $0xffff,-0x8(%rbp)\njne    0x83\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rdi\ncall   0x60\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rdi\ncall   0x83\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x30\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_307",
        "query_text": "The function takes one input: an unsigned integer, and produces an output of type bool. It shifts the unsigned integer right by 10 bits and then verifies whether the resulting value does not equal the hexadecimal constant 0x36. If the condition is met, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_307",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshr    $0xa,%eax\ncmp    $0x36,%eax\nsetne  %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6c\nlea    0x0(%rip),%rax        # 0x41\nmov    %rax,%rdi\ncall   0x49\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdi\ncall   0x6c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x19\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_194",
        "query_text": "The function checks whether a string begins with a specified prefix. It accepts two strings as input and returns a boolean value. First, it verifies that the length of the input string is at least as long as the prefix. If this condition is met, the function extracts the beginning segment of the string\u2014matching the length of the prefix\u2014and compares it with the prefix. If these two values are identical, it returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_194",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x40,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    $0x0,%ebx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncall   0x37\nmov    %rax,%r12\nmov    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   0x46\ncmp    %rax,%r12\njb     0x96\nmov    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   0x57\nmov    %rax,%rdx\nlea    -0x40(%rbp),%rax\nmov    -0x48(%rbp),%rsi\nmov    %rdx,%rcx\nmov    $0x0,%edx\nmov    %rax,%rdi\ncall   0x72\nmov    $0x1,%ebx\nmov    -0x50(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x8a\ntest   %al,%al\nje     0x96\nmov    $0x1,%r12d\njmp    0x9c\nmov    $0x0,%r12d\ntest   %bl,%bl\nje     0xac\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0xac\nmov    %r12d,%eax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xe7\njmp    0xe2\nendbr64 \nmov    %rax,%r12\ntest   %bl,%bl\nje     0xd7\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0xd7\nmov    %r12,%rax\nmov    %rax,%rdi\ncall   0xe2\ncall   0xe7\nadd    $0x40,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x143\ncmpl   $0xffff,-0x8(%rbp)\njne    0x143\nlea    0x0(%rip),%rax        # 0x118\nmov    %rax,%rdi\ncall   0x120\nlea    0x0(%rip),%rax        # 0x127\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x131\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x13b\nmov    %rax,%rdi\ncall   0x143\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsetb   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\ncmpq   $0x0,-0x28(%rbp)\njne    0x29\nmov    $0x0,%eax\njmp    0xc2\nmov    $0x0,%eax\ntest   %al,%al\nje     0xaa\nmovq   $0x0,-0x8(%rbp)\n\njmp    0x99\nmov    -0x20(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x5d\ntest   %al,%al\nje     0x68\nmov    $0xffffffff,%eax\njmp    0xc2\nmov    -0x18(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x89\ntest   %al,%al\nje     0x94\nmov    $0x1,%eax\njmp    0xc2\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x28(%rbp),%rax\njb     0x3c\nmov    $0x0,%eax\njmp    0xc2\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0xc1\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x10,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x23\nmov    %rax,%rbx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x32\ncmp    %rax,%rbx\njne    0x7a\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x43\nmov    %rax,%r12\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x52\nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x61\nmov    %r12,%rdx\nmov    %rbx,%rsi\nmov    %rax,%rdi\ncall   0x6f\ntest   %eax,%eax\njne    0x7a\nmov    $0x1,%eax\njmp    0x7f\nmov    $0x0,%eax\nadd    $0x10,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_174",
        "query_text": "The function takes an integer input representing an alert type and logs a formatted alert message if debug mode is enabled. It first converts the integer to a string using a helper routine; if the conversion is successful, it incorporates the string into a predefined message format and logs the result. When debug mode is not enabled, the input is disregarded and no logging occurs. The function does not produce a return value.",
        "code_id": "c_group_1_id_174",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x61\ncmpl   $0xffff,-0x8(%rbp)\njne    0x61\nlea    0x0(%rip),%rax        # 0x36\nmov    %rax,%rdi\ncall   0x3e\nlea    0x0(%rip),%rax        # 0x45\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xe\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_258",
        "query_text": "This function retrieves version information by constructing a formatted constant string. It takes no input arguments and produces an output that concatenates predefined constants representing the package and version details with a static copyright message. The function returns a pointer to a constant character array containing this version-related information.",
        "code_id": "c_group_1_id_258",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x64\ncmpl   $0xffff,-0x8(%rbp)\njne    0x64\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_172",
        "query_text": "The function accepts a single unsigned long integer that represents an error code and returns a pointer to a constant character string. It is designed to generate a human-readable description of the library associated with the provided error code. When a specific compile-time flag is enabled, the function extracts a library identifier from the error code and then checks this identifier against known values. If it matches one of the predefined identifiers (such as those corresponding to routines for handling specific file formats or cryptographic operations), it returns a descriptive string for that library routine. If the identifier is unrecognized or the compile-time flag is not enabled, the function simply returns an empty string. This mechanism is primarily utilized for error logging and debugging purposes.",
        "code_id": "c_group_1_id_172",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\nlea    0x0(%rip),%rax        # 0x1a\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6f\nlea    0x0(%rip),%rax        # 0x44\nmov    %rax,%rdi\ncall   0x4c\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x67\nmov    %rax,%rdi\ncall   0x6f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_276",
        "query_text": "The function computes the Root Mean Square (RMS) error between two arrays of double-precision floating-point numbers. It takes as input two arrays and an integer representing the number of elements in the arrays. The function iterates over the elements, calculates the squared difference between each pair of corresponding elements, and accumulates these values. It then divides the total by one less than the number of elements before taking the square root of the result. The output is a double-precision floating-point number representing the RMS error.",
        "code_id": "c_group_1_id_276",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    0xae\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nsubsd  %xmm2,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     0x2c\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x24(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm2        # 0xcb\n\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmovsd  -0x8(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   0xeb\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x14a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x14a\nlea    0x0(%rip),%rax        # 0x11f\nmov    %rax,%rdi\ncall   0x127\nlea    0x0(%rip),%rax        # 0x12e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x138\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x142\nmov    %rax,%rdi\ncall   0x14a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf7\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_223",
        "query_text": "The function receives two time values as inputs. It calculates their difference and converts this difference into seconds by dividing by the constant that specifies the number of clock ticks per second. The computed elapsed time is then returned as a double.",
        "code_id": "c_group_1_id_223",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nsub    -0x18(%rbp),%rax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x29\n\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x96\ncmpl   $0xffff,-0x8(%rbp)\njne    0x96\nlea    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdi\ncall   0x73\nlea    0x0(%rip),%rax        # 0x7a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x84\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdi\ncall   0x96\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x43\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_232",
        "query_text": "The function takes two inputs: a byte size of type size_t and an integer flag for huge page usage. It attempts to allocate a memory block using the mmap system call, creating an anonymous and private memory mapping. If the flag for huge pages is enabled, the function sets the appropriate mapping flag. Upon successful allocation, it returns a pointer to the allocated memory block of type void*. If the allocation fails, it prints an error message to the standard error stream and terminates the program.",
        "code_id": "c_group_1_id_232",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x22,-0xc(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\nje     0x27\norl    $0x40000,-0xc(%rbp)\nmov    -0xc(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    $0x0,%r9d\nmov    $0xffffffff,%r8d\nmov    %edx,%ecx\nmov    $0x3,%edx\nmov    %rax,%rsi\nmov    $0x0,%edi\ncall   0x4e\nmov    %rax,-0x8(%rbp)\ncmpq   $0xffffffffffffffff,-0x8(%rbp)\njne    0x92\ncall   0x5e\nmov    (%rax),%eax\nmov    %eax,%edi\ncall   0x67\nmov    %rax,%rdx\nmov    0x0(%rip),%rax        # 0x71\nlea    0x0(%rip),%rcx        # 0x78\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x88\nmov    $0x1,%edi\ncall   0x92\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xeb\ncmpl   $0xffff,-0x8(%rbp)\njne    0xeb\nlea    0x0(%rip),%rax        # 0xc0\nmov    %rax,%rdi\ncall   0xc8\nlea    0x0(%rip),%rax        # 0xcf\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xd9\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xe3\nmov    %rax,%rdi\ncall   0xeb\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x98\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_171",
        "query_text": "The function is a void function that accepts no input parameters and returns no value. It initializes the error handling mechanism of the library by loading a set of predefined error strings. These error messages allow for error codes generated during execution to be translated into meaningful, human-readable descriptions.",
        "code_id": "c_group_1_id_171",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_268",
        "query_text": "The function accepts two integers: one representing an ASCII character and the other representing a radix (base). It begins by verifying that the provided character code corresponds to a decimal digit (i.e., between '0' and '9'). It then checks whether the numeric value of that digit (obtained by subtracting the ASCII value for '0') is less than the specified radix. Finally, the function returns a boolean value: it outputs true if both conditions are met, and false otherwise.",
        "code_id": "c_group_1_id_268",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x2f,-0x4(%rbp)\njle    0x2c\ncmpl   $0x39,-0x4(%rbp)\njg     0x2c\nmov    -0x4(%rbp),%eax\nsub    $0x2f,%eax\ncmp    %eax,-0x8(%rbp)\njl     0x2c\nmov    $0x1,%eax\njmp    0x31\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x86\ncmpl   $0xffff,-0x8(%rbp)\njne    0x86\nlea    0x0(%rip),%rax        # 0x5b\nmov    %rax,%rdi\ncall   0x63\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x74\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rdi\ncall   0x86\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x33\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_227",
        "query_text": "The function accepts a single parameter: a reference to an input stream (of type std::istream&). It reads all characters from the stream\u2014from the current position to the end\u2014and constructs a string containing the complete set of data read. The function then returns this string (of type std::string) holding the stream's content.",
        "code_id": "c_group_1_id_227",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x58,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nlea    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3c\nmov    -0x60(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x4f\nlea    -0x41(%rbp),%r8\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rdi\nmov    -0x40(%rbp),%rsi\nmov    -0x38(%rbp),%rdx\nmov    -0x58(%rbp),%rax\nmov    %r8,%r9\nmov    %rdi,%r8\nmov    %rax,%rdi\ncall   0x75\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0x81\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xb5\njmp    0xb0\nendbr64 \nmov    %rax,%rbx\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0xa5\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xb0\ncall   0xb5\nmov    -0x58(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x112\ncmpl   $0xffff,-0x8(%rbp)\njne    0x112\nlea    0x0(%rip),%rax        # 0xe7\nmov    %rax,%rdi\ncall   0xef\nlea    0x0(%rip),%rax        # 0xf6\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x100\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x10a\nmov    %rax,%rdi\ncall   0x112\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xbf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffffffff,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nsub    $0x18,%rax\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,%rdi\ncall   0x34\nmov    -0x8(%rbp),%rdx\nmov    %rax,(%rdx)\ncall   0x40\nmov    -0x8(%rbp),%rdx\nmov    %eax,0x8(%rdx)\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,(%rax)\ncall   0x20\nmov    -0x8(%rbp),%rdx\nmov    %eax,0x8(%rdx)\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,%rax\nmov    %rdx,%rsi\nmov    %rsi,%rdx\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,%rax\nmov    %r8,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %r9,-0x20(%rbp)\nmov    -0x18(%rbp),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x47\nmov    %rax,%rcx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x5c\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rdi\nmov    -0x30(%rbp),%rsi\nmov    -0x28(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdi,%r8\nmov    %rax,%rdi\ncall   0x7b\njmp    0x9b\nendbr64 \nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x90\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x9b\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,%rax\nmov    %rdx,%rsi\nmov    %rsi,%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,%rax\nmov    %r8,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rdi\nmov    -0x20(%rbp),%rsi\nmov    -0x18(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdi,%r8\nmov    %rax,%rdi\ncall   0x51\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,%rax\nmov    %rdx,%rsi\nmov    %rsi,%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,%rax\nmov    %r8,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rdi\nmov    -0x20(%rbp),%rsi\nmov    -0x18(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdi,%r8\nmov    %rax,%rdi\ncall   0x51\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x58,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,%rax\nmov    %rdx,%rsi\nmov    %rsi,%rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %rcx,%rax\nmov    %r8,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x60(%rbp)\nmov    %rdx,-0x58(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x28(%rbp)\n\nmovq   $0xf,-0x30(%rbp)\n\njmp    0x8e\nlea    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    %eax,%ebx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x6e\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x28(%rbp)\nadd    %rcx,%rax\nmov    %bl,(%rax)\nlea    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   0x8e\nlea    -0x60(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xa1\ntest   %al,%al\nje     0xb6\nmov    -0x30(%rbp),%rax\ncmp    %rax,-0x28(%rbp)\njae    0xb6\nmov    $0x1,%eax\njmp    0xbb\nmov    $0x0,%eax\ntest   %al,%al\njne    0x54\njmp    0x183\nmov    -0x30(%rbp),%rax\ncmp    %rax,-0x28(%rbp)\njne    0x149\nmov    -0x28(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x28(%rbp),%rdx\nlea    -0x30(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0xf1\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x101\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x117\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x123\nmov    -0x20(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x136\nmov    -0x30(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x149\nlea    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   0x155\nmov    %eax,%ebx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x163\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x28(%rbp)\nadd    %rcx,%rax\nmov    %bl,(%rax)\nlea    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   0x183\nlea    -0x60(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x196\ntest   %al,%al\njne    0xc4\nmov    -0x28(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x1b1\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x1fc\njmp    0x1f7\nendbr64 \nmov    %rax,%rdi\ncall   0x1cf\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1db\ncall   0x1e0\nendbr64 \nmov    %rax,%rbx\ncall   0x1ec\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x1f7\ncall   0x1fc\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nxor    $0x1,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2b\nmov    %eax,-0xc(%rbp)\nlea    -0xc(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3a\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x4e\ncall   0x4e\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   0x1f\ncall   0x24\nmov    -0x8(%rbp),%rdx\nmov    %eax,0x8(%rdx)\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x21\nmov    %eax,%ebx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2f\ncmp    %al,%bl\nsete   %al\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\nje     0x5b\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   0x30\ntest   %al,%al\nje     0x5b\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   0x43\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   0x50\ntest   %al,%al\nje     0x5b\nmov    $0x1,%eax\njmp    0x60\nmov    $0x0,%eax\ntest   %al,%al\nje     0x6f\nmov    -0x18(%rbp),%rax\nmovq   $0x0,(%rax)\nmov    -0x4(%rbp),%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nmov    %eax,%edi\ncall   0x23\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0xffffffff,-0xc(%rbp)\nlea    -0xc(%rbp),%rdx\nlea    -0x14(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x38\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x4c\ncall   0x4c\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_274",
        "query_text": "The function takes three inputs: a pointer to a wide-character string, a wide-character separator, and a count of type size_t. It first verifies that the input string is not null and immediately returns the original string if the count is zero. If the count is non-zero, it searches for the first occurrence of the separator in the string. The function then iterates to locate the subsequent occurrences until it finds the nth occurrence. If the nth occurrence is found, it returns a pointer to the character immediately following that occurrence; otherwise, if any occurrence is missing or the string is empty, the function returns a null pointer.",
        "code_id": "c_group_1_id_274",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    0x25\nmov    $0x0,%eax\njmp    0x99\ncmpq   $0x0,-0x18(%rbp)\njne    0x32\nmov    -0x8(%rbp),%rax\njmp    0x99\nmov    -0xc(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x43\nmov    %rax,-0x8(%rbp)\nsubq   $0x1,-0x18(%rbp)\njmp    0x7b\ncmpq   $0x0,-0x8(%rbp)\njne    0x5c\nmov    $0x0,%eax\njmp    0x99\nsubq   $0x1,-0x18(%rbp)\naddq   $0x4,-0x8(%rbp)\nmov    -0xc(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x77\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    0x4e\ncmpq   $0x0,-0x8(%rbp)\nje     0x93\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\njmp    0x98\nmov    $0x0,%eax\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xee\ncmpl   $0xffff,-0x8(%rbp)\njne    0xee\nlea    0x0(%rip),%rax        # 0xc3\nmov    %rax,%rdi\ncall   0xcb\nlea    0x0(%rip),%rax        # 0xd2\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xdc\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xe6\nmov    %rax,%rdi\ncall   0xee\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x9b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_294",
        "query_text": "The function accepts an input of type const char*, representing the name of an environment variable. It queries the system's environment for the variable and returns a const char* representing the corresponding value if it exists and is non-empty. If the environment variable does not exist, is an empty string, or if the platform is unsupported, the function returns NULL.",
        "code_id": "c_group_1_id_294",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x71\ncmpl   $0xffff,-0x8(%rbp)\njne    0x71\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdi\ncall   0x4e\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_179",
        "query_text": "The function takes a pointer to an integer, representing a socket file descriptor, as its input. It first checks whether the socket is open by examining if the integer is not equal to -1. If the socket is open, the function proceeds to close the socket and then sets the file descriptor to -1 to mark it as invalid. Additionally, under a specific compilation condition, it resets a global status flag to 0. The function does not return any value; its main purpose is to safely close and clean up the socket.",
        "code_id": "c_group_1_id_179",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    $0xffffffff,%eax\nje     0x32\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,%edi\ncall   0x28\nmov    -0x8(%rbp),%rax\nmovl   $0xffffffff,(%rax)\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x88\ncmpl   $0xffff,-0x8(%rbp)\njne    0x88\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdi\ncall   0x65\nlea    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x76\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdi\ncall   0x88\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x35\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_176",
        "query_text": "The function takes an input\u2014a constant C-string pointer that represents a directory path\u2014and attempts to remove the directory. It uses a platform-specific system call: on Windows (compiled with MSVC), it invokes one removal function; on other platforms, it uses a different standard removal function. If the removal is successful, the function returns 0; if it fails, the function returns -1. The input type is a const char pointer and the output type is an int.",
        "code_id": "c_group_1_id_176",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\ntest   %eax,%eax\nsetne  %al\ntest   %al,%al\nje     0x2c\nmov    $0xffffffff,%eax\njmp    0x31\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x86\ncmpl   $0xffff,-0x8(%rbp)\njne    0x86\nlea    0x0(%rip),%rax        # 0x5b\nmov    %rax,%rdi\ncall   0x63\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x74\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rdi\ncall   0x86\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x33\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_300",
        "query_text": "The function begins by receiving a string input that is meant to be converted to a 64-bit integer, along with a pointer to an integer that reflects the success or failure of this conversion. It attempts to perform the conversion using a standard library routine, and then examines any remaining characters or error flags to determine whether the conversion completed without issues. If extraneous characters are found or an error occurs, it sets the provided status pointer to indicate failure and returns a zero value. Otherwise, it marks the conversion as successful via the status pointer and returns the successfully parsed 64-bit integer.",
        "code_id": "c_group_1_id_300",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\ncall   0x28\nmov    (%rax),%eax\nmov    %eax,-0x1c(%rbp)\ncall   0x32\nmovl   $0x0,(%rax)\nlea    -0x18(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x50\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x6a\ncall   0x64\nmov    (%rax),%eax\ntest   %eax,%eax\nje     0x86\ncall   0x6f\nmovl   $0x0,(%rax)\nmov    -0x30(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    $0x0,%eax\njmp    0x9e\ncall   0x8b\nmov    -0x1c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\nmovl   $0x1,(%rax)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xb2\ncall   0xb2\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x107\ncmpl   $0xffff,-0x8(%rbp)\njne    0x107\nlea    0x0(%rip),%rax        # 0xdc\nmov    %rax,%rdi\ncall   0xe4\nlea    0x0(%rip),%rax        # 0xeb\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xf5\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xff\nmov    %rax,%rdi\ncall   0x107\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb4\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_271",
        "query_text": "The function takes two floating-point numbers as input. It compares the second input value with the first input value, treated as an edge threshold. If the second value is less than the edge, it returns 0.0; otherwise, it returns 1.0. Essentially, the function implements a step function that produces a binary output (0.0 or 1.0) based on whether the provided value is below or above the specified edge.",
        "code_id": "c_group_1_id_271",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  %xmm1,-0x8(%rbp)\nmovss  -0x4(%rbp),%xmm0\ncomiss -0x8(%rbp),%xmm0\njbe    0x23\npxor   %xmm0,%xmm0\njmp    0x2b\nmovss  0x0(%rip),%xmm0        # 0x2b\n\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x80\ncmpl   $0xffff,-0x8(%rbp)\njne    0x80\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdi\ncall   0x5d\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x78\nmov    %rax,%rdi\ncall   0x80\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_292",
        "query_text": "The function takes an unsigned long integer as input and returns an integer. It starts by applying a built-in operation to count the consecutive zero bits in the binary representation of the input, scanning from the most significant bit until it reaches the first non-zero bit. The resulting count is then returned, and the function guarantees that no exceptions are thrown.",
        "code_id": "c_group_1_id_292",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nbsr    -0x8(%rbp),%rax\nxor    $0x3f,%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6a\nlea    0x0(%rip),%rax        # 0x3f\nmov    %rax,%rdi\ncall   0x47\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdi\ncall   0x6a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x17\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_229",
        "query_text": "The function takes two C-style strings as inputs\u2014one for the filename and one for the mode\u2014and returns a pointer to a FILE object. It opens the specified file using platform-specific logic: on Windows platforms (excluding MinGW), it uses a secure method to open the file, while on other platforms it uses the standard approach. The function returns the file pointer if the file is successfully opened, or a null pointer if the operation fails.",
        "code_id": "c_group_1_id_229",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7c\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,%rdi\ncall   0x59\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdi\ncall   0x7c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x29\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_284",
        "query_text": "This function determines the length of a wide-character string by counting its characters until the null terminator is reached. It validates that the input pointer (of type const wide-character string pointer) is not null using an assertion. Depending on a compile-time flag, it either employs a standard library function to obtain the length or iterates manually through the string. The computed length, excluding the null termiantor, is returned as a value of type size_t.",
        "code_id": "c_group_1_id_284",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    0x3f\nlea    0x0(%rip),%rax        # 0x1e\nmov    %rax,%rcx\nmov    $0xf,%edx\nlea    0x0(%rip),%rax        # 0x2d\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    0x4e\naddq   $0x4,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    0x49\nmov    -0x8(%rbp),%rax\nsub    -0x18(%rbp),%rax\nsar    $0x2,%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb9\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb9\nlea    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdi\ncall   0x96\nlea    0x0(%rip),%rax        # 0x9d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa7\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdi\ncall   0xb9\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x66\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_181",
        "query_text": "The function accepts a pointer to a double value representing a numerical quantity, and returns a constant C-string indicating a unit of measurement. It first evaluates compile-time flags to determine if a fixed unit should be used\u2014dividing the value accordingly by factors of 1,000,000,000, 1,000,000, or 1,000 for gigabytes, megabytes, or kilobytes respectively, or leaving the value unchanged for bytes. If no fixed unit is specified at compile time, the function adjusts the input value at runtime based on its magnitude: values larger than one million are scaled to megabytes, values larger than one thousand to kilobytes, and values below this threshold remain in bytes. Finally, a constant string denoting the unit (\"GB\", \"MB\", \"KB\", or \"bytes\") is returned.",
        "code_id": "c_group_1_id_181",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm0\ncomisd 0x0(%rip),%xmm0        # 0x1c\n\njbe    0x47\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x2e\n\ndivsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovsd  %xmm0,(%rax)\nlea    0x0(%rip),%rax        # 0x41\nmov    %rax,-0x8(%rbp)\njmp    0x8d\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm0\ncomisd 0x0(%rip),%xmm0        # 0x57\n\njbe    0x82\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x69\n\ndivsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovsd  %xmm0,(%rax)\nlea    0x0(%rip),%rax        # 0x7c\nmov    %rax,-0x8(%rbp)\njmp    0x8d\nlea    0x0(%rip),%rax        # 0x89\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xe6\ncmpl   $0xffff,-0x8(%rbp)\njne    0xe6\nlea    0x0(%rip),%rax        # 0xbb\nmov    %rax,%rdi\ncall   0xc3\nlea    0x0(%rip),%rax        # 0xca\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xd4\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xde\nmov    %rax,%rdi\ncall   0xe6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x93\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_249",
        "query_text": "This function converts an angle from radians to degrees. It takes a single input in the form of a pointer to a floating-point value representing the angle in radians. The function processes the value in-place by multiplying it by the conversion factor (180.0 divided by \u03c0), thereby updating the original value to reflect the equivalent measure in degrees. Both the input and output utilize the floating-point type.",
        "code_id": "c_group_1_id_249",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x1c\n\nmulss  %xmm1,%xmm0\nmovss  0x0(%rip),%xmm1        # 0x28\n\ndivss  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8a\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x78\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x82\nmov    %rax,%rdi\ncall   0x8a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x37\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_225",
        "query_text": "The function accepts two inputs: a floating-point number of type long double and a size_t value that specifies the desired precision for its conversion into a string. If the precision parameter is zero, the function automatically substitutes it with the maximum number of significant digits available for a long double. It then converts the value into a string representation using the C locale to ensure that the formatting remains consistent regardless of locale-specific differences. The output is a string that reflects the formatted floating-point number.",
        "code_id": "c_group_1_id_225",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x1b8,%rsp\nmov    %rdi,-0x1b8(%rbp)\nmov    %rsi,-0x1c0(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3c\nlea    -0x1b0(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x4a\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x55\nlea    -0x1a8(%rbp),%rax\nlea    -0x1b0(%rbp),%rdx\nlea    -0x1a0(%rbp),%rcx\nsub    $0xffffffffffffff80,%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x79\nlea    -0x1a8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x88\nlea    -0x1b0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x97\ncmpq   $0x0,-0x1c0(%rbp)\n\njne    0xac\nmovq   $0x15,-0x1c0(%rbp)\n\nmov    -0x1c0(%rbp),%rax\nlea    -0x1a0(%rbp),%rdx\nsub    $0xffffffffffffff80,%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0xc9\nlea    -0x1a0(%rbp),%rax\nadd    $0x10,%rax\npush   0x18(%rbp)\npush   0x10(%rbp)\nmov    %rax,%rdi\ncall   0xe2\nadd    $0x10,%rsp\nmov    -0x1b8(%rbp),%rax\nlea    -0x1a0(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xff\nnop\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x10f\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x15f\njmp    0x15a\nendbr64 \nmov    %rax,%rbx\nlea    -0x1b0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x137\njmp    0x140\nendbr64 \nmov    %rax,%rbx\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x14f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x15a\ncall   0x15f\nmov    -0x1b8(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x1bf\ncmpl   $0xffff,-0x8(%rbp)\njne    0x1bf\nlea    0x0(%rip),%rax        # 0x194\nmov    %rax,%rdi\ncall   0x19c\nlea    0x0(%rip),%rax        # 0x1a3\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x1ad\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x1b7\nmov    %rax,%rdi\ncall   0x1bf\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x16c\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_297",
        "query_text": "The function takes a single character (of type char) as input and returns its lowercase equivalent (of type char). It leverages the standard C++ locale facilities to perform the conversion according to the rules of the classic \"C\" locale.",
        "code_id": "c_group_1_id_297",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,%eax\nmov    %al,-0x14(%rbp)\ncall   0x16\nmov    %rax,%rdi\ncall   0x1e\nmov    %rax,-0x8(%rbp)\nmovsbl -0x14(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x34\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x89\ncmpl   $0xffff,-0x8(%rbp)\njne    0x89\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nlea    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x77\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x81\nmov    %rax,%rdi\ncall   0x89\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x36\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %al,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nadd    $0x20,%rax\nmov    (%rax),%rcx\nmovsbl -0xc(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   *%rcx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_178",
        "query_text": "The function generates a formatted string that lists supported protocol versions and optional feature flags, and then prints this string to the console. It begins by initializing a fixed-size character array with zeros and then conditionally appends version identifiers (such as \"0:\", \"1:\", \"2:\", etc.) based on preprocessor definitions. Depending on the compilation configuration, it may also append additional markers like a downgrade flag or an either-side flag. The function does not accept any input parameters and does not return any value.",
        "code_id": "c_group_1_id_178",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x70(%rbp),%rax\nmov    $0x64,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x31\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3d\nmov    %rax,%rdx\nlea    -0x70(%rbp),%rax\nadd    %rdx,%rax\nmovw   $0x3a32,(%rax)\nmovb   $0x0,0x2(%rax)\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncall   0x5c\nmov    %rax,%rdx\nlea    -0x70(%rbp),%rax\nadd    %rdx,%rax\nmovw   $0x3a33,(%rax)\nmovb   $0x0,0x2(%rax)\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncall   0x7b\nmov    %rax,%rdx\nlea    -0x70(%rbp),%rax\nadd    %rdx,%rax\nmovw   $0x3a34,(%rax)\nmovb   $0x0,0x2(%rax)\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nlea    -0x70(%rbp),%rax\nadd    %rdx,%rax\nmovabs $0x72676e776f642864,%rcx\n\nmov    %rcx,(%rax)\nmovl   $0x29656461,0x8(%rax)\nmovw   $0x3a,0xc(%rax)\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncall   0xca\nmov    0x0(%rip),%rax        # 0xd1\nmov    %rax,%rdi\ncall   0xd9\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xee\ncall   0xee\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x143\ncmpl   $0xffff,-0x8(%rbp)\njne    0x143\nlea    0x0(%rip),%rax        # 0x118\nmov    %rax,%rdi\ncall   0x120\nlea    0x0(%rip),%rax        # 0x127\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x131\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x13b\nmov    %rax,%rdi\ncall   0x143\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_280",
        "query_text": "The function takes a single input\u2014a pointer to a character array representing the program's name or path. It first extracts only the program name by removing any preceding directory path components if a '/' is present. Next, it prints a formatted message that details how to run the program, showing two examples: one for executing a single throughput test and another for running multiple tests (indicating the best result among them). Finally, the function terminates the program with an exit status of 0. The input is of type \"const char *\", and the function does not return any value (void).",
        "code_id": "c_group_1_id_280",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    $0x2f,%esi\nmov    %rax,%rdi\ncall   0x21\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsetne  %al\ntest   %al,%al\nje     0x39\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x58\nmov    $0x0,%edi\ncall   0x62\nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb5\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb5\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rdi\ncall   0x92\nlea    0x0(%rip),%rax        # 0x99\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa3\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xad\nmov    %rax,%rdi\ncall   0xb5\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x62\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_234",
        "query_text": "The function takes two inputs: a pointer to an array of character pointers and an unsigned integer representing the number of elements in that array. It iterates over the array, freeing each allocated sub-array of characters. After processing all elements, it frees the memory allocated for the array itself. The function returns no value, and its purpose is to deallocate all memory associated with a dynamically allocated two-dimensional array of strings.",
        "code_id": "c_group_1_id_234",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x3d\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   0x39\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njb     0x1c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x51\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa7\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa7\nlea    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rdi\ncall   0x84\nlea    0x0(%rip),%rax        # 0x8b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x95\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9f\nmov    %rax,%rdi\ncall   0xa7\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x54\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_273",
        "query_text": "The function accepts five floating-point arguments: one representing a scalar interpolation parameter and four representing control values that influence the smooth curve's behavior. Inside, it uses basic arithmetic operations\u2014such as multiplication and addition\u2014to compute several intermediate values. These computed values are then combined using a specific mathematical formula to perform the interpolation. The final result is a single floating-point value that represents the interpolated output. The function performs all calculations internally without relying on external dependencies, and its operation is fully deterministic, ensuring that identical inputs will always produce the same result.",
        "code_id": "c_group_1_id_273",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x24(%rbp)\nmovss  %xmm1,-0x28(%rbp)\nmovss  %xmm2,-0x2c(%rbp)\nmovss  %xmm3,-0x30(%rbp)\nmovss  %xmm4,-0x34(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmovss  -0x1c(%rbp),%xmm0\naddss  %xmm0,%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmovss  -0x18(%rbp),%xmm0\naddss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x18(%rbp),%xmm0\nmulss  -0x24(%rbp),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmulss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0xc(%rbp),%xmm0\nsubss  -0x1c(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x10(%rbp),%xmm0\nsubss  -0x14(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x95\n\naddss  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x28(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nsubss  -0x1c(%rbp),%xmm0\naddss  -0x24(%rbp),%xmm0\nmulss  -0x2c(%rbp),%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x30(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmovss  -0x34(%rbp),%xmm1\nmulss  -0x4(%rbp),%xmm1\nsubss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x12a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x12a\nlea    0x0(%rip),%rax        # 0xff\nmov    %rax,%rdi\ncall   0x107\nlea    0x0(%rip),%rax        # 0x10e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x118\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x122\nmov    %rax,%rdi\ncall   0x12a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xd7\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_183",
        "query_text": "The function accepts as input a pointer to a constant character array (string) and a pointer to an integer representing the current line length. It outputs the string with proper indentation and line wrapping: initially adding an indentation when starting a new line, then printing the string while updating the line length counter. If the current line length exceeds a predefined maximum value, the function outputs a newline and resets the counter. The function returns no value (void); its purpose is to format and print text so that it adheres to a specified line width.",
        "code_id": "c_group_1_id_183",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nlea    0x0(%rip),%rax        # 0x1c\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    0x61\nlea    0x0(%rip),%rax        # 0x31\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x3b\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x48\nmov    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdi\ncall   0x57\nmov    -0x30(%rbp),%rax\nmovl   $0xd,(%rax)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x7c\nmov    0x0(%rip),%rax        # 0x83\nmov    %rax,%rdi\ncall   0x8b\nmov    -0x30(%rbp),%rax\nmov    (%rax),%ebx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9d\nadd    $0x1,%eax\nlea    (%rbx,%rax,1),%edx\nmov    -0x30(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\nmov    (%rax),%eax\ncmp    $0x50,%eax\njle    0xd7\nmov    $0xa,%edi\ncall   0xbe\nmov    0x0(%rip),%rax        # 0xc5\nmov    %rax,%rdi\ncall   0xcd\nmov    -0x30(%rbp),%rax\nmovl   $0x0,(%rax)\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x131\ncmpl   $0xffff,-0x8(%rbp)\njne    0x131\nlea    0x0(%rip),%rax        # 0x106\nmov    %rax,%rdi\ncall   0x10e\nlea    0x0(%rip),%rax        # 0x115\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x11f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x129\nmov    %rax,%rdi\ncall   0x131\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xde\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_295",
        "query_text": "The function takes three parameters: an integer representing the total number of elements, and two arrays containing double-precision floating-point numbers that hold the datasets to be compared. It calculates the squared differences between corresponding elements in the two arrays, accumulates these values, and then divides the total by the number of elements to compute the average of the squared differences. Finally, it takes the square root of this average to obtain the Root Mean Square Error (RMSE), which is returned as a double.",
        "code_id": "c_group_1_id_295",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    0xae\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nsubsd  %xmm2,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     0x2c\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x14(%rbp),%xmm1\nmovsd  -0x8(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   0xdb\nmovq   %xmm0,%rax\nmov    %rax,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x148\ncmpl   $0xffff,-0x8(%rbp)\njne    0x148\nlea    0x0(%rip),%rax        # 0x11d\nmov    %rax,%rdi\ncall   0x125\nlea    0x0(%rip),%rax        # 0x12c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x136\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x140\nmov    %rax,%rdi\ncall   0x148\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf5\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_233",
        "query_text": "The function accepts a single character input (of type char) representing a hexadecimal digit. It checks if the input is a decimal digit between '0' and '9'; if so, it converts it to its corresponding integer value (0\u20139) by subtracting the ASCII value for '0'. If the input is a lowercase letter between 'a' and 'f', it converts it to its equivalent hexadecimal value (10\u201315) by adjusting for the ASCII offset for 'a'. If the character does not fall within these valid ranges, the function terminates the program abruptly using abort(). The resulting output is an integer (of type int) corresponding to the numeric value of the hexadecimal digit if valid.",
        "code_id": "c_group_1_id_233",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x2f,-0x4(%rbp)\njle    0x26\ncmpb   $0x39,-0x4(%rbp)\njg     0x26\nmovsbl -0x4(%rbp),%eax\nsub    $0x30,%eax\njmp    0x40\ncmpb   $0x60,-0x4(%rbp)\njle    0x3b\ncmpb   $0x66,-0x4(%rbp)\njg     0x3b\nmovsbl -0x4(%rbp),%eax\nsub    $0x57,%eax\njmp    0x40\ncall   0x40\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x95\ncmpl   $0xffff,-0x8(%rbp)\njne    0x95\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdi\ncall   0x72\nlea    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x83\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8d\nmov    %rax,%rdi\ncall   0x95\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x42\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_184",
        "query_text": "The function accepts two constant character arrays (strings) as inputs. It performs a case-sensitive exact string comparison and returns an integer value: it returns 1 if the strings are identical and 0 if they are not.",
        "code_id": "c_group_1_id_184",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x84\ncmpl   $0xffff,-0x8(%rbp)\njne    0x84\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rdi\ncall   0x84\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x31\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_302",
        "query_text": "The function accepts a pointer to an array of constant C-style strings (of type const char* const*). It checks whether the input pointer is null; if it is, the function exits without performing any operations. Otherwise, it iterates over the array, deleting each string via a helper routine, and finally deletes the array itself using the same helper. The function does not return any value (void).",
        "code_id": "c_group_1_id_302",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     0x4f\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    0x35\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   0x30\naddq   $0x8,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    0x21\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x4d\njmp    0x50\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa5\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa5\nlea    0x0(%rip),%rax        # 0x7a\nmov    %rax,%rdi\ncall   0x82\nlea    0x0(%rip),%rax        # 0x89\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x93\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9d\nmov    %rax,%rdi\ncall   0xa5\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x52\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_182",
        "query_text": "This function conditionally deallocates memory for a linked list of statistics data structures when a specific compilation flag is active. It iterates over the list starting from the head, freeing each node by invoking a custom memory deallocation routine. After traversing and freeing all nodes, the function resets both the head and tail pointers to null, thereby reinitializing the list. The function takes no inputs and returns no output (void), serving solely to clean up dynamically allocated memory associated with the statistics tracking system.",
        "code_id": "c_group_1_id_182",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_319",
        "query_text": "The function takes four unsigned integers that represent individual bytes of a UTF-8 encoded character, and it outputs a single unsigned integer representing the decoded Unicode code point. It does so by first applying bit masks to each byte to extract the relevant bits, then shifting these bits to their correct positions, and finally combining them using bitwise OR operations.",
        "code_id": "c_group_1_id_319",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %edx,-0xc(%rbp)\nmov    %ecx,-0x10(%rbp)\nmov    -0x4(%rbp),%eax\nshl    $0x12,%eax\nand    $0x1c0000,%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nshl    $0xc,%eax\nand    $0x3f000,%eax\nor     %eax,%edx\nmov    -0xc(%rbp),%eax\nshl    $0x6,%eax\nand    $0xfc0,%eax\nor     %eax,%edx\nmov    -0x10(%rbp),%eax\nand    $0x3f,%eax\nor     %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x98\ncmpl   $0xffff,-0x8(%rbp)\njne    0x98\nlea    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rdi\ncall   0x75\nlea    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x86\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x90\nmov    %rax,%rdi\ncall   0x98\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x45\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_296",
        "query_text": "The function takes an array of floating-point numbers and an integer representing the array's length. It iterates over the array, calculates the absolute value of each element, and updates the current maximum when a larger absolute value is found. Finally, it returns the maximum absolute value as a floating-point number.",
        "code_id": "c_group_1_id_296",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    0x79\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovq   0x0(%rip),%xmm1        # 0x41\n\nandpd  %xmm1,%xmm0\ncomisd -0x8(%rbp),%xmm0\njb     0x75\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovq   0x0(%rip),%xmm1        # 0x6c\n\nandpd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x21\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xe5\ncmpl   $0xffff,-0x8(%rbp)\njne    0xe5\nlea    0x0(%rip),%rax        # 0xba\nmov    %rax,%rdi\ncall   0xc2\nlea    0x0(%rip),%rax        # 0xc9\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xd3\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xdd\nmov    %rax,%rdi\ncall   0xe5\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x92\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_177",
        "query_text": "This function removes a file from the file system based on a provided string that specifies the file's name. It utilizes platform-specific system calls: on certain Windows compilers, it employs one call, whereas on other systems it uses an alternative call. If the deletion operation completes successfully, the function returns 0; if it fails, the function returns -1 to signal an error.",
        "code_id": "c_group_1_id_177",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\ntest   %eax,%eax\nsetne  %al\ntest   %al,%al\nje     0x2c\nmov    $0xffffffff,%eax\njmp    0x31\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x86\ncmpl   $0xffff,-0x8(%rbp)\njne    0x86\nlea    0x0(%rip),%rax        # 0x5b\nmov    %rax,%rdi\ncall   0x63\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x74\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rdi\ncall   0x86\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x33\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_248",
        "query_text": "The function takes a vector of pointers to unsigned characters and a pointer to a pointer to unsigned characters as inputs. It sequentially copies the elements from the vector into the memory location referenced by the second input using a standard library copy algorithm.",
        "code_id": "c_group_1_id_248",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x21\nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmov    %rax,%rcx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdx\nmov    %rbx,%rsi\nmov    %rcx,%rdi\ncall   0x45\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9f\nlea    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdi\ncall   0x7c\nlea    0x0(%rip),%rax        # 0x83\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x97\nmov    %rax,%rdi\ncall   0x9f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x4c\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x18(%rbp),%rdx\nlea    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x32\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x4a\ncall   0x4a\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x18(%rbp),%rax\nlea    0x8(%rax),%rdx\nlea    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x36\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x4e\ncall   0x4e\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x25\nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdx\nmov    %rbx,%rsi\nmov    %rcx,%rdi\ncall   0x49\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x27\nmov    %rax,%r12\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x36\nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x45\nmov    %r12,%rdx\nmov    %rbx,%rsi\nmov    %rax,%rdi\ncall   0x53\nmov    %rax,%rdx\nlea    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x65\nadd    $0x20,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nmov    (%rax),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nsub    -0x18(%rbp),%rax\nsar    $0x3,%rax\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     0x4e\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x4e\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_281",
        "query_text": "The function accepts three floating-point inputs. The first two inputs define a range, while the third represents a value within or beyond this range. The function determines the relative position of the third value between the two endpoints. It starts by calculating the difference between the second and first values. If this difference is zero, meaning the range is degenerate, the function returns 1.0 to indicate that the third value is considered at the end of the range. Otherwise, it computes the ratio of the difference between the third value and the first value to that overall range, effectively expressing the position as a percentage. The function then returns this computed ratio as the output.",
        "code_id": "c_group_1_id_281",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  %xmm1,-0x18(%rbp)\nmovss  %xmm2,-0x1c(%rbp)\nmovss  -0x18(%rbp),%xmm0\nsubss  -0x14(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\npxor   %xmm0,%xmm0\nucomiss -0x4(%rbp),%xmm0\nsetnp  %al\nmov    $0x0,%edx\npxor   %xmm0,%xmm0\nucomiss -0x4(%rbp),%xmm0\ncmovne %edx,%eax\ntest   %al,%al\nje     0x4f\nmovss  0x0(%rip),%xmm0        # 0x4d\n\njmp    0x5e\nmovss  -0x1c(%rbp),%xmm0\nsubss  -0x14(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb3\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb3\nlea    0x0(%rip),%rax        # 0x88\nmov    %rax,%rdi\ncall   0x90\nlea    0x0(%rip),%rax        # 0x97\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa1\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xab\nmov    %rax,%rdi\ncall   0xb3\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x60\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_282",
        "query_text": "The function accepts two parameters: a pointer to an array of floating-point numbers and an integer representing the number of elements in the array. It processes the array by swapping elements from opposite ends, starting with the first and last elements, gradually moving towards the center. This approach results in the entire array being reversed in place, meaning the original array is directly modified. The function does not return any value.",
        "code_id": "c_group_1_id_282",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x8(%rbp)\njmp    0x93\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rcx\n\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0xc(%rbp)\nsubl   $0x1,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njl     0x21\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xf2\ncmpl   $0xffff,-0x8(%rbp)\njne    0xf2\nlea    0x0(%rip),%rax        # 0xc7\nmov    %rax,%rdi\ncall   0xcf\nlea    0x0(%rip),%rax        # 0xd6\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xe0\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xea\nmov    %rax,%rdi\ncall   0xf2\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x9f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_304",
        "query_text": "The function accepts two characters as inputs. It computes the difference between their ASCII values and returns the result as an integer. A positive outcome indicates that the first character's ASCII value is greater, a negative outcome indicates it is lower, and zero signifies that both characters have the same ASCII value.",
        "code_id": "c_group_1_id_304",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%edx\nmov    %esi,%eax\nmov    %dl,-0x4(%rbp)\nmov    %al,-0x8(%rbp)\nmovsbl -0x4(%rbp),%eax\nmovsbl -0x8(%rbp),%edx\nsub    %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x71\ncmpl   $0xffff,-0x8(%rbp)\njne    0x71\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdi\ncall   0x4e\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_309",
        "query_text": "This description details a function that prints a failure notification along with contextual information to standard output. It accepts three parameters: a pointer to a null-terminated string representing a file identifier, an integer signifying a source code line number, and a formatted string with optional variable arguments. The function begins by outputting the file identifier and line number in a formatted manner, then proceeds to print the dynamically formatted message, and finally appends a newline character. Note that the function does not return any value (void).",
        "code_id": "c_group_1_id_309",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0xf0,%rsp\nmov    %rdi,-0xd8(%rbp)\nmov    %esi,-0xdc(%rbp)\nmov    %rdx,-0xe8(%rbp)\nmov    %rcx,-0x98(%rbp)\nmov    %r8,-0x90(%rbp)\nmov    %r9,-0x88(%rbp)\ntest   %al,%al\nje     0x5c\nmovaps %xmm0,-0x80(%rbp)\nmovaps %xmm1,-0x70(%rbp)\nmovaps %xmm2,-0x60(%rbp)\nmovaps %xmm3,-0x50(%rbp)\nmovaps %xmm4,-0x40(%rbp)\nmovaps %xmm5,-0x30(%rbp)\nmovaps %xmm6,-0x20(%rbp)\nmovaps %xmm7,-0x10(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0xb8(%rbp)\nxor    %eax,%eax\nmovl   $0x18,-0xd0(%rbp)\n\nmovl   $0x30,-0xcc(%rbp)\n\nlea    0x10(%rbp),%rax\nmov    %rax,-0xc8(%rbp)\nlea    -0xb0(%rbp),%rax\nmov    %rax,-0xc0(%rbp)\nmov    -0xdc(%rbp),%edx\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0xb2\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xbf\nlea    -0xd0(%rbp),%rdx\nmov    -0xe8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xd8\nmov    $0xa,%edi\ncall   0xe2\nnop\nmov    -0xb8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xfa\ncall   0xfa\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x14f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x14f\nlea    0x0(%rip),%rax        # 0x124\nmov    %rax,%rdi\ncall   0x12c\nlea    0x0(%rip),%rax        # 0x133\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x13d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x147\nmov    %rax,%rdi\ncall   0x14f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xfc\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_301",
        "query_text": "This description details a function that writes two arrays of double-precision numbers to a file formatted for compatibility with a numerical computing tool. The function takes five parameters: a filename specifying where to write the data, a pointer to a double array representing input values, an integer denoting the number of elements in the input array, a pointer to a double array representing output values, and an integer for the number of elements in the output array. Initially, the function attempts to open the specified file for writing. If the file cannot be opened, it exits immediately without performing any operations. Otherwise, it writes a header comment to indicate that the file was not generated by the numerical computing tool. It then writes metadata for the input dataset, including the type identifier, the row count (derived from the input array length), and a fixed column count, followed by the actual input data values. Next, it writes analogous metadata for the output dataset and sequentially writes the corresponding output data. Finally, the file is closed, and the function completes without returning any value.",
        "code_id": "c_group_1_id_301",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    %r8d,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x2d\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x3a\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x45\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x50\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\ntest   %al,%al\njne    0x226\nmov    -0x8(%rbp),%rax\nmov    %rax,%rcx\nmov    $0x18,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rdi\ncall   0x84\nmov    -0x8(%rbp),%rax\nmov    %rax,%rcx\nmov    $0xe,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x9c\nmov    %rax,%rdi\ncall   0xa4\nmov    -0x8(%rbp),%rax\nmov    %rax,%rcx\nmov    $0xf,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0xbc\nmov    %rax,%rdi\ncall   0xc4\nmov    -0x24(%rbp),%edx\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0xd2\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xe2\nmov    -0x8(%rbp),%rax\nmov    %rax,%rcx\nmov    $0xd,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0xfa\nmov    %rax,%rdi\ncall   0x102\nmovl   $0x0,-0xc(%rbp)\njmp    0x146\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0x132\nmov    %rdx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x142\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     0x10b\nmov    -0x8(%rbp),%rax\nmov    %rax,%rcx\nmov    $0xf,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x166\nmov    %rax,%rdi\ncall   0x16e\nmov    -0x8(%rbp),%rax\nmov    %rax,%rcx\nmov    $0xf,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x186\nmov    %rax,%rdi\ncall   0x18e\nmov    -0x28(%rbp),%edx\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x19c\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x1ac\nmov    -0x8(%rbp),%rax\nmov    %rax,%rcx\nmov    $0xd,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rax        # 0x1c4\nmov    %rax,%rdi\ncall   0x1cc\nmovl   $0x0,-0xc(%rbp)\njmp    0x210\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmovq   %rdx,%xmm0\nlea    0x0(%rip),%rdx        # 0x1fc\nmov    %rdx,%rsi\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x20c\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x28(%rbp),%eax\njl     0x1d5\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x224\njmp    0x227\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x27c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x27c\nlea    0x0(%rip),%rax        # 0x251\nmov    %rax,%rdi\ncall   0x259\nlea    0x0(%rip),%rax        # 0x260\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x26a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x274\nmov    %rax,%rdi\ncall   0x27c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x229\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_279",
        "query_text": "The function receives three inputs: an array of string pointers (with each string represented by an array of unsigned characters), an integer specifying the count of strings in the array, and another integer that indicates the starting offset within each string for comparisons. It performs an in-place ascending order sort on the array using an insertion sort algorithm. The comparison process begins at the provided offset for each string and continues character by character until a discrepancy is detected or the end of a string is reached. This function does not return any value since it modifies the input array directly.",
        "code_id": "c_group_1_id_279",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %edx,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nadd    $0x8,%rax\nmov    %rax,-0x20(%rbp)\njmp    0xd9\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x18(%rbp)\njmp    0xc3\nmov    -0x18(%rbp),%rax\nsub    $0x8,%rax\nmov    (%rax),%rdx\nmov    -0x30(%rbp),%eax\ncltq   \nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x30(%rbp),%eax\ncltq   \nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\njmp    0x66\naddq   $0x1,-0x10(%rbp)\naddq   $0x1,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    0x83\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x5c\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njbe    0xd3\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x18(%rbp),%rax\nlea    -0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nsubq   $0x8,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x28(%rbp),%rax\nja     0x30\njmp    0xd4\nnop\naddq   $0x8,-0x20(%rbp)\nsubl   $0x1,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\nsetg   %al\ntest   %al,%al\njne    0x23\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x143\ncmpl   $0xffff,-0x8(%rbp)\njne    0x143\nlea    0x0(%rip),%rax        # 0x118\nmov    %rax,%rdi\ncall   0x120\nlea    0x0(%rip),%rax        # 0x127\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x131\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x13b\nmov    %rax,%rdi\ncall   0x143\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_278",
        "query_text": "The function accepts three parameters: an unsigned long integer, an unsigned char indicating the number of leading bits, and an unsigned char serving as a right shift amount. It first creates a header by computing a bit pattern where the specified number of highest-order bits are set. Then, it constructs a mask by right-shifting a full 8-bit value to leave room for the header. After shifting the integer by the provided amount and applying the mask to isolate the relevant bits, it combines these results using a bitwise OR operation. The final output is a char value that encodes the adjusted data based on the header and masked portion.",
        "code_id": "c_group_1_id_278",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,%ecx\nmov    %edx,%eax\nmov    %ecx,%edx\nmov    %dl,-0x1c(%rbp)\nmov    %al,-0x20(%rbp)\nmovzbl -0x1c(%rbp),%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nlea    -0x1(%rax),%edx\nmovzbl -0x1c(%rbp),%ecx\nmov    $0x8,%eax\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nmov    %al,-0x2(%rbp)\nmovzbl -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    $0xff,%edx\nmov    %eax,%ecx\nsar    %cl,%edx\nmov    %edx,%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x20(%rbp),%eax\nmov    -0x18(%rbp),%rdx\nmov    %eax,%ecx\nshr    %cl,%rdx\nmov    %rdx,%rax\nand    -0x1(%rbp),%al\nor     -0x2(%rbp),%al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xbe\ncmpl   $0xffff,-0x8(%rbp)\njne    0xbe\nlea    0x0(%rip),%rax        # 0x93\nmov    %rax,%rdi\ncall   0x9b\nlea    0x0(%rip),%rax        # 0xa2\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xac\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb6\nmov    %rax,%rdi\ncall   0xbe\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x6b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_306",
        "query_text": "The function receives two inputs, each being a generic pointer that represents a constant string. It casts these generic inputs into string types and then compares them lexicographically using a standard library routine. The function returns an integer: a negative value indicates that the first string is lexicographically smaller than the second, zero indicates that they are equal, and a positive value indicates that the first string is lexicographically larger than the second.",
        "code_id": "c_group_1_id_306",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7c\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,%rdi\ncall   0x59\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdi\ncall   0x7c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x29\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_330",
        "query_text": "The function takes two integers as input and returns an integer. It computes a divisor by raising 2 to the power of the second input, then checks whether the first input is divisible by this divisor. If it is divisible, the function returns 1; otherwise, it returns 0.",
        "code_id": "c_group_1_id_330",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x2c\nshll   -0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     0x25\nmov    -0x14(%rbp),%eax\ncltd   \nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\nje     0x48\nmovl   $0x0,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa0\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa0\nlea    0x0(%rip),%rax        # 0x75\nmov    %rax,%rdi\ncall   0x7d\nlea    0x0(%rip),%rax        # 0x84\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x98\nmov    %rax,%rdi\ncall   0xa0\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x4d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_305",
        "query_text": "The function takes two unsigned integers as inputs: a 64-bit value to be manipulated and a 32-bit value that specifies the number of bit positions for the rotation. It first confines the rotation count to a valid range (0 to 63) by applying a mask. The function then performs a right bitwise rotation by shifting the 64-bit input to the right by the specified count and combining it with the input shifted to the left by the complementary number (64 minus the count). Finally, it returns the resulting 64-bit unsigned integer after the rotation.",
        "code_id": "c_group_1_id_305",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nandl   $0x3f,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nmov    %eax,%ecx\nror    %cl,%rdx\nmov    %rdx,%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x77\ncmpl   $0xffff,-0x8(%rbp)\njne    0x77\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rdi\ncall   0x54\nlea    0x0(%rip),%rax        # 0x5b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x65\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rdi\ncall   0x77\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x24\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_347",
        "query_text": "The function overloads the stream insertion operator to output a 128-bit unsigned integer to an output stream. It accepts two inputs: an output stream and a 128-bit unsigned integer. The function starts by initializing a temporary copy of the integer and preparing a character buffer to hold its decimal representation. It then iteratively computes the digits by repeatedly taking the remainder when divided by 10 and storing the corresponding character in the buffer in reverse order, until the entire number has been processed. Once the conversion is complete, the resulting string is written to the output stream. If the write operation does not successfully output the complete string, the function sets an error state on the stream. Finally, the output stream is returned to facilitate chained stream operations. The input types are an output stream and a 128-bit unsigned integer, and the output type is an output stream.",
        "code_id": "c_group_1_id_347",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0xe8,%rsp\nmov    %rdi,-0xd8(%rbp)\nmov    %rdx,%rcx\nmov    %rsi,%rax\nmov    %rdi,%rdx\nmov    %rcx,%rdx\nmov    %rax,-0xf0(%rbp)\nmov    %rdx,-0xe8(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0xd8(%rbp),%rdx\nlea    -0xc0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x59\nlea    -0xc0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x68\ntest   %al,%al\nje     0x1e7\nmov    -0xf0(%rbp),%rax\nmov    -0xe8(%rbp),%rdx\nmov    %rax,-0xb0(%rbp)\nmov    %rdx,-0xa8(%rbp)\nlea    -0xa0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9b\nmov    %rax,-0xc8(%rbp)\nsubq   $0x1,-0xc8(%rbp)\n\nmov    -0xb0(%rbp),%rax\nmov    -0xa8(%rbp),%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    $0xa,%edx\nmov    $0x0,%ecx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   0xd9\nmov    %rax,%rcx\nmov    %rdx,%rbx\nlea    0x0(%rip),%rax        # 0xe6\nadd    %rcx,%rax\nmovzbl (%rax),%edx\nmov    -0xc8(%rbp),%rax\nmov    %dl,(%rax)\nmov    -0xb0(%rbp),%rax\nmov    -0xa8(%rbp),%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    $0xa,%edx\nmov    $0x0,%ecx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   0x124\nmov    %rax,-0xb0(%rbp)\nmov    %rdx,-0xa8(%rbp)\nmov    -0xa8(%rbp),%rax\nor     -0xb0(%rbp),%rax\ntest   %rax,%rax\njne    0xa2\nlea    -0xa0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x158\nsub    -0xc8(%rbp),%rax\nmov    %eax,-0xcc(%rbp)\nmov    -0xd8(%rbp),%rax\nmov    (%rax),%rax\nsub    $0x18,%rax\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    -0xd8(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,%rdi\ncall   0x18b\nmov    %rax,%rcx\nmov    -0xcc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc8(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0x1a9\nmov    -0xcc(%rbp),%edx\nmovslq %edx,%rdx\ncmp    %rdx,%rax\nsetne  %al\ntest   %al,%al\nje     0x1e7\nmov    -0xd8(%rbp),%rax\nmov    (%rax),%rax\nsub    $0x18,%rax\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    -0xd8(%rbp),%rax\nadd    %rdx,%rax\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   0x1e7\nmov    -0xd8(%rbp),%rbx\nlea    -0xc0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1fd\nmov    %rbx,%rax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x237\njmp    0x232\nendbr64 \nmov    %rax,%rbx\nlea    -0xc0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x227\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x232\ncall   0x237\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x290\ncmpl   $0xffff,-0x8(%rbp)\njne    0x290\nlea    0x0(%rip),%rax        # 0x265\nmov    %rax,%rdi\ncall   0x26d\nlea    0x0(%rip),%rax        # 0x274\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x27e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x288\nmov    %rax,%rdi\ncall   0x290\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x23d\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nsub    $0xffffffffffffff80,%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_275",
        "query_text": "The function takes a single input: a floating-point value that typically represents a normalized time or progress value between 0 and 1. It then computes and returns a floating-point output by evaluating the input against a series of four distinct intervals. For each interval, a different mathematical expression is applied\u2014beginning with the calculation of the input\u2019s square\u2014resulting in a smooth, non-linear transformation. This piecewise computation generates what is known as a \"bounce-out\" easing effect, which is commonly used in animations to simulate a deceleration with a bouncing motion as the transition nears completion.",
        "code_id": "c_group_1_id_275",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x23\n\ncomiss -0x14(%rbp),%xmm0\njbe    0x4b\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x36\n\nmulss  %xmm1,%xmm0\nmovss  0x0(%rip),%xmm1        # 0x42\n\ndivss  %xmm1,%xmm0\njmp    0x10a\nmovss  0x0(%rip),%xmm0        # 0x53\n\ncomiss -0x14(%rbp),%xmm0\njbe    0x90\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x66\n\nmulss  %xmm1,%xmm0\nmovss  -0x14(%rbp),%xmm2\nmovss  0x0(%rip),%xmm1        # 0x77\n\nmulss  %xmm1,%xmm2\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmovss  0x0(%rip),%xmm0        # 0x8a\n\naddss  %xmm1,%xmm0\njmp    0x10a\nmovss  0x0(%rip),%xmm0        # 0x98\n\ncomiss -0x14(%rbp),%xmm0\njbe    0xd5\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xab\n\nmulss  %xmm1,%xmm0\nmovss  -0x14(%rbp),%xmm2\nmovss  0x0(%rip),%xmm1        # 0xbc\n\nmulss  %xmm1,%xmm2\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmovss  0x0(%rip),%xmm0        # 0xcf\n\naddss  %xmm1,%xmm0\njmp    0x10a\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xe2\n\nmulss  %xmm1,%xmm0\nmovss  -0x14(%rbp),%xmm2\nmovss  0x0(%rip),%xmm1        # 0xf3\n\nmulss  %xmm1,%xmm2\nmovaps %xmm0,%xmm1\nsubss  %xmm2,%xmm1\nmovss  0x0(%rip),%xmm0        # 0x106\n\naddss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x15f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x15f\nlea    0x0(%rip),%rax        # 0x134\nmov    %rax,%rdi\ncall   0x13c\nlea    0x0(%rip),%rax        # 0x143\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x14d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x157\nmov    %rax,%rdi\ncall   0x15f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x10c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_277",
        "query_text": "The function takes two inputs: a pointer to a constant character string, and a pointer to a pointer to a constant character string. It checks whether the target string starts with the given prefix by comparing the beginning of the target string with the prefix. If the target string starts with the prefix, it advances the pointer to the target string by the length of the prefix and returns true; if not, it leaves the pointer unchanged and returns false. The input types are a pointer to a constant char and a pointer to a pointer to a constant char, and the output is of type bool.",
        "code_id": "c_group_1_id_277",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    %rax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rdx\nmov    -0x18(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x3e\ntest   %eax,%eax\njne    0x5e\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,(%rax)\nmov    $0x1,%eax\njmp    0x63\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb8\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb8\nlea    0x0(%rip),%rax        # 0x8d\nmov    %rax,%rdi\ncall   0x95\nlea    0x0(%rip),%rax        # 0x9c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa6\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb0\nmov    %rax,%rdi\ncall   0xb8\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x65\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_332",
        "query_text": "The function accepts two 64-bit unsigned integers as inputs and returns a 64-bit unsigned integer output computed as the high-order 64 bits of their product. If the system provides native support for 128-bit integers, the function multiplies the inputs directly, shifts the result right by 64 bits to obtain the high-order portion, and performs a conditional adjustment based on the sign bit. Otherwise, the function manually performs the multiplication by splitting each input into higher and lower 32-bit segments, calculates the respective partial products, and combines them\u2014taking into account necessary carry-overs\u2014to yield the correct high-order bits of the overall product.",
        "code_id": "c_group_1_id_332",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rsi\nmov    %rsi,%rcx\nmov    $0x0,%ebx\nmov    -0x40(%rbp),%rsi\nmov    %rsi,%rax\nmov    $0x0,%edx\nmov    %rbx,%rdi\nimul   %rax,%rdi\nmov    %rdx,%rsi\nimul   %rcx,%rsi\nadd    %rdi,%rsi\nmul    %rcx\nlea    (%rsi,%rdx,1),%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\nmov    %rax,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\ntest   %rax,%rax\njns    0x78\nmov    -0x28(%rbp),%rax\nadd    $0x1,%rax\njmp    0x7c\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd5\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd5\nlea    0x0(%rip),%rax        # 0xaa\nmov    %rax,%rdi\ncall   0xb2\nlea    0x0(%rip),%rax        # 0xb9\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xc3\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xcd\nmov    %rax,%rdi\ncall   0xd5\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x82\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_287",
        "query_text": "The function takes no parameters and returns a std::string representing the temporary directory path, determined based on the operating system and environment. It first checks if a custom temporary directory function is defined via a specific macro; if so, it returns the result of that function. On Windows Mobile, it directly returns a hard-coded directory path (\"\\\\temp\\\\\"). For Windows systems, it retrieves an environment variable; if the variable is either unset or empty, it defaults to the same hard-coded path, and if it exists but lacks a trailing backslash, it appends one before returning. On Android, it returns a predefined path (\"/sdcard/\"), while for other systems such as Linux or Unix-like environments, it defaults to returning \"/tmp/\".",
        "code_id": "c_group_1_id_287",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2c\nlea    -0x19(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x3b\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x46\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x52\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x86\njmp    0x81\nendbr64 \nmov    %rax,%rbx\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x76\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x81\ncall   0x86\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xe3\ncmpl   $0xffff,-0x8(%rbp)\njne    0xe3\nlea    0x0(%rip),%rax        # 0xb8\nmov    %rax,%rdi\ncall   0xc0\nlea    0x0(%rip),%rax        # 0xc7\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xd1\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xdb\nmov    %rax,%rdi\ncall   0xe3\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x90\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_336",
        "query_text": "The function takes two inputs: a pointer to an array of floating-point numbers and an integer representing the number of elements in the array. It initializes a floating-point variable to hold a computed total. The function then iterates sequentially through the array, squaring each element and adding the resulting value to the total. After processing every element, it returns the final computed total, which represents the sum of the squares of the array's elements.",
        "code_id": "c_group_1_id_336",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    0x67\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0xc(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x21\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd3\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd3\nlea    0x0(%rip),%rax        # 0xa8\nmov    %rax,%rdi\ncall   0xb0\nlea    0x0(%rip),%rax        # 0xb7\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xc1\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xcb\nmov    %rax,%rdi\ncall   0xd3\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x80\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_340",
        "query_text": "The function accepts an array of double-precision values along with its length. It also takes two sets of filter coefficients\u2014one for low-pass and one for high-pass filtering\u2014along with information specifying their lengths and stride values for both input and output indexing. The function applies a symmetric discrete wavelet transform on the input array. It computes two separate output arrays: one storing approximation coefficients and the other storing detail coefficients derived from the transformation. To correctly handle cases where filter indices exceed the boundaries of the input array, the function mirrors the array values. This approach ensures that every computed coefficient is based on valid, reflected data.",
        "code_id": "c_group_1_id_340",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\nmov    %r8d,-0x30(%rbp)\nmov    %r9,-0x48(%rbp)\nmov    -0x30(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    0x38e\nmov    -0x18(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%eax\nimul   0x28(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmovl   $0x0,-0x14(%rbp)\njmp    0x37e\nmov    -0xc(%rbp),%eax\nsub    -0x14(%rbp),%eax\ntest   %eax,%eax\njs     0x18b\nmov    -0xc(%rbp),%eax\nsub    -0x14(%rbp),%eax\ncmp    %eax,-0x2c(%rbp)\njle    0x18b\nmov    -0xc(%rbp),%eax\nsub    -0x14(%rbp),%eax\nmov    0x20(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x37a\nmov    -0xc(%rbp),%eax\nsub    -0x14(%rbp),%eax\ntest   %eax,%eax\njns    0x280\nmov    -0x14(%rbp),%eax\nsub    -0xc(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    0x20(%rbp),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    0x37a\nmov    -0xc(%rbp),%eax\nsub    -0x14(%rbp),%eax\ncmp    %eax,-0x2c(%rbp)\njg     0x37a\nmov    -0x2c(%rbp),%eax\nadd    %eax,%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nlea    -0x1(%rax),%edx\nmov    0x20(%rbp),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\nmov    -0x8(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njl     0x8a\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    0x10(%rbp),%eax\njl     0x31\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x3f1\ncmpl   $0xffff,-0x8(%rbp)\njne    0x3f1\nlea    0x0(%rip),%rax        # 0x3c6\nmov    %rax,%rdi\ncall   0x3ce\nlea    0x0(%rip),%rax        # 0x3d5\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x3df\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x3e9\nmov    %rax,%rdi\ncall   0x3f1\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x39e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_219",
        "query_text": "The function takes a constant reference to a std::string as input and checks if the string contains no characters. It returns a boolean value: true if the string is empty, and false otherwise.",
        "code_id": "c_group_1_id_219",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x71\ncmpl   $0xffff,-0x8(%rbp)\njne    0x71\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdi\ncall   0x4e\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_339",
        "query_text": "The function accepts a single 64-bit unsigned integer as input and returns a 32-bit unsigned integer. It counts the number of trailing zero bits (i.e., the consecutive zeros starting from the least significant bit) present in the binary representation of the input. The function first attempts to use platform-specific optimizations, such as compiler intrinsics, to perform this calculation efficiently. If these optimizations are unavailable, it falls back to a bitwise algorithm to determine the count. The design emphasizes both performance and portability across different platforms and compilers.",
        "code_id": "c_group_1_id_339",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nxor    %eax,%eax\ntzcnt  -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x69\ncmpl   $0xffff,-0x8(%rbp)\njne    0x69\nlea    0x0(%rip),%rax        # 0x3e\nmov    %rax,%rdi\ncall   0x46\nlea    0x0(%rip),%rax        # 0x4d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdi\ncall   0x69\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x16\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_344",
        "query_text": "The function takes a 32-bit unsigned integer as input and returns a 32-bit unsigned integer as output. It reverses the byte order of the input value\u2014transforming the first byte into the last, the second byte into the third, the third byte into the second, and the last byte into the first\u2014effectively swapping between big-endian and little-endian representations. This is accomplished by isolating and rearranging the individual bytes using bitwise operations.",
        "code_id": "c_group_1_id_344",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshl    $0x18,%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nshl    $0x8,%eax\nand    $0xff0000,%eax\nor     %eax,%edx\nmov    -0x4(%rbp),%eax\nshr    $0x8,%eax\nand    $0xff00,%eax\nor     %eax,%edx\nmov    -0x4(%rbp),%eax\nshr    $0x18,%eax\nor     %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8a\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x78\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x82\nmov    %rax,%rdi\ncall   0x8a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x37\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_327",
        "query_text": "The function takes a reference to a string as input and modifies it in place by converting any uppercase letters to their corresponding lowercase letters. It achieves the conversion by iterating over each character and applying a transformation that checks if the character is uppercase; if so, it adjusts its value to the lowercase equivalent. Subsequently, the function returns the modified string, maintaining the input\u2019s type.",
        "code_id": "c_group_1_id_327",
        "code_text": "push   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %al,-0xc(%rbp)\ncmpb   $0x40,-0xc(%rbp)\njle    0x22\ncmpb   $0x5a,-0xc(%rbp)\njg     0x22\nmovzbl -0xc(%rbp),%eax\nadd    $0x20,%eax\njmp    0x26\nmovzbl -0xc(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x10,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x47\nmov    %rax,%r12\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x56\nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x65\nmov    %r12,%rdx\nmov    %rbx,%rsi\nmov    %rax,%rdi\ncall   0x80\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\njmp    0xe3\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0xa7\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nlea    -0x29(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x0\nmov    %eax,%ebx\nlea    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xc9\nmov    %bl,(%rax)\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0xd7\nlea    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xe3\nlea    -0x20(%rbp),%rdx\nlea    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf6\ntest   %al,%al\njne    0x9b\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x157\ncmpl   $0xffff,-0x8(%rbp)\njne    0x157\nlea    0x0(%rip),%rax        # 0x12c\nmov    %rax,%rdi\ncall   0x134\nlea    0x0(%rip),%rax        # 0x13b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x145\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x14f\nmov    %rax,%rdi\ncall   0x157\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x104\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x21\nmov    (%rax),%rbx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmov    (%rax),%rax\ncmp    %rax,%rbx\nsetne  %al\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_269",
        "query_text": "The function takes an integer input representing a Unicode code point and returns a boolean value. It first checks whether the character is one of a set of explicitly defined symbols (for instance, certain punctuation marks, whitespace characters, and specific control characters) and immediately returns false for them\u2014with one exception where a particular control value results in true. If the input does not match these cases, the function performs a series of range checks: it rejects characters that fall into control ranges (i.e., below a given low threshold), ignores characters in a narrow range following the standard printable set, and then further excludes characters within specific invalid Unicode ranges (such as surrogate pairs, non-characters, and code points exceeding the Unicode maximum). Generally, printable ASCII characters and valid Unicode characters that do not trigger any of these conditions are accepted as anchor characters. \n\nInput: int (representing a Unicode code point)  \nOutput: bool (true if the character qualifies as an anchor character, false otherwise)",
        "code_id": "c_group_1_id_269",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0xfeff,-0x4(%rbp)\nje     0xab\ncmpl   $0xfeff,-0x4(%rbp)\njg     0xbf\ncmpl   $0x2c,-0x4(%rbp)\njg     0x9a\ncmpl   $0x9,-0x4(%rbp)\njge    0x76\njmp    0xbf\nmov    -0x4(%rbp),%eax\nsub    $0x5b,%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%rdx\nmovabs $0x500000005,%rax\n\nand    %rdx,%rax\ntest   %rax,%rax\nsetne  %al\ntest   %al,%al\njne    0xab\nmovabs $0x40000000000,%rax\n\nand    %rdx,%rax\ntest   %rax,%rax\nsetne  %al\ntest   %al,%al\njne    0xb5\njmp    0xbf\nmov    -0x4(%rbp),%eax\nmovabs $0x100100002600,%rdx\n\nmov    %eax,%ecx\nshr    %cl,%rdx\nmov    %rdx,%rax\nand    $0x1,%eax\ntest   %rax,%rax\nsetne  %al\ntest   %al,%al\njne    0xab\njmp    0xbf\ncmpl   $0x85,-0x4(%rbp)\njg     0xbf\ncmpl   $0x5b,-0x4(%rbp)\njge    0x36\njmp    0xbf\nmov    $0x0,%eax\njmp    0x146\nmov    $0x1,%eax\njmp    0x146\ncmpl   $0x1f,-0x4(%rbp)\njg     0xcc\nmov    $0x0,%eax\njmp    0x146\ncmpl   $0x7d,-0x4(%rbp)\njg     0xd9\nmov    $0x1,%eax\njmp    0x146\ncmpl   $0x9f,-0x4(%rbp)\njg     0xe9\nmov    $0x0,%eax\njmp    0x146\ncmpl   $0xd7ff,-0x4(%rbp)\njle    0x102\ncmpl   $0xdfff,-0x4(%rbp)\njg     0x102\nmov    $0x0,%eax\njmp    0x146\nmov    -0x4(%rbp),%eax\nand    $0xfffe,%eax\ncmp    $0xfffe,%eax\njne    0x118\nmov    $0x0,%eax\njmp    0x146\ncmpl   $0xfdcf,-0x4(%rbp)\njle    0x131\ncmpl   $0xfdef,-0x4(%rbp)\njg     0x131\nmov    $0x0,%eax\njmp    0x146\ncmpl   $0x10ffff,-0x4(%rbp)\njle    0x141\nmov    $0x0,%eax\njmp    0x146\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x19b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x19b\nlea    0x0(%rip),%rax        # 0x170\nmov    %rax,%rdi\ncall   0x178\nlea    0x0(%rip),%rax        # 0x17f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x189\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x193\nmov    %rax,%rdi\ncall   0x19b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x148\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_286",
        "query_text": "The function accepts an unsigned integer as input and returns an unsigned integer as output. It computes the base-2 logarithm of the input by determining the position of the most significant set bit, effectively finding the highest power of 2 that is less than or equal to the input value. This is achieved by counting the number of leading zero bits in the binary representation of the input using a compiler intrinsic, and then calculating the logarithm by adjusting this count.",
        "code_id": "c_group_1_id_286",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nbsr    -0x4(%rbp),%eax\nxor    $0x1f,%eax\nmov    %eax,%edx\nmov    $0x1f,%eax\nsub    %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x70\ncmpl   $0xffff,-0x8(%rbp)\njne    0x70\nlea    0x0(%rip),%rax        # 0x45\nmov    %rax,%rdi\ncall   0x4d\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x68\nmov    %rax,%rdi\ncall   0x70\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_230",
        "query_text": "The function accepts a single parameter of type char. It converts the provided character to an unsigned char for compatibility with the standard library's character classification routine, which is then used to determine if the character is a whitespace character. Based on this evaluation, the function returns a boolean value: true if the character is whitespace, and false otherwise.",
        "code_id": "c_group_1_id_230",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   0x1f\ntest   %eax,%eax\nsetne  %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_329",
        "query_text": "The function accepts three inputs: an integer denoting the number of elements, and two pointers to arrays of double-precision floating-point numbers. It begins by computing the mean of each dataset by iterating through each array and averaging the values. Using these means, the function calculates the covariance between the two datasets by summing the product of the differences from the mean for each pair of corresponding elements. Simultaneously, it determines the sum of squared differences for each dataset to evaluate the standard deviations. Finally, it computes the Pearson correlation coefficient by dividing the covariance by the product of the two standard deviations, and returns this value as a double representing the strength and direction of the linear relationship between the datasets.",
        "code_id": "c_group_1_id_329",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %edi,-0x54(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %rdx,-0x68(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  -0x38(%rbp),%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovl   $0x0,-0x44(%rbp)\njmp    0x83\nmov    -0x44(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  -0x40(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmov    -0x44(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  -0x38(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x54(%rbp),%eax\njl     0x33\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x54(%rbp),%xmm1\nmovsd  -0x40(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x54(%rbp),%xmm1\nmovsd  -0x38(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovl   $0x0,-0x44(%rbp)\njmp    0x170\nmov    -0x44(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nsubsd  -0x40(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x44(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nsubsd  -0x38(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  -0x30(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\nmovsd  -0x28(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\nmovsd  -0x20(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x54(%rbp),%eax\njl     0xe2\nmovsd  -0x28(%rbp),%xmm0\nmulsd  -0x20(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   0x195\nmovapd %xmm0,%xmm1\nmovsd  -0x30(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  -0x18(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x20b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x20b\nlea    0x0(%rip),%rax        # 0x1e0\nmov    %rax,%rdi\ncall   0x1e8\nlea    0x0(%rip),%rax        # 0x1ef\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x1f9\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x203\nmov    %rax,%rdi\ncall   0x20b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b8\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_334",
        "query_text": "The function accepts two arrays of double-precision floating-point numbers and an integer that indicates the number of elements in each array. It computes the relative error between the arrays by first calculating the square root of the cumulative squared differences between corresponding elements in the arrays, and then dividing this value by the square root of the cumulative squared values of the elements in the first array. The function returns the resulting double-precision floating-point number as the relative error.",
        "code_id": "c_group_1_id_334",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %edx,-0x44(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    0xfa\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm2\nsubsd  %xmm2,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x20(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x24(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x18(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     0x36\nmov    -0x20(%rbp),%rax\nmovq   %rax,%xmm0\ncall   0x114\nmovq   %xmm0,%rbx\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\ncall   0x127\nmovq   %rbx,%xmm1\ndivsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x193\ncmpl   $0xffff,-0x8(%rbp)\njne    0x193\nlea    0x0(%rip),%rax        # 0x168\nmov    %rax,%rdi\ncall   0x170\nlea    0x0(%rip),%rax        # 0x177\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x181\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x18b\nmov    %rax,%rdi\ncall   0x193\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x140\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_314",
        "query_text": "The function accepts three integers as input: one representing the total number of partitions in a distributed testing framework, another indicating the current partition's index, and the last representing a test identifier. It computes the remainder of the test identifier divided by the total number of partitions and compares this result to the current partition index. If they match, the function returns a boolean true, signifying that the test associated with the identifier should execute on the given partition; otherwise, it returns false. The function's primary purpose is to distribute tests evenly across partitions using modulo arithmetic.",
        "code_id": "c_group_1_id_314",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %edx,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncltd   \nidivl  -0x4(%rbp)\nmov    %edx,%eax\ncmp    %eax,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x75\ncmpl   $0xffff,-0x8(%rbp)\njne    0x75\nlea    0x0(%rip),%rax        # 0x4a\nmov    %rax,%rdi\ncall   0x52\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x63\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rdi\ncall   0x75\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x22\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_338",
        "query_text": "This function outputs a two-dimensional array formatted as text. It accepts a one-dimensional array of double-precision values representing the matrix, along with integer parameters specifying the number of rows and columns. Initially, the function prints the matrix dimensions in a \"rows x columns\" format. It then iterates through each row, prefacing the row with its index and printing each element sequentially, followed by a closing row index. The result is a neatly formatted display on the console, and no value is returned.",
        "code_id": "c_group_1_id_338",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nmov    %eax,%esi\nlea    0x0(%rip),%rax        # 0x25\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x32\nmovl   $0x0,-0x8(%rbp)\njmp    0xc4\nmov    -0x8(%rbp),%eax\nmov    %eax,%esi\nlea    0x0(%rip),%rax        # 0x4a\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x57\nmovl   $0x0,-0x4(%rbp)\njmp    0x9f\nmov    -0x8(%rbp),%eax\nimul   -0x20(%rbp),%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nadd    %edx,%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmovq   %rax,%xmm0\nlea    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x9b\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     0x60\nmov    -0x8(%rbp),%eax\nmov    %eax,%esi\nlea    0x0(%rip),%rax        # 0xb3\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xc0\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     0x3e\nnop\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x127\ncmpl   $0xffff,-0x8(%rbp)\njne    0x127\nlea    0x0(%rip),%rax        # 0xfc\nmov    %rax,%rdi\ncall   0x104\nlea    0x0(%rip),%rax        # 0x10b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x115\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x11f\nmov    %rax,%rdi\ncall   0x127\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xd4\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_348",
        "query_text": "The function takes a constant character string as input and does not return any value. Its sole purpose is to immediately trigger an exception by throwing an instance of a memory allocation failure exception, without utilizing the provided message.",
        "code_id": "c_group_1_id_348",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    $0x8,%edi\ncall   0x1b\nmov    %rax,%rbx\nmov    %rbx,%rdi\ncall   0x26\nmov    0x0(%rip),%rax        # 0x2d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rsi\nmov    %rbx,%rdi\ncall   0x42\nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x95\ncmpl   $0xffff,-0x8(%rbp)\njne    0x95\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdi\ncall   0x72\nlea    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x83\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8d\nmov    %rax,%rdi\ncall   0x95\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x42\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nlea    0x0(%rip),%rdx        # 0x13\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nlea    0x0(%rip),%rdx        # 0x23\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_377",
        "query_text": "The function takes an unsigned 64-bit integer as input and returns an integer representing the count of bits set to 1 in the binary representation of the input. It computes what is commonly known as the Hamming weight or population count, utilizing an efficient built-in method provided by the compiler.",
        "code_id": "c_group_1_id_377",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   0x19\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6e\nlea    0x0(%rip),%rax        # 0x43\nmov    %rax,%rdi\ncall   0x4b\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdi\ncall   0x6e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_311",
        "query_text": "The function accepts two inputs: a string and a character. It first checks if the string is non-empty. If the string is not empty, it compares the first character of the string with the provided character and returns a boolean value indicating whether they match. If the string is empty, the function returns false.",
        "code_id": "c_group_1_id_311",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %al,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x21\nxor    $0x1,%eax\ntest   %al,%al\nje     0x48\nmov    -0x8(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x39\nmovzbl (%rax),%eax\ncmp    %al,-0xc(%rbp)\njne    0x48\nmov    $0x1,%eax\njmp    0x4d\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa2\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa2\nlea    0x0(%rip),%rax        # 0x77\nmov    %rax,%rdi\ncall   0x7f\nlea    0x0(%rip),%rax        # 0x86\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x90\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9a\nmov    %rax,%rdi\ncall   0xa2\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x4f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_333",
        "query_text": "The function accepts a constant character pointer as input, representing a path to a directory. It checks if a directory actually exists at the specified path by inspecting the file system attributes of the path. If the path corresponds to an existing directory, the function returns 1; otherwise, if the directory does not exist or if the path points to a non-directory object, it returns 0. The input is of type const char*, and the output is an integer indicating the existence of a directory.",
        "code_id": "c_group_1_id_333",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0xa8(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0xa0(%rbp),%rdx\nmov    -0xa8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x3e\ntest   %eax,%eax\nsetne  %al\ntest   %al,%al\nje     0x4e\nmov    $0x0,%eax\njmp    0x69\nmov    -0x88(%rbp),%eax\nand    $0x4000,%eax\ntest   %eax,%eax\nje     0x64\nmov    $0x1,%eax\njmp    0x69\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x7d\ncall   0x7d\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd2\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd2\nlea    0x0(%rip),%rax        # 0xa7\nmov    %rax,%rdi\ncall   0xaf\nlea    0x0(%rip),%rax        # 0xb6\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xc0\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xca\nmov    %rax,%rdi\ncall   0xd2\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_322",
        "query_text": "The function receives one floating-point parameter, typically representing a normalized time value between 0 and 1, and returns a floating-point result. For input values below 0.5, it computes a quintic easing-in transformation by raising the input to the fifth power (after appropriate intermediate steps). For input values of 0.5 or greater, it calculates a quintic easing-out effect by first transforming the input and then applying a quintic formula. The outcome is a smoothly interpolated value that transitions from 0 to 1 with symmetric acceleration and deceleration around the midpoint, making it suitable for natural-looking animations and transitions.",
        "code_id": "c_group_1_id_322",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x15\n\ncomiss -0x14(%rbp),%xmm0\njbe    0x46\nmovss  -0x14(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x36\n\nmulss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\njmp    0x98\nmovss  -0x14(%rbp),%xmm0\naddss  %xmm0,%xmm0\nmovss  0x0(%rip),%xmm1        # 0x57\n\nsubss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x8(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x7b\n\nmulss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x94\n\naddss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xed\ncmpl   $0xffff,-0x8(%rbp)\njne    0xed\nlea    0x0(%rip),%rax        # 0xc2\nmov    %rax,%rdi\ncall   0xca\nlea    0x0(%rip),%rax        # 0xd1\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xdb\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xe5\nmov    %rax,%rdi\ncall   0xed\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x9a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_270",
        "query_text": "The function takes no input parameters and returns a boolean value indicating the support status of a specific mapping feature. It determines the availability based on whether a particular preprocessor directive is defined; if the directive is present, the function returns false, indicating that the mapping feature is disabled, otherwise, it returns true, signifying that the feature is enabled.",
        "code_id": "c_group_1_id_270",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_320",
        "query_text": "The function accepts two inputs of type float. It considers one input as the first value and the other as the second value, then compares them to determine which is larger. The function returns the greater float value as its output. Its primary purpose is to compute the maximum value between the two provided floating-point numbers.",
        "code_id": "c_group_1_id_320",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  %xmm1,-0x8(%rbp)\nmovss  -0x4(%rbp),%xmm0\ncomiss -0x8(%rbp),%xmm0\njbe    0x24\nmovss  -0x4(%rbp),%xmm0\njmp    0x29\nmovss  -0x8(%rbp),%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7e\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rdi\ncall   0x5b\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x76\nmov    %rax,%rdi\ncall   0x7e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_343",
        "query_text": "The function accepts two generic pointers of type const void* as inputs and returns an integer. It compares the memory addresses pointed to by the two input parameters. If the addresses differ, the function yields an integer value of 1; if the addresses are identical, it yields 0. The input parameters are generic pointers (const void*), and the output is an integer reflecting whether the pointers reference different memory locations.",
        "code_id": "c_group_1_id_343",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nsetne  %al\nmovzbl %al,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x73\ncmpl   $0xffff,-0x8(%rbp)\njne    0x73\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdi\ncall   0x50\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdi\ncall   0x73\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x20\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_303",
        "query_text": "The function accepts two wide character inputs (of type wchar_t) and returns a boolean value (bool). It determines whether these characters form a valid UTF-16 surrogate pair. To do so, it ensures that the first character falls within the high surrogate range (0xD800\u20130xDBFF) and the second falls within the low surrogate range (0xDC00\u20130xDFFF), while also confirming that the size of wchar_t is exactly 2 bytes. If all checks pass, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_303",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x68\ncmpl   $0xffff,-0x8(%rbp)\njne    0x68\nlea    0x0(%rip),%rax        # 0x3d\nmov    %rax,%rdi\ncall   0x45\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x56\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdi\ncall   0x68\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x15\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_366",
        "query_text": "The function takes no input arguments. It flushes all open output streams to ensure that any buffered data is immediately written out to their proper destinations. It does not return any value (void).",
        "code_id": "c_group_1_id_366",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%edi\ncall   0x12\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x68\ncmpl   $0xffff,-0x8(%rbp)\njne    0x68\nlea    0x0(%rip),%rax        # 0x3d\nmov    %rax,%rdi\ncall   0x45\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x56\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdi\ncall   0x68\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x15\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_253",
        "query_text": "The function takes no inputs and returns an integer value representing the overall outcome of a series of tests. It starts by initializing a status variable used to monitor whether any test fails. Under a conditional compilation flag, the function displays a start message and then sequentially invokes several test routines\u2014each assessing a different aspect of QUIC functionality, such as cryptographic operations, handshake procedures, and session-related behaviors. If any test routine returns a non-zero value (indicating a failure), the function immediately halts further testing and proceeds to a final stage where it prints an error message highlighting the failure of one or more tests. A closing message is then printed, and the function returns the status variable; a return value of zero signifies that all tests have passed, while any non-zero value indicates that at least one test did not succeed. Additionally, some tests are conditionally executed based on preprocessor directives, allowing the function to adapt to different build configurations and feature sets.",
        "code_id": "c_group_1_id_253",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_374",
        "query_text": "The function accepts a single parameter: a pointer to a constant character array (const char*), representing a C-style string. It first computes the length of the string using a standard library function that counts characters. Prior to returning, the function includes a safety check to ensure that the computed length, originally of a size-type, can be safely converted to an integer without data loss. Once the check is successful, it returns the length as an integer.",
        "code_id": "c_group_1_id_374",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncltq   \ncmp    %rax,-0x8(%rbp)\nje     0x54\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rcx\nmov    $0xf,%edx\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rdi\ncall   0x54\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xad\ncmpl   $0xffff,-0x8(%rbp)\njne    0xad\nlea    0x0(%rip),%rax        # 0x82\nmov    %rax,%rdi\ncall   0x8a\nlea    0x0(%rip),%rax        # 0x91\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x9b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xa5\nmov    %rax,%rdi\ncall   0xad\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x5a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_231",
        "query_text": "The function accepts a single character as its input and returns a boolean value indicating whether the input character is an uppercase letter. It operates by utilizing a standard library function to evaluate if the character belongs to the uppercase category, ultimately converting the non-zero result into a boolean true or false outcome. The primary purpose of this function is to determine the uppercase status of the provided character.",
        "code_id": "c_group_1_id_231",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   0x1f\ntest   %eax,%eax\nsetne  %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_367",
        "query_text": "The function accepts three parameters: a pointer to a destination character array, a pointer to a source character array, and a size value that specifies the maximum number of characters to copy. It copies characters from the source array to the destination array and, if the source is shorter than the specified limit, it pads the destination with null characters. The function then returns a pointer to the destination array.",
        "code_id": "c_group_1_id_367",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x84\ncmpl   $0xffff,-0x8(%rbp)\njne    0x84\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rdi\ncall   0x84\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x31\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_335",
        "query_text": "The function accepts four parameters: a pointer to floating-point input data representing deinterleaved multi-channel audio, a pointer to a floating-point output buffer for interleaved audio, an integer specifying the number of audio frames, and an integer specifying the number of channels. It iterates over each frame and then each channel, reordering the samples from the input buffer into the output buffer so that all channel samples for a given frame are stored contiguously. The output is the interleaved audio data arranged by frame and channel.",
        "code_id": "c_group_1_id_335",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    %ecx,-0x28(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    0x7e\nmovl   $0x0,-0x4(%rbp)\njmp    0x72\nmov    -0x24(%rbp),%eax\nimul   -0x4(%rbp),%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%eax\nimul   -0x8(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\nadd    %ecx,%eax\ncltq   \nlea    0x0(,%rax,4),%rcx\n\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x28(%rbp),%eax\njl     0x28\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     0x1f\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xdc\ncmpl   $0xffff,-0x8(%rbp)\njne    0xdc\nlea    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdi\ncall   0xb9\nlea    0x0(%rip),%rax        # 0xc0\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xca\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xd4\nmov    %rax,%rdi\ncall   0xdc\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x89\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_370",
        "query_text": "The function takes two inputs: a pointer to a generic memory location and a pointer to a boolean variable. Inside the function, a local variable is defined, and its memory address is compared with the provided pointer. The outcome of this comparison\u2014a boolean indicating whether the local variable's address is lower than the given address\u2014is stored in the boolean variable. No value is returned directly by the function.",
        "code_id": "c_group_1_id_370",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0xc(%rbp),%rax\ncmp    %rax,-0x18(%rbp)\nseta   %dl\nmov    -0x20(%rbp),%rax\nmov    %dl,(%rax)\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x49\ncall   0x49\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9e\nlea    0x0(%rip),%rax        # 0x73\nmov    %rax,%rdi\ncall   0x7b\nlea    0x0(%rip),%rax        # 0x82\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x96\nmov    %rax,%rdi\ncall   0x9e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x4b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_369",
        "query_text": "The function takes no input and returns a pointer to an array of character pointers. Each element in the array represents a string corresponding to an environment variable. The function does not perform any additional processing and is implemented inline.",
        "code_id": "c_group_1_id_369",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    0x0(%rip),%rax        # 0xf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x64\ncmpl   $0xffff,-0x8(%rbp)\njne    0x64\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_359",
        "query_text": "This function accepts a pointer to a constant dataset that represents a sequence of characters. It determines the size of the string by iterating through the characters until a null terminator is encountered. After counting all the characters, the function increments the count by one to include the null terminator. Ultimately, it returns the computed size as a value of type size_t.",
        "code_id": "c_group_1_id_359",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x23\naddq   $0x1,-0x10(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x1e\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x93\ncmpl   $0xffff,-0x8(%rbp)\njne    0x93\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rdi\ncall   0x70\nlea    0x0(%rip),%rax        # 0x77\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x81\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8b\nmov    %rax,%rdi\ncall   0x93\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x40\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_328",
        "query_text": "The function accepts five floating-point inputs. The first represents a position along a curve (a value between 0 and 1), and the remaining four denote the points defining a cubic B\u00e9zier curve: the starting point, two control points, and the ending point. Internally, the function uses B\u00e9zier interpolation formulas to blend these points mathematically and calculates an intermediate value corresponding to the position on the curve at the specified parameter. It then returns this computed floating-point value as the output.",
        "code_id": "c_group_1_id_328",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x24(%rbp)\nmovss  %xmm1,-0x28(%rbp)\nmovss  %xmm2,-0x2c(%rbp)\nmovss  %xmm3,-0x30(%rbp)\nmovss  %xmm4,-0x34(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x29\n\nsubss  -0x24(%rbp),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nsubss  -0xc(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x64\n\nmulss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x28(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x10(%rbp),%xmm1\nmovss  -0x2c(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x30(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x34(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\naddss  %xmm1,%xmm0\nsubss  -0x4(%rbp),%xmm0\nmulss  -0x24(%rbp),%xmm0\naddss  -0x4(%rbp),%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x10c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x10c\nlea    0x0(%rip),%rax        # 0xe1\nmov    %rax,%rdi\ncall   0xe9\nlea    0x0(%rip),%rax        # 0xf0\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xfa\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x104\nmov    %rax,%rdi\ncall   0x10c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb9\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_324",
        "query_text": "The function accepts a single integer input representing a CPU index and returns an integer output. It assembles a file path referencing a system file in the CPU frequency directory by incorporating the CPU index into the path string. It then opens the file in read mode and attempts to read the minimum frequency setting from it. If the file cannot be opened or if the frequency value cannot be correctly retrieved, the function returns -1 to signal an error. Otherwise, it returns the obtained frequency value as an integer. Additionally, the function manages any necessary dynamic memory allocation for constructing the file path and ensures the file is closed properly after the operation.",
        "code_id": "c_group_1_id_324",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x18(%rbp)\n\nmov    -0x24(%rbp),%edx\nlea    -0x18(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x34\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x44\ncmp    $0xffffffff,%eax\nsete   %al\ntest   %al,%al\nje     0x55\nmov    $0xffffffff,%eax\njmp    0xc8\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x60\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x6b\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x7b\ncmpq   $0x0,-0x10(%rbp)\njne    0x89\nmov    $0xffffffff,%eax\njmp    0xc8\nlea    -0x1c(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x98\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xa8\ncmp    $0x1,%eax\nsetne  %al\ntest   %al,%al\nje     0xb9\nmovl   $0xffffffff,-0x1c(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0xc5\nmov    -0x1c(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xdc\ncall   0xdc\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x131\ncmpl   $0xffff,-0x8(%rbp)\njne    0x131\nlea    0x0(%rip),%rax        # 0x106\nmov    %rax,%rdi\ncall   0x10e\nlea    0x0(%rip),%rax        # 0x115\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x11f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x129\nmov    %rax,%rdi\ncall   0x131\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xde\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_360",
        "query_text": "The function takes four inputs. The first input is a pointer to a mutable character array that serves as the destination buffer, the second is an unsigned integer that specifies the maximum length of that buffer, the third is an unsigned integer indicating the number of times the source string should be concatenated, and the fourth is a pointer to a constant character array representing the source string. The function first determines the length of the source string, then verifies whether the destination buffer is large enough to accommodate the source string repeated the specified number of times. It returns an error code (-1) if the buffer size is insufficient or if the total number of characters to be written exceeds the maximum integer value. If the repetition count is zero or the source string is empty, it returns zero immediately. Otherwise, the function concatenates the source string into the destination buffer the specified number of times and finally returns the total number of characters written.",
        "code_id": "c_group_1_id_360",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x28\nmov    %rax,-0x8(%rbp)\nmov    -0x38(%rbp),%rax\nimul   -0x8(%rbp),%rax\ncmp    %rax,-0x30(%rbp)\nja     0x45\nmov    $0xffffffff,%eax\njmp    0x125\ncmpq   $0x0,-0x38(%rbp)\njne    0x56\nmov    $0x0,%eax\njmp    0x125\nmov    -0x38(%rbp),%rax\nimul   -0x8(%rbp),%rax\nmov    $0x80000000,%edx\ncmp    %rdx,%rax\njb     0x73\nmov    $0xffffffff,%eax\njmp    0x125\ncmpq   $0x0,-0x8(%rbp)\njne    0x84\nmov    $0x0,%eax\njmp    0x125\nmov    -0x38(%rbp),%rax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nimul   %edx,%eax\nmov    %eax,%edx\nmov    -0x30(%rbp),%rsi\nmov    -0x28(%rbp),%rax\nmov    $0x0,%r8d\nmov    %edx,%ecx\nlea    0x0(%rip),%rdx        # 0xaa\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xb7\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njns    0xc5\nmov    -0x1c(%rbp),%eax\njmp    0x125\nmovq   $0x0,-0x18(%rbp)\n\nmovq   $0x0,-0x18(%rbp)\n\njmp    0x10e\nmov    -0x40(%rbp),%rax\nmov    %rax,-0x10(%rbp)\njmp    0xfe\nmov    -0x10(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x10(%rbp)\nmovzbl (%rax),%edx\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rcx\nmov    %rcx,-0x28(%rbp)\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0xe1\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x38(%rbp),%rax\njb     0xd7\nmov    -0x38(%rbp),%rax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nimul   %edx,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x17a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x17a\nlea    0x0(%rip),%rax        # 0x14f\nmov    %rax,%rdi\ncall   0x157\nlea    0x0(%rip),%rax        # 0x15e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x168\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x172\nmov    %rax,%rdi\ncall   0x17a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x127\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_376",
        "query_text": "The function takes one input: a boolean value. It returns a double-precision floating-point value. If the input is true, the function returns negative zero (i.e., -0.0), and if the input is false, it returns positive zero (i.e., 0.0). The function essentially determines the sign of zero based on the boolean input.",
        "code_id": "c_group_1_id_376",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x0,-0x4(%rbp)\nje     0x1d\nmovsd  0x0(%rip),%xmm0        # 0x1b\n\njmp    0x21\npxor   %xmm0,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x80\ncmpl   $0xffff,-0x8(%rbp)\njne    0x80\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdi\ncall   0x5d\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x78\nmov    %rax,%rdi\ncall   0x80\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_342",
        "query_text": "The function takes four inputs: an integer specifying the count of frequency values, a pointer to an array of double values representing these frequencies, a double value indicating the maximum amplitude, and an integer defining the length of a pre-allocated array of floating-point values for output. Initially, it computes an effective amplitude by dividing the maximum amplitude by the number of frequencies and sets all elements of the output array to zero. It then iterates over each frequency, checking that each value lies within a valid range (greater than 0 and less than 0.5). If a frequency falls outside this range, the function halts execution after outputting an error message. For every valid frequency, the function calculates a sine wave component using the frequency, a predetermined phase offset, and the effective amplitude, accumulating the result in the output array. Finally, a windowing function is applied to the entire output array to smooth the signal, and the modified array is returned as the final output.",
        "code_id": "c_group_1_id_342",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x24(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovsd  %xmm0,-0x38(%rbp)\nmov    %rdx,-0x40(%rbp)\nmov    %ecx,-0x28(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x24(%rbp),%xmm1\nmovsd  -0x38(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    0x5f\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x28(%rbp),%eax\njl     0x3f\nmovl   $0x0,-0x14(%rbp)\njmp    0x1d8\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x24(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x84\n\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\npxor   %xmm0,%xmm0\ncomisd %xmm1,%xmm0\njae    0xd1\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\ncomisd 0x0(%rip),%xmm0        # 0xcf\n\njb     0x11a\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x14(%rbp),%eax\nmovq   %rdx,%xmm0\nmov    %eax,%edx\nlea    0x0(%rip),%rax        # 0xf9\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x103\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   0x110\nmov    $0x1,%edi\ncall   0x11a\nmovl   $0x0,-0x18(%rbp)\njmp    0x1c8\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovsd  %xmm2,-0x48(%rbp)\nmov    -0x14(%rbp),%eax\ncltq   \nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x18(%rbp),%eax\nadd    %eax,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmulsd  %xmm0,%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x17c\n\nmulsd  %xmm1,%xmm0\naddsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   0x194\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nmulsd  -0x10(%rbp),%xmm0\naddsd  -0x48(%rbp),%xmm0\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\ncvtsd2ss %xmm0,%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x28(%rbp),%eax\njl     0x126\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     0x73\nmovl   $0x0,-0x18(%rbp)\njmp    0x28c\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm3,%xmm3\ncvtss2sd %xmm0,%xmm3\nmovsd  %xmm3,-0x48(%rbp)\nmov    -0x18(%rbp),%eax\nadd    %eax,%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x22a\n\nmulsd  %xmm1,%xmm0\nmov    -0x28(%rbp),%eax\nsub    $0x1,%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   0x24f\nmovsd  0x0(%rip),%xmm1        # 0x257\n\nmulsd  %xmm0,%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x263\n\nsubsd  %xmm1,%xmm0\nmulsd  -0x48(%rbp),%xmm0\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\ncvtsd2ss %xmm0,%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x28(%rbp),%eax\njl     0x1f0\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x2ee\ncmpl   $0xffff,-0x8(%rbp)\njne    0x2ee\nlea    0x0(%rip),%rax        # 0x2c3\nmov    %rax,%rdi\ncall   0x2cb\nlea    0x0(%rip),%rax        # 0x2d2\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x2dc\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x2e6\nmov    %rax,%rdi\ncall   0x2ee\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x29b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_252",
        "query_text": "The function takes four inputs: a pointer to the beginning of a memory block, the size of that block, a pointer to a second memory block to search for, and the size of this second block. It examines the first memory block for the initial occurrence of the second memory block. If it finds an exact match, the function returns a pointer to its starting position within the first block; if no match is found or if the search block is larger than the first block, it returns NULL. The inputs are of types const void* and size_t, while the output is of type void*.",
        "code_id": "c_group_1_id_252",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x40(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njbe    0x39\nmov    $0x0,%eax\njmp    0xb5\nmovq   $0x0,-0x20(%rbp)\n\njmp    0xa2\nmovq   $0x0,-0x18(%rbp)\n\njmp    0x79\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x8(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    0x85\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x40(%rbp),%rax\njb     0x4d\njmp    0x86\nnop\nmov    -0x18(%rbp),%rax\ncmp    -0x40(%rbp),%rax\njne    0x9d\nmov    -0x10(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\njmp    0xb5\naddq   $0x1,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nsub    -0x40(%rbp),%rax\ncmp    %rax,-0x20(%rbp)\njbe    0x43\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x10a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x10a\nlea    0x0(%rip),%rax        # 0xdf\nmov    %rax,%rdi\ncall   0xe7\nlea    0x0(%rip),%rax        # 0xee\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xf8\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x102\nmov    %rax,%rdi\ncall   0x10a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb7\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_356",
        "query_text": "The function accepts two pointers to sequences of unsigned characters and compares them byte by byte. It iterates through both sequences simultaneously until it encounters a null terminator in each. During the iteration, if a byte from the first sequence is less than the corresponding byte from the second sequence, it immediately returns -1; if that byte is greater, it returns 1. If the end of both strings is reached without any differences, it returns 0 to indicate the sequences are identical. Although designed for UTF-8 encoded strings, the function performs a simple byte-wise comparison without interpreting multi-byte characters.",
        "code_id": "c_group_1_id_356",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    0x5e\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njae    0x3b\nmov    $0xffffffff,%eax\njmp    0x79\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njbe    0x54\nmov    $0x1,%eax\njmp    0x79\naddq   $0x1,-0x10(%rbp)\naddq   $0x1,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x22\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x22\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xce\ncmpl   $0xffff,-0x8(%rbp)\njne    0xce\nlea    0x0(%rip),%rax        # 0xa3\nmov    %rax,%rdi\ncall   0xab\nlea    0x0(%rip),%rax        # 0xb2\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xbc\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xc6\nmov    %rax,%rdi\ncall   0xce\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_368",
        "query_text": "The function accepts two inputs, each of type const char*, representing a file path and an operating mode (such as read, write, or append). It passes these arguments to a standard library function to open the file. The function returns a pointer to a FILE object if the file is successfully opened, and returns a null pointer if not.",
        "code_id": "c_group_1_id_368",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7c\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,%rdi\ncall   0x59\nlea    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x74\nmov    %rax,%rdi\ncall   0x7c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x29\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_244",
        "query_text": "The function takes no input parameters and returns no value. It starts by checking if a specific compile-time flag is defined; when this flag is active, it resets two pointer variables used for tracking statistics, effectively clearing any previous benchmarking data. Afterward, it initializes a cycle counter via a predefined macro, setting up performance measurement. Its overall purpose is to prepare the system for collecting benchmarking statistics and measuring execution cycles.",
        "code_id": "c_group_1_id_244",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_375",
        "query_text": "The function accepts a single parameter of type char as input and simply returns that same character as output. It performs no modifications or transformations on the input, serving solely as a direct pass-through mechanism. The purpose of the function is to ensure that the input character is returned unchanged.",
        "code_id": "c_group_1_id_375",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x66\ncmpl   $0xffff,-0x8(%rbp)\njne    0x66\nlea    0x0(%rip),%rax        # 0x3b\nmov    %rax,%rdi\ncall   0x43\nlea    0x0(%rip),%rax        # 0x4a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x13\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_362",
        "query_text": "The function takes two inputs, each a pointer to a constant character representing positions in a string. The first pointer marks the start position, while the second pointer indicates the end position. The function calculates the distance between these two pointers, effectively determining the length of the substring defined by them. It returns this distance as a signed integer of type ptrdiff_t. An assertion ensures that the end pointer is not before the start pointer.",
        "code_id": "c_group_1_id_362",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njae    0x46\nlea    0x0(%rip),%rax        # 0x25\nmov    %rax,%rcx\nmov    $0xf,%edx\nlea    0x0(%rip),%rax        # 0x34\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x3e\nmov    %rax,%rdi\ncall   0x46\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa3\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa3\nlea    0x0(%rip),%rax        # 0x78\nmov    %rax,%rdi\ncall   0x80\nlea    0x0(%rip),%rax        # 0x87\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x91\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9b\nmov    %rax,%rdi\ncall   0xa3\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x50\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_363",
        "query_text": "The function accepts three inputs: two pointers to memory locations (used to specify the beginning and end of a data block) and a pointer designated to store a computed size value. It compares the data between the two memory pointers with a predefined custom string. If the data matches the custom string, the function sets the size value to 25 and returns 0 to indicate success; otherwise, it returns 1 to indicate failure. The inputs are of type const void* for the memory locations and size_t* for the size value, and the output is an integer indicating whether the operation was successful (0) or not (1).",
        "code_id": "c_group_1_id_363",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nlea    0x0(%rip),%rax        # 0x1f\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nsub    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\ncmp    %rax,-0x8(%rbp)\njbe    0x4f\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x4d\njmp    0x53\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rsi\nmov    -0x18(%rbp),%rcx\nmov    %rax,%rdx\nmov    %rcx,%rdi\ncall   0x66\ntest   %eax,%eax\njne    0x7c\nmov    -0x28(%rbp),%rax\nmovq   $0x19,(%rax)\nmov    $0x0,%eax\njmp    0x81\nmov    $0x1,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd6\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd6\nlea    0x0(%rip),%rax        # 0xab\nmov    %rax,%rdi\ncall   0xb3\nlea    0x0(%rip),%rax        # 0xba\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xc4\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xce\nmov    %rax,%rdi\ncall   0xd6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x83\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_395",
        "query_text": "The function takes no input arguments and returns a reference to a constant pointer. It is defined inline and begins by initializing a static constant pointer that points to the stream buffer associated with the standard error stream. Finally, it returns a reference to this pointer, effectively giving access to the stream buffer without allowing modifications. The output of the function is a reference to a pointer of type std::streambuf*.",
        "code_id": "c_group_1_id_395",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax        # 0x22\nmov    %rax,%rdi\ncall   0x2a\nmov    %rax,-0x10(%rbp)\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x47\ncall   0x47\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9c\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nlea    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x94\nmov    %rax,%rdi\ncall   0x9c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x49\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_365",
        "query_text": "The function retrieves memory usage data for the current process by opening a system file that holds memory statistics. It reads a fixed number of bytes into a buffer and prints the retrieved string to the console. The function takes no parameters, returns no value, and ensures that the file is properly closed after reading.",
        "code_id": "c_group_1_id_365",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x150,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax        # 0x25\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x2f\nmov    %rax,%rdi\ncall   0x37\nmov    %rax,-0x150(%rbp)\ncmpq   $0x0,-0x150(%rbp)\n\nje     0xb5\nmov    -0x150(%rbp),%rdx\nlea    -0x140(%rbp),%rax\nmov    %rdx,%rcx\nmov    $0xc8,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   0x6b\nmov    %rax,-0x148(%rbp)\nlea    -0x140(%rbp),%rdx\nmov    -0x148(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nlea    -0x140(%rbp),%rax\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x97\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xa4\nmov    -0x150(%rbp),%rax\nmov    %rax,%rdi\ncall   0xb3\njmp    0xb6\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xca\ncall   0xca\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x11f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x11f\nlea    0x0(%rip),%rax        # 0xf4\nmov    %rax,%rdi\ncall   0xfc\nlea    0x0(%rip),%rax        # 0x103\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x10d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x117\nmov    %rax,%rdi\ncall   0x11f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xcc\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_262",
        "query_text": "The function reads a set number of bytes from a file descriptor into a provided buffer. It takes three inputs: an integer (representing the file descriptor), a pointer (pointing to the buffer where data will be stored), and an unsigned integer (specifying the number of bytes to read). Internally, it wraps the standard system call to perform the read operation and returns an integer indicating the actual number of bytes read or -1 if an error is encountered.",
        "code_id": "c_group_1_id_262",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x8(%rbp)\nmov    -0x8(%rbp),%edx\nmov    -0x10(%rbp),%rcx\nmov    -0x4(%rbp),%eax\nmov    %rcx,%rsi\nmov    %eax,%edi\ncall   0x2a\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7f\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rdi\ncall   0x5c\nlea    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x77\nmov    %rax,%rdi\ncall   0x7f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_355",
        "query_text": "The function takes an integer as input and returns a constant string pointer. It checks the input value against a set of predefined error codes and returns the corresponding error message. If the input matches one of the specific error codes, the function outputs the associated message. Otherwise, if the input is a negative value, it returns \"Unknown error code\"; if the input is non-negative, it returns \"Success\". The input type is int, and the output type is a constant char pointer.",
        "code_id": "c_group_1_id_355",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0xffffffff,-0x4(%rbp)\nje     0x31\ncmpl   $0x0,-0x4(%rbp)\njns    0x55\ncmpl   $0xfffffffe,-0x4(%rbp)\nje     0x43\ncmpl   $0xfffffffe,-0x4(%rbp)\njg     0x55\ncmpl   $0xfffffffc,-0x4(%rbp)\nje     0x3a\ncmpl   $0xfffffffd,-0x4(%rbp)\nje     0x4c\njmp    0x55\nlea    0x0(%rip),%rax        # 0x38\njmp    0x6b\nlea    0x0(%rip),%rax        # 0x41\njmp    0x6b\nlea    0x0(%rip),%rax        # 0x4a\njmp    0x6b\nlea    0x0(%rip),%rax        # 0x53\njmp    0x6b\ncmpl   $0x0,-0x4(%rbp)\njns    0x64\nlea    0x0(%rip),%rax        # 0x62\njmp    0x6b\nlea    0x0(%rip),%rax        # 0x6b\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc0\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc0\nlea    0x0(%rip),%rax        # 0x95\nmov    %rax,%rdi\ncall   0x9d\nlea    0x0(%rip),%rax        # 0xa4\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xae\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb8\nmov    %rax,%rdi\ncall   0xc0\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x6d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_285",
        "query_text": "The function takes no input arguments and does not return any value. It outputs a series of formatted messages to the console that provide usage instructions for a unit testing program. Specifically, it prints details on available command-line options, including displaying help information, listing available tests, running specific tests by either number or name, and specifying a file for cipher suite testing. This information serves as guidance on how to operate the unit testing tool.",
        "code_id": "c_group_1_id_285",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\nmov    %rax,%rdi\ncall   0x17\nmov    0x0(%rip),%rax        # 0x1e\nmov    %rax,%rdi\ncall   0x26\nlea    0x0(%rip),%rax        # 0x2d\nmov    %rax,%rdi\ncall   0x35\nmov    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdi\ncall   0x53\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nlea    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nmov    0x0(%rip),%rax        # 0x78\nmov    %rax,%rdi\ncall   0x80\nlea    0x0(%rip),%rax        # 0x87\nmov    %rax,%rdi\ncall   0x8f\nmov    0x0(%rip),%rax        # 0x96\nmov    %rax,%rdi\ncall   0x9e\nlea    0x0(%rip),%rax        # 0xa5\nmov    %rax,%rdi\ncall   0xad\nmov    0x0(%rip),%rax        # 0xb4\nmov    %rax,%rdi\ncall   0xbc\nlea    0x0(%rip),%rax        # 0xc3\nmov    %rax,%rdi\ncall   0xcb\nmov    0x0(%rip),%rax        # 0xd2\nmov    %rax,%rdi\ncall   0xda\nlea    0x0(%rip),%rax        # 0xe1\nmov    %rax,%rdi\ncall   0xe9\nmov    0x0(%rip),%rax        # 0xf0\nmov    %rax,%rdi\ncall   0xf8\nlea    0x0(%rip),%rax        # 0xff\nmov    %rax,%rdi\ncall   0x107\nmov    0x0(%rip),%rax        # 0x10e\nmov    %rax,%rdi\ncall   0x116\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x16c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x16c\nlea    0x0(%rip),%rax        # 0x141\nmov    %rax,%rdi\ncall   0x149\nlea    0x0(%rip),%rax        # 0x150\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x15a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x164\nmov    %rax,%rdi\ncall   0x16c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x119\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_265",
        "query_text": "The function takes a single character as input and returns a boolean value indicating whether the character is alphabetic (either uppercase or lowercase). Internally, it converts the input character to an unsigned representation and utilizes a standard library function to perform the alphabetic check. If the input character qualifies as a letter, the function returns true; otherwise, it returns false. The input is of type char and the output is of type bool.",
        "code_id": "c_group_1_id_265",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   0x1f\ntest   %eax,%eax\nsetne  %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_357",
        "query_text": "The function takes two input pointers: one pointing to a UTF-8 encoded source string and the other to a set of characters that should cause processing to cease. It iterates through the source string, decoding each UTF-8 character in turn. As it examines each character, it checks whether it appears in the reject set. If a character from the reject set is encountered, the function immediately stops processing and returns the count of UTF-8 characters processed up to that point. If it reaches the end of the source string without finding any rejected characters, it returns the total count of UTF-8 characters. The returned value is of type size_t, indicating the number of characters examined.",
        "code_id": "c_group_1_id_357",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmovq   $0x0,-0x18(%rbp)\n\njmp    0xd0\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmovq   $0x0,-0x8(%rbp)\n\njmp    0xa5\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nand    $0xc0,%eax\ncmp    $0x80,%eax\nje     0x5d\ncmpq   $0x0,-0x8(%rbp)\nje     0x5d\nmov    -0x18(%rbp),%rax\njmp    0xe3\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x20(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    0x82\naddq   $0x1,-0x8(%rbp)\naddq   $0x1,-0x10(%rbp)\njmp    0xa5\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nand    $0xc0,%eax\ncmp    $0x80,%eax\nje     0x82\nmovq   $0x0,-0x8(%rbp)\n\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x37\naddq   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nand    $0xc0,%eax\ncmp    $0x80,%eax\nje     0xb0\naddq   $0x1,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x25\nmov    -0x18(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x138\ncmpl   $0xffff,-0x8(%rbp)\njne    0x138\nlea    0x0(%rip),%rax        # 0x10d\nmov    %rax,%rdi\ncall   0x115\nlea    0x0(%rip),%rax        # 0x11c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x126\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x130\nmov    %rax,%rdi\ncall   0x138\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xe5\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_358",
        "query_text": "The function receives three inputs: two pointers to constant memory blocks representing raw byte sequences and a size value indicating the maximum number of bytes to compare. It begins by casting the byte sequence pointers to pointers to unsigned characters so that it can process them one byte at a time. Then, it compares the two sequences lexicographically, examining corresponding bytes until either a null terminator is encountered in at least one sequence or the specified maximum byte count is reached. If it finds a byte in the first sequence that is less than its counterpart in the second, the function returns -1; if it is greater, it returns 1. If both sequences are identical for the compared portion or the comparison reaches the specified length, the function returns 0. Note that the function treats the inputs as raw byte arrays without any assumptions about character encoding.",
        "code_id": "c_group_1_id_358",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    0x62\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njae    0x3f\nmov    $0xffffffff,%eax\njmp    0x9e\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njbe    0x58\nmov    $0x1,%eax\njmp    0x9e\naddq   $0x1,-0x10(%rbp)\naddq   $0x1,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nlea    -0x1(%rax),%rdx\nmov    %rdx,-0x28(%rbp)\ntest   %rax,%rax\nje     0x90\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x89\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     0x90\nmov    $0x1,%eax\njmp    0x95\nmov    $0x0,%eax\ntest   %al,%al\njne    0x26\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xf3\ncmpl   $0xffff,-0x8(%rbp)\njne    0xf3\nlea    0x0(%rip),%rax        # 0xc8\nmov    %rax,%rdi\ncall   0xd0\nlea    0x0(%rip),%rax        # 0xd7\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xe1\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xeb\nmov    %rax,%rdi\ncall   0xf3\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xa0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_315",
        "query_text": "The function takes a boolean value as input and returns its corresponding string representation. Specifically, if the input is true, it returns the string \"true\"; if the input is false, it returns the string \"false.\" The input is of type bool, and the output is of type std::string.",
        "code_id": "c_group_1_id_315",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,%eax\nmov    %al,-0x2c(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x31\ncmpb   $0x0,-0x2c(%rbp)\nje     0x40\nlea    0x0(%rip),%rax        # 0x3e\njmp    0x47\nlea    0x0(%rip),%rax        # 0x47\nlea    -0x19(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0x5a\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x66\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x9a\njmp    0x95\nendbr64 \nmov    %rax,%rbx\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x8a\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x95\ncall   0x9a\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xf7\ncmpl   $0xffff,-0x8(%rbp)\njne    0xf7\nlea    0x0(%rip),%rax        # 0xcc\nmov    %rax,%rdi\ncall   0xd4\nlea    0x0(%rip),%rax        # 0xdb\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xe5\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xef\nmov    %rax,%rdi\ncall   0xf7\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xa4\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_353",
        "query_text": "The function converts an unsigned integer input into a single-character string output. It casts the unsigned integer to a character and constructs a new string comprised of that character. The output is of type std::string, encapsulating the converted character.",
        "code_id": "c_group_1_id_353",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2f\nmov    -0x2c(%rbp),%eax\nmovsbl %al,%edx\nlea    -0x19(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   0x4a\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x56\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x8a\njmp    0x85\nendbr64 \nmov    %rax,%rbx\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x7a\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x85\ncall   0x8a\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xe7\ncmpl   $0xffff,-0x8(%rbp)\njne    0xe7\nlea    0x0(%rip),%rax        # 0xbc\nmov    %rax,%rdi\ncall   0xc4\nlea    0x0(%rip),%rax        # 0xcb\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xd5\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xdf\nmov    %rax,%rdi\ncall   0xe7\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x94\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,%eax\nmov    %rcx,-0x30(%rbp)\nmov    %al,-0x24(%rbp)\nmov    -0x18(%rbp),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2e\nmov    %rax,%rcx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x43\nmovsbl -0x24(%rbp),%edx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x5a\njmp    0x7a\nendbr64 \nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x6f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x7a\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_361",
        "query_text": "The function accepts a buffer for wide characters, its size, a repetition count, and a narrow C-style string as input. It converts the narrow string into its wide-character representation and writes this result repeatedly into the provided buffer. The conversion handles both single-byte and multi-byte characters and validates the multi-byte sequences during processing. Prior to writing the repeated sequence, the function ensures that the resulting output fits within the allotted buffer size. On success, it returns the total number of wide characters written into the buffer; if an error occurs due to an invalid multi-byte sequence or insufficient buffer space, the function returns a negative value.",
        "code_id": "c_group_1_id_361",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x180,%rsp\nmov    %rdi,-0x168(%rbp)\nmov    %rsi,-0x170(%rbp)\nmov    %rdx,-0x178(%rbp)\nmov    %rcx,-0x180(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x180(%rbp),%rax\nmov    %rax,%rdi\ncall   0x49\nmov    %rax,-0x128(%rbp)\ncmpq   $0x1,-0x128(%rbp)\n\njbe    0x185\nmov    -0x180(%rbp),%rax\nmov    %rax,-0x148(%rbp)\njmp    0x173\nmov    -0x148(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njs     0x8c\naddq   $0x1,-0x148(%rbp)\n\njmp    0x173\nmov    -0x180(%rbp),%rax\nmov    %rax,-0x150(%rbp)\nlea    -0x118(%rbp),%rax\nmov    $0x8,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0xb3\nlea    -0x118(%rbp),%rdx\nlea    -0x150(%rbp),%rsi\nlea    -0x110(%rbp),%rax\nmov    %rdx,%rcx\nmov    $0x40,%edx\nmov    %rax,%rdi\ncall   0xd8\nmov    %rax,-0x120(%rbp)\ncmpq   $0xffffffffffffffff,-0x120(%rbp)\n\nje     0xf3\ncmpq   $0x1,-0x120(%rbp)\n\njbe    0xfd\nmov    $0xffffffff,%eax\njmp    0x2d8\nmov    -0x120(%rbp),%rax\nmovl   $0x0,-0x110(%rbp,%rax,4)\n\nmov    -0x178(%rbp),%rax\nmov    %rax,-0x140(%rbp)\njmp    0x13e\nmov    -0x110(%rbp),%edx\nmov    -0x168(%rbp),%rax\nmov    %edx,(%rax)\naddq   $0x4,-0x168(%rbp)\n\nsubq   $0x1,-0x140(%rbp)\n\ncmpq   $0x0,-0x140(%rbp)\n\njne    0x11f\nmov    -0x178(%rbp),%rax\nlea    0x0(,%rax,4),%rdx\n\nmov    -0x168(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\nmov    -0x178(%rbp),%rax\njmp    0x2d8\nmov    -0x148(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x71\nmov    -0x178(%rbp),%rax\nimul   -0x128(%rbp),%rax\n\ncmp    %rax,-0x170(%rbp)\nja     0x1a7\nmov    $0xffffffff,%eax\njmp    0x2d8\ncmpq   $0x0,-0x178(%rbp)\n\njne    0x1bb\nmov    $0x0,%eax\njmp    0x2d8\nmov    -0x178(%rbp),%rax\nimul   -0x128(%rbp),%rax\n\nmov    $0x80000000,%edx\ncmp    %rdx,%rax\njb     0x1de\nmov    $0xffffffff,%eax\njmp    0x2d8\ncmpq   $0x0,-0x128(%rbp)\n\njne    0x1f2\nmov    $0x0,%eax\njmp    0x2d8\nmov    -0x178(%rbp),%rax\nmov    %eax,%edx\nmov    -0x128(%rbp),%rax\nimul   %edx,%eax\nmov    %eax,%edx\nmov    -0x170(%rbp),%rsi\nmov    -0x168(%rbp),%rax\nmov    $0x0,%r8d\nmov    %edx,%ecx\nlea    0x0(%rip),%rdx        # 0x224\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x231\nmov    %eax,-0x154(%rbp)\ncmpl   $0x0,-0x154(%rbp)\njns    0x24b\nmov    -0x154(%rbp),%eax\njmp    0x2d8\nmovq   $0x0,-0x138(%rbp)\n\nmovq   $0x0,-0x138(%rbp)\n\njmp    0x2b5\nmov    -0x180(%rbp),%rax\nmov    %rax,-0x130(%rbp)\njmp    0x29f\nmov    -0x130(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x130(%rbp)\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x168(%rbp),%rax\nlea    0x4(%rax),%rcx\nmov    %rcx,-0x168(%rbp)\nmov    %edx,(%rax)\nmov    -0x130(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x273\naddq   $0x1,-0x138(%rbp)\n\nmov    -0x138(%rbp),%rax\ncmp    -0x178(%rbp),%rax\njb     0x263\nmov    -0x178(%rbp),%rax\nmov    %eax,%edx\nmov    -0x128(%rbp),%rax\nimul   %edx,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x2ec\ncall   0x2ec\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x341\ncmpl   $0xffff,-0x8(%rbp)\njne    0x341\nlea    0x0(%rip),%rax        # 0x316\nmov    %rax,%rdi\ncall   0x31e\nlea    0x0(%rip),%rax        # 0x325\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x32f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x339\nmov    %rax,%rdi\ncall   0x341\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2ee\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_247",
        "query_text": "The function rotates a 32-bit unsigned integer to the right by a given number of bit positions. It accepts two 32-bit unsigned integer inputs: one representing the value to be rotated, and the other indicating how many positions to rotate. The function begins by constraining the rotation count to the range 0 through 31 using a bitmask. It then shifts the value right by the specified count, while simultaneously shifting the value left by the complement of the count to capture any bits that \"fall off\" the right end. The two shifted results are then combined using a bitwise OR, yielding a new 32-bit unsigned integer with the bits rotated as specified.",
        "code_id": "c_group_1_id_247",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmovl   $0x1f,-0x4(%rbp)\nandl   $0x1f,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    -0x14(%rbp),%edx\nmov    %eax,%ecx\nror    %cl,%edx\nmov    %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7a\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdi\ncall   0x57\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x27\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_371",
        "query_text": "The function takes no parameters and returns no value. Upon being called, it executes an empty body, meaning that it performs no operations or computations. Essentially, it is a no-op, serving as a placeholder or stub for potential future implementations.",
        "code_id": "c_group_1_id_371",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_321",
        "query_text": "The function takes two parameters: one representing the number of seconds since the epoch (a time specification) and another, a pointer to a structure for holding the broken-down time. It converts the time specification into its broken-down format in a thread-safe and platform-independent manner. Depending on the platform, it uses different conversion routines: a secure conversion function on one platform, a fallback approach that manually copies the result on another, and a reentrant conversion function on the remaining systems. The function returns a boolean value indicating whether the conversion was successful.",
        "code_id": "c_group_1_id_321",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nlea    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\ntest   %rax,%rax\nsetne  %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x82\ncmpl   $0xffff,-0x8(%rbp)\njne    0x82\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rdi\ncall   0x5f\nlea    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x70\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7a\nmov    %rax,%rdi\ncall   0x82\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_331",
        "query_text": "The function takes a 64-bit unsigned integer as input and returns an integer that corresponds to the number of digits in that number. Internally, it leverages a precomputed lookup table that maps bit-level information to an initial digit count estimate, and it uses a table of powers of 10 to refine this count. The method avoids explicit loops or recursion, thereby optimizing performance. The output value ranges from 1 to 20, depending on the size of the input number.",
        "code_id": "c_group_1_id_331",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x120,%rsp\nmov    %rdi,-0x118(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x303020202010101,%rax\n\nmovabs $0x505050404040403,%rdx\n\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmovabs $0x807070707060606,%rax\n\nmovabs $0xa0a0a0909090808,%rdx\n\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovabs $0xd0c0c0c0b0b0b0a,%rax\n\nmovabs $0xf0f0e0e0e0d0d0d,%rdx\n\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovabs $0x111111101010100f,%rax\n\nmovabs $0x1413131313121212,%rdx\n\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x118(%rbp),%rax\nor     $0x1,%rax\nbsr    %rax,%rax\nxor    $0x3f,%rax\nxor    $0x3f,%eax\ncltq   \nmovzbl -0x50(%rbp,%rax,1),%eax\nmov    %al,-0x101(%rbp)\nmovq   $0x0,-0x100(%rbp)\n\nmovq   $0x0,-0xf8(%rbp)\n\nmovq   $0xa,-0xf0(%rbp)\n\nmovq   $0x64,-0xe8(%rbp)\n\nmovq   $0x3e8,-0xe0(%rbp)\n\nmovq   $0x2710,-0xd8(%rbp)\n\nmovq   $0x186a0,-0xd0(%rbp)\n\nmovq   $0xf4240,-0xc8(%rbp)\n\nmovq   $0x989680,-0xc0(%rbp)\n\nmovq   $0x5f5e100,-0xb8(%rbp)\n\nmovq   $0x3b9aca00,-0xb0(%rbp)\n\nmovabs $0x2540be400,%rax\n\nmov    %rax,-0xa8(%rbp)\nmovabs $0x174876e800,%rax\n\nmov    %rax,-0xa0(%rbp)\nmovabs $0xe8d4a51000,%rax\n\nmov    %rax,-0x98(%rbp)\nmovabs $0x9184e72a000,%rax\n\nmov    %rax,-0x90(%rbp)\nmovabs $0x5af3107a4000,%rax\n\nmov    %rax,-0x88(%rbp)\nmovabs $0x38d7ea4c68000,%rax\n\nmov    %rax,-0x80(%rbp)\nmovabs $0x2386f26fc10000,%rax\n\nmov    %rax,-0x78(%rbp)\nmovabs $0x16345785d8a0000,%rax\n\nmov    %rax,-0x70(%rbp)\nmovabs $0xde0b6b3a7640000,%rax\n\nmov    %rax,-0x68(%rbp)\nmovabs $0x8ac7230489e80000,%rax\n\nmov    %rax,-0x60(%rbp)\nmovzbl -0x101(%rbp),%edx\nmovzbl -0x101(%rbp),%eax\ncltq   \nmov    -0x100(%rbp,%rax,8),%rax\n\ncmp    %rax,-0x118(%rbp)\nsetb   %al\nmovzbl %al,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x209\ncall   0x209\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x25e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x25e\nlea    0x0(%rip),%rax        # 0x233\nmov    %rax,%rdi\ncall   0x23b\nlea    0x0(%rip),%rax        # 0x242\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x24c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x256\nmov    %rax,%rdi\ncall   0x25e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x20b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_272",
        "query_text": "The function receives three inputs: a pointer to a destination buffer, a pointer to a source string, and the size of the destination buffer. It iterates through the source string, copying each character to the destination buffer until either the null terminator of the source string is encountered or the destination buffer has been filled up to one less than its capacity. After copying, the function appends a null terminator to the destination buffer to ensure it forms a valid C-style string. Finally, the function returns a value of type size_t representing the number of characters copied (excluding the terminating null character).",
        "code_id": "c_group_1_id_272",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\ncmpq   $0x0,-0x28(%rbp)\njne    0x22\nmov    $0x0,%eax\njmp    0x72\nmovq   $0x0,-0x8(%rbp)\n\njmp    0x4e\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmovzbl (%rax),%edx\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rcx\nmov    %rcx,-0x18(%rbp)\nmov    %dl,(%rax)\naddq   $0x1,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nsub    $0x1,%rax\ncmp    %rax,-0x8(%rbp)\njae    0x67\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x2c\nmov    -0x18(%rbp),%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc7\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc7\nlea    0x0(%rip),%rax        # 0x9c\nmov    %rax,%rdi\ncall   0xa4\nlea    0x0(%rip),%rax        # 0xab\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xb5\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xbf\nmov    %rax,%rdi\ncall   0xc7\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x74\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_364",
        "query_text": "This function examines a contiguous block of memory to determine if it begins with any emoji characters from a predefined set. It accepts three inputs: two pointers that mark the start and end of the memory block, and a pointer to a size variable where the computed width will be stored. The function scans the beginning of the memory block for specific emoji sequences, and upon detecting one at the start, it sets the width to a fixed value and returns a success code. If no matching emoji is found, the function returns a failure code.",
        "code_id": "c_group_1_id_364",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %rdx,-0x58(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax        # 0x2e\nmov    %rax,-0x20(%rbp)\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,-0x18(%rbp)\nmovq   $0x2,-0x28(%rbp)\n\nmov    -0x50(%rbp),%rax\nsub    -0x48(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmovq   $0x0,-0x30(%rbp)\n\njmp    0xbe\nmov    -0x30(%rbp),%rax\nmov    -0x20(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   0x6c\nmov    %rax,-0x38(%rbp)\nlea    -0x40(%rbp),%rdx\nlea    -0x38(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x83\nmov    (%rax),%rdx\nmov    -0x30(%rbp),%rax\nmov    -0x20(%rbp,%rax,8),%rcx\nmov    -0x48(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9e\ntest   %eax,%eax\nsete   %al\ntest   %al,%al\nje     0xb9\nmov    -0x58(%rbp),%rax\nmovq   $0x2,(%rax)\nmov    $0x0,%eax\njmp    0xca\naddq   $0x1,-0x30(%rbp)\ncmpq   $0x1,-0x30(%rbp)\njbe    0x5b\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xde\ncall   0xde\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x133\ncmpl   $0xffff,-0x8(%rbp)\njne    0x133\nlea    0x0(%rip),%rax        # 0x108\nmov    %rax,%rdi\ncall   0x110\nlea    0x0(%rip),%rax        # 0x117\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x121\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x12b\nmov    %rax,%rdi\ncall   0x133\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xe0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\njae    0x29\nmov    -0x10(%rbp),%rax\njmp    0x2d\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_398",
        "query_text": "The function accepts an integer and performs a series of arithmetic transformations. Initially, it multiplies the input by a constant value, then adds a fixed offset to the result. Following this, it calculates the remainder when the sum is divided by a predetermined divisor. The final computed remainder is returned as an integer.",
        "code_id": "c_group_1_id_398",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nlea    0x1(%rax),%edx\nmovslq %edx,%rax\nimul   $0x38e38e39,%rax,%rax\nshr    $0x20,%rax\nsar    %eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x3,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8f\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdi\ncall   0x6c\nlea    0x0(%rip),%rax        # 0x73\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x87\nmov    %rax,%rdi\ncall   0x8f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_341",
        "query_text": "The function accepts a single integer parameter representing a file descriptor. It calculates the size of the file by moving the file pointer to the end and capturing the resulting offset as an off_t value. If moving the file pointer fails at any point, the function prints an error message to the standard error stream and terminates the program. After determining the file size, the function resets the file pointer back to the beginning before returning the computed size.",
        "code_id": "c_group_1_id_341",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmov    $0x2,%edx\nmov    $0x0,%esi\nmov    %eax,%edi\ncall   0x23\nmov    %rax,-0x8(%rbp)\ncmpq   $0xffffffffffffffff,-0x8(%rbp)\njne    0x67\ncall   0x33\nmov    (%rax),%eax\nmov    %eax,%edi\ncall   0x3c\nmov    %rax,%rdx\nmov    0x0(%rip),%rax        # 0x46\nlea    0x0(%rip),%rcx        # 0x4d\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x5d\nmov    $0x1,%edi\ncall   0x67\nmov    -0x14(%rbp),%eax\nmov    $0x0,%edx\nmov    $0x0,%esi\nmov    %eax,%edi\ncall   0x7b\ncmp    $0xffffffffffffffff,%rax\nsete   %al\ntest   %al,%al\nje     0xbf\ncall   0x8b\nmov    (%rax),%eax\nmov    %eax,%edi\ncall   0x94\nmov    %rax,%rdx\nmov    0x0(%rip),%rax        # 0x9e\nlea    0x0(%rip),%rcx        # 0xa5\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0xb5\nmov    $0x1,%edi\ncall   0xbf\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x118\ncmpl   $0xffff,-0x8(%rbp)\njne    0x118\nlea    0x0(%rip),%rax        # 0xed\nmov    %rax,%rdi\ncall   0xf5\nlea    0x0(%rip),%rax        # 0xfc\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x106\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x110\nmov    %rax,%rdi\ncall   0x118\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xc5\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_289",
        "query_text": "The function accepts a pointer to a double as its input and returns a value of type const char*. Its primary objective is to select and return the appropriate unit of measurement (for example, \"GiB\", \"MiB\", \"KiB\", or \"bytes\") based on the value pointed to by the input. Additionally, the function scales the numeric value in place by dividing it by the corresponding factor for the selected unit. In configurations where fixed units are specified via preprocessor directives, the function uses the predetermined unit and scaling factor. If no fixed unit is configured, it dynamically determines the unit based on whether the value exceeds certain thresholds (for instance, greater than 1024 or 1024\u00d71024), applying the corresponding division and returning the related unit string.",
        "code_id": "c_group_1_id_289",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm0\ncomisd 0x0(%rip),%xmm0        # 0x1c\n\njbe    0x47\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x2e\n\ndivsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovsd  %xmm0,(%rax)\nlea    0x0(%rip),%rax        # 0x41\nmov    %rax,-0x8(%rbp)\njmp    0x8d\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm0\ncomisd 0x0(%rip),%xmm0        # 0x57\n\njbe    0x82\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x69\n\ndivsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovsd  %xmm0,(%rax)\nlea    0x0(%rip),%rax        # 0x7c\nmov    %rax,-0x8(%rbp)\njmp    0x8d\nlea    0x0(%rip),%rax        # 0x89\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xe6\ncmpl   $0xffff,-0x8(%rbp)\njne    0xe6\nlea    0x0(%rip),%rax        # 0xbb\nmov    %rax,%rdi\ncall   0xc3\nlea    0x0(%rip),%rax        # 0xca\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xd4\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xde\nmov    %rax,%rdi\ncall   0xe6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x93\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_401",
        "query_text": "The function accepts two integer values and returns a boolean result. It compares the two integers by checking if the second is smaller than the first. If this condition holds, it returns true; otherwise, it returns false. This comparison logic is typically employed to establish a custom ordering for operations such as sorting.",
        "code_id": "c_group_1_id_401",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\nsetl   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x76\ncmpl   $0xffff,-0x8(%rbp)\njne    0x76\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdi\ncall   0x53\nlea    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rdi\ncall   0x76\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x23\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_397",
        "query_text": "The function takes no input parameters and returns an integer value. It calculates this value by simply returning a constant result, with no computations or conditional logic applied. The function always produces the same output, making it entirely deterministic, and its return type is int.",
        "code_id": "c_group_1_id_397",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x5,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_404",
        "query_text": "The function takes a single integer input and returns a boolean value. It determines whether the provided integer is odd by performing a bitwise AND operation with 1. If the outcome of the operation equals 1, the function concludes that the integer is odd and returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_404",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nsetne  %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6b\nlea    0x0(%rip),%rax        # 0x40\nmov    %rax,%rdi\ncall   0x48\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdi\ncall   0x6b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x18\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_399",
        "query_text": "The function accepts an integer input and determines whether the number is odd. It accomplishes this by performing a bitwise AND operation with the value 1. If the result equals 1, the function returns a boolean value of true, indicating that the input integer is odd; otherwise, it returns false, indicating that the input is even. The primary purpose of this function is to check the parity of the given integer.",
        "code_id": "c_group_1_id_399",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nsetne  %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6b\nlea    0x0(%rip),%rax        # 0x40\nmov    %rax,%rdi\ncall   0x48\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdi\ncall   0x6b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x18\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_402",
        "query_text": "The function takes an integer input, increments its value by 1, and returns the updated integer as output. Both the input and the output are of type int.",
        "code_id": "c_group_1_id_402",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nadd    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6a\nlea    0x0(%rip),%rax        # 0x3f\nmov    %rax,%rdi\ncall   0x47\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdi\ncall   0x6a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x17\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_373",
        "query_text": "This function is a void function that accepts no input parameters and does not perform any operations. It serves solely as a placeholder with no effect when invoked, as it neither executes any computation nor returns a value.",
        "code_id": "c_group_1_id_373",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_291",
        "query_text": "The function takes no input arguments and returns a constant string representing the version information of a specific library. The output is of type const char*, which points to a predefined constant string holding the version details. This function serves as a straightforward utility to retrieve the library's version without performing any additional processing.",
        "code_id": "c_group_1_id_291",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x64\ncmpl   $0xffff,-0x8(%rbp)\njne    0x64\nlea    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x11\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_264",
        "query_text": "The function takes two constant string inputs. It first checks if the length of the first string is at least as long as the length of the second string. If this condition is satisfied, the function compares the corresponding characters from the beginning of the first string with those from the second string. If all compared characters match, the function returns a boolean value of true; otherwise, it returns false. The primary functionality of the function is to determine whether the first string starts with the second string.",
        "code_id": "c_group_1_id_264",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x10,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x23\nmov    %rax,%rbx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x32\ncmp    %rax,%rbx\njb     0x7a\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x43\nmov    %rax,%r12\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x52\nmov    %rax,%rbx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x61\nmov    %r12,%rdx\nmov    %rbx,%rsi\nmov    %rax,%rdi\ncall   0x6f\ntest   %al,%al\nje     0x7a\nmov    $0x1,%eax\njmp    0x7f\nmov    $0x0,%eax\nadd    $0x10,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xdb\ncmpl   $0xffff,-0x8(%rbp)\njne    0xdb\nlea    0x0(%rip),%rax        # 0xb0\nmov    %rax,%rdi\ncall   0xb8\nlea    0x0(%rip),%rax        # 0xbf\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xc9\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xd3\nmov    %rax,%rdi\ncall   0xdb\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x88\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x27\nmov    %rax,%r12\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x36\nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x45\nmov    %r12,%rdx\nmov    %rbx,%rsi\nmov    %rax,%rdi\ncall   0x53\nadd    $0x20,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nmov    (%rax),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovb   $0x1,-0x1(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nsub    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     0x49\nmov    -0x8(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x42\ntest   %eax,%eax\nsete   %al\njmp    0x4e\nmov    $0x1,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2f\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_352",
        "query_text": "This function accepts an integer input that represents a Unicode code point and converts it into a UTF-16 surrogate pair. It generates the high surrogate by right-shifting the input and combining it with an offset constant, while the low surrogate is produced by applying a bitmask to the input and then merging it with a fixed bit pattern. The two 16-bit values, representing the high and low surrogates respectively, are returned together as a pair, thus ensuring proper encoding of characters outside the Basic Multilingual Plane according to the UTF-16 standard.",
        "code_id": "c_group_1_id_352",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0xd7c0,-0x10(%rbp)\nmov    -0x24(%rbp),%eax\nsar    $0xa,%eax\nor     $0xd7c0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x24(%rbp),%eax\nand    $0x3ff,%eax\nor     $0xdc,%ah\nmov    %eax,-0x14(%rbp)\nlea    -0x14(%rbp),%rdx\nlea    -0x18(%rbp),%rcx\nlea    -0xc(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x58\nmov    -0xc(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6f\ncall   0x6f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc4\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc4\nlea    0x0(%rip),%rax        # 0x99\nmov    %rax,%rdi\ncall   0xa1\nlea    0x0(%rip),%rax        # 0xa8\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xb2\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xbc\nmov    %rax,%rdi\ncall   0xc4\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x71\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x24\nmov    (%rax),%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %dx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nmov    (%rax),%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %dx,0x2(%rax)\nnop\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_349",
        "query_text": "The function takes a single character as input and determines if it is a lowercase letter according to the ASCII standard. It returns a boolean value that is true if the character falls within the range of lowercase letters ('a' to 'z'); otherwise, it returns false.",
        "code_id": "c_group_1_id_349",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x60,-0x4(%rbp)\njle    0x20\ncmpb   $0x7a,-0x4(%rbp)\njg     0x20\nmov    $0x1,%eax\njmp    0x25\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7a\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdi\ncall   0x57\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x27\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_290",
        "query_text": "The function takes no input arguments and returns an unsigned 32-bit integer representing the number of available hardware threads (logical processors). It queries the system's online processor count using a standard system configuration call. If the call fails or returns a non-positive value, the function defaults to returning 1; otherwise, it returns the queried count.",
        "code_id": "c_group_1_id_290",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x54,%edi\ncall   0x16\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njle    0x27\nmov    -0x8(%rbp),%rax\njmp    0x2c\nmov    $0x1,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x81\ncmpl   $0xffff,-0x8(%rbp)\njne    0x81\nlea    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nlea    0x0(%rip),%rax        # 0x65\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdi\ncall   0x81\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_396",
        "query_text": "The function accepts four parameters, all of type size_t. It converts the first three parameters into their string representations, appends a fixed suffix (\"   |\") to each string, and then prints these strings to the console with a specific field width determined by the fourth parameter. The formatted output is printed directly to standard output, and the function does not return any value.",
        "code_id": "c_group_1_id_396",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x218,%rsp\nmov    %rdi,-0x208(%rbp)\nmov    %rsi,-0x210(%rbp)\nmov    %rdx,-0x218(%rbp)\nmov    %rcx,-0x220(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x200(%rbp),%rax\nmov    %rax,%rdi\ncall   0x4a\nlea    -0x1e0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x59\nlea    -0x1c0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x68\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x77\nmov    -0x208(%rbp),%rax\nlea    -0x1a0(%rbp),%rdx\nadd    $0x10,%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x94\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x9e\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0xa9\nmov    %rax,%rdx\nmov    -0x210(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0xbe\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xc8\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0xd3\nmov    %rax,%rdx\nmov    -0x218(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0xe8\nlea    -0x200(%rbp),%rdx\nlea    -0x1a0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x101\nmov    %rax,%rdx\nlea    -0x1e0(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x116\nmov    %rax,%rdx\nlea    -0x1c0(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x12b\nlea    -0x200(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x139\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x144\nmov    -0x220(%rbp),%rax\nmov    %eax,%edi\ncall   0x152\nmov    %eax,%esi\nlea    0x0(%rip),%rax        # 0x15b\nmov    %rax,%rdi\ncall   0x163\nmov    %rax,%rdx\nlea    -0x200(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x178\nlea    -0x1e0(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x186\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x191\nmov    -0x220(%rbp),%rax\nmov    %eax,%edi\ncall   0x19f\nmov    %eax,%esi\nlea    0x0(%rip),%rax        # 0x1a8\nmov    %rax,%rdi\ncall   0x1b0\nmov    %rax,%rdx\nlea    -0x1e0(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x1c5\nlea    -0x1c0(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x1d3\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x1de\nmov    -0x220(%rbp),%rax\nmov    %eax,%edi\ncall   0x1ec\nmov    %eax,%esi\nlea    0x0(%rip),%rax        # 0x1f5\nmov    %rax,%rdi\ncall   0x1fd\nmov    %rax,%rdx\nlea    -0x1c0(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x212\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x21c\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x227\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x236\nlea    -0x1c0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x245\nlea    -0x1e0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x254\nlea    -0x200(%rbp),%rax\nmov    %rax,%rdi\ncall   0x263\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x2d0\njmp    0x2cb\nendbr64 \nmov    %rax,%rbx\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x28a\njmp    0x293\nendbr64 \nmov    %rax,%rbx\nlea    -0x1c0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2a2\nlea    -0x1e0(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2b1\nlea    -0x200(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2c0\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x2cb\ncall   0x2d0\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x329\ncmpl   $0xffff,-0x8(%rbp)\njne    0x329\nlea    0x0(%rip),%rax        # 0x2fe\nmov    %rax,%rdi\ncall   0x306\nlea    0x0(%rip),%rax        # 0x30d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x317\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x321\nmov    %rax,%rdi\ncall   0x329\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2d6\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_372",
        "query_text": "This function accepts an integer as input and performs no operations on it. Its body is empty, and it returns no value (void). Essentially, it serves as a placeholder with no implemented functionality.",
        "code_id": "c_group_1_id_372",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x61\ncmpl   $0xffff,-0x8(%rbp)\njne    0x61\nlea    0x0(%rip),%rax        # 0x36\nmov    %rax,%rdi\ncall   0x3e\nlea    0x0(%rip),%rax        # 0x45\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xe\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_354",
        "query_text": "The function does not return any value and accepts no input parameters. When called, it prints a usage guide to the standard error stream, describing the expected command-line arguments for a program. Specifically, the message outlines that the program may be invoked with an optional numeric argument, a boolean flag specified as either a short or a long option, and an optional filename.",
        "code_id": "c_group_1_id_354",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nlea    0x0(%rip),%rax        # 0xf\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x19\nmov    %rax,%rdi\ncall   0x21\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x77\ncmpl   $0xffff,-0x8(%rbp)\njne    0x77\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rdi\ncall   0x54\nlea    0x0(%rip),%rax        # 0x5b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x65\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rdi\ncall   0x77\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x24\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_420",
        "query_text": "The function takes no input parameters and directly returns the integer value 42. The output is of type int.",
        "code_id": "c_group_1_id_420",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x2a,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_283",
        "query_text": "This function is responsible for handling critical errors within a program. It accepts a single input\u2014a constant character pointer representing an error message. If the message is non-null, the function writes the message to the standard error stream with a fixed error prefix. Immediately after outputting the error message, the function terminates the program by calling for an exit with a failure status. The design of this function uses a non-returning attribute, indicating that it does not return any value and that its execution forces program termination.",
        "code_id": "c_group_1_id_283",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    0x0(%rip),%rax        # 0x17\nmov    -0x8(%rbp),%rdx\nlea    0x0(%rip),%rcx        # 0x22\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x32\nmov    $0x1,%edi\ncall   0x3c\nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8f\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdi\ncall   0x6c\nlea    0x0(%rip),%rax        # 0x73\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x87\nmov    %rax,%rdi\ncall   0x8f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_259",
        "query_text": "The function takes a single character of type char as input and returns a boolean value indicating whether the character is a whitespace character. It does so by comparing the input character against a fixed set of characters representing space, tab, newline, and carriage return. If the character is found within this set, the function returns true; otherwise, it returns false. The input is of type char, while the output is of type bool.",
        "code_id": "c_group_1_id_259",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x58,%rsp\nmov    %edi,%eax\nmov    %al,-0x54(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\nlea    -0x41(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x3c\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x47\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0x53\nmovsbl -0x54(%rbp),%ecx\nlea    -0x40(%rbp),%rax\nmov    $0x0,%edx\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   0x6a\ncmp    $0xffffffffffffffff,%rax\nsetne  %bl\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x7d\nmov    %ebx,%eax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xb3\njmp    0xae\nendbr64 \nmov    %rax,%rbx\nlea    -0x41(%rbp),%rax\nmov    %rax,%rdi\ncall   0xa3\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xae\ncall   0xb3\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x10c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x10c\nlea    0x0(%rip),%rax        # 0xe1\nmov    %rax,%rdi\ncall   0xe9\nlea    0x0(%rip),%rax        # 0xf0\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xfa\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x104\nmov    %rax,%rdi\ncall   0x10c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb9\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_418",
        "query_text": "This function accepts a floating-point number as input and returns an integer representing the rounded value. It adds 0.49999 to the input value, and then converts the result to an integer, which effectively rounds the input to the nearest whole number. The input is of type double, and the output is of type int.",
        "code_id": "c_group_1_id_418",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  -0x18(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x1a\n\naddsd  %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7d\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdi\ncall   0x5a\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x75\nmov    %rax,%rdi\ncall   0x7d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_380",
        "query_text": "The function accepts a single input of type std::size_t and simply returns that same value as its output. It performs no modifications or additional processing on the input, effectively acting as a pass-through function. The input and output types are both std::size_t.",
        "code_id": "c_group_1_id_380",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x65\ncmpl   $0xffff,-0x8(%rbp)\njne    0x65\nlea    0x0(%rip),%rax        # 0x3a\nmov    %rax,%rdi\ncall   0x42\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdi\ncall   0x65\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x12\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_350",
        "query_text": "The function accepts a single character as input and determines whether its value lies between 'A' and 'Z', inclusive. It returns true if the character is uppercase and false otherwise, effectively using the ASCII ordering of characters to perform the check.",
        "code_id": "c_group_1_id_350",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x40,-0x4(%rbp)\njle    0x20\ncmpb   $0x5a,-0x4(%rbp)\njg     0x20\nmov    $0x1,%eax\njmp    0x25\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7a\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdi\ncall   0x57\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x27\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_421",
        "query_text": "The function accepts an unsigned integer as input and returns a boolean value. It evaluates whether the input is greater than 15 and less than 272, thereby determining if the value lies within the exclusive range of 16 to 271. If the input satisfies these conditions, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_421",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0xf,-0x4(%rbp)\njbe    0x21\ncmpl   $0x10f,-0x4(%rbp)\nja     0x21\nmov    $0x1,%eax\njmp    0x26\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7b\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdi\ncall   0x58\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x69\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x73\nmov    %rax,%rdi\ncall   0x7b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x28\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_403",
        "query_text": "The function accepts two integer inputs and returns an integer computed by adding them together. It performs a straightforward arithmetic addition on the provided values and produces the resulting sum, leaving the original inputs unaltered.",
        "code_id": "c_group_1_id_403",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nadd    %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x73\ncmpl   $0xffff,-0x8(%rbp)\njne    0x73\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdi\ncall   0x50\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdi\ncall   0x73\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x20\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_400",
        "query_text": "The function accepts an integer as input and returns a boolean value indicating whether the number is even. It determines evenness by inspecting the least significant bit of the integer; if this bit is not set, the function concludes that the number is even and returns true, otherwise it returns false. The input is of type integer, and the output is of type boolean.",
        "code_id": "c_group_1_id_400",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6b\nlea    0x0(%rip),%rax        # 0x40\nmov    %rax,%rdi\ncall   0x48\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdi\ncall   0x6b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x18\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_310",
        "query_text": "The function accepts a single parameter: a character. It first determines if the character corresponds to a valid hexadecimal digit\u2014specifically, one of the characters that represent the digits 0-9 or the letters A-F/a-f. Based on this check, it returns a boolean value: true if the character is a hexadecimal digit, or false otherwise.",
        "code_id": "c_group_1_id_310",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   0x1f\ntest   %eax,%eax\nsetne  %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_288",
        "query_text": "The function takes an integer as input, representing a signature algorithm identifier, and returns an integer indicating whether this algorithm is supported. It checks the input against a set of supported algorithms, which are conditionally included based on compile-time flags. If the input matches any one of these supported algorithms, the function returns 1; otherwise, it returns 0. The input is of type int and the output is also an int.",
        "code_id": "c_group_1_id_288",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6a\nlea    0x0(%rip),%rax        # 0x3f\nmov    %rax,%rdi\ncall   0x47\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdi\ncall   0x6a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x17\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_266",
        "query_text": "The function accepts two constant string references. It checks if the second string appears as a contiguous sequence of characters within the first string. The function returns a boolean value indicating the result, where \"true\" signifies that the second string is found and \"false\" indicates it is not.",
        "code_id": "c_group_1_id_266",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2c\ncmp    $0xffffffffffffffff,%rax\nsetne  %al\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x88\ncmpl   $0xffff,-0x8(%rbp)\njne    0x88\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdi\ncall   0x65\nlea    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x76\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x80\nmov    %rax,%rdi\ncall   0x88\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x35\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_422",
        "query_text": "The function is a compile-time evaluable routine that accepts a variable number of arguments, although it does not process them in any way. It simply returns a boolean value of true without performing any computations or modifications based on the input. The routine is designed to be executed during compilation, as suggested by its constant expression attribute, and includes a modifier that may be specific to certain platforms.",
        "code_id": "c_group_1_id_422",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_417",
        "query_text": "The function accepts an integer input and systematically eliminates all occurrences of the factors 2, 3, 5, and 7. It does so by repeatedly performing integer division on the input with each of these divisors whenever the current value is divisible by them. Ultimately, the function returns the modified integer after all such factor removals have been applied. The input and output are both of type int.",
        "code_id": "c_group_1_id_417",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x4(%rbp)\njmp    0x35\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffff92492493,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0xffffffff92492493,%rax,%rax\nshr    $0x20,%rax\nadd    %edx,%eax\nsar    $0x2,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x3,%ecx\nsub    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x13\njmp    0x80\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x63\njmp    0xc7\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    %edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    %eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x2,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0xa8\njmp    0x101\nmov    -0x4(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     0xf2\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x163\ncmpl   $0xffff,-0x8(%rbp)\njne    0x163\nlea    0x0(%rip),%rax        # 0x138\nmov    %rax,%rdi\ncall   0x140\nlea    0x0(%rip),%rax        # 0x147\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x151\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x15b\nmov    %rax,%rdi\ncall   0x163\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x110\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_351",
        "query_text": "The function accepts a character and returns a boolean. It assesses whether the character is a trailing byte in a UTF-8 sequence by examining if its two most significant bits conform to the binary pattern 10. The character is treated as part of a potential multi-byte encoding, and if the bit pattern matches, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_351",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovsbl -0x4(%rbp),%eax\nand    $0xc0,%eax\ncmp    $0x80,%eax\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x73\ncmpl   $0xffff,-0x8(%rbp)\njne    0x73\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdi\ncall   0x50\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdi\ncall   0x73\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x20\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_415",
        "query_text": "The function accepts an integer input and processes it by consecutively dividing it by a predefined series of numbers. For each divisor in the sequence, the function divides the input repeatedly as long as the division yields no remainder. After iterating through all the specified divisors, the function checks the resulting value: if it has been reduced to 1, the function returns 1; otherwise, it returns 0. The input is an integer, and the output is an integer that indicates whether the input has been entirely factored by the given numbers.",
        "code_id": "c_group_1_id_415",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\njmp    0x2d\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x4d4873ed,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x4,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x4d4873ed,%rax,%rax\nshr    $0x20,%rax\nsar    $0x4,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nimul   $0x35,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0xd\njmp    0x77\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffffae4c415d,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x5,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffffae4c415d,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x5,%edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nimul   $0x2f,%edx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\ntest   %edx,%edx\nje     0x55\njmp    0xc1\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x2fa0be83,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x3,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x2fa0be83,%rax,%rax\nshr    $0x20,%rax\nsar    $0x3,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nimul   $0x2b,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0xa1\njmp    0x109\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x63e7063f,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x4,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x63e7063f,%rax,%rax\nshr    $0x20,%rax\nsar    $0x4,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nshl    $0x3,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     0xe9\njmp    0x15e\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffffdd67c8a7,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x5,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0xffffffffdd67c8a7,%rax,%rax\nshr    $0x20,%rax\nadd    %ecx,%eax\nsar    $0x5,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x3,%eax\nadd    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     0x13c\njmp    0x1b5\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffff84210843,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x4,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0xffffffff84210843,%rax,%rax\nshr    $0x20,%rax\nadd    %edx,%eax\nsar    $0x4,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x5,%ecx\nsub    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x193\njmp    0x205\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffff8d3dcb09,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x4,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffff8d3dcb09,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x4,%edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nimul   $0x1d,%edx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\ntest   %edx,%edx\nje     0x1e3\njmp    0x251\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffffb21642c9,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x4,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffffb21642c9,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x4,%edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nimul   $0x17,%edx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\ntest   %edx,%edx\nje     0x22f\njmp    0x29b\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x78787879,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x3,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x78787879,%rax,%rax\nshr    $0x20,%rax\nsar    $0x3,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x4,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x27b\njmp    0x2e7\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x4ec4ec4f,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     0x2c7\njmp    0x338\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x2e8ba2e9,%rdx,%rdx\nshr    $0x20,%rdx\nsar    %edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x2e8ba2e9,%rax,%rax\nshr    $0x20,%rax\nsar    %eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     0x319\njmp    0x37a\nmov    -0x4(%rbp),%eax\nlea    0x7(%rax),%edx\ntest   %eax,%eax\ncmovs  %edx,%eax\nsar    $0x3,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x7,%eax\ntest   %eax,%eax\nje     0x369\njmp    0x3a8\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffff92492493,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0xffffffff92492493,%rax,%rax\nshr    $0x20,%rax\nadd    %edx,%eax\nsar    $0x2,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x3,%ecx\nsub    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x386\njmp    0x3f5\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    %edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    %eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x2,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x3d6\njmp    0x431\nmov    -0x4(%rbp),%eax\nlea    0x3(%rax),%edx\ntest   %eax,%eax\ncmovs  %edx,%eax\nsar    $0x2,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x3,%eax\ntest   %eax,%eax\nje     0x420\njmp    0x45a\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x43d\njmp    0x491\nmov    -0x4(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     0x482\ncmpl   $0x1,-0x4(%rbp)\njne    0x4a8\nmov    $0x1,%eax\njmp    0x4ad\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x502\ncmpl   $0xffff,-0x8(%rbp)\njne    0x502\nlea    0x0(%rip),%rax        # 0x4d7\nmov    %rax,%rdi\ncall   0x4df\nlea    0x0(%rip),%rax        # 0x4e6\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4f0\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x4fa\nmov    %rax,%rdi\ncall   0x502\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x4af\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_419",
        "query_text": "The function takes no input parameters and consistently returns an integer value of 42. The return type is int, and the function does not perform any operations apart from returning this constant value.",
        "code_id": "c_group_1_id_419",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x2a,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_416",
        "query_text": "The function accepts two inputs. The first is an integer value, and the second is a pointer to an array of integers. The algorithm determines the prime factors of the given integer and sequentially stores each factor in the array. It first checks for divisibility by a series of specific larger primes in descending order (such as 53, 47, 43, etc.), then proceeds with checks for smaller primes (for example, 2, 3, 5, etc.). If the remaining quotient after these checks is greater than a particular threshold (31), the function switches to a generalized approach that iteratively tests for additional prime factors using a computed sequence of potential divisors. Finally, the function returns an integer representing the total number of prime factors found and stored in the array.",
        "code_id": "c_group_1_id_416",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x24(%rbp),%eax\nmov    %eax,-0x14(%rbp)\njmp    0x5c\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x4d4873ed,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x4,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x35,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x4d4873ed,%rax,%rax\nshr    $0x20,%rax\nsar    $0x4,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nimul   $0x35,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x1e\njmp    0xc4\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffffae4c415d,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x5,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x2f,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffffae4c415d,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x5,%edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nimul   $0x2f,%edx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\ntest   %edx,%edx\nje     0x84\njmp    0x12c\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x2fa0be83,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x3,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x2b,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x2fa0be83,%rax,%rax\nshr    $0x20,%rax\nsar    $0x3,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nimul   $0x2b,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0xee\njmp    0x192\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x63e7063f,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x4,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x29,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x63e7063f,%rax,%rax\nshr    $0x20,%rax\nsar    $0x4,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nshl    $0x3,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     0x154\njmp    0x205\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffffdd67c8a7,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x5,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x25,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0xffffffffdd67c8a7,%rax,%rax\nshr    $0x20,%rax\nadd    %ecx,%eax\nsar    $0x5,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x3,%eax\nadd    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     0x1c5\njmp    0x27a\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffff84210843,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x4,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1f,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0xffffffff84210843,%rax,%rax\nshr    $0x20,%rax\nadd    %edx,%eax\nsar    $0x4,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x5,%ecx\nsub    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x23a\njmp    0x2e8\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffff8d3dcb09,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x4,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1d,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffff8d3dcb09,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x4,%edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nimul   $0x1d,%edx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\ntest   %edx,%edx\nje     0x2a8\njmp    0x352\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffffb21642c9,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x4,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x17,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffffb21642c9,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x4,%edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nimul   $0x17,%edx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\ntest   %edx,%edx\nje     0x312\njmp    0x3ba\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x6bca1af3,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x3,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x13,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x6bca1af3,%rax,%rax\nshr    $0x20,%rax\nsar    $0x3,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x3,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     0x37c\njmp    0x42a\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x78787879,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x3,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x11,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x78787879,%rax,%rax\nshr    $0x20,%rax\nsar    $0x3,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x4,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x3ec\njmp    0x494\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x4ec4ec4f,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0xd,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     0x456\njmp    0x503\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x2e8ba2e9,%rdx,%rdx\nshr    $0x20,%rdx\nsar    %edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0xb,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x2e8ba2e9,%rax,%rax\nshr    $0x20,%rax\nsar    %eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     0x4c6\njmp    0x563\nmov    -0x14(%rbp),%eax\nlea    0x7(%rax),%edx\ntest   %eax,%eax\ncmovs  %edx,%eax\nsar    $0x3,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x8,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nand    $0x7,%eax\ntest   %eax,%eax\nje     0x534\njmp    0x5af\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0xffffffff92492493,%rdx,%rdx\nshr    $0x20,%rdx\nadd    %eax,%edx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x7,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0xffffffff92492493,%rax,%rax\nshr    $0x20,%rax\nadd    %edx,%eax\nsar    $0x2,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x3,%ecx\nsub    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x56f\njmp    0x61a\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    %edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x5,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    %eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x2,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x5dd\njmp    0x674\nmov    -0x14(%rbp),%eax\nlea    0x3(%rax),%edx\ntest   %eax,%eax\ncmovs  %edx,%eax\nsar    $0x2,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x4,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nand    $0x3,%eax\ntest   %eax,%eax\nje     0x645\njmp    0x6bb\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x3,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     0x680\njmp    0x710\nmov    -0x14(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x2,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     0x6e3\ncmpl   $0x1f,-0x14(%rbp)\njle    0x7ca\nmovl   $0x2,-0x10(%rbp)\njmp    0x7c0\nmov    -0x10(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    0x779\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\ncltd   \nidivl  -0x8(%rbp)\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltd   \nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\nje     0x752\njmp    0x7af\nmov    -0x18(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\ncltd   \nidivl  -0x4(%rbp)\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltd   \nidivl  -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\nje     0x788\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njg     0x730\nmov    -0x18(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x822\ncmpl   $0xffff,-0x8(%rbp)\njne    0x822\nlea    0x0(%rip),%rax        # 0x7f7\nmov    %rax,%rdi\ncall   0x7ff\nlea    0x0(%rip),%rax        # 0x806\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x810\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x81a\nmov    %rax,%rdi\ncall   0x822\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7cf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_378",
        "query_text": "The function accepts one parameter: a pointer to a constant character (of type const char*). It immediately returns this pointer without performing any modification or transformation on it. The function is marked for compile-time evaluation and is explicitly inlined for performance optimization. The input and output types are both const char*.",
        "code_id": "c_group_1_id_378",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x65\ncmpl   $0xffff,-0x8(%rbp)\njne    0x65\nlea    0x0(%rip),%rax        # 0x3a\nmov    %rax,%rdi\ncall   0x42\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdi\ncall   0x65\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x12\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_379",
        "query_text": "The function takes a single size_t input (expected to be within the range 0 to 99) and returns a pointer to a constant character string representing the two-digit number corresponding to the input value. Internally, it uses a precomputed lookup table that contains contiguous pairs of digits for the numbers 00 through 99. By calculating an offset based on the input, the function retrieves and returns the appropriate two-character substring from this table. The function does not produce any output other than the returned pointer.",
        "code_id": "c_group_1_id_379",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0xf0,%rsp\nmov    %rdi,-0xe8(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x3330323031303030,%rax\n\nmovabs $0x3730363035303430,%rdx\n\nmov    %rax,-0xe0(%rbp)\nmov    %rdx,-0xd8(%rbp)\nmovabs $0x3131303139303830,%rax\n\nmovabs $0x3531343133313231,%rdx\n\nmov    %rax,-0xd0(%rbp)\nmov    %rdx,-0xc8(%rbp)\nmovabs $0x3931383137313631,%rax\n\nmovabs $0x3332323231323032,%rdx\n\nmov    %rax,-0xc0(%rbp)\nmov    %rdx,-0xb8(%rbp)\nmovabs $0x3732363235323432,%rax\n\nmovabs $0x3133303339323832,%rdx\n\nmov    %rax,-0xb0(%rbp)\nmov    %rdx,-0xa8(%rbp)\nmovabs $0x3533343333333233,%rax\n\nmovabs $0x3933383337333633,%rdx\n\nmov    %rax,-0xa0(%rbp)\nmov    %rdx,-0x98(%rbp)\nmovabs $0x3334323431343034,%rax\n\nmovabs $0x3734363435343434,%rdx\n\nmov    %rax,-0x90(%rbp)\nmov    %rdx,-0x88(%rbp)\nmovabs $0x3135303539343834,%rax\n\nmovabs $0x3535343533353235,%rdx\n\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmovabs $0x3935383537353635,%rax\n\nmovabs $0x3336323631363036,%rdx\n\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmovabs $0x3736363635363436,%rax\n\nmovabs $0x3137303739363836,%rdx\n\nmov    %rax,-0x60(%rbp)\nmov    %rdx,-0x58(%rbp)\nmovabs $0x3537343733373237,%rax\n\nmovabs $0x3937383737373637,%rdx\n\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmovabs $0x3338323831383038,%rax\n\nmovabs $0x3738363835383438,%rdx\n\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovabs $0x3139303939383838,%rax\n\nmovabs $0x3539343933393239,%rdx\n\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovabs $0x3939383937393639,%rax\n\nmov    %rax,-0x20(%rbp)\nmovb   $0x0,-0x18(%rbp)\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x1c4\ncall   0x1c4\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x219\ncmpl   $0xffff,-0x8(%rbp)\njne    0x219\nlea    0x0(%rip),%rax        # 0x1ee\nmov    %rax,%rdi\ncall   0x1f6\nlea    0x0(%rip),%rax        # 0x1fd\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x207\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x211\nmov    %rax,%rdi\ncall   0x219\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1c6\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_325",
        "query_text": "The function takes an integer as input, representing a day-of-week index (with 0 corresponding to Sunday and 6 to Saturday). It checks if the provided index falls within the valid range of 0 to 6. If the input is valid, the function returns a pointer to a constant string that holds the full name of the day. If the input is outside the valid range, it returns a pointer to a constant string containing a question mark (\"?\"). The input is of type int, and the output is of type const char*.",
        "code_id": "c_group_1_id_325",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax        # 0x25\nmov    %rax,-0x40(%rbp)\nlea    0x0(%rip),%rax        # 0x30\nmov    %rax,-0x38(%rbp)\nlea    0x0(%rip),%rax        # 0x3b\nmov    %rax,-0x30(%rbp)\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,-0x28(%rbp)\nlea    0x0(%rip),%rax        # 0x51\nmov    %rax,-0x20(%rbp)\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,-0x18(%rbp)\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,-0x10(%rbp)\ncmpl   $0x0,-0x44(%rbp)\njs     0x83\ncmpl   $0x6,-0x44(%rbp)\njg     0x83\nmov    -0x44(%rbp),%eax\ncltq   \nmov    -0x40(%rbp,%rax,8),%rax\njmp    0x8a\nlea    0x0(%rip),%rax        # 0x8a\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x9e\ncall   0x9e\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xf3\ncmpl   $0xffff,-0x8(%rbp)\njne    0xf3\nlea    0x0(%rip),%rax        # 0xc8\nmov    %rax,%rdi\ncall   0xd0\nlea    0x0(%rip),%rax        # 0xd7\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xe1\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xeb\nmov    %rax,%rdi\ncall   0xf3\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xa0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_323",
        "query_text": "The function takes a pointer to an array of unsigned characters along with an integer representing the number of elements in the array. It reverses the order of the elements in place by swapping the first element with the last, the second with the second-to-last, and so on until the array is completely reversed. The function does not return any value (void). Its primary purpose is to modify the array directly by reversing its content.",
        "code_id": "c_group_1_id_323",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    0x6e\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x9(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x8(%rbp)\nsubl   $0x1,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     0x21\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xcd\ncmpl   $0xffff,-0x8(%rbp)\njne    0xcd\nlea    0x0(%rip),%rax        # 0xa2\nmov    %rax,%rdi\ncall   0xaa\nlea    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xbb\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xc5\nmov    %rax,%rdi\ncall   0xcd\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_293",
        "query_text": "The function takes a single character as input and returns a character converted to lowercase. It first converts the input to an unsigned character to ensure safe handling of potential negative values, then applies a standard lowercase conversion routine, and finally casts the result back to a character. This process guarantees that the output is the lowercase equivalent of the input.",
        "code_id": "c_group_1_id_293",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   0x1f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x74\ncmpl   $0xffff,-0x8(%rbp)\njne    0x74\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rdi\ncall   0x51\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rdi\ncall   0x74\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x21\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_345",
        "query_text": "The function takes no input parameters and returns a constant reference to a locale object representing the classic (or \"C\") locale. It uses a static local variable to ensure that the locale is initialized only once and then reused on subsequent calls, providing an efficient, shared access point to the minimal default locale settings.",
        "code_id": "c_group_1_id_345",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\ncall   0x11\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6e\nlea    0x0(%rip),%rax        # 0x43\nmov    %rax,%rdi\ncall   0x4b\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdi\ncall   0x6e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_405",
        "query_text": "The function accepts an integer as input and returns an integer as output representing the sign of the input. It returns \u20131 if the input is negative, 1 if the input is positive, and 0 if the input equals zero. The determination of the sign is performed using bitwise operations that compare the sign bit of the input and its negation.",
        "code_id": "c_group_1_id_405",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltd   \nmov    -0x4(%rbp),%eax\nneg    %eax\nshr    $0x1f,%eax\nadd    %edx,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6e\nlea    0x0(%rip),%rax        # 0x43\nmov    %rax,%rdi\ncall   0x4b\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdi\ncall   0x6e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_426",
        "query_text": "The function acts as a signal handler that is invoked when a particular signal is received. It accepts an integer input representing the signal number, although this input is not utilized within the function. Upon activation, it immediately prints an error message indicating that a hang has been detected within a callback reading function. Following the message display, the function terminates the program abnormally by calling an exit routine with a status code of 1.\n\n\u2022 Input: An integer representing a signal number (unused within the function).  \n\u2022 Output: None (void function).  \n\u2022 Functionality: The function serves as a signal handler; it outputs an error message alerting of a detected hang in a callback reading process and then forces program termination with an exit status of 1.",
        "code_id": "c_group_1_id_426",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nlea    0x0(%rip),%rax        # 0x16\nmov    %rax,%rdi\ncall   0x1e\nmov    $0x1,%edi\ncall   0x28\nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7b\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdi\ncall   0x58\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x69\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x73\nmov    %rax,%rdi\ncall   0x7b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x28\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_308",
        "query_text": "The function takes an unsigned integer as input and returns a string. It returns an empty string if the input is 1, \"both \" if the input is 2, and \"all \" if the input is greater than 2. The output is a string determined by the value of the input.",
        "code_id": "c_group_1_id_308",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x20,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    $0x0,%ebx\ncmpq   $0x1,-0x30(%rbp)\njne    0x40\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3e\njmp    0x7b\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x4c\nmov    $0x1,%ebx\ncmpq   $0x2,-0x30(%rbp)\njne    0x61\nlea    0x0(%rip),%rax        # 0x5f\njmp    0x68\nlea    0x0(%rip),%rax        # 0x68\nlea    -0x19(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0x7b\ntest   %bl,%bl\nje     0xaf\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x8b\njmp    0xaf\nendbr64 \nmov    %rax,%r12\ntest   %bl,%bl\nje     0xa4\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0xa4\nmov    %r12,%rax\nmov    %rax,%rdi\ncall   0xaf\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xc3\ncall   0xc3\nmov    -0x28(%rbp),%rax\nadd    $0x20,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x123\ncmpl   $0xffff,-0x8(%rbp)\njne    0x123\nlea    0x0(%rip),%rax        # 0xf8\nmov    %rax,%rdi\ncall   0x100\nlea    0x0(%rip),%rax        # 0x107\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x111\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x11b\nmov    %rax,%rdi\ncall   0x123\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xd0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_424",
        "query_text": "The function accepts an array of integers and its length as input, along with an array to store the output. It processes each element by dividing the integer by a constant value (computed as 8.0 multiplied by a large constant) and then casting the result to a floating-point number. The computed float is stored in the output array at the corresponding position. The input consists of an integer array and its length, and the function returns an array of floats after processing every element up to the specified length.",
        "code_id": "c_group_1_id_424",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x66\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x42\n\ndivsd  %xmm1,%xmm0\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\ncvtsd2ss %xmm0,%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     0x1c\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc4\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc4\nlea    0x0(%rip),%rax        # 0x99\nmov    %rax,%rdi\ncall   0xa1\nlea    0x0(%rip),%rax        # 0xa8\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xb2\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xbc\nmov    %rax,%rdi\ncall   0xc4\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x71\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_425",
        "query_text": "The function accepts three inputs: a pointer to an array of floats, an integer representing the number of elements in the array, and another integer that denotes an expected count of peaks. It returns a double that represents the signal-to-noise ratio (SNR). Instead of processing the inputs, the function immediately provides a constant double value of 200.0, serving as a placeholder or stub.",
        "code_id": "c_group_1_id_425",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmovsd  0x0(%rip),%xmm0        # 0x1a\n\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x83\ncmpl   $0xffff,-0x8(%rbp)\njne    0x83\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rdi\ncall   0x60\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rdi\ncall   0x83\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x30\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_312",
        "query_text": "The function takes two inputs: a constant string (passed by reference) and a character. It verifies that the string is not empty and then checks if the last character of the string is equal to the specified character. If the conditions are met, it returns a boolean value true; otherwise, it returns false.",
        "code_id": "c_group_1_id_312",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,%eax\nmov    %al,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x21\nxor    $0x1,%eax\ntest   %al,%al\nje     0x56\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\nlea    -0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x47\nmovzbl (%rax),%eax\ncmp    %al,-0xc(%rbp)\njne    0x56\nmov    $0x1,%eax\njmp    0x5b\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb0\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb0\nlea    0x0(%rip),%rax        # 0x85\nmov    %rax,%rdi\ncall   0x8d\nlea    0x0(%rip),%rax        # 0x94\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x9e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xa8\nmov    %rax,%rdi\ncall   0xb0\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x5d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_326",
        "query_text": "The function takes a string as input and returns a boolean value. It evaluates the input string to determine if it is readable by checking two conditions: whether the string\u2019s length is 20 characters or fewer, or whether it does not contain the characters '<' or '('. If either condition is satisfied, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_326",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\ncmp    $0x14,%rax\njbe    0x43\nmov    -0x8(%rbp),%rax\nmov    $0x0,%edx\nlea    0x0(%rip),%rcx        # 0x32\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x3d\ncmp    $0xffffffffffffffff,%rax\njne    0x4a\nmov    $0x1,%eax\njmp    0x4f\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa4\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa4\nlea    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdi\ncall   0x81\nlea    0x0(%rip),%rax        # 0x88\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x92\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9c\nmov    %rax,%rdi\ncall   0xa4\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x51\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_423",
        "query_text": "The function takes three inputs: a pointer to an array of short integers, a pointer to an array of floats, and an integer representing the number of elements. It processes every element in the input array by dividing each short integer by the constant value 32768.0 (expressed as 0x8000 in hexadecimal) and casting the result to a float. The converted values are then stored sequentially in the output array. The input types are short integers and an int, and the output type is float.",
        "code_id": "c_group_1_id_423",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x64\nmov    -0x4(%rbp),%eax\ncltq   \nlea    (%rax,%rax,1),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\ncwtl   \npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x40\n\ndivsd  %xmm1,%xmm0\nmov    -0x4(%rbp),%eax\ncltq   \nlea    0x0(,%rax,4),%rdx\n\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\ncvtsd2ss %xmm0,%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     0x1c\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc2\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc2\nlea    0x0(%rip),%rax        # 0x97\nmov    %rax,%rdi\ncall   0x9f\nlea    0x0(%rip),%rax        # 0xa6\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xb0\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xba\nmov    %rax,%rdi\ncall   0xc2\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x6f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_413",
        "query_text": "The function takes a constant string as input and returns a dynamically allocated string as output. It opens a system file that contains information about the current process and reads it line by line. For each line, the function splits the line at a delimiter and compares the first part with the provided key. If a match is found, it extracts the corresponding value by trimming any leading whitespace and removing the trailing newline character, then returns a copy of this value. If no matching entry is found or an error occurs (such as the file failing to open), it returns a NULL pointer, indicating failure. The caller is responsible for deallocating the returned string when it is no longer needed.",
        "code_id": "c_group_1_id_413",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x20(%rbp)\n\nmovq   $0x0,-0x30(%rbp)\n\nmovq   $0x0,-0x28(%rbp)\n\nlea    0x0(%rip),%rax        # 0x3e\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdi\ncall   0x50\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\nje     0x16c\njmp    0x144\nmov    -0x30(%rbp),%rax\nmov    $0x3a,%esi\nmov    %rax,%rdi\ncall   0x75\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     0x144\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x94\njmp    0x144\nmov    -0x18(%rbp),%rax\nmovb   $0x0,(%rax)\nmov    -0x30(%rbp),%rax\nmov    -0x38(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xae\ntest   %eax,%eax\nje     0xb7\njmp    0x144\naddq   $0x1,-0x18(%rbp)\njmp    0xc3\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     0xbe\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x9,%al\nje     0xbe\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0xe5\ncmp    $0x1,%rax\njbe    0x105\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0xf7\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     0x16f\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nnop\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x18(%rbp)\nmovzbl (%rax),%edx\nmov    -0x30(%rbp),%rax\nlea    0x1(%rax),%rcx\nmov    %rcx,-0x30(%rbp)\nmov    %dl,(%rax)\nmovzbl (%rax),%eax\ntest   %al,%al\nsetne  %al\ntest   %al,%al\njne    0x119\njmp    0x170\nmov    -0x10(%rbp),%rdx\nlea    -0x28(%rbp),%rcx\nlea    -0x30(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x15b\ncmp    $0xffffffffffffffff,%rax\nsetne  %al\ntest   %al,%al\njne    0x64\njmp    0x170\nnop\njmp    0x170\nnop\ncmpq   $0x0,-0x20(%rbp)\njne    0x183\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x183\ncmpq   $0x0,-0x10(%rbp)\nje     0x196\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x196\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x1ae\ncall   0x1ae\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x203\ncmpl   $0xffff,-0x8(%rbp)\njne    0x203\nlea    0x0(%rip),%rax        # 0x1d8\nmov    %rax,%rdi\ncall   0x1e0\nlea    0x0(%rip),%rax        # 0x1e7\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x1f1\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x1fb\nmov    %rax,%rdi\ncall   0x203\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b0\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_414",
        "query_text": "The function accepts three inputs: a character array that serves as a destination buffer, an array of character pointers representing strings, and an unsigned integer indicating the total number of strings. It iterates over the first half of the string array while pairing each element with a corresponding element from the second half. For each pair, the function removes the trailing newline (or similar character) from the first string, then appends it to the destination buffer with a set of spaces, followed by a separator and the paired string. If the total number of strings is odd, the leftover string (without a pair) is appended to the buffer without the separator. The function modifies the destination buffer directly and does not return any value.",
        "code_id": "c_group_1_id_414",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x34(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x34(%rbp),%eax\nshr    %eax\nmov    %eax,-0x14(%rbp)\njmp    0xfa\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rbx\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   0x5e\nsub    $0x1,%rax\nadd    %rbx,%rax\nmovb   $0x0,(%rax)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x20202020,(%rax)\nmovb   $0x0,0x4(%rax)\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xb8\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x207c2020,(%rax)\nmovw   $0x20,0x4(%rax)\nmov    -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf2\naddl   $0x1,-0x18(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x34(%rbp),%eax\nshr    %eax\ncmp    %eax,-0x18(%rbp)\njb     0x2c\nmov    -0x14(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njae    0x154\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11c\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x20202020,(%rax)\nmovb   $0x0,0x4(%rax)\nmov    -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\n\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x154\nnop\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x1ae\ncmpl   $0xffff,-0x8(%rbp)\njne    0x1ae\nlea    0x0(%rip),%rax        # 0x183\nmov    %rax,%rdi\ncall   0x18b\nlea    0x0(%rip),%rax        # 0x192\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x19c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x1a6\nmov    %rax,%rdi\ncall   0x1ae\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x15b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_299",
        "query_text": "This function accepts a pointer to a character array along with its length as inputs. It iterates through each character in the array and checks if the character is an unprintable control character, while explicitly ignoring the tab, newline, and carriage return characters. If an unprintable control character is found, the function returns a boolean true immediately. If no such character is encountered after examining the entire string, it returns false.",
        "code_id": "c_group_1_id_299",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmovq   $0x0,-0x8(%rbp)\n\njmp    0x69\nmov    -0x10(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x10(%rbp)\nmovzbl (%rax),%eax\nmov    %al,-0x11(%rbp)\nmovzbl -0x11(%rbp),%eax\nmov    %eax,%edi\ncall   0x43\ntest   %eax,%eax\nje     0x64\nmovzbl -0x11(%rbp),%eax\ncmp    $0xa,%eax\njg     0x57\ncmp    $0x9,%eax\njge    0x63\njmp    0x5c\ncmp    $0xd,%eax\nje     0x63\nmov    $0x1,%eax\njmp    0x78\nnop\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     0x26\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xcd\ncmpl   $0xffff,-0x8(%rbp)\njne    0xcd\nlea    0x0(%rip),%rax        # 0xa2\nmov    %rax,%rdi\ncall   0xaa\nlea    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xbb\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xc5\nmov    %rax,%rdi\ncall   0xcd\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_407",
        "query_text": "The function takes two inputs: a pointer to a pointer to unsigned char, representing an array of pointers, and a size_t value indicating the length of the memory block. It releases the memory block by invoking the munmap system call on the specified address and length. The function does not return any value.",
        "code_id": "c_group_1_id_407",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7d\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdi\ncall   0x5a\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x75\nmov    %rax,%rdi\ncall   0x7d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_406",
        "query_text": "The function takes a string as input (input type: const char*) and returns a pointer to a character array (output type: char*). It first copies the input string into a static buffer and then processes the copied string to extract the last component of a file path, returning the resulting substring.",
        "code_id": "c_group_1_id_406",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x150,%rsp\nmov    %rdi,-0x148(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x148(%rbp),%rdx\nlea    -0x140(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x3e\nlea    -0x140(%rbp),%rax\nmov    %rax,%rdi\ncall   0x4d\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x61\ncall   0x61\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb6\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb6\nlea    0x0(%rip),%rax        # 0x8b\nmov    %rax,%rdi\ncall   0x93\nlea    0x0(%rip),%rax        # 0x9a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa4\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xae\nmov    %rax,%rdi\ncall   0xb6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x63\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_408",
        "query_text": "The function is defined with internal linkage and does not accept any input parameters. It returns no value. It is intended to output timing results in an XML format; however, its current implementation is empty and does not perform any operations or produce output.",
        "code_id": "c_group_1_id_408",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_313",
        "query_text": "The function accepts three double-precision floating-point numbers as inputs and returns a boolean value. It determines whether two floating-point numbers are approximately equal within a provided tolerance. To do this, it computes whether adding the tolerance to the first number results in a value that is at least as large as the second number, and similarly, whether adding the tolerance to the second number results in a value that is at least as large as the first. If both these conditions hold true, the function returns true; otherwise, it returns false. This behavior makes the function useful for comparing floating-point numbers while accounting for potential inaccuracies due to precision limitations.",
        "code_id": "c_group_1_id_313",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  %xmm1,-0x10(%rbp)\nmovsd  %xmm2,-0x18(%rbp)\nmovsd  -0x8(%rbp),%xmm0\naddsd  -0x18(%rbp),%xmm0\ncomisd -0x10(%rbp),%xmm0\njb     0x40\nmovsd  -0x10(%rbp),%xmm0\naddsd  -0x18(%rbp),%xmm0\ncomisd -0x8(%rbp),%xmm0\njb     0x40\nmov    $0x1,%eax\njmp    0x45\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9a\nlea    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rdi\ncall   0x77\nlea    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x88\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x92\nmov    %rax,%rdi\ncall   0x9a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x47\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_316",
        "query_text": "The function takes a single character as input and returns a boolean value. It checks whether the provided character matches the standard option prefix. On all platforms, it verifies if the character is a hyphen ('-'). Additionally, on Windows systems, it also checks if the character is a forward slash ('/'). If the input character meets any of these conditions, the function returns true; otherwise, it returns false. The input is of type char and the output is of type bool.",
        "code_id": "c_group_1_id_316",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x2d,-0x4(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x69\ncmpl   $0xffff,-0x8(%rbp)\njne    0x69\nlea    0x0(%rip),%rax        # 0x3e\nmov    %rax,%rdi\ncall   0x46\nlea    0x0(%rip),%rax        # 0x4d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdi\ncall   0x69\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x16\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_410",
        "query_text": "This function is a stub that currently performs no operations. It accepts no input parameters and returns no value. Although marked as inline, its empty body indicates that it is intended as a placeholder for future implementation rather than providing any immediate functionality.",
        "code_id": "c_group_1_id_410",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_92",
        "query_text": "The function takes an integer as input and returns an unsigned integer representing the floor of the base-2 logarithm of the input value. It calculates this by repeatedly right-shifting the input (effectively dividing it by 2) until the value becomes zero, incrementing a counter with each shift. The number of shifts performed corresponds to the floor of the logarithm to base 2. The input is of type int, and the output is of type unsigned int.",
        "code_id": "c_group_1_id_92",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    0x18\naddl   $0x1,-0x4(%rbp)\nsarl   -0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\nsetne  %al\ntest   %al,%al\njne    0x14\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7e\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rdi\ncall   0x5b\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x76\nmov    %rax,%rdi\ncall   0x7e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_411",
        "query_text": "The function takes no input parameters and returns no output. It performs no operations when executed, acting as a no-operation (no-op) procedure. This function serves as a placeholder for situations where a function call is syntactically necessary but no functionality is required.",
        "code_id": "c_group_1_id_411",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_412",
        "query_text": "The function is a placeholder that accepts no parameters and returns no value. It is declared as an inline static function, indicating that its definition is provided in the header and may be substituted directly at the point of call. The empty function body signifies that no operations are performed when this function is invoked.",
        "code_id": "c_group_1_id_412",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_318",
        "query_text": "The function accepts a constant string reference as input and returns a new string with leading and trailing whitespace characters removed. It locates the first and last characters in the input that are not whitespace and extracts the substring between these positions. If the input string consists solely of whitespace, the function returns an empty string. The input is of type std::string (passed as a constant reference), and the output is of type std::string.",
        "code_id": "c_group_1_id_318",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax        # 0x2a\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rcx\nmov    -0x30(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x46\nmov    %rax,-0x18(%rbp)\nmov    -0x20(%rbp),%rcx\nmov    -0x30(%rbp),%rax\nmov    $0xffffffffffffffff,%rdx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x64\nmov    %rax,-0x10(%rbp)\ncmpq   $0xffffffffffffffff,-0x18(%rbp)\nje     0x91\nmov    -0x10(%rbp),%rax\nsub    -0x18(%rbp),%rax\nlea    0x1(%rax),%rcx\nmov    -0x28(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    -0x30(%rbp),%rsi\nmov    %rax,%rdi\ncall   0x8f\njmp    0x9d\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9d\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xb1\ncall   0xb1\nmov    -0x28(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x10a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x10a\nlea    0x0(%rip),%rax        # 0xdf\nmov    %rax,%rdi\ncall   0xe7\nlea    0x0(%rip),%rax        # 0xee\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xf8\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x102\nmov    %rax,%rdi\ncall   0x10a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb7\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_501",
        "query_text": "The function accepts no input arguments. It returns an integer value of 0, using this value to indicate a successful or default initialization state. The function does not perform any additional computations or operations.",
        "code_id": "c_group_1_id_501",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_486",
        "query_text": "The function receives a size_t value as its input and outputs a pointer to a constant character string. It treats the input as an index into a pre-constructed string containing every two-digit combination from \"00\" to \"99\". By multiplying the input by 2, it determines the correct starting position of the desired pair of digits within the string. Finally, the function returns a pointer to that specific two-character substring.",
        "code_id": "c_group_1_id_486",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    (%rax,%rax,1),%rdx\nlea    0x0(%rip),%rax        # 0x1b\nadd    %rdx,%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x73\ncmpl   $0xffff,-0x8(%rbp)\njne    0x73\nlea    0x0(%rip),%rax        # 0x48\nmov    %rax,%rdi\ncall   0x50\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdi\ncall   0x73\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x20\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_502",
        "query_text": "The function takes no input parameters and returns no value. It is a no-operation (no-op) function that does not perform any actions or modifications when invoked.",
        "code_id": "c_group_1_id_502",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_381",
        "query_text": "The function takes no arguments and returns no value. It calls a standard library function with a null pointer to flush all open output streams, ensuring that any buffered data is promptly written to their respective destinations.",
        "code_id": "c_group_1_id_381",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%edi\ncall   0x12\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x68\ncmpl   $0xffff,-0x8(%rbp)\njne    0x68\nlea    0x0(%rip),%rax        # 0x3d\nmov    %rax,%rdi\ncall   0x45\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x56\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdi\ncall   0x68\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x15\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_409",
        "query_text": "The function takes two unsigned character inputs and returns an unsigned integer. It begins by asserting that the two inputs are not equal, ensuring that this condition holds true during execution. However, it does not perform any further computations or comparisons on the inputs; they are effectively ignored. Ultimately, the function always returns the constant value 0, serving as a placeholder or stub implementation. The inputs are of type unsigned char, and the output is of type unsigned int.",
        "code_id": "c_group_1_id_409",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%edx\nmov    %esi,%eax\nmov    %dl,-0x4(%rbp)\nmov    %al,-0x8(%rbp)\nmovzbl -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%al\njne    0x47\nlea    0x0(%rip),%rax        # 0x26\nmov    %rax,%rcx\nmov    $0xf,%edx\nlea    0x0(%rip),%rax        # 0x35\nmov    %rax,%rsi\nlea    0x0(%rip),%rax        # 0x3f\nmov    %rax,%rdi\ncall   0x47\nmov    $0x0,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa1\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa1\nlea    0x0(%rip),%rax        # 0x76\nmov    %rax,%rdi\ncall   0x7e\nlea    0x0(%rip),%rax        # 0x85\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x99\nmov    %rax,%rdi\ncall   0xa1\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x4e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_382",
        "query_text": "The function pauses the program's execution for a specified duration in milliseconds. It accepts an integer input representing the number of milliseconds to delay, converts this value into a timespec structure, and then calls a system-level function to suspend execution for that period. It does not return any value.",
        "code_id": "c_group_1_id_382",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x20(%rbp)\n\nmovq   $0x0,-0x18(%rbp)\n\nmov    -0x24(%rbp),%eax\ncltq   \nimul   $0xf4240,%rax,%rax\nmov    %rax,-0x18(%rbp)\nlea    -0x20(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x4f\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x64\ncall   0x64\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb9\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb9\nlea    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdi\ncall   0x96\nlea    0x0(%rip),%rax        # 0x9d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa7\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdi\ncall   0xb9\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x66\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_383",
        "query_text": "The function accepts a string as its input and produces a string as its output. It first checks if the input string starts with a predetermined prefix. If the prefix is present, the function then searches for a specific delimiter that follows the prefix. When the delimiter is located, it removes a section of the string that lies between a defined static part of the prefix and the delimiter. If the input string does not start with the required prefix or if the delimiter is not found, the input string remains unmodified.",
        "code_id": "c_group_1_id_383",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x5f5f3a3a647473,%rax\n\nmov    %rax,-0x10(%rbp)\nlea    -0x10(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rcx\nmov    $0x7,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   0x4e\ntest   %eax,%eax\nsete   %al\ntest   %al,%al\nje     0x96\nmov    -0x30(%rbp),%rax\nmov    $0x7,%edx\nlea    0x0(%rip),%rcx        # 0x67\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x72\nmov    %rax,-0x18(%rbp)\ncmpq   $0xffffffffffffffff,-0x18(%rbp)\nje     0x96\nmov    -0x18(%rbp),%rax\nlea    -0x3(%rax),%rdx\nmov    -0x30(%rbp),%rax\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   0x96\nmov    -0x30(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x28(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x116\ncmpl   $0xffff,-0x8(%rbp)\njne    0x116\nlea    0x0(%rip),%rax        # 0xeb\nmov    %rax,%rdi\ncall   0xf3\nlea    0x0(%rip),%rax        # 0xfa\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x104\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x10e\nmov    %rax,%rdi\ncall   0x116\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xc3\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_498",
        "query_text": "This function accepts three pointer arguments referring to memory locations. The first two pointers supply integer values, which are retrieved by dereferencing. The function then computes the sum of these integers and writes the result into the memory location indicated by the third pointer. No value is returned by the function, as the computed sum is stored directly via the provided output pointer.",
        "code_id": "c_group_1_id_498",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%edx\nmov    -0x4(%rbp),%eax\nadd    %eax,%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8a\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x78\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x82\nmov    %rax,%rdi\ncall   0x8a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x37\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_500",
        "query_text": "The function accepts two inputs: a pointer to an array of unsigned 8-bit integers and a size indicator that specifies the number of elements in the array. It sequentially examines each element in the array, checking whether the value of the current byte exceeds 127. If it finds a byte with a value greater than 127, the function immediately returns the index of that byte. If no byte exceeding 127 is encountered after traversing the entire array, the function returns the total size of the array. The output is of type size_t, which represents either the index of the first byte exceeding 127 or the array's length if all bytes are within the limit.",
        "code_id": "c_group_1_id_500",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x0,-0x8(%rbp)\n\njmp    0x37\nmov    -0x18(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njns    0x32\nmov    -0x8(%rbp),%rax\njmp    0x45\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     0x1a\nmov    -0x20(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9a\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9a\nlea    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rdi\ncall   0x77\nlea    0x0(%rip),%rax        # 0x7e\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x88\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x92\nmov    %rax,%rdi\ncall   0x9a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x47\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_384",
        "query_text": "The function takes no arguments and returns a boolean value. It is implemented as a constexpr function that consistently returns true. Its primary purpose is to serve as a marker indicating that a certain feature is deprecated. The function does not perform any additional computations or operations; it merely provides a constant boolean output to signal the deprecation status.",
        "code_id": "c_group_1_id_384",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_385",
        "query_text": "The function receives a null pointer constant and a pointer to an output stream as inputs. It writes the string \"(nullptr)\" to the output stream, thereby providing a clear textual representation of a null pointer. The function does not return any value (void).",
        "code_id": "c_group_1_id_385",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x1f\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2a\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x80\ncmpl   $0xffff,-0x8(%rbp)\njne    0x80\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdi\ncall   0x5d\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x78\nmov    %rax,%rdi\ncall   0x80\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_497",
        "query_text": "The function takes a pointer to an integer as input. It retrieves the integer value stored at the referenced memory location, multiplies it by 2, and updates that same location with the computed result. The function does not return any value, as it performs the operation in-place. The input is a pointer to an integer, and there is no explicit output value.",
        "code_id": "c_group_1_id_497",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_386",
        "query_text": "The function takes a constant void pointer as its only input and returns the identical pointer without any alterations. The input and output are both of type \"const void*\". Essentially, the function acts as a pass-through, simply relaying the pointer that was provided.",
        "code_id": "c_group_1_id_386",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x65\ncmpl   $0xffff,-0x8(%rbp)\njne    0x65\nlea    0x0(%rip),%rax        # 0x3a\nmov    %rax,%rdi\ncall   0x42\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdi\ncall   0x65\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x12\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_499",
        "query_text": "The function accepts two constant void pointers as inputs and treats them as pointers to character arrays. It compares these arrays byte by byte over a fixed length of 28 bytes (equivalent to 7 times the size of an int). During this process, if any byte differs between the two arrays, the function returns 1, indicating inequality. If all 28 bytes match exactly, it returns 0, signifying that the memory regions are identical. The function operates solely by checking the specified range without modifying any input data and returns an integer result that reflects the outcome of the comparison.",
        "code_id": "c_group_1_id_499",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    0x50\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     0x42\nmov    $0x1,%eax\njmp    0x60\naddq   $0x1,-0x10(%rbp)\naddq   $0x1,-0x8(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltq   \ncmp    $0x1b,%rax\njbe    0x29\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb5\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb5\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rdi\ncall   0x92\nlea    0x0(%rip),%rax        # 0x99\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa3\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xad\nmov    %rax,%rdi\ncall   0xb5\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x62\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_494",
        "query_text": "The function accepts no input parameters and returns no value. It is designed to initialize or configure global settings, but its current implementation is empty and does not perform any operations.",
        "code_id": "c_group_1_id_494",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_495",
        "query_text": "The function accepts three parameters: a pointer to a character array allocated dynamically, and two pointers to constant characters representing other strings. It first checks whether the dynamically allocated string is not the same as either of the constant strings. If this condition is met, it frees the memory associated with the dynamically allocated string. The function does not return a value (void) and is designed solely to conditionally release memory based on the relationship between the inputs.",
        "code_id": "c_group_1_id_495",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x8(%rbp),%rax\nje     0x38\nmov    -0x18(%rbp),%rax\ncmp    -0x8(%rbp),%rax\nje     0x38\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x8e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x8e\nlea    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdi\ncall   0x6b\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x86\nmov    %rax,%rdi\ncall   0x8e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x3b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_387",
        "query_text": "The function accepts two wide characters as input and returns a 32-bit unsigned integer. It initially checks whether the underlying wide-character type is 2 bytes (UTF-16). If so, it combines the two characters into a single Unicode code point by extracting lower-order bits from each character, shifting bits accordingly, and adding a fixed offset. Otherwise, when the wide-character type exceeds 2 bytes, the function simply converts and returns the first input character as a 32-bit unsigned integer.",
        "code_id": "c_group_1_id_387",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmovl   $0x3ff,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_346",
        "query_text": "The function receives two strings as inputs and returns a boolean value. It begins by verifying that the length of the first string is at least as long as the second (serving as the suffix). If this condition is met, the function compares the characters at the end of the first string with those of the suffix by iterating over them in reverse order. The function ultimately returns true if all corresponding characters match, indicating that the first string indeed ends with the provided suffix; otherwise, it returns false.",
        "code_id": "c_group_1_id_346",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmov    %rax,%rbx\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3f\ncmp    %rax,%rbx\njb     0x9f\nlea    -0x20(%rbp),%rax\nmov    -0x38(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x57\nlea    -0x28(%rbp),%rax\nmov    -0x40(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x6a\nlea    -0x30(%rbp),%rax\nmov    -0x40(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x7d\nlea    -0x20(%rbp),%rdx\nlea    -0x28(%rbp),%rcx\nlea    -0x30(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x94\ntest   %al,%al\nje     0x9f\nmov    $0x1,%eax\njmp    0xa4\nmov    $0x0,%eax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xb8\ncall   0xb8\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x111\ncmpl   $0xffff,-0x8(%rbp)\njne    0x111\nlea    0x0(%rip),%rax        # 0xe6\nmov    %rax,%rdi\ncall   0xee\nlea    0x0(%rip),%rax        # 0xf5\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xff\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x109\nmov    %rax,%rdi\ncall   0x111\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xbe\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rdx\nlea    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x3a\nmov    -0x30(%rbp),%rdx\nlea    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x4d\nmov    -0x28(%rbp),%rdx\nlea    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x60\nlea    -0x10(%rbp),%rdx\nlea    -0x18(%rbp),%rcx\nlea    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x77\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x8b\ncall   0x8b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    (%rdx),%rdx\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %rdx,-0x58(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x58(%rbp),%rdx\nlea    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x3a\nlea    -0x10(%rbp),%rax\nlea    -0x18(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x4d\nmov    -0x50(%rbp),%rdx\nlea    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x60\nlea    -0x20(%rbp),%rax\nlea    -0x28(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x73\nmov    -0x48(%rbp),%rdx\nlea    -0x38(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x86\nlea    -0x30(%rbp),%rax\nlea    -0x38(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x99\nlea    -0x10(%rbp),%rdx\nlea    -0x20(%rbp),%rcx\nlea    -0x30(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0xb0\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0xc4\ncall   0xc4\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2f\nmov    %rax,%rdi\ncall   0x37\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x49\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x5d\ncall   0x5d\nmov    -0x18(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovb   $0x0,-0x21(%rbp)\nmov    -0x48(%rbp),%rdx\nlea    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x3e\nmov    -0x40(%rbp),%rdx\nlea    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x51\nmov    -0x38(%rbp),%rdx\nlea    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x64\nlea    -0x10(%rbp),%rdx\nlea    -0x18(%rbp),%rcx\nlea    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x7b\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x8f\ncall   0x8f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nmov    (%rax),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nlea    -0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nsubq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\njmp    0x61\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x27\nmovzbl (%rax),%ebx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x36\nmovzbl (%rax),%eax\ncmp    %al,%bl\nsetne  %al\ntest   %al,%al\nje     0x49\nmov    $0x0,%eax\njmp    0x7d\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x55\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x61\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\ntest   %al,%al\njne    0x1b\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nxor    $0x1,%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x21\nmov    %rax,%rbx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\ncmp    %rax,%rbx\nsete   %al\nmov    -0x8(%rbp),%rbx\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_391",
        "query_text": "The function accepts a single input of type signed char and returns a constant string pointer. Regardless of the input, it always returns an empty string (\"\"). The primary purpose of the function is to provide a fixed, unchanging string output independent of the parameter value.",
        "code_id": "c_group_1_id_391",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nlea    0x0(%rip),%rax        # 0x14\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x69\ncmpl   $0xffff,-0x8(%rbp)\njne    0x69\nlea    0x0(%rip),%rax        # 0x3e\nmov    %rax,%rdi\ncall   0x46\nlea    0x0(%rip),%rax        # 0x4d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdi\ncall   0x69\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x16\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_508",
        "query_text": "The function takes a 16-bit unsigned integer as input and counts the number of trailing zeros in its binary representation. It returns a 32-bit unsigned integer that represents the count of the least significant bits set to zero. The implementation utilizes platform-specific optimizations\u2014such as compiler intrinsics or inline assembly instructions\u2014when available for improved performance and falls back to a bitwise shift-and-check approach otherwise.",
        "code_id": "c_group_1_id_508",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %ax,-0x4(%rbp)\nmovzwl -0x4(%rbp),%eax\ntzcnt  %eax,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6b\nlea    0x0(%rip),%rax        # 0x40\nmov    %rax,%rdi\ncall   0x48\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdi\ncall   0x6b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x18\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_487",
        "query_text": "The function takes a structure representing time (with an hour component) as input and determines whether the time is in the \"AM\" or \"PM\" period. It evaluates the hour field: if it is 12 or greater, the function returns the constant string \"PM\"; otherwise, it returns \"AM\". The input is a time structure, and the output is a pointer to a constant character string.",
        "code_id": "c_group_1_id_487",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\ncmp    $0xb,%eax\njle    0x21\nlea    0x0(%rip),%rax        # 0x1f\njmp    0x28\nlea    0x0(%rip),%rax        # 0x28\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7d\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdi\ncall   0x5a\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x75\nmov    %rax,%rdi\ncall   0x7d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_496",
        "query_text": "The function accepts three pointers: two that may reference integer values (or be null) and one that designates the destination for storing an integer result. It first verifies whether each of the first two pointers is non-null, in which case it retrieves the integer value pointed to; if a pointer is null, it substitutes a value of 0. It then adds the two integer values and stores the sum in the memory location indicated by the third pointer. The function does not return any value, with the computed sum being stored directly via the result pointer.",
        "code_id": "c_group_1_id_496",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     0x23\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\njmp    0x28\nmov    $0x0,%eax\nmov    %eax,-0x8(%rbp)\ncmpq   $0x0,-0x20(%rbp)\nje     0x3a\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\njmp    0x3f\nmov    $0x0,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%edx\nmov    -0x4(%rbp),%eax\nadd    %eax,%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa6\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa6\nlea    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rdi\ncall   0x83\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x94\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9e\nmov    %rax,%rdi\ncall   0xa6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x53\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_430",
        "query_text": "The function is defined as a static inline function that accepts no inputs and returns no output. It performs no operations and serves purely as a placeholder or no-op function, meant to be used in contexts where a function call is required despite no functional action being necessary.",
        "code_id": "c_group_1_id_430",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_488",
        "query_text": "The function converts a 24-hour format time into a 12-hour format based solely on the hour field from a time structure. Initially, it examines the hour value stored within the structure. If the hour is greater than 12, the function subtracts 12 to effectively convert the value from 24-hour to 12-hour notation; otherwise, it leaves the hour unchanged. The function then returns this final hour as an integer.",
        "code_id": "c_group_1_id_488",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\ncmp    $0xc,%eax\njle    0x24\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\nsub    $0xc,%eax\njmp    0x2b\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x80\ncmpl   $0xffff,-0x8(%rbp)\njne    0x80\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdi\ncall   0x5d\nlea    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x78\nmov    %rax,%rdi\ncall   0x80\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_390",
        "query_text": "The function accepts a single character (of type char) as input and always returns a constant string (of type const char*). Regardless of the input provided, the function simply returns an empty string (\"\") without performing any additional operations or modifications.",
        "code_id": "c_group_1_id_390",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nlea    0x0(%rip),%rax        # 0x14\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x69\ncmpl   $0xffff,-0x8(%rbp)\njne    0x69\nlea    0x0(%rip),%rax        # 0x3e\nmov    %rax,%rdi\ncall   0x46\nlea    0x0(%rip),%rax        # 0x4d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdi\ncall   0x69\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x16\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_393",
        "query_text": "The function takes a single input\u2014a wide character (wchar_t)\u2014and always returns a pointer to a constant string. Regardless of the input value, the function produces the same constant output, the string literal \"L\" (of type const char*).",
        "code_id": "c_group_1_id_393",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nlea    0x0(%rip),%rax        # 0x12\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_389",
        "query_text": "The function accepts two inputs: a pointer to a constant void type and a pointer to a boolean variable. It defines a local integer variable and compares its memory address with the provided pointer. If the local variable's address is lower (i.e., precedes in memory) than the given address, the function sets the boolean output to true; otherwise, it assigns false. The function solely performs this comparison without modifying the input pointer or conducting any additional operations.",
        "code_id": "c_group_1_id_389",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0xc(%rbp)\nmov    -0x18(%rbp),%rdx\nlea    -0xc(%rbp),%rcx\nlea    -0xd(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x41\nmov    -0x20(%rbp),%rdx\nmov    %al,(%rdx)\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x5c\ncall   0x5c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb1\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb1\nlea    0x0(%rip),%rax        # 0x86\nmov    %rax,%rdi\ncall   0x8e\nlea    0x0(%rip),%rax        # 0x95\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x9f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xa9\nmov    %rax,%rdi\ncall   0xb1\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x5e\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    -0x18(%rbp),%rax\ncmp    %rax,%rdx\nsetb   %al\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_392",
        "query_text": "The function receives an unsigned 8-bit integer (of type unsigned char) and produces an output of type constant character pointer (const char*). It returns a constant empty string (\"\") regardless of the input value, meaning that the function does not perform any computation or transformation on the provided input.",
        "code_id": "c_group_1_id_392",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nlea    0x0(%rip),%rax        # 0x14\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x69\ncmpl   $0xffff,-0x8(%rbp)\njne    0x69\nlea    0x0(%rip),%rax        # 0x3e\nmov    %rax,%rdi\ncall   0x46\nlea    0x0(%rip),%rax        # 0x4d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x57\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdi\ncall   0x69\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x16\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_434",
        "query_text": "This function takes no input and returns an integer that signifies a test case has been intentionally skipped. It does not perform any operations besides immediately returning a predefined constant representing the skipped test status. The function serves as a marker or placeholder to indicate that the particular test is not executed during a testing run.",
        "code_id": "c_group_1_id_434",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_427",
        "query_text": "The function takes a pointer to an integer and an integer value as inputs. It first retrieves the current value stored at the provided pointer, then adds the provided integer value to it, updating the original value atomically to ensure thread safety. Finally, the function returns the original integer value obtained before the addition.",
        "code_id": "c_group_1_id_427",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x81\ncmpl   $0xffff,-0x8(%rbp)\njne    0x81\nlea    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nlea    0x0(%rip),%rax        # 0x65\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdi\ncall   0x81\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_510",
        "query_text": "This function accepts a floating-point input that is expected to be within a normalized range (e.g., [0, 1]). It returns a floating-point result obtained by applying a quadratic easing-out transformation\u2014a process where the change is initially rapid and then gradually decelerates as the value approaches its maximum. The operation is purely mathematical and independent of any external state or supplementary parameters.",
        "code_id": "c_group_1_id_510",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x1a\n\nsubss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x2b\n\nxorps  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x83\ncmpl   $0xffff,-0x8(%rbp)\njne    0x83\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rdi\ncall   0x60\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x71\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rdi\ncall   0x83\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x30\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_432",
        "query_text": "This function tests secure remote password protocol operations in a controlled environment. It is conditionally compiled to run only when both the secure remote password and SHA-512 features are enabled. The function takes no input parameters and returns no value. It first initializes the cryptographic library before sequentially testing various SRP operations such as context initialization, username and parameter setting, and\u2014if SHA is enabled\u2014password configuration, public key generation, shared key computation, and session proof verification. It also tests a callback mechanism for key generation before finally cleaning up the cryptographic library.",
        "code_id": "c_group_1_id_432",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_433",
        "query_text": "The function takes no input arguments and returns an integer value. It immediately outputs a predefined constant that signifies that a particular test or operation has been skipped. The function performs no computations or modifications; its sole purpose is to serve as an indicator for the skipped functionality.",
        "code_id": "c_group_1_id_433",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_388",
        "query_text": "The function accepts a single input of type std::string. It then iterates over the string to locate newline characters that indicate the end of each line. For every identified line, the function prefixes it with a fixed text segment. If the end of the string is reached and a newline is not encountered, the remaining part of the string is treated as the final line and the prefix is still applied. Finally, the function returns a new std::string containing all the lines, each with the prefixed text.",
        "code_id": "c_group_1_id_388",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x58,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmovq   $0x0,-0x50(%rbp)\n\nmov    -0x50(%rbp),%rdx\nmov    -0x60(%rbp),%rax\nmov    $0xa,%esi\nmov    %rax,%rdi\ncall   0x4d\nmov    %rax,-0x48(%rbp)\nmov    -0x58(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x5c\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x67\ncmpq   $0xffffffffffffffff,-0x48(%rbp)\njne    0xc2\nlea    -0x40(%rbp),%rax\nmov    -0x50(%rbp),%rdx\nmov    -0x60(%rbp),%rsi\nmov    $0xffffffffffffffff,%rcx\nmov    %rax,%rdi\ncall   0x89\nlea    -0x40(%rbp),%rdx\nmov    -0x58(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x9c\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0xa8\nnop\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x15f\njmp    0x15a\nmov    -0x48(%rbp),%rax\nsub    -0x50(%rbp),%rax\nlea    0x1(%rax),%rcx\nlea    -0x40(%rbp),%rax\nmov    -0x50(%rbp),%rdx\nmov    -0x60(%rbp),%rsi\nmov    %rax,%rdi\ncall   0xe2\nlea    -0x40(%rbp),%rdx\nmov    -0x58(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf5\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x101\nmov    -0x48(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x50(%rbp)\njmp    0x38\nendbr64 \nmov    %rax,%rbx\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x125\njmp    0x143\nendbr64 \nmov    %rax,%rbx\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x13a\njmp    0x143\nendbr64 \nmov    %rax,%rbx\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   0x14f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x15a\ncall   0x15f\nmov    -0x58(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x1bc\ncmpl   $0xffff,-0x8(%rbp)\njne    0x1bc\nlea    0x0(%rip),%rax        # 0x191\nmov    %rax,%rdi\ncall   0x199\nlea    0x0(%rip),%rax        # 0x1a0\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x1aa\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x1b4\nmov    %rax,%rdi\ncall   0x1bc\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x169\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_428",
        "query_text": "The function takes two inputs: a pointer to an integer and an integer. It retrieves the current value from the integer pointed to by the pointer, subtracts the given integer from it, and then returns the original value before the subtraction occurred. The function returns an int.",
        "code_id": "c_group_1_id_428",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nsub    -0x1c(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x81\ncmpl   $0xffff,-0x8(%rbp)\njne    0x81\nlea    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nlea    0x0(%rip),%rax        # 0x65\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdi\ncall   0x81\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_429",
        "query_text": "The function takes an unsigned long integer as input and returns a constant character pointer (string). It ignores the numerical input and does not use it in any computation. Instead, it logs a debug message to inform the user that it does not provide the name of the function that failed, advising them to consult the debug logs for additional error details. The function always returns an empty string and does not supply any specific error-related information directly.",
        "code_id": "c_group_1_id_429",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nlea    0x0(%rip),%rax        # 0x13\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x68\ncmpl   $0xffff,-0x8(%rbp)\njne    0x68\nlea    0x0(%rip),%rax        # 0x3d\nmov    %rax,%rdi\ncall   0x45\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x56\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x60\nmov    %rax,%rdi\ncall   0x68\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x15\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_453",
        "query_text": "This function takes no input arguments and returns an integer indicating a test status. Specifically, it always returns a predefined constant that signifies the associated test has been skipped. The function does not perform any further processing or calculations, and its return type is an integer.",
        "code_id": "c_group_1_id_453",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_431",
        "query_text": "The function accepts three parameters: a pointer to an unsigned character array, an integer representing a size, and an integer representing a type. It ignores the unsigned character array and then prints a formatted message to the console that includes the size and type values, signaling that a specific cache add callback has been triggered. The function does not return any value.",
        "code_id": "c_group_1_id_431",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %edx,-0x10(%rbp)\nmov    -0x10(%rbp),%edx\nmov    -0xc(%rbp),%eax\nmov    %eax,%esi\nlea    0x0(%rip),%rax        # 0x25\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x32\nmov    0x0(%rip),%rax        # 0x39\nmov    %rax,%rdi\ncall   0x41\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x97\ncmpl   $0xffff,-0x8(%rbp)\njne    0x97\nlea    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rdi\ncall   0x74\nlea    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x85\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8f\nmov    %rax,%rdi\ncall   0x97\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x44\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_444",
        "query_text": "The function takes no external inputs and returns an integer indicating the overall test result. It uses a fixed key, an initialization vector, a plaintext message, and additional authenticated data. The procedure is as follows:\n\n1. First, multiple encryption contexts are initialized for a Galois/Counter Mode cipher configured with three different key sizes. For each configuration, the function encrypts the plaintext by processing the additional authenticated data and obtains both the ciphertext and an authentication tag.\n\n2. Next, corresponding decryption contexts are set up. Each decryption process uses the fixed key and initialization vector to recover the original plaintext from the ciphertext while validating the authentication tag. Additionally, the function deliberately alters the authentication tag to verify that decryption fails when the tag is incorrect.\n\n3. Finally, after cleaning up the encryption and decryption contexts, the function returns an integer value representing whether the test passed, failed, or was skipped (e.g., if necessary features were unavailable).\n\nThe overall goal is to validate that the cipher's encryption and decryption operations function correctly and robustly across different configurations.",
        "code_id": "c_group_1_id_444",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_456",
        "query_text": "The function accepts no input parameters and returns an integer value. It indicates that a specific DTLS (Datagram Transport Layer Security) test within a particular security library is skipped by directly returning a predefined constant that signifies the test is not executed. The function does not perform any internal computations or processing; it simply provides the test's skipped status via its integer return value.",
        "code_id": "c_group_1_id_456",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_505",
        "query_text": "The function accepts an integer as input and returns an integer as output. It operates by comparing the input value against a predefined set of constants. If the input matches any one of these constants, the function returns 0; if no match is found, it returns 1.",
        "code_id": "c_group_1_id_505",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x80,-0x4(%rbp)\nje     0x32\ncmpl   $0x100,-0x4(%rbp)\nje     0x32\ncmpl   $0x200,-0x4(%rbp)\nje     0x32\ncmpl   $0x1,-0x4(%rbp)\nje     0x32\ncmpl   $0x2,-0x4(%rbp)\njne    0x39\nmov    $0x0,%eax\njmp    0x3e\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x93\ncmpl   $0xffff,-0x8(%rbp)\njne    0x93\nlea    0x0(%rip),%rax        # 0x68\nmov    %rax,%rdi\ncall   0x70\nlea    0x0(%rip),%rax        # 0x77\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x81\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8b\nmov    %rax,%rdi\ncall   0x93\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x40\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_394",
        "query_text": "The function takes three inputs: a string, a flag string, and a boolean indicating if the flag value is optional. It begins by constructing a prefix by concatenating a constant literal with the flag string and then checks if the input string starts with this prefix. If it does, the function examines the subsequent character(s): if the flag is marked as optional and the string ends immediately after the prefix, it returns a pointer to that position; otherwise, if the flag is expected to have a value, it verifies that an equals sign immediately follows the prefix and returns a pointer to the beginning of the value. If these conditions are not met, the function returns a null pointer. The output is a pointer to a constant character.",
        "code_id": "c_group_1_id_394",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x98,%rsp\nmov    %rdi,-0x88(%rbp)\nmov    %rsi,-0x90(%rbp)\nmov    %edx,%eax\nmov    %al,-0x94(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\ncmpq   $0x0,-0x88(%rbp)\n\nje     0x49\ncmpq   $0x0,-0x90(%rbp)\n\njne    0x53\nmov    $0x0,%ebx\njmp    0x142\nlea    -0x71(%rbp),%rax\nmov    %rax,%rdi\ncall   0x5f\nlea    -0x71(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x6e\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x79\nlea    -0x60(%rbp),%rax\nmov    -0x90(%rbp),%rdx\nlea    -0x40(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x93\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9f\nlea    -0x71(%rbp),%rax\nmov    %rax,%rdi\ncall   0xab\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   0xb7\nmov    %rax,-0x70(%rbp)\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   0xc7\nmov    %rax,%rcx\nmov    -0x70(%rbp),%rdx\nmov    -0x88(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0xe0\ntest   %eax,%eax\nsetne  %al\ntest   %al,%al\nje     0xf0\nmov    $0x0,%ebx\njmp    0x136\nmov    -0x88(%rbp),%rdx\nmov    -0x70(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x68(%rbp)\ncmpb   $0x0,-0x94(%rbp)\nje     0x11c\nmov    -0x68(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    0x11c\nmov    -0x68(%rbp),%rbx\njmp    0x136\nmov    -0x68(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x3d,%al\nje     0x12e\nmov    $0x0,%ebx\njmp    0x136\nmov    -0x68(%rbp),%rax\nlea    0x1(%rax),%rbx\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   0x142\nmov    %rbx,%rax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x18e\njmp    0x189\nendbr64 \nmov    %rax,%rbx\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x169\njmp    0x172\nendbr64 \nmov    %rax,%rbx\nlea    -0x71(%rbp),%rax\nmov    %rax,%rdi\ncall   0x17e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x189\ncall   0x18e\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x1e7\ncmpl   $0xffff,-0x8(%rbp)\njne    0x1e7\nlea    0x0(%rip),%rax        # 0x1bc\nmov    %rax,%rdi\ncall   0x1c4\nlea    0x0(%rip),%rax        # 0x1cb\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x1d5\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x1df\nmov    %rax,%rdi\ncall   0x1e7\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x194\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x2b\nmov    %rax,%rdi\ncall   0x33\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x45\nmov    -0x8(%rbp),%rax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_511",
        "query_text": "This function takes a floating-point input that is expected to be between 0 and 1 and computes a quadratic easing effect with distinct accelerating and decelerating phases. For values less than 0.5, it applies an accelerating quadratic transformation; for values 0.5 or greater, it applies a decelerating quadratic transformation. The design guarantees a smooth, continuous transition at the midpoint, and the function returns a floating-point result that remains within the 0 to 1 range.",
        "code_id": "c_group_1_id_511",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x23\n\ncomiss -0x14(%rbp),%xmm0\njbe    0x34\nmovss  -0x4(%rbp),%xmm0\naddss  %xmm0,%xmm0\njmp    0x66\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x41\n\nmulss  %xmm0,%xmm1\nmovss  -0x14(%rbp),%xmm2\nmovss  0x0(%rip),%xmm0        # 0x52\n\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\nmovss  0x0(%rip),%xmm1        # 0x62\n\nsubss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xbb\ncmpl   $0xffff,-0x8(%rbp)\njne    0xbb\nlea    0x0(%rip),%rax        # 0x90\nmov    %rax,%rdi\ncall   0x98\nlea    0x0(%rip),%rax        # 0x9f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa9\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb3\nmov    %rax,%rdi\ncall   0xbb\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x68\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_514",
        "query_text": "The function takes a floating-point input (ranging from 0.0 to 1.0) that represents the progress of a transition. It employs a cubic easing algorithm to compute a smooth in-out motion. Specifically, it accelerates the transition for progress values below 0.5 and decelerates for values of 0.5 or greater, ensuring a gradual start and finish. The computed value is also a floating-point number normalized within the range 0.0 to 1.0.",
        "code_id": "c_group_1_id_514",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x15\n\ncomiss -0x14(%rbp),%xmm0\njbe    0x38\nmovss  -0x14(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x28\n\nmulss  %xmm1,%xmm0\nmulss  -0x14(%rbp),%xmm0\nmulss  -0x14(%rbp),%xmm0\njmp    0x7c\nmovss  -0x14(%rbp),%xmm0\naddss  %xmm0,%xmm0\nmovss  0x0(%rip),%xmm1        # 0x49\n\nsubss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x5f\n\nmulss  %xmm1,%xmm0\nmulss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x78\n\naddss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd1\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd1\nlea    0x0(%rip),%rax        # 0xa6\nmov    %rax,%rdi\ncall   0xae\nlea    0x0(%rip),%rax        # 0xb5\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xbf\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xc9\nmov    %rax,%rdi\ncall   0xd1\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_490",
        "query_text": "This function accepts a single parameter of type std::nullptr_t and returns a value of the same type. Its operation is straightforward: regardless of the input, it always returns a constant null pointer value (nullptr). Essentially, the function serves as a no-operation wrapper for null pointer values, ensuring that the null pointer is passed through unchanged.",
        "code_id": "c_group_1_id_490",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x66\ncmpl   $0xffff,-0x8(%rbp)\njne    0x66\nlea    0x0(%rip),%rax        # 0x3b\nmov    %rax,%rdi\ncall   0x43\nlea    0x0(%rip),%rax        # 0x4a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x13\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_492",
        "query_text": "The function accepts a single input of type std::nullptr_t, representing a null pointer literal. It returns a std::string that contains the text \"nullptr\", effectively converting the null pointer literal into its string representation. The input type is std::nullptr_t, while the output type is std::string.",
        "code_id": "c_group_1_id_492",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nlea    -0x19(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x3f\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x4a\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x56\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x8a\njmp    0x85\nendbr64 \nmov    %rax,%rbx\nlea    -0x19(%rbp),%rax\nmov    %rax,%rdi\ncall   0x7a\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x85\ncall   0x8a\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xe7\ncmpl   $0xffff,-0x8(%rbp)\njne    0xe7\nlea    0x0(%rip),%rax        # 0xbc\nmov    %rax,%rdi\ncall   0xc4\nlea    0x0(%rip),%rax        # 0xcb\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xd5\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xdf\nmov    %rax,%rdi\ncall   0xe7\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x94\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_447",
        "query_text": "The function takes no parameters and returns an integer that indicates the test outcome. It first creates an original stack of certificate names and populates it with three entries. It then duplicates this stack using a duplication function and verifies that the duplicated stack has the same size as the original. Additionally, the function tests edge cases by providing null inputs and attempting to pop elements from both a null stack and an empty stack. Finally, it frees all allocated resources and returns an integer value representing success, failure, or skip status.",
        "code_id": "c_group_1_id_447",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_450",
        "query_text": "The function performs a conditional cleanup operation related to an external module, but only when a specific compile-time macro is defined. It accepts no input parameters and returns an integer status code. Initially, the function sets the status to indicate a skipped operation. If the macro is defined, it invokes a cleanup routine from the module and updates the status to indicate a successful operation. Finally, the function returns the appropriate status, reflecting whether the cleanup was executed.",
        "code_id": "c_group_1_id_450",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_443",
        "query_text": "The function takes no input parameters. It checks a specific compile-time condition: if a certain macro is defined, it calls a routine to load cryptographic error messages and then returns an integer constant representing success; otherwise, it directly returns an integer constant indicating that the operation was skipped. The function thereby returns an integer whose value depends on the defined macro.",
        "code_id": "c_group_1_id_443",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_452",
        "query_text": "The function takes no inputs and returns an integer. It is designed to simply return a predefined constant integer value that indicates a test has been skipped. The function's behavior does not depend on any parameters and does not perform additional operations beyond returning the constant value. The return type is int.",
        "code_id": "c_group_1_id_452",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_512",
        "query_text": "The function takes a floating-point input and returns the cubic easing result for that value. It calculates a smooth acceleration effect by computing the cube of the input. The output is of type float, and the function operates purely in a mathematical context without relying on any external state.",
        "code_id": "c_group_1_id_512",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmulss  -0x4(%rbp),%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x70\ncmpl   $0xffff,-0x8(%rbp)\njne    0x70\nlea    0x0(%rip),%rax        # 0x45\nmov    %rax,%rdi\ncall   0x4d\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x68\nmov    %rax,%rdi\ncall   0x70\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1d\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_435",
        "query_text": "The function takes no input arguments and returns an integer indicating the outcome of its test. It conditionally tests the export functionality of TLS sessions by first verifying that the environment is configured to support session export for TLS version 1.2. If these conditions are met, it proceeds to execute tests for TLS 1.2 and, if further configured, for TLS 1.3. The integer output represents whether the tests passed, failed, or were skipped due to unmet preprocessor conditions.",
        "code_id": "c_group_1_id_435",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_448",
        "query_text": "The function checks if it should run based on a compile-time condition. When the condition is met, it first performs a cleanup by freeing all configuration modules. It then executes three unload operations with different parameter values (0, 1, and -1) to ensure that the modules are fully released. If the compile-time condition is defined and all operations succeed, the function returns a success status; otherwise, it returns a skipped status. The function does not take any inputs and returns an integer indicating the test outcome.",
        "code_id": "c_group_1_id_448",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_437",
        "query_text": "This function validates the process of generating a shared secret using an elliptic curve cryptography algorithm based on SM2. It begins by initializing a random number generator alongside two separate elliptic curve key pairs. It then performs key generation for both pairs and proceeds to compute shared secrets for each using the SM2 method. The function confirms that the shared secrets produced by the two key pairs are identical and do not exceed the expected maximum length. Additionally, it rigorously tests the error handling capabilities by providing various invalid input combinations to ensure that improper arguments are correctly rejected. Finally, the function returns a result indicating whether the test passed, failed, or was skipped due to missing dependencies.",
        "code_id": "c_group_1_id_437",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_513",
        "query_text": "The function takes a floating-point number as input and computes a result based on a cubic easing operation. It first shifts the input by subtracting 1.0, then raises the resulting value to the power of three, and finally adds 1.0 to obtain the output. Designed to provide a smooth deceleration effect for animations or transitions, the function expects an input typically in the range of 0 to 1 and returns a value that usually remains within this range, although a slight overshoot is possible due to the cubic calculation.",
        "code_id": "c_group_1_id_513",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x1a\n\nsubss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x3c\n\naddss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x95\ncmpl   $0xffff,-0x8(%rbp)\njne    0x95\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdi\ncall   0x72\nlea    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x83\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8d\nmov    %rax,%rdi\ncall   0x95\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x42\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_491",
        "query_text": "The function takes a single character as input and outputs its string representation. It first checks if the character is one of the special control characters (specifically carriage return, form feed, newline, or tab) and, if so, returns a string containing the corresponding escape sequence. If the character is another non-printable control character (with an ASCII value between 0 and 31, excluding the aforementioned cases), the function converts it to an unsigned integer and recursively processes it to obtain its string representation. For all other printable characters, it returns a string that encloses the character within single quotes.",
        "code_id": "c_group_1_id_491",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,%eax\nmov    %al,-0x2c(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\ncmpb   $0xd,-0x2c(%rbp)\njne    0x62\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x37\nlea    -0x1d(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x46\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x51\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x5d\njmp    0x214\ncmpb   $0xc,-0x2c(%rbp)\njne    0x9f\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x74\nlea    -0x1d(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x83\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x8e\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9a\njmp    0x214\ncmpb   $0xa,-0x2c(%rbp)\njne    0xdc\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0xb1\nlea    -0x1d(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0xc0\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0xcb\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0xd7\njmp    0x214\ncmpb   $0x9,-0x2c(%rbp)\njne    0x119\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0xee\nlea    -0x1d(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0xfd\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x108\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x114\njmp    0x214\ncmpb   $0x0,-0x2c(%rbp)\njs     0x13c\ncmpb   $0x1f,-0x2c(%rbp)\njg     0x13c\nmovsbl -0x2c(%rbp),%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   0x137\njmp    0x214\nmovl   $0x272027,-0x1c(%rbp)\nmovzbl -0x2c(%rbp),%eax\nmov    %al,-0x1b(%rbp)\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x156\nlea    -0x1d(%rbp),%rdx\nlea    -0x1c(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x16d\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x179\njmp    0x214\nendbr64 \nmov    %rax,%rbx\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x191\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x19c\nendbr64 \nmov    %rax,%rbx\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1af\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x1ba\nendbr64 \nmov    %rax,%rbx\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1cd\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x1d8\nendbr64 \nmov    %rax,%rbx\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1eb\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x1f6\nendbr64 \nmov    %rax,%rbx\nlea    -0x1d(%rbp),%rax\nmov    %rax,%rdi\ncall   0x209\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x214\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x228\ncall   0x228\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x285\ncmpl   $0xffff,-0x8(%rbp)\njne    0x285\nlea    0x0(%rip),%rax        # 0x25a\nmov    %rax,%rdi\ncall   0x262\nlea    0x0(%rip),%rax        # 0x269\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x273\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x27d\nmov    %rax,%rdi\ncall   0x285\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x232\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ntest   %al,%al\nje     0x2f\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2d\njmp    0x3c\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x3b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x10(%rbp)\n\njmp    0x2e\naddq   $0x1,-0x10(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nlea    -0x11(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x4c\nxor    $0x1,%eax\ntest   %al,%al\njne    0x29\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x38\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdx\nmov    %rcx,%rsi\nmov    %rbx,%rdi\ncall   0x4d\ncmpq   $0x0,-0x40(%rbp)\nje     0x69\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   0x60\nmov    -0x40(%rbp),%rdx\nadd    %rdx,%rax\njmp    0x6e\nmov    $0x1,%eax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x89\njmp    0xa9\nendbr64 \nmov    %rax,%rbx\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   0x9e\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0xa9\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0xbd\ncall   0xbd\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x20\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x33\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   0x34\ntest   %al,%al\nje     0x49\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nje     0x49\nmov    $0x1,%eax\njmp    0x4e\nmov    $0x0,%eax\ntest   %al,%al\nje     0x61\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rdi\ncall   0x61\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x74\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    $0xf,%rax\njbe    0xbf\nlea    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x9a\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xac\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xbf\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0xcb\nmov    %rax,%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   0xe1\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0xf4\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\n\nje     0x13f\njmp    0x13a\nendbr64 \nmov    %rax,%rdi\ncall   0x112\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x11e\ncall   0x123\nendbr64 \nmov    %rax,%rbx\ncall   0x12f\nmov    %rbx,%rax\nmov    %rax,%rdi\ncall   0x13a\ncall   0x13f\nmov    -0x8(%rbp),%rbx\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_504",
        "query_text": "The function takes one input of type const char pointer. It performs no operations or computations on the input and does not produce any output or return any value. The parameter is explicitly marked as unused, indicating that the function serves as a no-op (no operation) placeholder across translation units.",
        "code_id": "c_group_1_id_504",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_519",
        "query_text": "The function takes a single floating-point value as input and produces a floating-point value as output. It applies a quintic easing-out transformation to the input, calculated by subtracting one from the input, squaring the result, and using this squared value repeatedly to compute a fifth-power term before adding one. Consequently, when the input is within the range [0, 1], the output is also guaranteed to be within [0, 1]. This easing operation is typically used in animations and transitions to create a smooth deceleration effect toward the end of a movement or change.",
        "code_id": "c_group_1_id_519",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x1a\n\nsubss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x8(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4a\n\naddss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa3\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa3\nlea    0x0(%rip),%rax        # 0x78\nmov    %rax,%rdi\ncall   0x80\nlea    0x0(%rip),%rax        # 0x87\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x91\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9b\nmov    %rax,%rdi\ncall   0xa3\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x50\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_445",
        "query_text": "This function verifies the encryption and decryption processes of an SM4-GCM algorithm when provided with an empty (zero-length) plaintext input. It begins by initializing separate contexts for both encryption and decryption, and it employs predetermined byte arrays for the key and initialization vector (IV). During encryption, the function processes the empty plaintext to produce an empty ciphertext and generates an authentication tag. This tag is then compared to a predefined expected value. In the decryption phase, it takes the empty ciphertext along with the same fixed key and IV, sets the authentication tag, and confirms that the decryption also results in an empty output. The function uses various integer variables to track data sizes and processing results, and finally, it returns a status indicating whether the test passed, was skipped, or failed.",
        "code_id": "c_group_1_id_445",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_439",
        "query_text": "The function takes no arguments and returns an integer status. It checks for a specific compile-time flag, and if present, it performs two cleanup operations: one on a certificate store context and another on a related trusted component. If the flag is defined, the function executes both cleanup routines and returns a success status; otherwise, it skips the operations and returns a skipped status.",
        "code_id": "c_group_1_id_439",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_463",
        "query_text": "The function takes no input arguments and returns an integer value. It unconditionally returns a predefined constant indicating that the associated test is skipped, without performing any additional computations or operations.",
        "code_id": "c_group_1_id_463",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_515",
        "query_text": "The function accepts a single floating-point value as input and applies a quart-in easing operation by computing its fourth power. It begins by squaring the input value to produce an intermediate result, and then squares that intermediate result to achieve the final output. The function returns the resulting floating-point value after performing this computation.",
        "code_id": "c_group_1_id_515",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  %xmm0,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_451",
        "query_text": "The function does not accept any parameters and returns an integer value. Its sole operation is to return a predefined constant that signifies that the associated test has been intentionally skipped. The function does not execute any further steps or computations.",
        "code_id": "c_group_1_id_451",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_517",
        "query_text": "The function takes a single floating-point input, which is expected to be in the range of 0 to 1, and applies a smooth quartic easing transition. It first checks whether the input is in the first half (less than 0.5) or the second half (0.5 or greater) of the progression. For inputs below 0.5, it computes an accelerated, quartic-in easing; for inputs of 0.5 or more, it computes a decelerated, quartic-out easing. The function returns a floating-point output\u2014also in the range of 0 to 1\u2014that reflects this symmetric easing effect. Additionally, the logic implicitly clamps the input to ensure a smooth and valid result even if the provided value is outside the expected range.",
        "code_id": "c_group_1_id_517",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x15\n\ncomiss -0x14(%rbp),%xmm0\njbe    0x41\nmovss  -0x14(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x36\n\nmulss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\njmp    0x8a\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x4e\n\nsubss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x8(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x72\n\nmulss  %xmm1,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x86\n\naddss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xdf\ncmpl   $0xffff,-0x8(%rbp)\njne    0xdf\nlea    0x0(%rip),%rax        # 0xb4\nmov    %rax,%rdi\ncall   0xbc\nlea    0x0(%rip),%rax        # 0xc3\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xcd\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xd7\nmov    %rax,%rdi\ncall   0xdf\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x8c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_449",
        "query_text": "The function tests the mechanism for setting dynamic lock callbacks in a cryptographic context. It only performs its actions when a particular macro is defined. Under that condition, the function assigns three types of dynamic lock callbacks\u2014creation, destruction, and locking\u2014by invoking their respective setter functions twice each: once with a null pointer and once with a non-zero integer cast as a function pointer. If the macro is not defined, the function skips its operations and returns a code indicating that the test was not executed. Otherwise, it returns a code representing success. The function takes no input parameters and returns an integer that indicates the outcome of the test.",
        "code_id": "c_group_1_id_449",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_458",
        "query_text": "The function performs a test of a hash algorithm's implementation. It initializes a hashing context, then iteratively updates this context with fixed-size byte array data using varying sizes\u2014including edge cases such as null inputs and zero-length data\u2014and finalizes the hash computation. Throughout the process, it validates error handling and ensures the computed hash matches an expected fixed-size hash value. Additionally, it checks the proper cleanup and deallocation of resources. The procedure returns an integer result that indicates whether the tests passed, failed, or were skipped.",
        "code_id": "c_group_1_id_458",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_446",
        "query_text": "The function takes no explicit input parameters; instead, it utilizes internally defined constants for the encryption key, initialization vector (IV), plaintext, and additional authenticated data. It proceeds through the following steps:\n\n1. Encryption Phase:\n   - Initializes an encryption context for the SM4-GCM algorithm.\n   - Processes the additional authenticated data (AAD) and encrypts the plaintext using the key and IV.\n   - Finalizes the encryption to produce ciphertext and generates an authentication tag for integrity.\n\n2. Decryption Phase:\n   - Initializes a decryption context with the SM4-GCM algorithm.\n   - Uses the same key, IV, and AAD to decrypt the ciphertext.\n   - Verifies the integrity of the decrypted data by applying the authentication tag.\n\n3. Error Handling:\n   - Alters the authentication tag deliberately and attempts decryption again, ensuring the process fails as expected.\n\nThe function returns an integer value indicating the overall result of the performed tests, such as success, failure, or a skipped test. Internal variables include byte arrays for the cryptographic elements (key, IV, plaintext, ciphertext, decrypted text, and tag), various size indicators, and cryptographic context structures for managing encryption and decryption operations.",
        "code_id": "c_group_1_id_446",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_454",
        "query_text": "The function takes no input arguments and returns an integer. It simply returns a constant value that signifies that the associated test is intentionally skipped. The function does not perform any additional operations or computations.",
        "code_id": "c_group_1_id_454",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_489",
        "query_text": "The function takes a boolean value as input and returns that same value without any modifications. The input and output are of type bool.",
        "code_id": "c_group_1_id_489",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x66\ncmpl   $0xffff,-0x8(%rbp)\njne    0x66\nlea    0x0(%rip),%rax        # 0x3b\nmov    %rax,%rdi\ncall   0x43\nlea    0x0(%rip),%rax        # 0x4a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x54\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5e\nmov    %rax,%rdi\ncall   0x66\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x13\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_436",
        "query_text": "The function takes no explicit inputs and returns an integer representing a test outcome. It begins by initializing internal structures for a random number generator and an elliptic curve cryptography key. The function then validates error handling by invoking the key generation routine with invalid (null) parameters and verifying that the expected error codes are returned. Following these checks, it calls the key generation routine with proper inputs to create an SM2 key pair and confirms that the generated key corresponds to the designated SM2 curve. Finally, it frees the allocated resources and returns an integer result indicating whether the test passed, failed, or was skipped.",
        "code_id": "c_group_1_id_436",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_516",
        "query_text": "The function accepts a single floating-point value as an input, typically within the interval [0.0, 1.0], and applies a quartic easing transformation that decelerates smoothly toward the endpoint. Internally, it subtracts one from the input, raises the result to the third power, multiplies it by the complement of the original input, and finally adds one to produce a transformed value. This effect is commonly used in animations or transitions to create a smooth slowdown. The function returns the computed floating-point result without modifying the original input.",
        "code_id": "c_group_1_id_516",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x1a\n\nsubss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x3c\n\nsubss  -0x14(%rbp),%xmm0\nmulss  %xmm0,%xmm1\nmovss  0x0(%rip),%xmm0        # 0x4d\n\naddss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xa6\ncmpl   $0xffff,-0x8(%rbp)\njne    0xa6\nlea    0x0(%rip),%rax        # 0x7b\nmov    %rax,%rdi\ncall   0x83\nlea    0x0(%rip),%rax        # 0x8a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x94\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x9e\nmov    %rax,%rdi\ncall   0xa6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x53\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_461",
        "query_text": "The function takes no input arguments and returns an integer value. It performs a single operation: returning a predefined constant that signifies a test was skipped. No additional computations or operations are performed.",
        "code_id": "c_group_1_id_461",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_441",
        "query_text": "The function performs a test to validate macro behavior under certain compile-time conditions. It begins by evaluating whether any of several preprocessor flags are defined. If at least one is active, the function invokes a macro using a predefined constant string. Upon successful execution of the macro call, it returns a code signifying success; otherwise, it returns a code indicating that the test was skipped. The function takes no input parameters and returns an integer representing the outcome of the test.",
        "code_id": "c_group_1_id_441",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_470",
        "query_text": "This function accepts no input arguments and directly returns a predefined constant (of type int) that signifies a particular test case or operation was skipped. The output is an int representing this status.",
        "code_id": "c_group_1_id_470",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_472",
        "query_text": "The function takes no input arguments and returns an integer value. It serves to indicate that an associated test case is intentionally bypassed. Upon invocation, it simply returns a constant value designated to represent \"skipped,\" without performing any additional operations or computations.",
        "code_id": "c_group_1_id_472",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_457",
        "query_text": "This function returns a fixed integer constant indicating that a particular test has been intentionally skipped. It takes no input arguments and performs no additional processing or computations. The returned value is of type int, serving solely as a marker to bypass the execution of the test scenario.",
        "code_id": "c_group_1_id_457",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_509",
        "query_text": "The function accepts a floating-point value as its input and returns a floating-point number as output. It calculates the output by squaring the input value, thereby implementing a quadratic ease-in effect. This produces a smooth, accelerating progression beginning from zero, with the intensity increasing quadratically as the input value grows.",
        "code_id": "c_group_1_id_509",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  %xmm0,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6b\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6b\nlea    0x0(%rip),%rax        # 0x40\nmov    %rax,%rdi\ncall   0x48\nlea    0x0(%rip),%rax        # 0x4f\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x59\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x63\nmov    %rax,%rdi\ncall   0x6b\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x18\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_455",
        "query_text": "The function takes no input arguments and returns an output of type int. It simply produces a predefined constant value that signifies a skipped test and does not perform any other computations.",
        "code_id": "c_group_1_id_455",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_465",
        "query_text": "This function takes no input arguments and returns an integer value. Its only operation is to immediately return a predefined constant that indicates a specific test is skipped. There is no further computation, processing, or side effects; the function simply serves to signal that the particular test is not executed.",
        "code_id": "c_group_1_id_465",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_493",
        "query_text": "The function accepts two strings as inputs: one provided as a constant reference, representing the source string, and the other as a modifiable reference, representing the destination string. It copies the entire content of the source string into the destination string. The function does not return a value; its purpose is solely to replicate the source content into the destination.",
        "code_id": "c_group_1_id_493",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7d\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdi\ncall   0x5a\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x75\nmov    %rax,%rdi\ncall   0x7d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_464",
        "query_text": "The function does not accept any input arguments and returns an integer value. Its only operation is to return a predefined constant that signifies a particular test was skipped. The output is specifically of type int, and the function performs no other computations.",
        "code_id": "c_group_1_id_464",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_520",
        "query_text": "The function accepts a floating-point input representing a normalized value (typically within the range [0, 1]) used to indicate progress, time, or an interpolation factor. It computes a transformation that simulates a \u201cback-in\u201d easing effect\u2014initiating motion gradually, overshooting the target slightly, and then settling towards the final value. The function returns a float that embodies this modified progress, making it useful for creating smooth animations or transitions. Both the input and output are of type float.",
        "code_id": "c_group_1_id_520",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x15\n\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x27\n\naddss  %xmm1,%xmm0\nmulss  -0x14(%rbp),%xmm0\nsubss  -0x8(%rbp),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmulss  -0x4(%rbp),%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9d\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nlea    0x0(%rip),%rax        # 0x81\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x95\nmov    %rax,%rdi\ncall   0x9d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x4a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_462",
        "query_text": "The function takes no input arguments and returns an integer value. It is a static function that simply returns a predefined constant, which indicates that a particular test or operation has been skipped. No further computations or operations are performed beyond returning this constant value.",
        "code_id": "c_group_1_id_462",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_525",
        "query_text": "This function obtains the unique identifier of the currently executing thread in a platform-independent manner. It takes no input parameters and returns the thread ID as an unsigned size_t value. The implementation conditionally selects the appropriate system call or library function based on the operating system (e.g., Windows, Linux, macOS, BSD variants, etc.), thereby abstracting away platform-specific details to provide a consistent interface for retrieving the thread identifier.",
        "code_id": "c_group_1_id_525",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xba,%edi\nmov    $0x0,%eax\ncall   0x17\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6c\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6c\nlea    0x0(%rip),%rax        # 0x41\nmov    %rax,%rdi\ncall   0x49\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x64\nmov    %rax,%rdi\ncall   0x6c\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x19\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_459",
        "query_text": "The function takes no input arguments and returns an integer that indicates the outcome of a test. It is intended to verify the mechanism for iterating over all available message digest algorithms from a cryptographic library, but only if a specific conditional compilation macro is defined. In that case, it first invokes a utility to display all message digest algorithms by passing a null callback and a standard error stream as parameters. Next, it repeats the invocation using a particular callback function to list the algorithms. If both iterations succeed, the function produces a success status. If the macro is not defined, it returns a status indicating that the test was skipped.",
        "code_id": "c_group_1_id_459",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_474",
        "query_text": "The function takes no input arguments and returns an integer output. Its sole operation is to immediately return a predefined constant that signifies a certain test case is skipped. No additional computations or operations are performed.",
        "code_id": "c_group_1_id_474",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_438",
        "query_text": "The function is a test procedure that returns an integer test result indicating whether the test passed, failed, or was skipped. It operates as follows:\n\n1. Initialization: It sets up an elliptic curve key structure and prepares several input byte arrays, which include a public key, an identifier, and a message. Additionally, it determines the hash algorithm (choosing between two possible types based on compile-time configuration).\n\n2. Error Handling: It deliberately invokes a digest creation routine with various invalid or null inputs\u2014such as null pointers and incorrect buffer sizes\u2014to verify that the routine consistently returns appropriate error codes when supplied with invalid arguments.\n\n3. Digest Creation: It calls the digest creation routine with proper inputs to generate a cryptographic digest (hash). The resulting digest is then compared with a predefined expected hash value to ensure correctness.\n\n4. Cleanup: Any resources allocated during the initialization (such as the elliptic curve structure) are freed before the function returns.\n\nThe overall purpose is to thoroughly test the digest creation functionality under both valid and error conditions, with the function's inputs being byte arrays (for the public key, identifier, and message) plus an enumeration for hash type, and the output being a test result code (integer).",
        "code_id": "c_group_1_id_438",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_442",
        "query_text": "The function takes no input parameters. It initializes a result variable with a value that indicates the test is skipped. Then, when compiled with certain preprocessor flags defined, it invokes a function that removes or resets an error state and updates the result variable to show that the test was successful. Finally, the function returns the result variable. The primary purpose of the function is to test the removal of an error state under specific compilation conditions.",
        "code_id": "c_group_1_id_442",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_466",
        "query_text": "The function accepts no input parameters and returns an integer. Its sole operation is to immediately return a predefined constant that signifies the associated test has been skipped. No additional computations are performed, and the output solely indicates that the test is inactive.",
        "code_id": "c_group_1_id_466",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_518",
        "query_text": "This function takes a floating-point value as its input and returns a floating-point value representing the result of applying a quintic easing-in transformation. It internally computes the square of the input, then multiplies that squared value by itself and by the original input, effectively raising the input to the fifth power. This produces an easing effect where the progression starts slowly and accelerates sharply, yielding a smooth, non-linear transition.",
        "code_id": "c_group_1_id_518",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmulss  -0x14(%rbp),%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7e\nlea    0x0(%rip),%rax        # 0x53\nmov    %rax,%rdi\ncall   0x5b\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x76\nmov    %rax,%rdi\ncall   0x7e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_460",
        "query_text": "The function, which takes no parameters, is conditionally compiled to execute only when a specific macro is defined. Initially, it sets a status variable to indicate that the test has been skipped. Within the conditional block, the function invokes an internal operation several times with various combinations of parameters. These invocations include passing predefined constant types, a callback function pointer, a file stream, and sometimes a NULL value to represent an absent callback or stream. If all the intended calls execute properly, the function updates the status to indicate success. Ultimately, the function returns an integer status value reflecting whether the test was skipped or successfully completed, serving as a black-box test for verifying the behavior of the underlying operation across different scenarios.",
        "code_id": "c_group_1_id_460",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_467",
        "query_text": "The function takes no input arguments and returns an integer value. It simply indicates that a certain test is skipped by returning a predefined constant. The function does not perform any processing or computation; its sole purpose is to signal that the test case is not run by returning an integer constant that represents the skipped status.",
        "code_id": "c_group_1_id_467",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_473",
        "query_text": "This function does not take any input arguments and returns an integer value. Its only operation is to provide a constant result that signifies that a specific test or operation has been skipped. No additional computations or modifications are performed.",
        "code_id": "c_group_1_id_473",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_485",
        "query_text": "The function accepts five inputs: a pointer to an integer, a pointer to a void type, an integer, and two additional pointers to integers. It disregards the second, third, and fifth inputs by casting them to void. The function evaluates whether the value referenced by the first pointer is non-negative. If so, it increments the value referenced by the fourth pointer and returns 1; if not, it returns 0. The output is of type int, reflecting the result of this check.",
        "code_id": "c_group_1_id_485",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x14(%rbp)\nmov    %rcx,-0x20(%rbp)\nmov    %r8,-0x28(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njs     0x3b\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x20(%rbp),%rax\nmov    %edx,(%rax)\nmov    $0x1,%eax\njmp    0x40\nmov    $0x0,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x95\ncmpl   $0xffff,-0x8(%rbp)\njne    0x95\nlea    0x0(%rip),%rax        # 0x6a\nmov    %rax,%rdi\ncall   0x72\nlea    0x0(%rip),%rax        # 0x79\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x83\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8d\nmov    %rax,%rdi\ncall   0x95\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x42\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_440",
        "query_text": "The function takes no input parameters and is designed to test an error queue mechanism in a multi-threaded context. It begins by clearing any existing error state and then creates and starts a number of threads that each perform a logging operation. After initializing the threads, the function waits for all of them to complete their execution. Depending on whether certain preprocessor conditions (such as multi-threading, error queue per thread support, and debug options) are met, the function returns an integer value that indicates either a successful test run or that the test was skipped. The output type is int.",
        "code_id": "c_group_1_id_440",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x3,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x67\ncmpl   $0xffff,-0x8(%rbp)\njne    0x67\nlea    0x0(%rip),%rax        # 0x3c\nmov    %rax,%rdi\ncall   0x44\nlea    0x0(%rip),%rax        # 0x4b\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rdi\ncall   0x67\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x14\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_478",
        "query_text": "The function takes no input arguments and returns an integer value. The returned integer represents a predefined constant that indicates a test case is intentionally skipped. Its primary purpose is to serve as a placeholder or marker for a test that is not executed during the testing process.",
        "code_id": "c_group_1_id_478",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_475",
        "query_text": "The function takes no input arguments and returns an integer value. It simply returns a predefined constant indicating that a test\u2014specifically one related to a DTLS 1.3 configuration using a null cipher\u2014is skipped. No computation or additional processing is performed within the function.",
        "code_id": "c_group_1_id_475",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_522",
        "query_text": "The function takes a single floating-point number as input, which represents a normalized progress value typically ranging from 0 to 1. It computes an eased output value by applying a symmetric easing effect that combines both an initial \"back-in\" motion and a final \"back-out\" motion, creating a smooth transition with slight overshoots at both ends. The function returns the computed floating-point value to be used for animations or interpolations, while implicitly handling inputs outside the standard range.",
        "code_id": "c_group_1_id_522",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x24(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x15\n\nmovss  %xmm0,-0x18(%rbp)\nmovss  -0x18(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x27\n\nmulss  %xmm1,%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x38\n\nmovss  %xmm0,-0x10(%rbp)\nmovss  -0x24(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x4a\n\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x5b\n\ncomiss -0xc(%rbp),%xmm0\njbe    0xa4\nmovss  -0x14(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x6e\n\naddss  %xmm1,%xmm0\nmulss  -0xc(%rbp),%xmm0\nsubss  -0x14(%rbp),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovss  -0x8(%rbp),%xmm1\nmulss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\njmp    0x10a\nmovss  -0xc(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0xb1\n\nsubss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x14(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xc7\n\naddss  %xmm1,%xmm0\nmulss  -0xc(%rbp),%xmm0\nmovss  -0x14(%rbp),%xmm1\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0xc(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0xf7\n\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x4(%rbp),%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x15f\ncmpl   $0xffff,-0x8(%rbp)\njne    0x15f\nlea    0x0(%rip),%rax        # 0x134\nmov    %rax,%rdi\ncall   0x13c\nlea    0x0(%rip),%rax        # 0x143\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x14d\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x157\nmov    %rax,%rdi\ncall   0x15f\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x10c\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_521",
        "query_text": "The function accepts one input of type float and returns a float value. It processes the input by applying an easing transformation that produces a smooth animation effect with a slight overshoot before settling. Essentially, the transformation modifies the input value\u2014assumed to typically lie within the range [0, 1]\u2014to create a more natural motion, where the output may temporarily exceed 1 due to the overshooting. No checks are performed to constrain the input value within any specific bounds.",
        "code_id": "c_group_1_id_521",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x14(%rbp)\nmovss  0x0(%rip),%xmm0        # 0x15\n\nmovss  %xmm0,-0xc(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1        # 0x27\n\nsubss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0xc(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x3d\n\naddss  %xmm1,%xmm0\nmulss  -0x8(%rbp),%xmm0\nmovss  -0xc(%rbp),%xmm1\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0        # 0x6d\n\naddss  %xmm1,%xmm0\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc6\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc6\nlea    0x0(%rip),%rax        # 0x9b\nmov    %rax,%rdi\ncall   0xa3\nlea    0x0(%rip),%rax        # 0xaa\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xb4\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xbe\nmov    %rax,%rdi\ncall   0xc6\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x73\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_503",
        "query_text": "The function takes a constant string reference as its input and copies its content to another string reference provided as the output. It effectively performs a direct assignment, duplicating the input string without modification. The input is a constant string (std::string) and the output is also a string (std::string).",
        "code_id": "c_group_1_id_503",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x27\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7d\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdi\ncall   0x5a\nlea    0x0(%rip),%rax        # 0x61\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x75\nmov    %rax,%rdi\ncall   0x7d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x2a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_469",
        "query_text": "The function takes no input parameters and returns an integer value. Its sole purpose is to immediately return a predefined constant that indicates a test or operation has been skipped. No additional computations or operations are performed.",
        "code_id": "c_group_1_id_469",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_479",
        "query_text": "The function takes no inputs and immediately returns an integer value that corresponds to a predefined constant indicating that a specific test has been skipped. It performs no further operations or computations.",
        "code_id": "c_group_1_id_479",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_482",
        "query_text": "The function processes a string to extract an integer version number based on a specific pattern. It begins by searching for a designated substring within the input. Once the substring is found, the pointer is advanced past the pattern, and, if the subsequent character meets certain conditions, it is moved further by a fixed offset. The function then converts the remaining portion of the string to an integer. If the substring is not found, the function returns a predefined error indicator. The input is a string and the output is an integer.",
        "code_id": "c_group_1_id_482",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmovl   $0xffffffff,-0x14(%rbp)\nlea    0x0(%rip),%rax        # 0x1e\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x35\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\nje     0x6f\naddq   $0x3,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x64,%al\nje     0x5b\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x65,%al\njne    0x60\naddq   $0x2,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x6c\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc7\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc7\nlea    0x0(%rip),%rax        # 0x9c\nmov    %rax,%rdi\ncall   0xa4\nlea    0x0(%rip),%rax        # 0xab\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xb5\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xbf\nmov    %rax,%rdi\ncall   0xc7\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x74\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_476",
        "query_text": "The function takes no inputs and returns an integer value. When invoked, it provides a predefined constant that indicates a specific test case is skipped. Essentially, the function serves as a placeholder to mark that the associated test is intentionally bypassed.",
        "code_id": "c_group_1_id_476",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_484",
        "query_text": "The function takes six parameters: a pointer to an integer, a pointer to a void type, an integer, a pointer to an integer, another integer, and a second pointer to an integer. It explicitly casts all these inputs to void to indicate they are unused. Independently of the provided arguments, the function always returns the integer value 1. The output is of type int.",
        "code_id": "c_group_1_id_484",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x14(%rbp)\nmov    %rcx,-0x20(%rbp)\nmov    %r8d,-0x18(%rbp)\nmov    %r9,-0x28(%rbp)\nmov    $0x1,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x79\ncmpl   $0xffff,-0x8(%rbp)\njne    0x79\nlea    0x0(%rip),%rax        # 0x4e\nmov    %rax,%rdi\ncall   0x56\nlea    0x0(%rip),%rax        # 0x5d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x67\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x71\nmov    %rax,%rdi\ncall   0x79\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x26\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_471",
        "query_text": "The function takes no input arguments and returns a value of type int. It is implemented as a static function whose primary purpose is to indicate that a specific test case has been skipped. Instead of performing any computation or operations, the function directly returns a predetermined constant value that signifies the test was not executed.",
        "code_id": "c_group_1_id_471",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_480",
        "query_text": "The function takes no input parameters and returns no value. It is designated as a static, void-returning function primarily intended to perform setup operations for initializing or configuring a test environment or related resources. However, the current implementation is empty, serving merely as a placeholder for potential future setup functionality.",
        "code_id": "c_group_1_id_480",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_481",
        "query_text": "The function is a static void function that takes no input parameters and returns no value. It conditionally clears accumulated error information within a library by invoking an internal error-clearing routine, but only when specific compilation flags are set. If either of these flags is defined during compilation, the error information is cleared; otherwise, the function performs no operations.",
        "code_id": "c_group_1_id_481",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_191",
        "query_text": "The function takes a floating-point number as input and computes the cumulative probability for a standard normal distribution. It utilizes the complementary error function to determine the probability that a standard normally distributed random variable is less than or equal to the input value, then scales the result to yield the correct CDF value, which is returned as a floating-point number.",
        "code_id": "c_group_1_id_191",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   0x0(%rip),%xmm1        # 0x1e\n\nxorpd  %xmm1,%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x2a\n\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   0x3d\nmovq   %xmm0,%rax\nmovsd  0x0(%rip),%xmm0        # 0x4a\n\nmovq   %rax,%xmm1\ndivsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb2\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb2\nlea    0x0(%rip),%rax        # 0x87\nmov    %rax,%rdi\ncall   0x8f\nlea    0x0(%rip),%rax        # 0x96\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa0\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xaa\nmov    %rax,%rdi\ncall   0xb2\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x5f\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_189",
        "query_text": "The function takes a C-style string and a size limit (of type std::size_t) as inputs. It computes the string's length up to the given limit, stopping if a null terminator is encountered. If the null terminator is found before reaching the limit, the function returns the number of characters before it; otherwise, it returns the specified size limit. The output is of type std::size_t, representing the computed length.",
        "code_id": "c_group_1_id_189",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovb   $0x0,-0x11(%rbp)\nlea    -0x11(%rbp),%rdx\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x3e\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\nje     0x53\nmov    -0x10(%rbp),%rax\nsub    -0x28(%rbp),%rax\njmp    0x57\nmov    -0x30(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x6b\ncall   0x6b\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xc0\ncmpl   $0xffff,-0x8(%rbp)\njne    0xc0\nlea    0x0(%rip),%rax        # 0x95\nmov    %rax,%rdi\ncall   0x9d\nlea    0x0(%rip),%rax        # 0xa4\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xae\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb8\nmov    %rax,%rdi\ncall   0xc0\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x6d\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    0x26\nmov    $0x0,%eax\njmp    0x65\nmov    $0x0,%eax\ntest   %al,%al\nje     0x48\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x46\njmp    0x65\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%ecx\nmov    -0x10(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   0x64\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nsete   %al\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovq   $0x0,-0x8(%rbp)\n\njmp    0x52\nmov    -0x18(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   0x3c\ntest   %al,%al\nje     0x4d\nmov    -0x18(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\njmp    0x61\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     0x22\nmov    $0x0,%eax\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_468",
        "query_text": "The function takes no input arguments and returns an integer value. It performs no computations aside from returning a predefined constant that denotes a skipped test or operation.",
        "code_id": "c_group_1_id_468",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_190",
        "query_text": "The function is an inline function that takes no input arguments and returns no output values. It embeds an inline assembly instruction that serves as a compiler memory barrier, informing the compiler that the memory state may have changed. The embedded assembly code prevents the compiler from optimizing or reordering memory operations across the barrier. Its primary purpose is to enforce memory consistency and ensure that memory accesses are performed in the intended order.",
        "code_id": "c_group_1_id_190",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x5e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x5e\nlea    0x0(%rip),%rax        # 0x33\nmov    %rax,%rdi\ncall   0x3b\nlea    0x0(%rip),%rax        # 0x42\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x4c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x56\nmov    %rax,%rdi\ncall   0x5e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xb\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_483",
        "query_text": "The function accepts a pointer to a time value and returns a time value. If the pointer is not NULL, it sets the time value at the pointed memory location to 99. Regardless of whether the pointer is NULL or not, the function always returns 99.",
        "code_id": "c_group_1_id_483",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     0x1e\nmov    -0x8(%rbp),%rax\nmovq   $0x63,(%rax)\nmov    $0x63,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x78\ncmpl   $0xffff,-0x8(%rbp)\njne    0x78\nlea    0x0(%rip),%rax        # 0x4d\nmov    %rax,%rdi\ncall   0x55\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x66\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x70\nmov    %rax,%rdi\ncall   0x78\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x25\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_193",
        "query_text": "The function takes a single input character and returns a transformed character that is its lowercase equivalent. It first casts the input to an unsigned character to ensure proper processing by the standard library's lowercase conversion function, then converts the result back to a character before returning it.",
        "code_id": "c_group_1_id_193",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   0x1f\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x74\ncmpl   $0xffff,-0x8(%rbp)\njne    0x74\nlea    0x0(%rip),%rax        # 0x49\nmov    %rax,%rdi\ncall   0x51\nlea    0x0(%rip),%rax        # 0x58\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x62\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x6c\nmov    %rax,%rdi\ncall   0x74\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x21\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_477",
        "query_text": "The function takes no input parameters and returns an integer value. It indicates that a specific DTLS over IPv6 test is skipped by immediately returning a predefined constant that represents a skipped state. The output is an integer signaling that the test is not executed.",
        "code_id": "c_group_1_id_477",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0x3,%eax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x62\ncmpl   $0xffff,-0x8(%rbp)\njne    0x62\nlea    0x0(%rip),%rax        # 0x37\nmov    %rax,%rdi\ncall   0x3f\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x50\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x5a\nmov    %rax,%rdi\ncall   0x62\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0xf\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_246",
        "query_text": "The function takes no input parameters and returns a 64-bit unsigned integer. It begins by retrieving the current system time using a high-resolution clock. This time point is then interpreted as the duration elapsed since the epoch (typically January 1, 1970) and converted into a nanosecond count, which is finally returned as the output.",
        "code_id": "c_group_1_id_246",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\ncall   0x20\nmov    %rax,-0x20(%rbp)\nlea    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   0x30\nmov    %rax,-0x18(%rbp)\nlea    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   0x40\nmov    %rax,-0x10(%rbp)\nlea    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   0x50\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x64\ncall   0x64\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xb9\ncmpl   $0xffff,-0x8(%rbp)\njne    0xb9\nlea    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdi\ncall   0x96\nlea    0x0(%rip),%rax        # 0x9d\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xa7\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xb1\nmov    %rax,%rdi\ncall   0xb9\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x66\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %fs:0x28,%rax\n\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   0x2b\nmov    %rax,-0x18(%rbp)\nlea    -0x18(%rbp),%rdx\nlea    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   0x42\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n\nje     0x5a\ncall   0x5a\nleave  \nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_245",
        "query_text": "SUMMARY:  \nThe function takes a modifiable string as its input and processes it in place. It iteratively scans the string for a specific two-character substring (composed of two colons) and, upon finding it, replaces that occurrence with a single dot character. The search continues from just after each replacement until no further occurrences are detected. The input is of type std::string, and the function modifies it directly without returning a new string.",
        "code_id": "c_group_1_id_245",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    $0x0,%edx\nlea    0x0(%rip),%rcx        # 0x20\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x2b\nmov    %rax,-0x8(%rbp)\njmp    0x73\nmov    -0x8(%rbp),%rsi\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rdx        # 0x40\nmov    %rdx,%rcx\nmov    $0x2,%edx\nmov    %rax,%rdi\ncall   0x50\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nlea    0x0(%rip),%rcx        # 0x64\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   0x6f\nmov    %rax,-0x8(%rbp)\ncmpq   $0xffffffffffffffff,-0x8(%rbp)\njne    0x31\nnop\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0xd1\ncmpl   $0xffff,-0x8(%rbp)\njne    0xd1\nlea    0x0(%rip),%rax        # 0xa6\nmov    %rax,%rdi\ncall   0xae\nlea    0x0(%rip),%rax        # 0xb5\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0xbf\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0xc9\nmov    %rax,%rdi\ncall   0xd1\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x7e\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_255",
        "query_text": "The function takes two inputs. The first is a pointer to a block of memory, and the second is an integer value representing the size in bytes of that block. The function initializes the entire block by setting every byte to zero. It achieves this by either invoking a standard library function to fill the memory with zeros (if a certain macro is defined) or by manually iterating over each byte in the block to set it to zero. The function does not return any value.",
        "code_id": "c_group_1_id_255",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    0x29\nmov    -0x8(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x8(%rbp)\nmovb   $0x0,(%rax)\nmov    -0x20(%rbp),%rax\nlea    -0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\ntest   %rax,%rax\nsetne  %al\ntest   %al,%al\njne    0x1a\nnop\nnop\npop    %rbp\nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x96\ncmpl   $0xffff,-0x8(%rbp)\njne    0x96\nlea    0x0(%rip),%rax        # 0x6b\nmov    %rax,%rdi\ncall   0x73\nlea    0x0(%rip),%rax        # 0x7a\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x84\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x8e\nmov    %rax,%rdi\ncall   0x96\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x43\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_506",
        "query_text": "The function takes a single integer input that represents a file descriptor. It then determines whether this descriptor is associated with a terminal device by calling a standard library function. The function immediately returns a result that is non-zero if the descriptor refers to a terminal, or zero if it does not.",
        "code_id": "c_group_1_id_506",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   0x19\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x6e\ncmpl   $0xffff,-0x8(%rbp)\njne    0x6e\nlea    0x0(%rip),%rax        # 0x43\nmov    %rax,%rdi\ncall   0x4b\nlea    0x0(%rip),%rax        # 0x52\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5c\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x66\nmov    %rax,%rdi\ncall   0x6e\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1b\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_192",
        "query_text": "The function takes a single double-precision floating-point input and returns a double-precision floating-point result. It computes the inverse of the error function by employing a piecewise polynomial approximation. First, it calculates an intermediate value using the negative logarithm of the product of (1 minus the input) and (1 plus the input). Based on the magnitude of this computed value, the function branches into one of three cases, each applying a different polynomial expression with predetermined coefficients. In the first case when the intermediate value is below a certain threshold, it adjusts the value and evaluates the corresponding polynomial. In the next case, if the value falls between two thresholds, it computes a square root-based adjustment before applying another set of coefficients. In the final case, for the largest values, it again uses a square root-based transformation followed by its own distinct polynomial evaluation. The output is then obtained by scaling the polynomial result with the original input value, yielding the inverse error function output.",
        "code_id": "c_group_1_id_192",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  0x0(%rip),%xmm0        # 0x19\n\nmovapd %xmm0,%xmm1\nsubsd  -0x18(%rbp),%xmm1\nmovsd  -0x18(%rbp),%xmm2\nmovsd  0x0(%rip),%xmm0        # 0x2f\n\naddsd  %xmm2,%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   0x46\nmovq   %xmm0,%rax\nmovq   0x0(%rip),%xmm0        # 0x53\n\nmovq   %rax,%xmm3\nxorpd  %xmm0,%xmm3\nmovapd %xmm3,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  0x0(%rip),%xmm0        # 0x6d\n\ncomisd -0x8(%rbp),%xmm0\njbe    0x31a\nmovsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x85\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  0x0(%rip),%xmm0        # 0x96\n\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0xad\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0xcc\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0xeb\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x106\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x125\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x144\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x15f\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x17a\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x199\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x1b4\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x1cf\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x1ee\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x209\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x224\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x243\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x25e\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x279\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x298\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x2b3\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x2ce\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x2ed\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x30c\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\njmp    0x784\nmovsd  0x0(%rip),%xmm0        # 0x322\n\ncomisd -0x8(%rbp),%xmm0\njbe    0x57e\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   0x33b\nmovq   %xmm0,%rax\nmovsd  0x0(%rip),%xmm1        # 0x348\n\nmovq   %rax,%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  0x0(%rip),%xmm0        # 0x35e\n\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x379\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x394\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x3b3\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x3d2\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x3ed\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x40c\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x42b\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x446\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x465\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x484\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x49f\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x4be\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x4d9\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x4f8\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x513\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x532\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x551\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x570\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\njmp    0x784\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   0x58c\nmovq   %xmm0,%rax\nmovsd  0x0(%rip),%xmm1        # 0x599\n\nmovq   %rax,%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  0x0(%rip),%xmm0        # 0x5af\n\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x5c6\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x5e5\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x600\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x61f\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x63a\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x659\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x674\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x693\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x6ae\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x6cd\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x6e8\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x707\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x722\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1        # 0x73d\n\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x75c\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0        # 0x77b\n\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x7ed\ncmpl   $0xffff,-0x8(%rbp)\njne    0x7ed\nlea    0x0(%rip),%rax        # 0x7c2\nmov    %rax,%rdi\ncall   0x7ca\nlea    0x0(%rip),%rax        # 0x7d1\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x7db\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x7e5\nmov    %rax,%rdi\ncall   0x7ed\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x79a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_523",
        "query_text": "The function accepts an error description as a string input (represented as a constant character pointer). It then prints this error message\u2014supplemented by the corresponding system error description if available\u2014to the standard error stream. Following this, the function terminates the program execution with a failure status and does not return any value. Although some behavior may differ slightly depending on platform-specific configurations or compiler attributes, the primary functionality remains consistent. The input is of type const char*, and there is no output since the function exits the program (void).",
        "code_id": "c_group_1_id_523",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\ncall   0x15\nmov    (%rax),%eax\nmov    %eax,%edi\ncall   0x1e\nmov    %rax,%rcx\nmov    0x0(%rip),%rax        # 0x28\nmov    -0x8(%rbp),%rdx\nlea    0x0(%rip),%rsi        # 0x33\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   0x40\nmov    $0x1,%edi\ncall   0x4a\nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x9d\ncmpl   $0xffff,-0x8(%rbp)\njne    0x9d\nlea    0x0(%rip),%rax        # 0x72\nmov    %rax,%rdi\ncall   0x7a\nlea    0x0(%rip),%rax        # 0x81\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x8b\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x95\nmov    %rax,%rdi\ncall   0x9d\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x4a\npop    %rbp\nret    ",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_337",
        "query_text": "The function accepts a single parameter: a pointer to a constant character string representing the name of an environment variable. It retrieves the corresponding value for that environment variable from the system using the standard runtime library, and returns a pointer to a constant character string containing the value. If the specified environment variable is not found, the function returns a null pointer. Its primary purpose is to access the environment variable's value based on its name.",
        "code_id": "c_group_1_id_337",
        "code_text": "endbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   0x1c\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    0x71\ncmpl   $0xffff,-0x8(%rbp)\njne    0x71\nlea    0x0(%rip),%rax        # 0x46\nmov    %rax,%rdi\ncall   0x4e\nlea    0x0(%rip),%rax        # 0x55\nmov    %rax,%rdx\nlea    0x0(%rip),%rax        # 0x5f\nmov    %rax,%rsi\nmov    0x0(%rip),%rax        # 0x69\nmov    %rax,%rdi\ncall   0x71\nnop\nleave  \nret    \nendbr64 \npush   %rbp\nmov    %rsp,%rbp\nmov    $0xffff,%esi\nmov    $0x1,%edi\ncall   0x1e\npop    %rbp\nret    ",
        "relevance": 2
    }
]