[
    {
        "query_id": "q_group_1_id_0",
        "query_text": "The function receives a constant reference to a string as input. It checks whether the input string is equal to one of several predefined representations that denote an infinity value. Specifically, the function determines if the string matches any of the designated patterns (such as those beginning with an optional plus sign followed by \".inf\" in various cases). If a match is found, it returns a boolean true; otherwise, it returns false. The input is of type std::string, and the output is a bool.",
        "code_id": "c_group_1_id_0",
        "code_text": "inline bool IsInfinity(const std::string& input) {\n  return input == \".inf\" || input == \".Inf\" || input == \".INF\" ||\n         input == \"+.inf\" || input == \"+.Inf\" || input == \"+.INF\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_1",
        "query_text": "The function accepts a constant character string as its sole input and immediately returns the integer value 0. It does not perform any operations or checks on the input; instead, the parameter is explicitly cast to void to indicate that it is unused. The input type is a pointer to a constant character, and the output type is an integer.",
        "code_id": "c_group_1_id_1",
        "code_text": "static FT_INLINE int ft_check_if_string_helper(const char *str)\n{\n    (void)str;\n    return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_2",
        "query_text": "The function takes a wide character string as input and immediately returns the integer 0. It does not perform any operations on the input string.",
        "code_id": "c_group_1_id_2",
        "code_text": "static FT_INLINE int ft_check_if_wstring_helper(const wchar_t *str)\n{\n    (void)str;\n    return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_3",
        "query_text": "The function accepts a boolean input and immediately returns that identical boolean value. It performs no additional processing or transformation, effectively serving as a simple pass-through.",
        "code_id": "c_group_1_id_3",
        "code_text": "bool IsTrue(bool condition) { return condition; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_4",
        "query_text": "This function is intended to write output to the standard error stream. It accepts no input parameters and does not return any value. However, its current implementation features an empty body, so it does not perform any logging or output operations.",
        "code_id": "c_group_1_id_4",
        "code_text": "inline void LogToStderr() {}\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_5",
        "query_text": "This function accepts a file pointer as input and returns the file's size in bytes as an unsigned integer type. It determines the size by repositioning the stream's pointer to the end of the file and then retrieving the current pointer position, which corresponds to the file size.",
        "code_id": "c_group_1_id_5",
        "code_text": "size_t GetFileSize(FILE* file) {\n  fseek(file, 0, SEEK_END);\n  return static_cast<size_t>(ftell(file));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_6",
        "query_text": "The function accepts a file pointer (of type FILE*) as input and returns an integer (of type int) that identifies the corresponding file descriptor. This integer is a unique identifier assigned by the operating system to the open file. Implemented as an inline function, it expands directly at the call site for enhanced efficiency.",
        "code_id": "c_group_1_id_6",
        "code_text": "inline int FileNo(FILE* file) { return fileno(file); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_7",
        "query_text": "The function accepts an integer representing a file descriptor and determines whether it is associated with a terminal device. It returns a non-zero integer if the file descriptor is connected to a terminal and zero otherwise. The function serves as a lightweight wrapper around an underlying system call that performs this check.",
        "code_id": "c_group_1_id_7",
        "code_text": "inline int IsATTY(int fd) { return isatty(fd); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_8",
        "query_text": "The function takes two input parameters, both of which are pointers to constant characters (C-style strings). It compares the two strings in a case-insensitive manner using an internal library function. If the strings are identical in a case-insensitive comparison, it returns 0; if the first string is lexicographically greater, it returns a positive value; and if it is lexicographically smaller, it returns a negative value. The input parameters are two pointers to constant characters, and the output is an integer representing the comparison result.",
        "code_id": "c_group_1_id_8",
        "code_text": "inline int StrCaseCmp(const char* s1, const char* s2) {\n  return strcasecmp(s1, s2);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_9",
        "query_text": "The function takes a constant character pointer as input (representing a C-style null-terminated string) and uses a standard library routine to create a duplicate of that string. It returns a pointer to the newly allocated duplicate, and the caller is responsible for freeing the allocated memory to prevent memory leaks.",
        "code_id": "c_group_1_id_9",
        "code_text": "inline char* StrDup(const char* src) { return strdup(src); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_10",
        "query_text": "The function accepts a single character string input that specifies a directory path. Its role is to delete the specified directory by calling the underlying system removal operation. After attempting the deletion, it returns an integer where a value of 0 indicates that the directory was removed successfully, while any non-zero value signals an error occurred during the operation.",
        "code_id": "c_group_1_id_10",
        "code_text": "inline int RmDir(const char* dir) { return rmdir(dir); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_11",
        "query_text": "The function accepts a single input, a string (type const char*), representing a directory path. It then passes this string to a system-level operation to update the program's current working directory to the specified location. The function returns an integer that indicates the outcome of this change: 0 signifies a successful update, while a non-zero value indicates an error occurred.",
        "code_id": "c_group_1_id_11",
        "code_text": "inline int ChDir(const char* dir) { return chdir(dir); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_12",
        "query_text": "This function reopens an existing file stream using a new file path and mode. It takes three parameters: a constant string representing the file path, a constant string defining the mode for opening the file, and a pointer to a file stream. Internally, it utilizes a standard C library call that reassigns the provided stream to the new file specified by the input path and mode. The function returns a pointer to the updated file stream\u2014if the underlying library call fails, it returns a null pointer.",
        "code_id": "c_group_1_id_12",
        "code_text": "inline FILE *FReopen(const char* path, const char* mode, FILE* stream) {\n  return freopen(path, mode, stream);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_13",
        "query_text": "The function takes two inputs: an integer representing a file descriptor and a string indicating the file mode. It returns a pointer to a file stream object, which allows the use of standard file operations on the opened file. Internally, it associates the given file descriptor with a file stream by invoking a system library routine designed for this purpose.",
        "code_id": "c_group_1_id_13",
        "code_text": "inline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_14",
        "query_text": "The function accepts a pointer to a file stream (of type FILE*), and it returns an integer. It closes the file stream by invoking the standard library's function for closing file streams. The returned integer indicates whether the operation was successful (with 0 denoting success and any non-zero value indicating failure).",
        "code_id": "c_group_1_id_14",
        "code_text": "inline int FClose(FILE* fp) { return fclose(fp); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_15",
        "query_text": "The function receives three inputs. The first input is an integer representing a file descriptor. The second input is a pointer to a buffer (of type const void*), and the third input is an unsigned integer that indicates the number of bytes to write. It acts as a wrapper around a system call to write the data from the buffer to the file associated with the file descriptor. The function returns an integer representing the number of bytes successfully written, or -1 if an error occurs.",
        "code_id": "c_group_1_id_15",
        "code_text": "inline int Write(int fd, const void* buf, unsigned int count) {\n  return static_cast<int>(write(fd, buf, count));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_16",
        "query_text": "The function accepts an integer representing a file descriptor associated with an open resource and returns an integer indicating the result of the closure operation. It operates as a simple wrapper around the system call that performs the actual closing. A return value of 0 signifies a successful closure, while a return value of -1 indicates a failure.",
        "code_id": "c_group_1_id_16",
        "code_text": "inline int Close(int fd) { return close(fd); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_17",
        "query_text": "The function takes an integer input that represents an error code and returns a string describing the associated error. The function internally serves as a wrapper for the standard library function that converts error codes into their corresponding error messages. The input is of type int, and the output is a pointer to a constant character string (const char*).",
        "code_id": "c_group_1_id_17",
        "code_text": "inline const char* StrError(int errnum) { return strerror(errnum); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_18",
        "query_text": "The function takes no input parameters and returns no value (void). It is an inline function that, when called, immediately terminates the program by invoking the standard library routine to abort execution, resulting in abnormal termination.",
        "code_id": "c_group_1_id_18",
        "code_text": "inline void Abort() { abort(); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_19",
        "query_text": "This function converts the content of a string stream into a standard string. It processes each character from the string stream one at a time and checks whether it is a null character. If a null character is detected, it appends the escape sequence \"\\0\" to the output string; all other characters are directly copied. The function also reserves extra capacity in the output string to accommodate the potential increase in size due to the replacement of null characters. The input is a pointer to a string stream, and the output is a standard string containing the transformed content.",
        "code_id": "c_group_1_id_19",
        "code_text": "std::string StringStreamToString(::std::stringstream* ss) {\n  const ::std::string& str = ss->str();\n  const char* const start = str.c_str();\n  const char* const end = start + str.length();\n\n  std::string result;\n  result.reserve(2 * (end - start));\n  for (const char* ch = start; ch != end; ++ch) {\n    if (*ch == '\\0') {\n      result += \"\\\\0\";  \n    } else {\n      result += *ch;\n    }\n  }\n\n  return result;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_20",
        "query_text": "The function accepts a C-style string as input. It searches the string for the first occurrence of a comma and returns a std::string containing the characters from the beginning of the string up to, but not including, that comma. If the comma is not found, it returns the entire input string as a std::string. The input is of type const char*, and the output is of type std::string.",
        "code_id": "c_group_1_id_20",
        "code_text": "inline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  return comma == NULL ? str : std::string(str, comma);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_21",
        "query_text": "The function takes a boolean input and writes its corresponding string representation (\"true\" or \"false\") to an output stream. It employs a conditional operator to determine the appropriate string based on the input value, and then outputs this string to a stream of type std::ostream. The function does not return any value.",
        "code_id": "c_group_1_id_21",
        "code_text": "inline void PrintTo(bool x, ::std::ostream* os) {\n  *os << (x ? \"true\" : \"false\");\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_22",
        "query_text": "The function accepts a single input of type string. It first checks if the string is enclosed in double quotes and, if so, ignores the outermost quotes. The function then examines the string for escaped characters, particularly looking for the sequence representing an escaped newline (a backslash followed by the character 'n'). Each time such an escaped newline is found, the function splits the string at that point. Finally, it returns a vector of strings containing the substrings obtained by splitting the input string, with the escaped newline delimiters removed.",
        "code_id": "c_group_1_id_22",
        "code_text": "std::vector<std::string> SplitEscapedString(const std::string& str) {\n  std::vector<std::string> lines;\n  size_t start = 0, end = str.size();\n  if (end > 2 && str[0] == '\"' && str[end - 1] == '\"') {\n    ++start;\n    --end;\n  }\n  bool escaped = false;\n  for (size_t i = start; i + 1 < end; ++i) {\n    if (escaped) {\n      escaped = false;\n      if (str[i] == 'n') {\n        lines.push_back(str.substr(start, i - start - 1));\n        start = i + 1;\n      }\n    } else {\n      escaped = str[i] == '\\\\';\n    }\n  }\n  lines.push_back(str.substr(start, end - start));\n  return lines;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_23",
        "query_text": "The function receives two inputs, each of type const wchar_t* (wide-character strings). It first checks if either string is NULL and, if so, returns a bool value that is true only when both inputs are NULL. If neither input is NULL, the function uses a standard library routine to determine whether the first string is a substring of the second. It then returns true if the substring is found, and false otherwise.",
        "code_id": "c_group_1_id_23",
        "code_text": "bool IsSubstringPred(const wchar_t* needle, const wchar_t* haystack) {\n  if (needle == NULL || haystack == NULL)\n    return needle == haystack;\n\n  return wcsstr(haystack, needle) != NULL;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_24",
        "query_text": "The function takes an input of type int, where the value determines the number of space characters. It then returns a std::string that consists precisely of that many spaces.",
        "code_id": "c_group_1_id_24",
        "code_text": "static inline std::string Indent(int width) {\n  return std::string(width, ' ');\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_25",
        "query_text": "The function accepts two inputs: a pointer to a null-terminated constant character array and an integer specifying the maximum number of characters allowed in the output. It processes the string by printing it on a single line to the standard output. During this process, any newline characters found within the string are substituted with the literal characters \"\\\" followed by \"n\". If the count of printed characters reaches the specified maximum length before the entire string is processed, the function stops printing further characters and appends an ellipsis (\"...\") to indicate that the string has been truncated. The function does not produce a return value and its primary role is to output a processed version of the input string directly to the standard output.",
        "code_id": "c_group_1_id_25",
        "code_text": "static void PrintOnOneLine(const char* str, int max_length) {\n  if (str != NULL) {\n    for (int i = 0; *str != '\\0'; ++str) {\n      if (i >= max_length) {\n        printf(\"...\");\n        break;\n      }\n      if (*str == '\\n') {\n        printf(\"\\\\n\");\n        i += 2;\n      } else {\n        printf(\"%c\", *str);\n        ++i;\n      }\n    }\n  }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_26",
        "query_text": "The function takes a wide character (wchar_t) as input and returns a boolean value. It checks whether the input character is a printable ASCII character by verifying if its value lies within the range of 0x20 to 0x7E. If the character falls within this range, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_26",
        "code_text": "inline bool IsPrintableAscii(wchar_t c) {\n  return 0x20 <= c && c <= 0x7E;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_27",
        "query_text": "The function accepts an 8-bit unsigned integer as input and returns a boolean value. It checks if the provided value is between 0x80 and 0xbf (inclusive). If the value satisfies this condition, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_27",
        "code_text": "bool IsUTF8TrailByte(unsigned char t) { return 0x80 <= t && t<= 0xbf; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_28",
        "query_text": "This function takes no input parameters and returns a reference to a stream used for standard output operations. Specifically, the output is an object of type std::ostream that enables printing messages to the console.",
        "code_id": "c_group_1_id_28",
        "code_text": "std::ostream& cout() { return std::cout; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_29",
        "query_text": "This function retrieves the standard error output stream by returning a reference to the underlying error stream object. It does not require any input arguments and outputs a reference to an object of type std::ostream. This returned stream is generally used for printing error messages or diagnostic information during program execution.",
        "code_id": "c_group_1_id_29",
        "code_text": "std::ostream& cerr() { return std::cerr; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_30",
        "query_text": "The function returns a reference to the program\u2019s standard logging stream. It takes no input parameters and outputs an object of type std::ostream that is used for logging and diagnostic messages. This function essentially provides access to the global logging utility in C++ programs by wrapping the standard logging stream.",
        "code_id": "c_group_1_id_30",
        "code_text": "std::ostream& clog() { return std::clog; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_31",
        "query_text": "The function takes no input arguments. It retrieves the current system time with high precision by utilizing a high-resolution clock, then computes the elapsed time in nanoseconds since the Unix epoch (typically January 1, 1970). Finally, it returns the resulting value as a 64-bit unsigned integer representing the nanoseconds count.",
        "code_id": "c_group_1_id_31",
        "code_text": "auto getCurrentNanosecondsSinceEpoch() -> uint64_t {\n        return std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_32",
        "query_text": "The function accepts three parameters: a reference to a modifiable string and two constant strings representing the target substring and the replacement substring, respectively. It scans the string for occurrences of the target substring and replaces each found instance with the replacement substring, modifying the string in-place. The function returns a boolean value\u2014true if at least one replacement was made and false if none were found.",
        "code_id": "c_group_1_id_32",
        "code_text": "bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {\n        bool replaced = false;\n        std::size_t i = str.find( replaceThis );\n        while( i != std::string::npos ) {\n            replaced = true;\n            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );\n            if( i < str.size()-withThis.size() )\n                i = str.find( replaceThis, i+withThis.size() );\n            else\n                i = std::string::npos;\n        }\n        return replaced;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_33",
        "query_text": "The function takes a single input\u2014a character of type char. It then checks whether this character is a member of a specific set of symbols, which includes closing brackets, punctuation marks, and various mathematical operators. If the character is found within the set, the function returns a boolean value of true; otherwise, it returns false.",
        "code_id": "c_group_1_id_33",
        "code_text": "inline auto isBreakableAfter(char c) -> bool {\n\tstatic std::string chars = \"])}>.,:;*+-=&/\\\\\";\n\treturn chars.find(c) != std::string::npos;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_34",
        "query_text": "The function accepts a string input provided as a constant reference and returns a string. On Windows platforms, if the first character of the input string is a forward slash ('/'), it returns a modified string where the initial forward slash is replaced with a hyphen ('-'). For non-Windows platforms or if the input string does not start with a forward slash, it returns the original string unchanged.",
        "code_id": "c_group_1_id_34",
        "code_text": "inline auto normaliseOpt( std::string const &optName ) -> std::string {\n#ifdef CATCH_PLATFORM_WINDOWS\n        if( optName[0] == '/' )\n            return \"-\" + optName.substr( 1 );\n        else\n#endif\n            return optName;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_35",
        "query_text": "The function takes no input and returns a boolean value. It determines whether color output should be enabled by verifying environmental conditions. Specifically, on certain platforms such as macOS or iOS, it checks that a debugger is not active. It also verifies that the standard output is connected to a terminal (using an isatty-like check), unless the platform enforces strict ANSI compliance (as in some DJGPP environments). If these conditions are not met, the function returns false, indicating that color output should not be used.",
        "code_id": "c_group_1_id_35",
        "code_text": "bool useColourOnPlatform() {\n        return\n#if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)\n            !isDebuggerActive() &&\n#endif\n#if defined( CATCH_INTERNAL_HAS_ISATTY ) && \\\n    !( defined( __DJGPP__ ) && defined( __STRICT_ANSI__ ) )\n            isatty(STDOUT_FILENO)\n#else\n            false\n#endif\n            ;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_36",
        "query_text": "The function takes a single floating-point value as input and returns a 32-bit integer as its output. It operates by directly copying the binary representation of the input float into the memory space of a 32-bit integer. This technique ensures that the integer holds exactly the same bit pattern as the original floating-point value, without performing any arithmetic conversion. An internal check confirms that the size of the floating-point type matches the size of the 32-bit integer type, as required by the implementation.",
        "code_id": "c_group_1_id_36",
        "code_text": "int32_t convert(float f) {\n        static_assert(sizeof(float) == sizeof(int32_t), \"Important ULP matcher assumption violated\");\n        int32_t i;\n        std::memcpy(&i, &f, sizeof(f));\n        return i;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_37",
        "query_text": "The function accepts a double-precision floating-point value as input and returns a 64-bit integer. It performs the conversion by directly copying the binary representation of the floating-point value into a 64-bit integer variable, effectively reinterpreting the bits without modifying them. The function also enforces an assumption that the size of the floating-point type is equal to the size of the 64-bit integer type.",
        "code_id": "c_group_1_id_37",
        "code_text": "int64_t convert(double d) {\n        static_assert(sizeof(double) == sizeof(int64_t), \"Important ULP matcher assumption violated\");\n        int64_t i;\n        std::memcpy(&i, &d, sizeof(d));\n        return i;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_38",
        "query_text": "The function takes no input arguments and returns a boolean value indicating whether there are any uncaught exceptions in the current execution context. It adapts its behavior based on the compilation environment and configuration: if exception support is disabled, it always returns false; if compiled with C++17 support and the appropriate configuration is defined, it uses a standard library function to check if the number of uncaught exceptions is greater than zero; otherwise, it employs another standard library function to determine the presence of any uncaught exception.",
        "code_id": "c_group_1_id_38",
        "code_text": "bool uncaught_exceptions() {\n#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)\n        return false;\n#elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)\n        return std::uncaught_exceptions() > 0;\n#else\n        return std::uncaught_exception();\n#endif\n  }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_39",
        "query_text": "The function accepts a reference to an output stream and an unsigned character as input. It formats the unsigned character into a hexadecimal escape sequence, outputting the literal \"\\x\" followed by the two-digit uppercase hexadecimal representation of the character. After writing the formatted output, the function restores the original state of the output stream\u2019s formatting flags to prevent side effects on any subsequent output operations. The input is an output stream and an unsigned character, while the output consists of the hexadecimal escape sequence written to the provided stream.",
        "code_id": "c_group_1_id_39",
        "code_text": "void hexEscapeChar(std::ostream& os, unsigned char c) {\n        std::ios_base::fmtflags f(os.flags());\n        os << \"\\\\x\"\n            << std::uppercase << std::hex << std::setfill('0') << std::setw(2)\n            << static_cast<int>(c);\n        os.flags(f);\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_40",
        "query_text": "The function takes no input arguments and returns a fixed, immutable string literal. Specifically, it outputs a pointer to a constant character array containing a predefined failure message. No modifications can be made to this string, and the primary purpose of the function is to provide a standard error indicator.",
        "code_id": "c_group_1_id_40",
        "code_text": "const char* failedString() { return \"failed\"; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_41",
        "query_text": "The function accepts no input arguments and returns a constant string literal. Its return type is a pointer to constant characters (const char*), ensuring that the returned string cannot be altered. The function\u2019s primary purpose is to provide a fixed immutable string without performing any additional operations.",
        "code_id": "c_group_1_id_41",
        "code_text": "const char* passedString() { return \"passed\"; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_42",
        "query_text": "The function accepts two unsigned integer inputs representing a part and a whole. It begins by checking whether the whole is nonzero; if it is, the function scales the part by a predefined constant and divides the product by the whole to compute a ratio. If the whole is zero, the function avoids division by zero by immediately returning zero. Additionally, if the computed ratio is zero even though the part is nonzero, the function adjusts the result to be at least one. The final output is an unsigned integer representing the computed, scaled ratio.",
        "code_id": "c_group_1_id_42",
        "code_text": "std::size_t makeRatio(std::size_t number, std::size_t total) {\n    std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;\n    return (ratio == 0 && number > 0) ? 1 : ratio;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_43",
        "query_text": "The function accepts three input parameters, each being a reference to an unsigned integer, and it determines which of these values is the largest. It performs comparisons among the three inputs: if the first value exceeds both the second and third, it returns a reference to the first; if not, it checks whether the second value is greater than the third and returns a reference to the second if true; otherwise, it returns a reference to the third value. The function does not modify any of the input values but provides direct access to the maximum value via the returned reference.",
        "code_id": "c_group_1_id_43",
        "code_text": "std::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {\n    if (i > j && i > k)\n        return i;\n    else if (j > k)\n        return j;\n    else\n        return k;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_44",
        "query_text": "The function generates and returns a string that represents the current date and time formatted according to the ISO 8601 standard in UTC. It accepts no input parameters and outputs a string. Internally, it obtains the current system time, converts it to Coordinated Universal Time (UTC), and then formats it into a character array following the pattern \"YYYY-MM-DDTHH:MM:SSZ\". The implementation also manages platform-specific differences in time retrieval and formatting to ensure consistent behavior across various environments.",
        "code_id": "c_group_1_id_44",
        "code_text": "std::string getCurrentTimestamp() {\n            \n            \n            time_t rawtime;\n            std::time(&rawtime);\n            auto const timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n\n#ifdef _MSC_VER\n            std::tm timeInfo = {};\n            gmtime_s(&timeInfo, &rawtime);\n#else\n            std::tm* timeInfo;\n            timeInfo = std::gmtime(&rawtime);\n#endif\n\n            char timeStamp[timeStampSize];\n            const char * const fmt = \"%Y-%m-%dT%H:%M:%SZ\";\n\n#ifdef _MSC_VER\n            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\n#else\n            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\n#endif\n            return std::string(timeStamp, timeStampSize-1);\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_45",
        "query_text": "The function accepts a constant reference to a vector of strings and returns a string. It iterates over the vector to locate the first element that begins with the '#' character. If such an element is identified, the function extracts a substring from this element starting from the second character and returns it. If none of the strings in the vector satisfy the condition, the function returns an empty string.",
        "code_id": "c_group_1_id_45",
        "code_text": "std::string fileNameTag(const std::vector<std::string> &tags) {\n            auto it = std::find_if(begin(tags),\n                                   end(tags),\n                                   [] (std::string const& tag) {return tag.front() == '#'; });\n            if (it != tags.end())\n                return it->substr(1);\n            return std::string();\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_46",
        "query_text": "The function accepts an unsigned 64-bit integer as its sole parameter. It calculates and returns an integer that represents the number of consecutive zero bits starting from the least significant bit of the input's binary representation. Note that if the input is zero, the behavior is undefined.",
        "code_id": "c_group_1_id_46",
        "code_text": "static inline int cbitset_trailing_zeroes(unsigned long long input_num) { return __builtin_ctzll(input_num); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_47",
        "query_text": "The function accepts three inputs: a string representing a file name, an integer representing a line number, and another string representing an error message. It prints a formatted error message to the standard error stream that includes the file name, line number, and error message, and then terminates the program by invoking an abort function. The function does not return any value.",
        "code_id": "c_group_1_id_47",
        "code_text": "void assert_fail(const char* file, int line, const char* message) {\n  \n  \n  fprintf(stderr, \"%s:%d: assertion failed: %s\", file, line, message);\n  abort();\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_48",
        "query_text": "The function takes no input arguments. It evaluates the system's byte order to determine if it is big-endian. Depending on the platform, the function uses a combination of predefined macros and a runtime check. On one platform, it directly returns false, assuming little-endian ordering; on others, it first checks for compile-time macros that indicate big-endian order, and if they are not available, it performs a runtime check by examining the byte representation of a numeric value. Ultimately, the function returns a boolean value: true if the system is big-endian, and false otherwise.",
        "code_id": "c_group_1_id_48",
        "code_text": "inline auto is_big_endian() -> bool {\n#ifdef _WIN32\n  return false;\n#elif defined(__BIG_ENDIAN__)\n  return true;\n#elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__)\n  return __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__;\n#else\n  struct bytes {\n    char data[sizeof(int)];\n  };\n  return bit_cast<bytes>(1).data[0] == 0;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_49",
        "query_text": "The function receives an unsigned 32-bit integer (of type uint32_t) and returns an integer representing the number of digits in the input. It calculates this digit count by employing a precomputed table alongside bitwise operations to avoid explicitly iterating through each digit. The design emphasizes performance by leveraging built-in compiler optimizations.",
        "code_id": "c_group_1_id_49",
        "code_text": "FMT_INLINE auto do_count_digits(uint32_t n) -> int {\n\n\n#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)\n  static constexpr uint64_t table[] = {\n      FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           \n      FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          \n      FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         \n      FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        \n      FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       \n      FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      \n      FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     \n      FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    \n      FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   \n      FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  \n      FMT_INC(1000000000), FMT_INC(1000000000)                        \n  };\n  auto inc = table[FMT_BUILTIN_CLZ(n | 1) ^ 31];\n  return static_cast<int>((n + inc) >> 32);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_50",
        "query_text": "The function takes two inputs, both of type unsigned. It modifies the first input in place by appending the second value using bitwise operations. Specifically, if the first input is non-zero, the second input is shifted left by 8 bits before being combined; otherwise, it is appended as is. Additionally, the function increments a counter stored in the higher bits of the first input. This counter is increased by a base value of 1, with an extra increment if the second input exceeds a certain threshold. The final result is an updated unsigned integer that reflects both the appended value and the incremented counter.",
        "code_id": "c_group_1_id_50",
        "code_text": "inline void prefix_append(unsigned& prefix, unsigned value) {\n  prefix |= prefix != 0 ? value << 8 : value;\n  prefix += (1u + (value > 0xff ? 1 : 0)) << 24;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_51",
        "query_text": "The function takes an integer as input and returns a 32-bit unsigned integer. It uses the input value as an index to retrieve a corresponding element from a fixed array of eight predefined 32-bit unsigned integer values that are encoded within Unicode string literals. The function essentially acts as a lookup table, returning the element associated with the provided index.",
        "code_id": "c_group_1_id_51",
        "code_text": "constexpr auto fractional_part_rounding_thresholds(int index) -> uint32_t {\n  \n  \n  \n  \n  \n  \n  return U\"\\x9999999a\\x828f5c29\\x80418938\\x80068db9\\x8000a7c6\\x800010c7\"\n         U\"\\x800001ae\\x8000002b\"[index];\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_52",
        "query_text": "The function accepts two 32-bit unsigned integers. The first is treated as the value to be rotated, and the second as the number of positions to rotate that value to the right. Initially, it ensures that the rotation count is within the valid range (0 to 31) by applying a mask. The function then shifts the input value to the right by the specified count and combines it with the value shifted to the left by the complement (32 minus the rotation count). Ultimately, it returns a 32-bit unsigned integer that represents the value after the rotation operation.",
        "code_id": "c_group_1_id_52",
        "code_text": "inline auto rotr(uint32_t n, uint32_t r) noexcept -> uint32_t {\n  r &= 31;\n  return (n >> r) | (n << (32 - r));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_53",
        "query_text": "The function accepts two inputs: the first is a 32-bit unsigned integer and the second is a 64-bit unsigned integer. It multiplies these values together and returns the lower 64 bits of the resultant product as a 64-bit unsigned integer. The implementation is optimized for performance, being defined as inline and marked as noexcept, ensuring that it does not throw exceptions.",
        "code_id": "c_group_1_id_53",
        "code_text": "inline auto umul96_lower64(uint32_t x, uint64_t y) noexcept -> uint64_t {\n  return x * y;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_54",
        "query_text": "The function accepts a 32-bit unsigned integer as input. It first converts the input to a 64-bit value to ensure accuracy during the ensuing arithmetic operation. It then multiplies this value by a predetermined constant (1374389535) and subsequently shifts the result to the right by 37 bits. Finally, the result is cast back to a 32-bit unsigned integer and returned. This sequence of operations is designed to be efficient and is implemented in a way that guarantees no exceptions are thrown.",
        "code_id": "c_group_1_id_54",
        "code_text": "inline auto divide_by_10_to_kappa_plus_1(uint32_t n) noexcept -> uint32_t {\n  \n  return static_cast<uint32_t>((static_cast<uint64_t>(n) * 1374389535) >> 37);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_55",
        "query_text": "The function accepts an integer input representing a month index and returns a string containing the full name of that month. Internally, it uses a static lookup table that maps indices 0 through 11 to month names (from January to December). If the input is outside this valid range, the function returns a placeholder string, \"?\". The function is designed to take an input type of int and output a pointer to a constant character array (const char*).",
        "code_id": "c_group_1_id_55",
        "code_text": "inline auto tm_mon_full_name(int mon) -> const char* {\n  static constexpr const char* full_name_list[] = {\n      \"January\", \"February\", \"March\",     \"April\",   \"May\",      \"June\",\n      \"July\",    \"August\",   \"September\", \"October\", \"November\", \"December\"};\n  return mon >= 0 && mon <= 11 ? full_name_list[mon] : \"?\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_56",
        "query_text": "The function takes an unsigned 32-bit integer, interpreted as a non-negative exponent, and returns a 64-bit signed integer representing 10 raised to that exponent. It employs recursion by checking if the input is zero\u2014in which case it returns 1\u2014and otherwise recursively calls itself with the exponent decremented by 1, multiplying the outcome by 10. The primary purpose of the function is to compute the power of 10 for the given exponent efficiently using recursive calls.",
        "code_id": "c_group_1_id_56",
        "code_text": "constexpr auto pow10(std::uint32_t n) -> long long {\n  return n == 0 ? 1 : 10 * pow10(n - 1);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_57",
        "query_text": "The function takes no input parameters and returns a boolean value. It is implemented as a constexpr function that always returns the constant value true. Its primary purpose is to serve as an indicator that the functionality is deprecated, with a suggestion to use an alternative implementation instead. This function does not involve any complex operations or computations.",
        "code_id": "c_group_1_id_57",
        "code_text": "GTEST_INTERNAL_DEPRECATED(\n    \"INSTANTIATE_TEST_CASE_P is deprecated, please use \"\n    \"INSTANTIATE_TEST_SUITE_P\")\nconstexpr bool InstantiateTestCase_P_IsDeprecated() { return true; }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_58",
        "query_text": "The function takes no input parameters and returns a boolean value. It is declared as a constant expression function (constexpr), allowing its return value to be determined at compile time. The constant output is the boolean value true, which serves as a marker to signal that a particular feature is deprecated.",
        "code_id": "c_group_1_id_58",
        "code_text": "GTEST_INTERNAL_DEPRECATED(\n    \"TYPED_TEST_CASE_P is deprecated, please use \"\n    \"TYPED_TEST_SUITE_P\")\nconstexpr bool TypedTestCase_P_IsDeprecated() { return true; }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_59",
        "query_text": "The function accepts a single parameter\u2014a 16-bit character value\u2014and returns a constant pointer to a null-terminated string. Regardless of the input value, it consistently returns the string \"u\". The function performs no additional operations or conditional logic, making its behavior invariant to the provided input.",
        "code_id": "c_group_1_id_59",
        "code_text": "static const char* GetCharWidthPrefix(char16_t) {\n  return \"u\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_60",
        "query_text": "The function takes two double-precision floating-point numbers as input and returns a double-precision floating-point number as output. It computes the next representable value after the first input, moving in the direction indicated by the second input. Essentially, it provides the minimal increment or decrement from the first value toward the second value, following the precision rules of double-precision arithmetic.",
        "code_id": "c_group_1_id_60",
        "code_text": "double nextafter(double x, double y) {\n        return ::nextafter(x, y);\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_61",
        "query_text": "The function takes one input: a floating-point value representing an angle in degrees. It computes the equivalent angle in radians by multiplying the input by the constant factor \u03c0/180. The function then returns the calculated floating-point value, performing the unit conversion directly on the provided argument.",
        "code_id": "c_group_1_id_61",
        "code_text": "CGLM_INLINE\nfloat\nglm_rad(float deg) {\n  return deg * GLM_PIf / 180.0f;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_62",
        "query_text": "The function takes two integer inputs. It compares these values and, if the first integer is less than the second, returns the first; otherwise, it returns the second integer. The function\u2019s return type is an integer.",
        "code_id": "c_group_1_id_62",
        "code_text": "CGLM_INLINE\nint\nglm_imin(int a, int b) {\n  if (a < b)\n    return a;\n  return b;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_63",
        "query_text": "The function accepts two inputs: an array of unsigned character pointers and a size parameter of type size_t. It processes the array by scanning through consecutive pairs of pointers and evaluates three possible issues. First, it counts how many consecutive pairs are identical. Second, it checks for pairs where at least one pointer is NULL. Third, for pairs where both pointers are valid, it compares the strings they reference and counts how many pairs are not in ascending order. If any of these conditions are met, the function outputs warning messages to the standard error stream that detail the number of identical pointers, invalid pointers, and incorrectly ordered pairs. Finally, the function returns an integer value\u2014returning 1 if any of the issues are detected, otherwise returning 0.",
        "code_id": "c_group_1_id_63",
        "code_text": "static inline int\ncheck_result(unsigned char **strings, size_t n)\n{\n\tsize_t wrong = 0;\n\tsize_t identical = 0;\n\tsize_t invalid = 0;\n\tfor (size_t i=0; i < n-1; ++i) {\n\t\tif (strings[i] == strings[i+1])\n\t\t\t++identical;\n\t\tif (strings[i]==NULL || strings[i+1]==NULL)\n\t\t\t++invalid;\n\t\telse if (strcmp((char*)strings[i], (char*)strings[i+1]) > 0)\n\t\t\t++wrong;\n\t}\n\tif (identical)\n\t\tfprintf(stderr,\n\t\t\t\"WARNING: found %zu identical pointers!\\n\",\n\t\t\tidentical);\n\tif (wrong)\n\t\tfprintf(stderr,\n\t\t\t\"WARNING: found %zu incorrect orderings!\\n\",\n\t\t\twrong);\n\tif (invalid)\n\t\tfprintf(stderr,\n\t\t\t\"WARNING: found %zu invalid pointers!\\n\",\n\t\t\tinvalid);\n\tif (identical || wrong || invalid)\n\t\treturn 1;\n\treturn 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_64",
        "query_text": "The function takes two 16-bit unsigned integers as input and returns an unsigned integer as output. It first verifies through an assertion that the two input values are not equal. It then isolates the higher 8 bits of each input value by applying a bitmask. The function checks if these isolated higher 8 bits are equal and non-zero; if both conditions are met, it returns 1, otherwise it returns 0.",
        "code_id": "c_group_1_id_64",
        "code_text": "static inline unsigned lcp(uint16_t a, uint16_t b)\n{\n\tassert(a != b);\n\tunsigned A, B;\n\tA = 0xFF00 & a;\n\tB = 0xFF00 & b;\n\tif (A==0 or A!=B) return 0;\n\treturn 1;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_65",
        "query_text": "The function takes no input arguments and returns a double-precision floating-point value. It uses a standard library function to generate a random integer, then scales and converts this value to produce a number in the inclusive range from 1 to 100. The input is absent, and the output is of type double.",
        "code_id": "c_group_1_id_65",
        "code_text": "double generate_rnd() {\n\tdouble rnd;\n\n\trnd = (double) (rand() % 100 + 1);\n\n\treturn rnd;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_66",
        "query_text": "This function receives two arrays of doubles representing approximation and detail coefficients, two filter arrays (one low-pass and one high-pass), and several integer parameters defining the lengths of the coefficient and filter arrays as well as input and output stride values. It reconstructs the original signal by iterating over a calculated range and computing paired output values at each step. For each iteration, the function applies the filter coefficients to a subset of the approximation and detail arrays, multiplying the values accordingly and summing them into two output positions while accounting for the provided strides. The function also handles boundary conditions by wrapping around the coefficient arrays when necessary. The resulting reconstructed signal is written directly into the output array without returning any value.",
        "code_id": "c_group_1_id_66",
        "code_text": "void idwt_per_stride(double *cA, int len_cA, double *cD, double *lpr, double *hpr, int lpr_len, double *X, int istride, int ostride) {\n\tint len_avg, i, l, m, n, t, l2;\n\tint is, ms, ns;\n\n\tlen_avg = lpr_len;\n\tl2 = len_avg / 2;\n\tm = -2;\n\tn = -1;\n\n\tfor (i = 0; i < len_cA + l2 - 1; ++i) {\n\t\tm += 2;\n\t\tn += 2;\n\t\tms = m * ostride;\n\t\tns = n * ostride;\n\t\tX[ms] = 0.0;\n\t\tX[ns] = 0.0;\n\t\tfor (l = 0; l < l2; ++l) {\n\t\t\tt = 2 * l;\n\t\t\tif ((i - l) >= 0 && (i - l) < len_cA) {\n\t\t\t\tis = (i - l) * istride;\n\t\t\t\tX[ms] += lpr[t] * cA[is] + hpr[t] * cD[is];\n\t\t\t\tX[ns] += lpr[t + 1] * cA[is] + hpr[t + 1] * cD[is];\n\t\t\t}\n\t\t\telse if ((i - l) >= len_cA && (i - l) < len_cA + len_avg - 1) {\n\t\t\t\tis = (i - l - len_cA) * istride;\n\t\t\t\tX[ms] += lpr[t] * cA[is] + hpr[t] * cD[is];\n\t\t\t\tX[ns] += lpr[t + 1] * cA[is] + hpr[t + 1] * cD[is];\n\t\t\t}\n\t\t\telse if ((i - l) < 0 && (i - l) > -l2) {\n\t\t\t\tis = (len_cA + i - l) * istride;\n\t\t\t\tX[ms] += lpr[t] * cA[is] + hpr[t] * cD[is];\n\t\t\t\tX[ns] += lpr[t + 1] * cA[is] + hpr[t + 1] * cD[is];\n\t\t\t}\n\t\t}\n\t}\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_67",
        "query_text": "The function takes three inputs: a pointer to a double array, an integer indicating the length of that array, and an additional integer that controls processing behavior. If the integer is negative, the function returns an error code (-1). When the integer is zero, the function directly copies the input array into an output double array and returns the original length. For a positive integer, the function performs an upsampling process on the input array by inserting zeros between its elements\u2014the number of inserted zeros is determined by the integer parameter. The function then returns the length of the newly constructed, upsampled output array. The inputs are a double pointer and two integers, and the output consists of a double array along with an integer representing its length (or an error code).",
        "code_id": "c_group_1_id_67",
        "code_text": "int upsamp(double *x, int lenx, int M, double *y) {\n\tint N, i, j, k;\n\n\tif (M < 0) {\n\t\treturn -1;\n\t}\n\n\tif (M == 0) {\n\t\tfor (i = 0; i < lenx; ++i) {\n\t\t\ty[i] = x[i];\n\t\t}\n\t\treturn lenx;\n\t}\n\n\tN = M * (lenx - 1) + 1;\n\tj = 1;\n\tk = 0;\n\n\tfor (i = 0; i < N; ++i) {\n\t\tj--;\n\t\ty[i] = 0.0;\n\t\tif (j == 0) {\n\t\t\ty[i] = x[k];\n\t\t\tk++;\n\t\t\tj = M;\n\t\t}\n\t}\n\n\treturn N;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_68",
        "query_text": "The function takes a string as input and iterates through each character to determine if it is not a UTF-8 continuation byte. For each character that is not a continuation byte, the function increments a counter. Once all characters are processed, it returns the total count, which represents the number of glyphs (logical characters) in the string. The input is of type std::string, and the output is of type std::string::size_type.",
        "code_id": "c_group_1_id_68",
        "code_text": "inline std::string::size_type Glyphs(const std::string &string_)\n    {\n        std::string::size_type length = 0;\n        for (const char c: string_)\n        {\n            if ((c & 0xc0) != 0x80)\n            {\n                ++length;\n            }\n        }\n        return length;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_69",
        "query_text": "The function takes two unsigned integers as input and returns an unsigned integer. It extracts the lower 4 bits from the first input, shifts them left by 6 positions, and combines them with the lower 6 bits of the second input using a bitwise OR operation. This process produces a single unsigned integer that merges the relevant bits from both inputs.",
        "code_id": "c_group_1_id_69",
        "code_text": "inline STRF_HD unsigned utf8_decode_first_2_of_3(unsigned ch0, unsigned ch1)\n{\n    return static_cast<unsigned>(((ch0 & 0x0F) << 6) | (ch1 & 0x3F));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_70",
        "query_text": "The function accepts an integer as its input and determines whether the provided value is greater than or equal to zero. It returns a boolean value: if the input is non-negative, the function produces true; otherwise, it produces false. This behavior can be evaluated at compile time due to its constexpr designation. The input is of type int, and the output is of type bool.",
        "code_id": "c_group_1_id_70",
        "code_text": "constexpr STRF_HD bool precision_is_set(int precision)\n{\n    return precision >= 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_71",
        "query_text": "The function takes no input arguments and performs a compile-time check to determine whether two specific preprocessor macros are defined. If both macros are present, the function returns an integer value indicating success; otherwise, it returns an integer value indicating that the test was skipped.",
        "code_id": "c_group_1_id_71",
        "code_text": "static int test_wolfSSL_EVP_EncodeFinal(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_BASE64_ENCODE)\n    \n    res = TEST_SUCCESS;\n#endif \n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_72",
        "query_text": "The function takes no explicit input. It is a test routine that validates the proper initialization, configuration, and cleanup of a cryptographic algorithm implementation. It first verifies that the algorithm\u2019s context initialization properly handles invalid parameters by expecting specific error codes, and then confirms a successful initialization under valid conditions. If encryption modes (such as ECB, CBC, CTR, or CCM) are enabled, the function proceeds to test key configuration by invoking the key-setting routine with both valid data and a variety of invalid scenarios\u2014including null pointers, incorrect key sizes, and other improper parameters\u2014to ensure robust error handling. For modes that require an initialization vector, the function similarly tests setting the IV, checking for proper error responses on invalid inputs and success when given valid data. Finally, the routine cleans up any allocated resources and returns an integer value that indicates the overall success or failure of these tests.",
        "code_id": "c_group_1_id_72",
        "code_text": "static int test_wc_Sm4(void)\n{\n    int res = TEST_SKIPPED;\n#ifdef WOLFSSL_SM4\n    EXPECT_DECLS;\n    wc_Sm4 sm4;\n#if defined(WOLFSSL_SM4_ECB) || defined(WOLFSSL_SM4_CBC) || \\\n    defined(WOLFSSL_SM4_CTR) || defined(WOLFSSL_SM4_CCM)\n    unsigned char key[SM4_KEY_SIZE];\n#endif\n#if defined(WOLFSSL_SM4_CBC) || defined(WOLFSSL_SM4_CTR)\n    unsigned char iv[SM4_IV_SIZE];\n#endif\n\n    \n    ExpectIntEQ(wc_Sm4Init(NULL, NULL, INVALID_DEVID), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_Sm4Init(&sm4, NULL, INVALID_DEVID), 0);\n\n#if defined(WOLFSSL_SM4_ECB) || defined(WOLFSSL_SM4_CBC) || \\\n    defined(WOLFSSL_SM4_CTR) || defined(WOLFSSL_SM4_CCM)\n    XMEMSET(key, 0, sizeof(key));\n\n    \n    ExpectIntEQ(wc_Sm4SetKey(NULL, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4SetKey(&sm4, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4SetKey(NULL, key, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4SetKey(NULL, NULL, SM4_KEY_SIZE), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4SetKey(&sm4, key, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4SetKey(&sm4, NULL, SM4_KEY_SIZE), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4SetKey(NULL, key, SM4_KEY_SIZE), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4SetKey(&sm4, key, SM4_KEY_SIZE-1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4SetKey(&sm4, key, SM4_KEY_SIZE+1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_Sm4SetKey(&sm4, key, SM4_KEY_SIZE), 0);\n#endif\n\n#if defined(WOLFSSL_SM4_CBC) || defined(WOLFSSL_SM4_CTR)\n    XMEMSET(iv, 0, sizeof(iv));\n\n    \n    ExpectIntEQ(wc_Sm4SetIV(NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4SetIV(&sm4, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4SetIV(NULL, iv), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_Sm4SetIV(&sm4, iv), 0);\n#endif\n\n    \n    wc_Sm4Free(NULL);\n    wc_Sm4Free(&sm4);\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_73",
        "query_text": "The function is designed to perform a series of tests on an encryption algorithm operating in Electronic Codebook mode. It begins by initializing an encryption context and setting a key, then proceeds to evaluate correct responses when invalid arguments (such as null pointers) are supplied. The function also performs encryption and decryption on provided data buffers, including in-place operations, and compares resulting outputs to verify consistency across multiple calls. It covers various edge cases, including operations with differing data lengths, to ensure that both encryption and decryption behave as expected. Finally, the function returns a value indicating whether the tests passed, failed, or were skipped.",
        "code_id": "c_group_1_id_73",
        "code_text": "static int test_wc_Sm4Ecb(void)\n{\n    int res = TEST_SKIPPED;\n#ifdef WOLFSSL_SM4_ECB\n    EXPECT_DECLS;\n    wc_Sm4 sm4;\n    unsigned char key[SM4_KEY_SIZE];\n    unsigned char in[SM4_BLOCK_SIZE * 2];\n    unsigned char out[SM4_BLOCK_SIZE * 2];\n    unsigned char out2[SM4_BLOCK_SIZE];\n\n    XMEMSET(key, 0, sizeof(key));\n    XMEMSET(in, 0, sizeof(in));\n\n    ExpectIntEQ(wc_Sm4Init(&sm4, NULL, INVALID_DEVID), 0);\n    ExpectIntEQ(wc_Sm4EcbEncrypt(&sm4, out, in, 0), WC_NO_ERR_TRACE(MISSING_KEY));\n    ExpectIntEQ(wc_Sm4EcbDecrypt(&sm4, out, in, 0), WC_NO_ERR_TRACE(MISSING_KEY));\n\n    \n    ExpectIntEQ(wc_Sm4SetKey(&sm4, key, SM4_KEY_SIZE), 0);\n\n    \n    ExpectIntEQ(wc_Sm4EcbEncrypt(NULL, NULL, NULL, 1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbEncrypt(&sm4, NULL, NULL, 1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbEncrypt(NULL, out, NULL, 1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbEncrypt(NULL, NULL, in, 1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbEncrypt(NULL, NULL, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbEncrypt(NULL, out, in, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbEncrypt(&sm4, NULL, in, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbEncrypt(&sm4, out, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbEncrypt(&sm4, out, in, 1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_Sm4EcbEncrypt(&sm4, out, in, 0), 0);\n    ExpectIntEQ(wc_Sm4EcbEncrypt(&sm4, out2, in, SM4_BLOCK_SIZE), 0);\n    ExpectIntEQ(wc_Sm4EcbEncrypt(&sm4, out, in, SM4_BLOCK_SIZE * 2), 0);\n    ExpectIntEQ(XMEMCMP(out, out2, SM4_BLOCK_SIZE), 0);\n    \n    ExpectIntEQ(wc_Sm4EcbEncrypt(&sm4, in, in, SM4_BLOCK_SIZE * 2), 0);\n    ExpectIntEQ(XMEMCMP(in, out, SM4_BLOCK_SIZE * 2), 0);\n\n    \n    ExpectIntEQ(wc_Sm4EcbDecrypt(NULL, NULL, NULL, 1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbDecrypt(&sm4, NULL, NULL, 1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbDecrypt(NULL, out, NULL, 1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbDecrypt(NULL, NULL, in, 1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbDecrypt(NULL, NULL, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbDecrypt(NULL, out, in, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbDecrypt(&sm4, NULL, in, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbDecrypt(&sm4, out, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4EcbDecrypt(&sm4, out, in, 1), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_Sm4EcbDecrypt(&sm4, out, in, 0), 0);\n    ExpectIntEQ(wc_Sm4EcbDecrypt(&sm4, out2, in, SM4_BLOCK_SIZE), 0);\n    ExpectIntEQ(wc_Sm4EcbDecrypt(&sm4, out, in, SM4_BLOCK_SIZE * 2), 0);\n    ExpectIntEQ(XMEMCMP(out, out2, SM4_BLOCK_SIZE), 0);\n    \n    ExpectIntEQ(wc_Sm4EcbDecrypt(&sm4, in, in, SM4_BLOCK_SIZE * 2), 0);\n    ExpectIntEQ(XMEMCMP(in, out, SM4_BLOCK_SIZE * 2), 0);\n\n    wc_Sm4Free(&sm4);\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_74",
        "query_text": "The function performs a series of tests to validate a block cipher\u2019s encryption and decryption routines using Galois/Counter Mode (GCM). It starts by initializing an encryption context and setting up necessary buffers for keys, nonces, plaintext/ciphertext, additional authenticated data (AAD), and authentication tags. The test sequence first checks for proper error handling by calling the encryption and decryption routines with various invalid arguments (such as null pointers, incorrect key sizes, unsuitable nonce lengths, and improperly sized authentication tags). It then proceeds to verify that valid inputs produce consistent outcomes by encrypting a data block and subsequently decrypting it to recover the original data. The function also examines edge cases including empty inputs, single and multiple data blocks, and large buffers. Throughout the tests, comparisons are made between expected and actual outputs to ensure that both encryption and decryption behave correctly under different scenarios. Finally, a status result is returned to indicate whether the tests passed, failed, or were skipped.",
        "code_id": "c_group_1_id_74",
        "code_text": "static int test_wc_Sm4Gcm(void)\n{\n    int res = TEST_SKIPPED;\n#ifdef WOLFSSL_SM4_GCM\n    EXPECT_DECLS;\n    wc_Sm4 sm4;\n    unsigned char key[SM4_KEY_SIZE];\n    unsigned char nonce[GCM_NONCE_MAX_SZ];\n    unsigned char in[SM4_BLOCK_SIZE * 2];\n    unsigned char in2[SM4_BLOCK_SIZE * 2];\n    unsigned char out[SM4_BLOCK_SIZE * 2];\n    unsigned char out2[SM4_BLOCK_SIZE * 2];\n    unsigned char dec[SM4_BLOCK_SIZE * 2];\n    unsigned char tag[SM4_BLOCK_SIZE];\n    unsigned char aad[SM4_BLOCK_SIZE * 2];\n    word32 i;\n\n    XMEMSET(key, 0, sizeof(key));\n    XMEMSET(nonce, 0, sizeof(nonce));\n    XMEMSET(in, 0, sizeof(in));\n    XMEMSET(in2, 0, sizeof(in2));\n    XMEMSET(aad, 0, sizeof(aad));\n\n    ExpectIntEQ(wc_Sm4Init(&sm4, NULL, INVALID_DEVID), 0);\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, 0, nonce, GCM_NONCE_MID_SZ, tag,\n        SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(MISSING_KEY));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, out, in, 0, nonce, GCM_NONCE_MID_SZ, tag,\n        SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(MISSING_KEY));\n\n    \n    ExpectIntEQ(wc_Sm4GcmSetKey(NULL, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmSetKey(&sm4, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmSetKey(NULL, key, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmSetKey(NULL, NULL, SM4_KEY_SIZE), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmSetKey(&sm4, key, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmSetKey(&sm4, NULL, SM4_KEY_SIZE), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmSetKey(NULL, key, SM4_KEY_SIZE), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_Sm4GcmSetKey(&sm4, key, SM4_KEY_SIZE), 0);\n\n    \n    ExpectIntEQ(wc_Sm4GcmEncrypt(NULL, NULL, NULL, 1, NULL, 0, NULL, 0, NULL,\n        0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, NULL, NULL, 1, NULL, 0, NULL, 0, NULL,\n        0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(NULL, out, NULL, 1, NULL, 0, NULL, 0, NULL,\n        0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(NULL, NULL, in, 1, NULL, 0, NULL, 0, NULL,\n        0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(NULL, NULL, NULL, 1, nonce, GCM_NONCE_MID_SZ,\n        NULL, 0, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(NULL, NULL, NULL, 1, NULL, 0, tag,\n        SM4_BLOCK_SIZE, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(NULL, out, in, 1, nonce, GCM_NONCE_MID_SZ, tag,\n        SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, NULL, in, 1, nonce, GCM_NONCE_MID_SZ,\n        tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, NULL, 1, nonce, GCM_NONCE_MID_SZ,\n        tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, 1, NULL, GCM_NONCE_MID_SZ, tag,\n        SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, 1, nonce, 0, tag,\n        SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, 1, nonce, GCM_NONCE_MID_SZ,\n        NULL, SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, 1, nonce, GCM_NONCE_MID_SZ, tag,\n        WOLFSSL_MIN_AUTH_TAG_SZ-1, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, 1, nonce, GCM_NONCE_MID_SZ, tag,\n        SM4_BLOCK_SIZE+1, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_Sm4GcmDecrypt(NULL, NULL, NULL, 1, NULL, 0, NULL, 0, NULL,\n        0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, NULL, NULL, 1, NULL, 0, NULL, 0, NULL,\n        0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(NULL, out, NULL, 1, NULL, 0, NULL, 0, NULL,\n        0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(NULL, NULL, in, 1, NULL, 0, NULL, 0, NULL,\n        0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(NULL, NULL, NULL, 1, nonce, GCM_NONCE_MID_SZ,\n        NULL, 0, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(NULL, NULL, NULL, 1, NULL, 0, tag,\n        SM4_BLOCK_SIZE, NULL, 0), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(NULL, out, in, 1, nonce, GCM_NONCE_MID_SZ, tag,\n        SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, NULL, in, 1, nonce, GCM_NONCE_MID_SZ,\n        tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, out, NULL, 1, nonce, GCM_NONCE_MID_SZ,\n        tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, out, in, 1, NULL, GCM_NONCE_MID_SZ, tag,\n        SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, out, in, 1, nonce, 0, tag,\n        SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, out, in, 1, nonce, GCM_NONCE_MID_SZ,\n        NULL, SM4_BLOCK_SIZE, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, out, in, 1, nonce, GCM_NONCE_MID_SZ, tag,\n        WOLFSSL_MIN_AUTH_TAG_SZ-1, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, out, in, 1, nonce, GCM_NONCE_MID_SZ, tag,\n        SM4_BLOCK_SIZE+1, aad, sizeof(aad)), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, NULL, NULL, 0, nonce, GCM_NONCE_MID_SZ,\n        tag, SM4_BLOCK_SIZE, NULL, 0), 0);\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, NULL, NULL, 0, nonce, GCM_NONCE_MID_SZ,\n        tag, SM4_BLOCK_SIZE, NULL, 0), 0);\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, NULL, NULL, 0, nonce, GCM_NONCE_MID_SZ,\n        tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, NULL, NULL, 0, nonce, GCM_NONCE_MID_SZ,\n        tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, SM4_BLOCK_SIZE, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, NULL, 0), 0);\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, in, out, SM4_BLOCK_SIZE, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, NULL, 0), 0);\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, SM4_BLOCK_SIZE, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, NULL, 1), 0);\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, in, out, SM4_BLOCK_SIZE, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, NULL, 1), 0);\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, SM4_BLOCK_SIZE * 2, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, in, out, SM4_BLOCK_SIZE * 2, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, in2, in2, SM4_BLOCK_SIZE * 2, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n    ExpectIntEQ(XMEMCMP(in2, out, SM4_BLOCK_SIZE * 2), 0);\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, in2, in2, SM4_BLOCK_SIZE * 2, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n    ExpectIntEQ(XMEMCMP(in2, in, SM4_BLOCK_SIZE * 2), 0);\n\n    \n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, SM4_BLOCK_SIZE, nonce,\n        GCM_NONCE_MAX_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, in, out, SM4_BLOCK_SIZE, nonce,\n        GCM_NONCE_MAX_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, SM4_BLOCK_SIZE * 2, nonce,\n        GCM_NONCE_MIN_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, in, out, SM4_BLOCK_SIZE * 2, nonce,\n        GCM_NONCE_MIN_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, in, out, SM4_BLOCK_SIZE * 2, nonce,\n        GCM_NONCE_MAX_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)),\n        WC_NO_ERR_TRACE(SM4_GCM_AUTH_E));\n\n    \n    for (i = WOLFSSL_MIN_AUTH_TAG_SZ; i < SM4_BLOCK_SIZE; i++) {\n        ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, SM4_BLOCK_SIZE, nonce,\n            GCM_NONCE_MID_SZ, tag, i, aad, sizeof(aad)), 0);\n        ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, in, out, SM4_BLOCK_SIZE, nonce,\n            GCM_NONCE_MID_SZ, tag, i, aad, sizeof(aad)), 0);\n    }\n\n    \n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, 0, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, NULL, 0), 0);\n    ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, out, in, 0, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, NULL, 0), 0);\n    ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, 1, nonce,\n        GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, NULL, 0), 0);\n    for (i = 2; i <= SM4_BLOCK_SIZE * 2; i++) {\n        XMEMCPY(out2, out, i - 1);\n        ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, out, in, i, nonce, GCM_NONCE_MID_SZ,\n            tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n        ExpectIntEQ(XMEMCMP(out, out2, i - 1), 0);\n        ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, dec, out, i, nonce, GCM_NONCE_MID_SZ,\n            tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n        ExpectIntEQ(XMEMCMP(in, dec, i), 0);\n    }\n\n    \n    {\n        static unsigned char largeIn[256 * SM4_BLOCK_SIZE];\n        static unsigned char largeOut[256 * SM4_BLOCK_SIZE];\n\n        ExpectIntEQ(wc_Sm4GcmEncrypt(&sm4, largeOut, largeIn, sizeof(largeIn),\n            nonce, GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n        ExpectIntEQ(wc_Sm4GcmDecrypt(&sm4, largeOut, largeOut, sizeof(largeIn),\n            nonce, GCM_NONCE_MID_SZ, tag, SM4_BLOCK_SIZE, aad, sizeof(aad)), 0);\n        ExpectIntEQ(XMEMCMP(largeOut, largeIn, sizeof(largeIn)), 0);\n    }\n\n    wc_Sm4Free(&sm4);\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_75",
        "query_text": "The function takes no input parameters and returns an integer representing the outcome of a test. It verifies the correctness of an elliptic curve digital signature verification process using SM2. The function performs the following steps:\n\n1. It initializes a key structure for an elliptic curve and two multi-precision integers that represent the signature components.\n2. It sets up fixed test data, including data for a public key, a message hash, and two signature components (one valid and one modified to simulate a failure scenario).\n3. It runs multiple verification tests:\n   - It first attempts to verify the signature using valid inputs.\n   - It then tests error handling by calling the verification routine with various combinations of invalid or missing parameters.\n   - Finally, it verifies that a signature check fails when a signature component is altered.\n4. It cleans up all allocated resources, freeing the multi-precision integers and the key structure.\n\nThe input is nonexistent, and the output is an integer indicating success, failure, or a skipped test result.",
        "code_id": "c_group_1_id_75",
        "code_text": "static int test_wc_ecc_sm2_verify_hash_ex(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(HAVE_ECC) && defined(WOLFSSL_SM2) && defined(HAVE_ECC_VERIFY) && \\\n    defined(WOLFSSL_PUBLIC_MP)\n    EXPECT_DECLS;\n    ecc_key key[1];\n    mp_int r[1];\n    mp_int s[1];\n    int verified;\n    unsigned char pub[] = {\n        0x04,\n        0x63, 0x7F, 0x1B, 0x13, 0x50, 0x36, 0xC9, 0x33,\n        0xDC, 0x3F, 0x7A, 0x8E, 0xBB, 0x1B, 0x7B, 0x2F,\n        0xD1, 0xDF, 0xBD, 0x26, 0x8D, 0x4F, 0x89, 0x4B,\n        0x5A, 0xD4, 0x7D, 0xBD, 0xBE, 0xCD, 0x55, 0x8F,\n        0xE8, 0x81, 0x01, 0xD0, 0x80, 0x48, 0xE3, 0x6C,\n        0xCB, 0xF6, 0x1C, 0xA3, 0x8D, 0xDF, 0x7A, 0xBA,\n        0x54, 0x2B, 0x44, 0x86, 0xE9, 0x9E, 0x49, 0xF3,\n        0xA7, 0x47, 0x0A, 0x85, 0x7A, 0x09, 0x64, 0x33\n    };\n    unsigned char hash[] = {\n        0x3B, 0xFA, 0x5F, 0xFB, 0xC4, 0x27, 0x8C, 0x9D,\n        0x02, 0x3A, 0x19, 0xCB, 0x1E, 0xAA, 0xD2, 0xF1,\n        0x50, 0x69, 0x5B, 0x20\n    };\n    unsigned char rData[] = {\n        0xD2, 0xFC, 0xA3, 0x88, 0xE3, 0xDF, 0xA3, 0x00,\n        0x73, 0x9B, 0x3C, 0x2A, 0x0D, 0xAD, 0x44, 0xA2,\n        0xFC, 0x62, 0xD5, 0x6B, 0x84, 0x54, 0xD8, 0x40,\n        0x22, 0x62, 0x3D, 0x5C, 0xA6, 0x61, 0x9B, 0xE7,\n    };\n    unsigned char sData[] = {\n        0x1D,\n        0xB5, 0xB5, 0xD9, 0xD8, 0xF1, 0x20, 0xDD, 0x97,\n        0x92, 0xBF, 0x7E, 0x9B, 0x3F, 0xE6, 0x3C, 0x4B,\n        0x03, 0xD8, 0x80, 0xBD, 0xB7, 0x27, 0x7E, 0x6A,\n        0x84, 0x23, 0xDE, 0x61, 0x7C, 0x8D, 0xDC\n    };\n    unsigned char rBadData[] = {\n        0xD2, 0xFC, 0xA3, 0x88, 0xE3, 0xDF, 0xA3, 0x00,\n        0x73, 0x9B, 0x3C, 0x2A, 0x0D, 0xAD, 0x44, 0xA2,\n        0xFC, 0x62, 0xD5, 0x6B, 0x84, 0x54, 0xD8, 0x40,\n        0x22, 0x62, 0x3D, 0x5C, 0xA6, 0x61, 0x9B, 0xE8,\n    };\n\n    XMEMSET(key, 0, sizeof(*key));\n    XMEMSET(r, 0, sizeof(*r));\n    XMEMSET(s, 0, sizeof(*s));\n\n    ExpectIntEQ(mp_init(r), 0);\n    ExpectIntEQ(mp_init(s), 0);\n    ExpectIntEQ(mp_read_unsigned_bin(r, rData, sizeof(rData)), 0);\n    ExpectIntEQ(mp_read_unsigned_bin(s, sData, sizeof(sData)), 0);\n\n    ExpectIntEQ(wc_ecc_init(key), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(r, s, hash, sizeof(hash),\n        &verified, key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    ExpectIntEQ(wc_ecc_import_x963_ex(pub, sizeof(pub), key, ECC_SM2P256V1), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(NULL, NULL, NULL, sizeof(hash),\n        NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(r, NULL, NULL, sizeof(hash),\n        NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(NULL, s, NULL, sizeof(hash),\n        NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(NULL, NULL, hash, sizeof(hash),\n        NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(NULL, NULL, NULL, sizeof(hash),\n        &verified, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(NULL, NULL, NULL, sizeof(hash),\n        NULL, key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(NULL, s, hash, sizeof(hash),\n        &verified, key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(r, NULL, hash, sizeof(hash),\n        &verified, key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(r, s, NULL, sizeof(hash),\n        &verified, key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(r, s, hash, sizeof(hash),\n        NULL, key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(r, s, hash, sizeof(hash),\n        &verified, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_ecc_set_curve(key, 32, ECC_SECP256R1), 0);\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(r, s, hash, sizeof(hash),\n        &verified, key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_set_curve(key, 32, ECC_SM2P256V1), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(r, s, hash, sizeof(hash),\n        &verified, key), 0);\n    ExpectIntEQ(verified, 1);\n\n    ExpectIntEQ(mp_read_unsigned_bin(r, rBadData, sizeof(rBadData)), 0);\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(r, s, hash, sizeof(hash),\n        &verified, key), 0);\n    ExpectIntEQ(verified, 0);\n\n    mp_free(s);\n    mp_free(r);\n    wc_ecc_free(key);\n#ifdef FP_ECC\n    wc_ecc_fp_free();\n#endif\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_76",
        "query_text": "The function is a test routine that validates the process of signing a hash using an elliptic curve cryptography algorithm based on the SM2 specification. It begins by initializing and configuring essential cryptographic components such as a random number generator, an elliptic curve key structure, and multi-precision integers to hold signature elements. Initially, it generates a random hash and attempts to invoke the signing operation with various deliberately faulty or null parameters to ensure that the signing routine properly returns error codes when provided with invalid inputs. The test also involves setting up the elliptic curve parameters and, in certain cases, intentionally supplying incorrectly sized mathematical structures to trigger error conditions. After these edge-case verifications, the function performs a valid signing operation and subsequently verifies the correctness of the resulting signature against the original hash using a separate verification routine. Throughout the process, it manages resource allocation and cleanup appropriately. The function ultimately returns an integer test result indicating success, failure, or if the test was skipped.",
        "code_id": "c_group_1_id_76",
        "code_text": "static int test_wc_ecc_sm2_sign_hash_ex(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(HAVE_ECC) && defined(WOLFSSL_SM2) && defined(HAVE_ECC_SIGN) && \\\n    defined(WOLFSSL_PUBLIC_MP)\n    EXPECT_DECLS;\n    WC_RNG  rng[1];\n    ecc_key key[1];\n    mp_int r[1];\n    mp_int s[1];\n    unsigned char hash[32];\n#ifdef HAVE_ECC_VERIFY\n    int verified;\n#endif\n\n    XMEMSET(rng, 0, sizeof(*rng));\n    XMEMSET(key, 0, sizeof(*key));\n    XMEMSET(r, 0, sizeof(*r));\n    XMEMSET(s, 0, sizeof(*s));\n\n    ExpectIntEQ(wc_InitRng(rng), 0);\n    ExpectIntEQ(mp_init(r), 0);\n    ExpectIntEQ(mp_init(s), 0);\n    ExpectIntEQ(wc_RNG_GenerateBlock(rng, hash, sizeof(hash)), 0);\n\n    ExpectIntEQ(wc_ecc_init(key), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(hash, sizeof(hash), rng, key, r, s),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    ExpectIntEQ(wc_ecc_sm2_make_key(rng, key, WC_ECC_FLAG_NONE), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(NULL, sizeof(hash), NULL, NULL, NULL,\n        NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(hash, sizeof(hash), NULL, NULL, NULL,\n        NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(NULL, sizeof(hash), rng, NULL, NULL,\n        NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(NULL, sizeof(hash), NULL, key, NULL,\n        NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(NULL, sizeof(hash), NULL, NULL, r,\n        NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(NULL, sizeof(hash), NULL, NULL, NULL,\n        s), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(NULL, sizeof(hash), rng, key, r, s),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(hash, sizeof(hash), NULL, key, r, s),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(hash, sizeof(hash), rng, NULL, r, s),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(hash, sizeof(hash), rng, key, NULL, s),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(hash, sizeof(hash), rng, key, r, NULL),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_ecc_set_curve(key, 32, ECC_SECP256R1), 0);\n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(hash, sizeof(hash), rng, key, r, s),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_set_curve(key, 32, ECC_SM2P256V1), 0);\n\n#ifdef WOLFSSL_SP_MATH_ALL\n    {\n        mp_int smallR[1];\n        sp_init_size(smallR, 1);\n        \n        ExpectIntLT(wc_ecc_sm2_sign_hash_ex(hash, sizeof(hash), rng, key,\n            smallR, s), 0);\n    }\n#endif\n\n    \n    ExpectIntEQ(wc_ecc_sm2_sign_hash_ex(hash, sizeof(hash), rng, key, r, s),\n        0);\n#ifdef HAVE_ECC_VERIFY\n    ExpectIntEQ(wc_ecc_sm2_verify_hash_ex(r, s, hash, sizeof(hash), &verified,\n        key), 0);\n    ExpectIntEQ(verified, 1);\n#endif\n\n    mp_free(s);\n    mp_free(r);\n    wc_ecc_free(key);\n    wc_FreeRng(rng);\n#ifdef FP_ECC\n    wc_ecc_fp_free();\n#endif\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_77",
        "query_text": "The function performs a self-contained test of an encryption algorithm operating in ECB mode using a cryptography library. It follows these steps:\n\n1. Initialization: The function creates and configures a context for both encryption and decryption. A key is set up (initialized to zero) and a fixed-size block of plaintext is defined.\n2. Encryption: It encrypts the plaintext using the specified algorithm and key, storing the resulting ciphertext in a dedicated buffer.\n3. Decryption: The function then decrypts the ciphertext using the same key, placing the resultant plaintext in another buffer.\n4. Validation: It compares the decrypted data against the original plaintext to ensure that the encryption and decryption processes function correctly.\n5. Cleanup: The function releases the allocated resources associated with the encryption/decryption context.\n\nThe output is an integer that indicates the test result\u2014success, failure, or skipped (in case necessary features are not enabled). No external inputs are required as the function operates on fixed-size byte arrays for the key, plaintext, ciphertext, and decrypted text.",
        "code_id": "c_group_1_id_77",
        "code_text": "static int test_wolfssl_EVP_sm4_ecb(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_SM4_ECB)\n    EXPECT_DECLS;\n    byte key[SM4_KEY_SIZE];\n    byte plainText[SM4_BLOCK_SIZE] = {\n        0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,\n        0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF\n    };\n    byte cipherText[sizeof(plainText) + SM4_BLOCK_SIZE];\n    byte decryptedText[sizeof(plainText) + SM4_BLOCK_SIZE];\n    EVP_CIPHER_CTX* ctx;\n    int outSz;\n\n    XMEMSET(key, 0, sizeof(key));\n\n    \n    ExpectNotNull((ctx = EVP_CIPHER_CTX_new()));\n    ExpectIntEQ(EVP_EncryptInit_ex(ctx, EVP_sm4_ecb(), NULL, NULL, NULL),\n        WOLFSSL_SUCCESS);\n    \n    ExpectIntEQ(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, 16, NULL),\n        WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_EncryptInit_ex(ctx, NULL, NULL, key, NULL),\n        WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_EncryptUpdate(ctx, cipherText, &outSz, plainText,\n        sizeof(plainText)), WOLFSSL_SUCCESS);\n    ExpectIntEQ(outSz, sizeof(plainText));\n    ExpectIntEQ(EVP_EncryptFinal_ex(ctx, cipherText + outSz, &outSz),\n        WOLFSSL_SUCCESS);\n    ExpectIntEQ(outSz, SM4_BLOCK_SIZE);\n    ExpectBufNE(cipherText, plainText, sizeof(plainText));\n    EVP_CIPHER_CTX_free(ctx);\n\n    \n    ExpectNotNull((ctx = EVP_CIPHER_CTX_new()));\n    ExpectIntEQ(EVP_DecryptInit_ex(ctx, EVP_sm4_ecb(), NULL, NULL, NULL),\n        WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DecryptInit_ex(ctx, NULL, NULL, key, NULL),\n        WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DecryptUpdate(ctx, decryptedText, &outSz, cipherText,\n        sizeof(cipherText)), WOLFSSL_SUCCESS);\n    ExpectIntEQ(outSz, sizeof(plainText));\n    ExpectIntEQ(EVP_DecryptFinal_ex(ctx, decryptedText + outSz, &outSz),\n        WOLFSSL_SUCCESS);\n    ExpectIntEQ(outSz, 0);\n    ExpectBufEQ(decryptedText, plainText, sizeof(plainText));\n    EVP_CIPHER_CTX_free(ctx);\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_78",
        "query_text": "The function tests the encryption and decryption processes for a symmetric algorithm when provided with an empty plaintext. It sets up separate encryption and decryption contexts using predefined byte arrays for a key and an initialization vector. The process unfolds as follows:\n\n1. It initializes the encryption context, setting the IV length and then attempts to encrypt an empty plaintext. During encryption, it produces a ciphertext (which is expected to be empty) and an authentication tag.\n2. The decryption context is then initialized using the same key and IV. It attempts to decrypt the empty ciphertext while verifying the authentication tag, expecting to recover an empty plaintext.\n3. Finally, the function cleans up by freeing the resources used by both contexts and returns an integer status that indicates whether the test passed, failed, or was skipped.",
        "code_id": "c_group_1_id_78",
        "code_text": "static int test_wolfssl_EVP_sm4_ccm_zeroLen(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_SM4_CCM)\n    \n    EXPECT_DECLS;\n    byte key[] = {\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n    }; \n    byte iv[]  = {\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n    }; \n    byte plaintxt[1];\n    int ivSz  = 12;\n    int plaintxtSz = 0;\n    unsigned char tag[16];\n\n    byte ciphertxt[SM4_BLOCK_SIZE * 4] = {0};\n    byte decryptedtxt[SM4_BLOCK_SIZE * 4] = {0};\n    int ciphertxtSz = 0;\n    int decryptedtxtSz = 0;\n    int len = 0;\n\n    EVP_CIPHER_CTX *en = EVP_CIPHER_CTX_new();\n    EVP_CIPHER_CTX *de = EVP_CIPHER_CTX_new();\n\n    ExpectIntEQ(1, EVP_EncryptInit_ex(en, EVP_sm4_ccm(), NULL, key, iv));\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(en, EVP_CTRL_CCM_SET_IVLEN, ivSz, NULL));\n    ExpectIntEQ(1, EVP_EncryptUpdate(en, ciphertxt, &ciphertxtSz , plaintxt,\n                                     plaintxtSz));\n    ExpectIntEQ(1, EVP_EncryptFinal_ex(en, ciphertxt, &len));\n    ciphertxtSz += len;\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(en, EVP_CTRL_CCM_GET_TAG, 16, tag));\n    ExpectIntEQ(1, EVP_CIPHER_CTX_cleanup(en));\n\n    ExpectIntEQ(0, ciphertxtSz);\n\n    EVP_CIPHER_CTX_init(de);\n    ExpectIntEQ(1, EVP_DecryptInit_ex(de, EVP_sm4_ccm(), NULL, key, iv));\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(de, EVP_CTRL_CCM_SET_IVLEN, ivSz, NULL));\n    ExpectIntEQ(1, EVP_DecryptUpdate(de, NULL, &len, ciphertxt, len));\n    decryptedtxtSz = len;\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(de, EVP_CTRL_CCM_SET_TAG, 16, tag));\n    ExpectIntEQ(1, EVP_DecryptFinal_ex(de, decryptedtxt, &len));\n    decryptedtxtSz += len;\n    ExpectIntEQ(0, decryptedtxtSz);\n\n    EVP_CIPHER_CTX_free(en);\n    EVP_CIPHER_CTX_free(de);\n\n    res = EXPECT_RESULT();\n#endif \n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_79",
        "query_text": "The function takes no input arguments. It immediately returns a boolean value of true without performing any calculation or condition checks. This constant behavior ensures that the output is always true, regardless of any external factors. The return type of the function is bool.",
        "code_id": "c_group_1_id_79",
        "code_text": "inline bool alwaysTrue() { return true; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_80",
        "query_text": "The function accepts a pointer to a constant void type as input and returns a boolean value. Internally, it casts the input pointer to an integer pointer and retrieves the integer value it points to. The function then checks if this integer value is zero; if so, it returns true, otherwise false.",
        "code_id": "c_group_1_id_80",
        "code_text": "bool pred1(const void* e)\n{\n    return *(int*)e == 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_81",
        "query_text": "This function takes an unsigned integer, a string, and a pair of double values as inputs. It computes the average time per operation by dividing the first double value by the unsigned integer, and calculates the relative error percentage using the difference between the two doubles. These computed values, along with the string (displayed left-aligned), are formatted and printed in a human-readable summary. The function does not return any value (void).",
        "code_id": "c_group_1_id_81",
        "code_text": "void pretty_print(size_t number_of_ops, std::string name, std::pair<double,double> result) {\n  printf(\"%-40s: %8.2f ns/ops (+/- %.1f %%) \\n\", name.data(),\n           result.first / number_of_ops,\n           (result.second - result.first) * 100.0 / result.second);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_82",
        "query_text": "The function takes five inputs: a double-precision floating-point number, an integer representing the desired precision, a boolean flag to determine if scientific notation is permitted, a character buffer to hold the formatted string, and the size of that buffer. It formats the floating-point number into the buffer using a fixed-point or scientific format based on the boolean flag. If the formatted string includes scientific notation (for instance, \"1.23e-4\"), the function terminates further processing. Otherwise, it checks for the presence of a decimal point and, if missing, appends \".0\" to the string. If a decimal point is present, the function removes any unnecessary trailing zeros following it, thereby simplifying the representation. The final formatted string is stored directly in the provided buffer, and no value is returned.",
        "code_id": "c_group_1_id_82",
        "code_text": "void libconfig_format_double(double val, int precision, int sci_ok, char *buf,\n                             size_t buflen)\n{\n  const char *fmt = sci_ok ? \"%.*g\" : \"%.*f\";\n  char *p, *q;\n\n  snprintf(buf, buflen - 3, fmt, precision, val);\n\n  \n  p = strchr(buf, 'e');\n  if(p) return;\n\n  \n  p = strchr(buf, '.');\n  if(!p)\n  {\n    \n    strcat(buf, \".0\");\n  }\n  else\n  {\n    \n    for(q = buf + strlen(buf) - 1; q > p + 1; --q)\n    {\n      if(*q == '0')\n        *q = '\\0';\n      else\n        break;\n    }\n  }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_83",
        "query_text": "The function accepts a single integer input that represents a type identifier. It evaluates whether this identifier falls within an inclusive range defined by two predetermined constants. If the identifier lies within this range, the function returns a non-zero integer (indicating a true value); if not, it returns zero (indicating false). Its primary purpose is to determine if the provided type identifier corresponds to a scalar type.",
        "code_id": "c_group_1_id_83",
        "code_text": "static int __config_type_is_scalar(int type)\n{\n  return((type >= CONFIG_TYPE_INT) && (type <= CONFIG_TYPE_BOOL));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_84",
        "query_text": "The function checks whether a string input meets specific validation criteria. It first verifies that the string is not empty; if it is, the string is deemed invalid. Next, it ensures that the first character is either a letter or an asterisk. Finally, it confirms that every subsequent character is either a letter, a digit, or one of the following allowed special characters: asterisk, underscore, or hyphen. Based on these checks, the function returns an integer indicating whether the string is valid or not.",
        "code_id": "c_group_1_id_84",
        "code_text": "static int __config_validate_name(const char *name)\n{\n  const char *p = name;\n\n  if(*p == '\\0')\n    return(CONFIG_FALSE);\n\n  if(! isalpha((int)*p) && (*p != '*'))\n    return(CONFIG_FALSE);\n\n  for(++p; *p; ++p)\n  {\n    if(! (isalpha((int)*p) || isdigit((int)*p) || strchr(\"*_-\", (int)*p)))\n      return(CONFIG_FALSE);\n  }\n\n  return(CONFIG_TRUE);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_85",
        "query_text": "The function accepts a single string as input and returns a boolean value. It checks whether the input string is equal to one of three specific literal values \u2013 \".nan\", \".NaN\", or \".NAN\". If the input matches any of these values, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_85",
        "code_text": "inline bool IsNaN(const std::string& input) {\n  return input == \".nan\" || input == \".NaN\" || input == \".NAN\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_86",
        "query_text": "The function takes a single character as input and returns an integer representing the number of bytes needed to encode that character using UTF-8 encoding. It evaluates the high-order bits of the unsigned version of the input character to determine the appropriate byte sequence. Specifically, it returns 1 for characters fitting the one-byte pattern, 2 for those matching the two-byte sequence, 3 for the three-byte pattern, and 4 for the four-byte sequence. If the character does not conform to any valid UTF-8 leading byte pattern, the function returns -1 to signal an invalid or unsupported character.",
        "code_id": "c_group_1_id_86",
        "code_text": "int Utf8BytesIndicated(char ch) {\n  int byteVal = static_cast<unsigned char>(ch);\n  switch (byteVal >> 4) {\n    case 0:\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n      return 1;\n    case 12:\n    case 13:\n      return 2;\n    case 14:\n      return 3;\n    case 15:\n      return 4;\n    default:\n      return -1;\n  }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_87",
        "query_text": "The function accepts three parameters: a pointer to a character array representing a string, an unsigned integer indicating the string's size, and a boolean flag that determines whether non-ASCII characters should trigger a validation failure. It iterates over each character in the string checking two conditions: if the boolean flag is set, it verifies that no character has a value equal to or exceeding 0x80 (thus ensuring all characters are ASCII), and it confirms that the string does not contain any newline characters. The function returns a boolean value\u2014true if all characters meet the specified criteria, or false otherwise.",
        "code_id": "c_group_1_id_87",
        "code_text": "bool IsValidSingleQuotedScalar(const char* str, std::size_t size, bool escapeNonAscii) {\n  \n  return std::none_of(str, str + size, [=](char ch) {\n    return (escapeNonAscii && (0x80 <= static_cast<unsigned char>(ch))) ||\n           (ch == '\\n');\n  });\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_88",
        "query_text": "The function accepts two pointers to constant memory areas representing a source string and a set of accepted characters. It processes the source as a UTF-8 encoded string, reading each character (or multi-byte sequence) and verifying if it exists within the accepted set. The function counts, in sequence, the number of characters from the source that are also found in the accepted set. It terminates the count when encountering the first character that does not match any in the accepted set or when the end of the source string is reached. The result, a count of type size_t, is returned as output.",
        "code_id": "c_group_1_id_88",
        "code_text": "size_t utf8spn(const void *src, const void *accept)\n{\n    const char *s = (const char *)src;\n    size_t chars = 0;\n\n    while ('\\0' != *s) {\n        const char *a = (const char *)accept;\n        size_t offset = 0;\n\n        while ('\\0' != *a) {\n            \n            \n            \n            if ((0x80 != (0xc0 & *a)) && (0 < offset)) {\n                \n                \n                \n                chars++;\n                s += offset;\n                break;\n            } else {\n                if (*a == s[offset]) {\n                    offset++;\n                    a++;\n                } else {\n                    \n                    \n                    do {\n                        a++;\n                    } while (0x80 == (0xc0 & *a));\n\n                    \n                    offset = 0;\n                }\n            }\n        }\n\n        \n        \n        if ('\\0' == *a) {\n            return chars;\n        }\n    }\n\n    return chars;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_89",
        "query_text": "The function accepts three inputs: a constant string, a separator character, and a non-negative integer. It searches the string for the nth occurrence of the separator character and returns a pointer to the beginning of the substring immediately following that occurrence. If the string is null, the separator character does not appear, or the nth occurrence is not found, the function returns a null pointer. The output is of type pointer to constant character.",
        "code_id": "c_group_1_id_89",
        "code_text": "FT_INTERNAL\nconst char *str_n_substring_beg(const char *str, char ch_separator, size_t n)\n{\n    if (str == NULL)\n        return NULL;\n\n    if (n == 0)\n        return str;\n\n    str = strchr(str, ch_separator);\n    --n;\n    while (n > 0) {\n        if (str == NULL)\n            return NULL;\n        --n;\n        str++;\n        str = strchr(str, ch_separator);\n    }\n    return str ? (str + 1) : NULL;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_90",
        "query_text": "This function returns a string representing the version of a library. It constructs the version string by concatenating the major, minor, and patch version numbers using the format \"X.Y.Z\". The function does not accept any input parameters and outputs a pointer to a constant character string that reflects the library's version.\n\n",
        "code_id": "c_group_1_id_90",
        "code_text": "const char *utf8proc_version(void) {\n  return STRINGIZE(UTF8PROC_VERSION_MAJOR) \".\" STRINGIZE(UTF8PROC_VERSION_MINOR) \".\" STRINGIZE(UTF8PROC_VERSION_PATCH) \"\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_91",
        "query_text": "The function takes no input arguments and returns a pointer to a constant character string. It simply provides the Unicode version information supported by the library\u2014specifically \"16.0.0\"\u2014without performing any additional processing.",
        "code_id": "c_group_1_id_91",
        "code_text": "const char *utf8proc_unicode_version(void) {\n  return \"16.0.0\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_92",
        "query_text": "The function takes an integer as input and returns an unsigned integer representing the floor of the base-2 logarithm of the input value. It calculates this by repeatedly right-shifting the input (effectively dividing it by 2) until the value becomes zero, incrementing a counter with each shift. The number of shifts performed corresponds to the floor of the logarithm to base 2. The input is of type int, and the output is of type unsigned int.",
        "code_id": "c_group_1_id_92",
        "code_text": "static unsigned int s_floor_ilog2(int value)\n{\n   unsigned int r = 0;\n   while ((value >>= 1) != 0) {\n      r++;\n   }\n   return r;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_93",
        "query_text": "The function accepts two integers as input and returns a boolean value. It evaluates whether the first integer qualifies as a valid digit within a numeral system defined by the second input (radix). The function checks three possible conditions: first, it verifies if the input falls within the numeric digit range ('0' to '9') and is valid for the given radix; second, for radices greater than 10, it checks if the input is a lowercase alphabetic digit (from 'a' onward) that represents a valid digit; and third, under the same condition (radix > 10), it verifies if the input is an uppercase alphabetic digit (from 'A' onward) corresponding to a valid digit. If any of these checks succeed, the function returns true, otherwise false.",
        "code_id": "c_group_1_id_93",
        "code_text": "static bool isDigit(int x, int radix) {\n  return (x >= '0' && x <= '9' && x < '0' + radix)\n      || (radix > 10 && x >= 'a' && x < 'a' + radix - 10)\n      || (radix > 10 && x >= 'A' && x < 'A' + radix - 10);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_94",
        "query_text": "The function accepts three parameters: an integer value representing a character or digit, an integer representing the radix (base) of a numeral system, and a character that serves as the starting point for additional alphabetic digits (for numeral systems with bases higher than 10). It first checks if the radix is greater than 10. If so, the function verifies whether the integer falls within a continuous range beginning at the provided character and extending for (radix \u2013 10) positions. The function returns a boolean value: true if the integer represents a valid digit character for the given radix; otherwise, it returns false.",
        "code_id": "c_group_1_id_94",
        "code_text": "static bool IsCharacterDigitForRadix(int c, int radix, char a_character) {\n  return radix > 10 && c >= a_character && c < a_character + radix - 10;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_95",
        "query_text": "The function takes a single input of type char. It verifies whether the input character is a numeric digit by checking if it lies between '0' and '9' (inclusive). If the input character meets this condition, the function returns true; otherwise, it returns false. The output of the function is of type bool.",
        "code_id": "c_group_1_id_95",
        "code_text": "static bool IsDigit(const char d) {\n  return ('0' <= d) && (d <= '9');\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_96",
        "query_text": "The function accepts a pointer to a UTF-8 encoded character array as its input. It decodes the first UTF-8 sequence found in the string and outputs two values: a 32-bit unsigned integer representing the resulting Unicode code point and an integer error code that indicates whether the sequence was valid. The function returns a pointer to the character immediately following the decoded sequence, enabling sequential processing of subsequent UTF-8 characters. The input is a pointer to a UTF-8 encoded string, while the outputs are the decoded Unicode code point and an error status indicator.",
        "code_id": "c_group_1_id_96",
        "code_text": "inline auto utf8_decode(const char* s, uint32_t* c, int* e)\n    -> const char* {\n  constexpr const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};\n  constexpr const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};\n  constexpr const int shiftc[] = {0, 18, 12, 6, 0};\n  constexpr const int shifte[] = {0, 6, 4, 2, 0};\n\n  int len = \"\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\2\\2\\2\\2\\3\\3\\4\"\n      [static_cast<unsigned char>(*s) >> 3];\n  \n  \n  \n  const char* next = s + len + !len;\n\n  using uchar = unsigned char;\n\n  \n  \n  *c = uint32_t(uchar(s[0]) & masks[len]) << 18;\n  *c |= uint32_t(uchar(s[1]) & 0x3f) << 12;\n  *c |= uint32_t(uchar(s[2]) & 0x3f) << 6;\n  *c |= uint32_t(uchar(s[3]) & 0x3f) << 0;\n  *c >>= shiftc[len];\n\n  \n  *e = (*c < mins[len]) << 6;       \n  *e |= ((*c >> 11) == 0x1b) << 7;  \n  *e |= (*c > 0x10FFFF) << 8;       \n  *e |= (uchar(s[1]) & 0xc0) >> 2;\n  *e |= (uchar(s[2]) & 0xc0) >> 4;\n  *e |= uchar(s[3]) >> 6;\n  *e ^= 0x2a;  \n  *e >>= shifte[len];\n\n  return next;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_97",
        "query_text": "The function takes a single character as input and determines whether it is alphanumeric\u2014that is, whether it is a letter (uppercase or lowercase) or a digit (0\u20139). If the character is alphanumeric, the function returns true; otherwise, it returns false. The input type is char, and the output is a boolean value.",
        "code_id": "c_group_1_id_97",
        "code_text": "inline bool IsAlNum(char ch) {\n  return isalnum(static_cast<unsigned char>(ch)) != 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_98",
        "query_text": "The function takes a single character as input and determines whether it represents a numeric digit (0-9). Internally, it casts the input to an unsigned character and uses a standard library routine to perform the check. Based on this evaluation, the function returns a boolean value: true if the character is a decimal digit, and false otherwise. The input is of type char, while the output is of type bool.",
        "code_id": "c_group_1_id_98",
        "code_text": "inline bool IsDigit(char ch) {\n  return isdigit(static_cast<unsigned char>(ch)) != 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_99",
        "query_text": "The function receives a single character of type char and returns a boolean value. It first casts the input to an unsigned char to ensure compatibility with a standard library function that checks for lowercase characters. It then evaluates the input using this function and produces a boolean result: true if the character is lowercase, or false otherwise.",
        "code_id": "c_group_1_id_99",
        "code_text": "inline bool IsLower(char ch) {\n  return islower(static_cast<unsigned char>(ch)) != 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_100",
        "query_text": "The function accepts a single input of type char and returns an output of the same type. It first converts the input character to an unsigned char to safely handle potential negative values. Then, it applies the standard library function for case conversion to transform the character into its lowercase equivalent. Finally, the result is cast back to a char before being returned.",
        "code_id": "c_group_1_id_100",
        "code_text": "inline char ToLower(char ch) {\n  return static_cast<char>(tolower(static_cast<unsigned char>(ch)));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_101",
        "query_text": "The function takes a char as input and returns a char as output. It converts the provided character to its uppercase equivalent by first casting it to an unsigned type to prevent issues with negative values, then applying a standard uppercase conversion operation, and finally casting the result back to a char before returning it.",
        "code_id": "c_group_1_id_101",
        "code_text": "inline char ToUpper(char ch) {\n  return static_cast<char>(toupper(static_cast<unsigned char>(ch)));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_102",
        "query_text": "The function takes two string inputs: one specifying a file path and the other specifying a file-mode indicator (such as \"r\" for read or \"w\" for write). On Windows systems (when not using a specific alternative compiler), it first converts these strings into wide-character format before attempting to open the file. On other systems, it directly opens the file using the provided strings. It returns a pointer to the opened file for later use.",
        "code_id": "c_group_1_id_102",
        "code_text": "inline FILE* FOpen(const char* path, const char* mode) {\n#if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MINGW\n  struct wchar_codecvt : public std::codecvt<wchar_t, char, std::mbstate_t> {};\n  std::wstring_convert<wchar_codecvt> converter;\n  std::wstring wide_path = converter.from_bytes(path);\n  std::wstring wide_mode = converter.from_bytes(mode);\n  return _wfopen(wide_path.c_str(), wide_mode.c_str());\n#else  \n  return fopen(path, mode);\n#endif  \n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_103",
        "query_text": "The function takes a Unicode character (of type char32_t) as input and writes its hexadecimal Unicode code point representation to an output stream (of type ::std::ostream*). It formats the output as \"U+XXXX\"\u2014where \"XXXX\" is the character's 4-digit uppercase hexadecimal value, padded with leading zeros if necessary\u2014and writes this formatted string to the provided stream.",
        "code_id": "c_group_1_id_103",
        "code_text": "void PrintTo(char32_t c, ::std::ostream* os) {\n  *os << std::hex << \"U+\" << std::uppercase << std::setfill('0') << std::setw(4)\n      << static_cast<uint32_t>(c);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_104",
        "query_text": "The function accepts a volatile constant pointer to a void type as input. It converts this pointer by removing the volatile qualifier while preserving the constant qualifier, and then returns the resulting constant pointer. This enables use of the pointer in scenarios where a non-volatile pointer is required without modifying the underlying data.",
        "code_id": "c_group_1_id_104",
        "code_text": "inline const void* VoidifyPointer(volatile const void* p) {\n  return const_cast<const void*>(p);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_105",
        "query_text": "The function takes three parameters: a string-like container, a pointer to a character array representing a pattern, and a pointer marking the end of the pattern. It checks whether the string conforms to the pattern using wildcard matching. The pattern may include two wildcards: one that matches any single character and another that matches zero or more characters. The function iterates through both the string and the pattern, comparing characters and applying the wildcard rules. If the entire string successfully matches the pattern, it returns a boolean true; if not, it returns false.",
        "code_id": "c_group_1_id_105",
        "code_text": "static bool PatternMatchesString(const std::string& name_str,\n                                 const char* pattern, const char* pattern_end) {\n  const char* name = name_str.c_str();\n  const char* const name_begin = name;\n  const char* const name_end = name + name_str.size();\n\n  const char* pattern_next = pattern;\n  const char* name_next = name;\n\n  while (pattern < pattern_end || name < name_end) {\n    if (pattern < pattern_end) {\n      switch (*pattern) {\n        default:  \n          if (name < name_end && *name == *pattern) {\n            ++pattern;\n            ++name;\n            continue;\n          }\n          break;\n        case '?':  \n          if (name < name_end) {\n            ++pattern;\n            ++name;\n            continue;\n          }\n          break;\n        case '*':\n          \n          \n          \n          pattern_next = pattern;\n          name_next = name + 1;\n          ++pattern;\n          continue;\n      }\n    }\n    \n    if (name_begin < name_next && name_next <= name_end) {\n      pattern = pattern_next;\n      name = name_next;\n      continue;\n    }\n    return false;\n  }\n  return true;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_106",
        "query_text": "The function accepts two parameters: one is a pointer to a constant character array, and the other is also a pointer to a constant character array. It first checks whether either pointer is NULL; if so, it returns true only if both pointers are NULL. Otherwise, it employs a string search function to determine if the first string exists within the second string. If the specified substring is found, it returns true; if not, it returns false.",
        "code_id": "c_group_1_id_106",
        "code_text": "bool IsSubstringPred(const char* needle, const char* haystack) {\n  if (needle == nullptr || haystack == nullptr) return needle == haystack;\n\n  return strstr(haystack, needle) != nullptr;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_107",
        "query_text": "The function accepts a pointer to an unsigned 32-bit integer and an integer specifying the number of bits to operate on. It extracts the lower bits from the unsigned 32-bit integer by applying a bit mask defined by the number of bits, then shifts the original integer right by that many bits to remove the extracted portion. Finally, it returns the extracted bits as an unsigned 32-bit integer. The input types are a pointer to an unsigned 32-bit integer and an integer, and the output type is an unsigned 32-bit integer.",
        "code_id": "c_group_1_id_107",
        "code_text": "inline uint32_t ChopLowBits(uint32_t* bits, int n) {\n  const uint32_t low_bits = *bits & ((static_cast<uint32_t>(1) << n) - 1);\n  *bits >>= n;\n  return low_bits;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_108",
        "query_text": "The function accepts three parameters: a pointer to a constant character array representing a string, a pointer to a constant character array representing a flag name, and a boolean value indicating whether an associated value with the flag is optional. It first constructs a flag pattern by concatenating a predefined prefix with the provided flag name, then checks if the input string starts with this pattern. If the string does not begin with the expected flag pattern, the function returns a null pointer. Once the pattern is matched, the function examines the character immediately following the flag pattern. If the flag value is optional and the flag pattern is immediately followed by the end of the string, it returns a pointer to that position. Otherwise, it checks whether the character following the flag pattern is an equals sign; if it is, the pointer is advanced past the equals sign and returned as the position where the flag value starts, and if not, a null pointer is returned.",
        "code_id": "c_group_1_id_108",
        "code_text": "static const char* ParseFlagValue(const char* str, const char* flag,\n                                  bool def_optional) {\n  \n  if (str == nullptr || flag == nullptr) return nullptr;\n\n  \n  const std::string flag_str = std::string(\"--\") + GTEST_FLAG_PREFIX_ + flag;\n  const size_t flag_len = flag_str.length();\n  if (strncmp(str, flag_str.c_str(), flag_len) != 0) return nullptr;\n\n  \n  const char* flag_end = str + flag_len;\n\n  \n  if (def_optional && (flag_end[0] == '\\0')) {\n    return flag_end;\n  }\n\n  \n  \n  \n  if (flag_end[0] != '=') return nullptr;\n\n  \n  return flag_end + 1;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_109",
        "query_text": "The function takes two inputs: a string (passed by constant reference) and a pointer to an output stream. It checks that the string is non-empty and that the output stream pointer is not null. If both conditions are met, the function appends the string to the output stream, preceded by a comma and a space. The function returns no value.",
        "code_id": "c_group_1_id_109",
        "code_text": "inline void PrintIfNotEmpty(const std::string& explanation,\n                            ::std::ostream* os) {\n  if (explanation != \"\" && os != nullptr) {\n    *os << \", \" << explanation;\n  }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_110",
        "query_text": "The function accepts a single integer input and returns a string that represents the frequency of an occurrence. When the input is 1, the function returns the string \"once\"; when the input is 2, it returns \"twice\". For any other integer value, the function constructs a string by concatenating the input value with the literal \" times\". The input parameter is of type int, and the output is of type std::string.",
        "code_id": "c_group_1_id_110",
        "code_text": "inline std::string FormatTimes(int n) {\n  if (n == 1) {\n    return \"once\";\n  } else if (n == 2) {\n    return \"twice\";\n  } else {\n    std::stringstream ss;\n    ss << n << \" times\";\n    return ss.str();\n  }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_111",
        "query_text": "The function accepts two parameters: a pointer to an array of unsigned characters (representing a series of bytes) and a corresponding non-negative integer indicating the number of bytes to process. It sets up platform-specific constant values based on whether it is running on a 32-bit or 64-bit system. The function iterates over each byte in the sequence, performing bitwise XOR operations followed by multiplications with a predefined constant. The outcome is an integer value (of type size_t) that represents the computed hash for the input sequence.",
        "code_id": "c_group_1_id_111",
        "code_text": "inline size_t bitwise_hash(const unsigned char* first, size_t count)\n{\n#if (_MSC_VER && _WIN64) || ((__GNUC__ || __clang__) &&__SIZEOF_POINTER__ == 8)\n  const size_t fnv_offset = 14695981039346656037ull;\n  const size_t fnv_prime = 1099511628211ull;\n#else\n  const size_t fnv_offset = 2166136261u;\n  const size_t fnv_prime = 16777619u;\n#endif\n  size_t result = fnv_offset;\n  for (size_t i = 0; i < count; ++i)\n  {\n    result ^= (size_t)first[i];\n    result *= fnv_prime;\n  }\n  return result;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_112",
        "query_text": "The function takes no input arguments and returns a reference to a constant pointer to a stream buffer object. Internally, the function utilizes a static variable to ensure that the pointer, which is initially set to point to the stream buffer of the standard logging stream, remains consistent across multiple invocations. This design guarantees that the same stream buffer is reused whenever the function is called.",
        "code_id": "c_group_1_id_112",
        "code_text": "inline const std::streambuf*& get_clogbuf()\n{\n  static const std::streambuf* plog = std::clog.rdbuf();\n  return plog;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_113",
        "query_text": "The function returns a unique integer value that serves as an index for an input/output stream. It accepts no arguments and produces an integer output. Internally, it uses a static variable to store the index, ensuring that the same value is returned on every call. Its inline definition contributes to minimal overhead and efficient performance.",
        "code_id": "c_group_1_id_113",
        "code_text": "inline int get_iword()\n{\n  static int i = std::ios_base::xalloc();\n  return i;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_114",
        "query_text": "This function computes the population count of an unsigned 32-bit integer by determining the number of binary ones in its representation. It takes an unsigned 32-bit integer as input, applies a built-in compiler helper to efficiently count the ones, and returns the resulting count as an unsigned 32-bit integer. The input is an unsigned 32-bit integer, and the output represents the number of ones present in the binary form of the input.",
        "code_id": "c_group_1_id_114",
        "code_text": "inline uint32_t countOnes(uint32_t x) {\n  return static_cast<uint32_t>(__builtin_popcount(x));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_115",
        "query_text": "This function operates on a mutable C-style string provided as a null-terminated character array. It processes the string in place to remove extraneous spaces. Specifically, during its iteration, it skips any space character that immediately follows a specific marker (the '@' character) or that is immediately succeeded by another space, the marker, or the end of the string. The function ensures that the modified string remains null-terminated and does not return any value.",
        "code_id": "c_group_1_id_115",
        "code_text": "static ASMJIT_FAVOR_SIZE void simplifyCpuBrand(char* s) noexcept {\n  char* d = s;\n\n  char c = s[0];\n  char prev = 0;\n\n  \n  \n  s[0] = '\\0';\n\n  for (;;) {\n    if (!c)\n      break;\n\n    if (!(c == ' ' && (prev == '@' || s[1] == ' ' || s[1] == '@' || s[1] == '\\0'))) {\n      *d++ = c;\n      prev = c;\n    }\n\n    c = *++s;\n    s[0] = '\\0';\n  }\n\n  d[0] = '\\0';\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_116",
        "query_text": "The function takes no input arguments and returns a boolean value. It first checks if the code is running on a specific operating system and architecture (macOS with ARM64), in which case it immediately returns true. On other platforms, it attempts to allocate a memory page with read, write, and execute permissions. If the allocation fails, the function concludes that a hardened security feature is enabled and returns true; if the allocation succeeds, it returns false. The result of this check is cached for future calls using atomic operations to ensure thread safety.",
        "code_id": "c_group_1_id_116",
        "code_text": "static bool hasHardenedRuntime() noexcept {\n#if defined(__APPLE__) && TARGET_OS_OSX && ASMJIT_ARCH_ARM >= 64\n  \n  return true;\n#else\n  static std::atomic<uint32_t> cachedHardenedFlag;\n\n  enum HardenedFlag : uint32_t {\n    kHardenedFlagUnknown  = 0,\n    kHardenedFlagDisabled = 1,\n    kHardenedFlagEnabled  = 2\n  };\n\n  uint32_t flag = cachedHardenedFlag.load();\n  if (flag == kHardenedFlagUnknown) {\n    size_t pageSize = size_t(::getpagesize());\n    void* ptr = mmap(nullptr, pageSize, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n    if (ptr == MAP_FAILED) {\n      flag = kHardenedFlagEnabled;\n    }\n    else {\n      flag = kHardenedFlagDisabled;\n      munmap(ptr, pageSize);\n    }\n\n    cachedHardenedFlag.store(flag);\n  }\n\n  return flag == kHardenedFlagEnabled;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_117",
        "query_text": "The function takes no input arguments and returns a boolean value indicating whether a particular system feature is supported. On one operating system with a non-standard architecture, it immediately returns true. On the same operating system but with a different architecture, it checks the system's kernel version; if the kernel version meets a specified minimum, it returns true, otherwise false, with the result cached for subsequent calls. On all other systems, it returns false. The output is of type bool.",
        "code_id": "c_group_1_id_117",
        "code_text": "static inline bool hasMapJitSupport() noexcept {\n#if defined(__APPLE__) && TARGET_OS_OSX && ASMJIT_ARCH_X86 == 0\n  \n  \n  return true;\n#elif defined(__APPLE__) && TARGET_OS_OSX\n  \n  static std::atomic<uint32_t> cachedMapJitSupport;\n  uint32_t val = cachedMapJitSupport.load();\n\n  if (val == 0u) {\n    KernelVersion ver = getKernelVersion();\n    val = uint32_t(ver.ge(18, 0)) + 1u;\n    cachedMapJitSupport.store(val);\n  }\n\n  return val == 2u;\n#else\n  \n  return false;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_118",
        "query_text": "The function takes a floating-point value as its input and evaluates its sign. It determines whether the input is positive, negative, or zero by comparing the value to zero. If the input is greater than zero, the function returns a positive floating-point value; if less than zero, it returns a negative floating-point value; and if equal to zero, it returns zero. The primary purpose of the function is to indicate the sign of the input float using these comparisons.",
        "code_id": "c_group_1_id_118",
        "code_text": "CGLM_INLINE\nfloat\nglm_signf(float val) {\n  return (float)((val > 0.0f) - (val < 0.0f));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_119",
        "query_text": "The function takes a single floating-point input representing a numerical value and computes its square. It does this by multiplying the input by itself, returning the result as a floating-point value. The operation effectively calculates the square of the given number.",
        "code_id": "c_group_1_id_119",
        "code_text": "CGLM_INLINE\nfloat\nglm_pow2(float x) {\n  return x * x;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_120",
        "query_text": "The function takes three inputs, all of type float. The first two floats represent the starting and ending values for interpolation, while the third float specifies the interpolation factor. The function computes the result by adding the product of the interpolation factor and the difference between the ending and starting values to the starting value. If the interpolation factor is 0, the output is the starting value; if it is 1, the output is the ending value; intermediate values yield a proportional blend of the two. The function returns a float representing the interpolated value.",
        "code_id": "c_group_1_id_120",
        "code_text": "CGLM_INLINE\nfloat\nglm_lerp(float from, float to, float t) {\n  return from + t * (to - from);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_121",
        "query_text": "The function takes a floating-point input and returns a floating-point output. It computes a smooth interpolation by applying a cubic easing transformation based on the input, specifically through a quadratic combination that clamps the output between 0 and 1 when the input is within that range. This behavior is ideal for generating smooth transitions or easing effects in animations and interpolations.",
        "code_id": "c_group_1_id_121",
        "code_text": "CGLM_INLINE\nfloat\nglm_smooth(float t) {\n  return t * t * (3.0f - 2.0f * t);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_122",
        "query_text": "The function takes two pointers to floating-point numbers as input and swaps the values stored at those memory locations. It operates by temporarily storing the value from the first pointer, replacing that slot with the value from the second pointer, and finally assigning the stored value to the second pointer. The function does not return any value; it modifies the floating-point numbers in place.",
        "code_id": "c_group_1_id_122",
        "code_text": "CGLM_INLINE\nvoid\nglm_swapf(float * __restrict a, float * __restrict b) {\n  float t;\n  t  = *a;\n  *a = *b;\n  *b = t;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_123",
        "query_text": "The function accepts a single floating-point parameter. It applies a linear transformation by simply returning the input value unchanged, thereby preserving a direct one-to-one relationship between input and output. Both the input and output are of type float, and the function does not modify or scale the value in any way.",
        "code_id": "c_group_1_id_123",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_linear(float t) {\n  return t;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_124",
        "query_text": "The function accepts two inputs: a pointer to an unsigned character array and a size value representing the length of the memory region. It then releases the allocated memory block by invoking the system's memory unmapping operation. This effectively frees up the memory for future use. The function does not produce any output.",
        "code_id": "c_group_1_id_124",
        "code_text": "static void\nfree_text(unsigned char *text, size_t text_len)\n{\n\tmunmap((void *)text, text_len);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_125",
        "query_text": "The function is a static void procedure that takes no inputs and does not return any value. Its purpose is to display a comprehensive help message on the standard output, guiding the user on how to use a string sorting program. The message outlines various command-line options such as validating output, controlling performance monitoring through file descriptors, enabling specific profiling tools, listing available algorithms both in descriptive and script-friendly formats, and directing the sorted output to a specified file. It also illustrates the use of suffix sorting and supports alternative output formats like XML or human-readable statistics. Additionally, the help message provides several usage examples to assist the user in correctly invoking different functionalities of the program.",
        "code_id": "c_group_1_id_125",
        "code_text": "static void\nusage(void)\n{\n\tputs(\n\t     \"String sorting\\n\"\n\t     \"--------------\\n\"\n\t     \"\\n\"\n\t     \"Usage: ./sortstring [options] <algorithm> <filename>\\n\"\n\t     \"\\n\"\n\t     \"Options:\\n\"\n\t     \"   --check          : Tries to check output for validity. Might not catch\\n\"\n\t     \"                      all errors. Prints a warning when errors found.\\n\"\n\t     \"   --perf-ctrl-fd=FD  Use file descriptor to control perf tool.\\n\"\n\t     \"                      Enable perf just before sorting algorithm is called,\\n\"\n\t     \"                      and disable after returning from the call.\\n\"\n\t     \"                      See perf --control option.\\n\"\n\t     \"   --oprofile       : Executes `oprofile --start' just before calling the\\n\"\n\t     \"                      actual sorting algorithm, and `oprofile --stop' after\\n\"\n\t     \"                      returning from the call. Can be used to obtain more\\n\"\n\t     \"                      accurate statistics with OProfile.\\n\"\n\t     \"   -A,--algs        : Prints available algorithm names and descriptions.\\n\"\n\t     \"   -L,--alg-names   : Prints available algorithm names, useful for scripts.\\n\"\n\t     \"                      Example:\\n\"\n\t     \"                         for N in `./sortstring -L` ; do\\n\"\n\t     \"                                   ./sortstring $N input ; done\\n\"\n\t     \"   --suffix-sorting : Treat input as text, and sort each suffix of the text.\\n\"\n\t     \"                      Can be _very_ slow.\\n\"\n\t     \"   --write          : Writes sorted output to `/tmp/$USERNAME/alg.out'\\n\"\n\t     \"   --write=outfile  : Writes sorted output to `outfile'\\n\"\n\t     \"   --xml-stats      : Outputs statistics in XML (default: human readable)\\n\"\n\t     \"   --hugetlb-text   : Place the input text into huge pages.\\n\"\n\t     \"   --hugetlb-ptrs   : Place the string pointer array into huge pages.\\n\"\n\t     \"                      HugeTLB requires kernel and hardware support.\\n\"\n\t     \"   --raw            : The input file is in raw format: strings are delimited\\n\"\n\t     \"                      with NULL bytes instead of newlines.\\n\"\n\t     \"\\n\"\n\t     \"Examples:\\n\"\n\t     \"   # Get list of what is available:\\n\"\n\t     \"   ./sortstring -A\\n\"\n\t     \"\\n\"\n\t     \"   # Sort input file with quicksort:\\n\"\n\t     \"   ./sortstring quicksort ~/testdata/testfile1\\n\"\n\t     \"\\n\"\n\t     \"   # Sort all suffixes of of the given text file with quicksort:\\n\"\n\t     \"   ./sortstring --check --suffix-sorting quicksort ~/testdata/text\\n\"\n\t     \"\\n\"\n\t     \"   # Perf tool and control file descriptor:\\n\"\n\t     \"   mkfifo ctrl && exec 9<>ctrl && rm ctrl\"\n\t         \" && perf stat --delay=-1 --control=fd:9\"\n\t\t \" -- taskset -c 0 ./sortstring --perf-ctrl-fd=9 quicksort testfile\"\n\t     \"\\n\");\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_126",
        "query_text": "The function accepts three parameters: an integer representing the count of command-line arguments, an array of character pointers holding the arguments, and a pointer to a file stream where output should be directed. It first checks if the file stream pointer is valid; if it is not, the function terminates without performing any output. If the stream is valid, the function writes a fixed prefix (\"Command line:\") to the stream, then iterates over the array of arguments\u2014writing each argument preceded by a space\u2014and finally outputs a newline character. The function does not return any value.",
        "code_id": "c_group_1_id_126",
        "code_text": "static void\nprint_cmdline(int argc, char **argv, FILE *fp)\n{\n\tint i;\n\tif (!fp)\n\t\treturn;\n\tfprintf(fp, \"Command line:\");\n\tfor (i=0; i < argc; ++i)\n\t\tfprintf(fp, \" %s\", argv[i]);\n\tfprintf(fp, \"\\n\");\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_127",
        "query_text": "This function performs a lexicographical comparison between two null-terminated arrays of bytes. It takes two inputs, each being a pointer to an unsigned character array, and uses assertions to ensure neither pointer is null. It then converts the input arrays to C-style strings and calls the standard string comparison function to determine their relative ordering, returning an integer result that indicates whether the first array is less than, equal to, or greater than the second array.",
        "code_id": "c_group_1_id_127",
        "code_text": "static inline int\ncmp(const unsigned char* a, const unsigned char* b)\n{\n\tassert(a != 0);\n\tassert(b != 0);\n\treturn strcmp(reinterpret_cast<const char*>(a),\n\t              reinterpret_cast<const char*>(b));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_128",
        "query_text": "The function takes an unsigned 8-bit integer representing a character as input and returns a string representing that character. If the input is a displayable character, it is directly converted to its string equivalent; otherwise, the function produces a string in which the integer value of the non-printable character is enclosed in angle brackets. The resulting string is returned as the output.",
        "code_id": "c_group_1_id_128",
        "code_text": "static std::string to_str(unsigned char c)\n{\n\tstd::ostringstream strm;\n\tif (isprint(c)) strm << c;\n\telse            strm << '<' << int(c) << '>';\n\treturn strm.str();\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_129",
        "query_text": "This function accepts a 16-bit unsigned integer as its parameter and returns a string representation of the input. It operates by dividing the input into two 8-bit segments: one corresponding to the upper half and the other to the lower half of the original value. Each segment is individually converted to a string via a helper conversion method, after which the two strings are concatenated. The final result is the combined string that reflects the original 16-bit integer.",
        "code_id": "c_group_1_id_129",
        "code_text": "static std::string to_str(uint16_t c)\n{ return to_str(uint8_t((0xFF00 & c) >> 8)) + to_str(uint8_t(c)); }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_130",
        "query_text": "This function accepts a single character input. It then checks if the input represents a valid hexadecimal digit by determining whether it falls within the range of numeric digits or lowercase alphabetical characters corresponding to hexadecimal values. The output is an integer value, where 1 indicates a valid hexadecimal digit and 0 indicates an invalid one.",
        "code_id": "c_group_1_id_130",
        "code_text": "static int\nishexdigit(char ch)\n{\n\treturn (ch >= '0' && ch <= '9')\n\t    || (ch >= 'a' && ch <= 'f');\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_131",
        "query_text": "The function takes three inputs: a pointer to an array of null-terminated strings (each string represented as an array of unsigned characters), an integer indicating the total number of strings, and an integer specifying the starting index for character comparison. It implements an insertion sort algorithm to reorder the strings in ascending order based on their characters starting from the given index. During the sorting process, each string is compared to the ones preceding it, and inserted in its appropriate position within the array. The function does not produce a return value, as it directly modifies the order of the strings in the input array.",
        "code_id": "c_group_1_id_131",
        "code_text": "void\ninssort(unsigned char** a, int n, int d)\n{\n\tunsigned char** pi;\n\tunsigned char** pj;\n\tunsigned char* s;\n\tunsigned char* t;\n\n\tfor (pi = a + 1; --n > 0; pi++) {\n\t\tunsigned char* tmp = *pi;\n\n\t\tfor (pj = pi; pj > a; pj--) {\n\t\t\tfor (s=*(pj-1)+d, t=tmp+d; *s==*t && *s!=0; ++s, ++t)\n\t\t\t\t;\n\t\t\tif (*s <= *t)\n\t\t\t\tbreak;\n\t\t\t*pj = *(pj-1);\n\t\t}\n\t\t*pj = tmp;\n\t}\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_132",
        "query_text": "The function accepts two inputs: pointers to unsigned characters (commonly representing strings). It compares the characters of the two strings sequentially until it encounters a mismatched character or reaches the terminating null character in either string. The function then returns an integer that represents the difference between the ASCII values of the first pair of characters that do not match. If the strings are identical, it returns 0.",
        "code_id": "c_group_1_id_132",
        "code_text": "int scmp( unsigned char *s1, unsigned char *s2 )\n{\n    while( *s1 != '\\0' && *s1 == *s2 )\n    {\n        s1++;\n        s2++;\n    }\n    return( *s1-*s2 );\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_133",
        "query_text": "The function takes two pointer-to-pointer parameters that reference memory blocks of unsigned characters and an integer specifying the number of iterations. In each iteration, it swaps the memory locations pointed to by the two pointer parameters and then increments both pointers. This process is repeated until the specified number of swaps is completed. The function performs the operations in place and does not return any value (void).",
        "code_id": "c_group_1_id_133",
        "code_text": "void vecswap2(unsigned char **a, unsigned char **b, int n)\n{   while (n-- > 0) {\n        unsigned char *t = *a;\n        *a++ = *b;\n        *b++ = t;\n    }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_134",
        "query_text": "The function accepts four parameters: three pointers to pointers of an unsigned byte and an integer representing the depth for comparison. It first extracts an integer value from each of the three pointer targets using an external helper function (assumed to retrieve the corresponding value at the specified depth). If the two values from the first and second pointers are equal, it immediately returns the first pointer. Otherwise, if the value from the third pointer matches either of the first two values, it returns the third pointer. If no matches are found, it returns the pointer corresponding to the median value among the three. The result is a pointer to a pointer of unsigned byte.",
        "code_id": "c_group_1_id_134",
        "code_text": "unsigned char **med3func(unsigned char **a, unsigned char **b, unsigned char **c, int depth)\n{   int va, vb, vc;\n    if ((va=ptr2char(a)) == (vb=ptr2char(b)))\n        return a;\n    if ((vc=ptr2char(c)) == va || vc == vb)\n        return c;       \n    return va < vb ?\n          (vb < vc ? b : (va < vc ? c : a ) )\n        : (vb > vc ? b : (va < vc ? a : c ) );\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_135",
        "query_text": "The function sorts an array of strings in place using the insertion sort algorithm. It takes as input an array of strings (pointers to unsigned characters), an integer representing the number of strings in the array, and a size_t value specifying the depth from which to begin comparing the strings lexicographically. The function modifies the input array directly and does not return any value.",
        "code_id": "c_group_1_id_135",
        "code_text": "static void\ninsertion_sort(unsigned char** strings, int n, size_t depth)\n{\n\tfor (unsigned char** i = strings + 1; --n > 0; ++i) {\n\t\tunsigned char** j = i;\n\t\tunsigned char* tmp = *i;\n\t\twhile (j > strings) {\n\t\t\tunsigned char* s = *(j-1)+depth;\n\t\t\tunsigned char* t = tmp+depth;\n\t\t\twhile (*s == *t && *s) {\n\t\t\t\t++s;\n\t\t\t\t++t;\n\t\t\t}\n\t\t\tif (*s <= *t) break;\n\t\t\t*j = *(j-1);\n\t\t\t--j;\n\t\t}\n\t\t*j = tmp;\n\t}\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_136",
        "query_text": "The function accepts two integer inputs and returns an integer that indicates their relative ordering. Specifically, it returns \u20131 if the first input is less than the second, 1 if the first input is greater than the second, and 0 if the two inputs are equal. The function uses simple conditional checks to determine the relationship between the two integers.",
        "code_id": "c_group_1_id_136",
        "code_text": "static int cmp(int a, int b)\n{\n\tif (a < b) return -1;\n\tif (a > b) return 1;\n\treturn 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_137",
        "query_text": "The function receives four inputs: a pointer to a character array representing a file path, a pointer to an unsigned character array serving as a byte buffer, a size value indicating the number of bytes in the buffer, and an integer representing a count. Initially, it checks whether the integer is non-negative and, if so, prints a failure message along with the corresponding document number. The function then opens the file specified by the path in binary read mode and proceeds to read its contents in fixed-size chunks. As each chunk is read, it is written to the standard output while simultaneously accumulating the total number of bytes processed. Once the entire file is read, the file is closed, and the function prints the total size of the file data followed by the contents of the provided byte buffer along with its size. Finally, the function returns a value of 0, indicating successful completion.",
        "code_id": "c_group_1_id_137",
        "code_text": "int print_output(char *name, unsigned char *buffer, size_t size, int count)\n{\n    FILE *file;\n    char data[BUFFER_SIZE];\n    size_t data_size = 1;\n    size_t total_size = 0;\n    if (count >= 0) {\n        printf(\"FAILED (at the document #%d)\\nSOURCE:\\n\", count+1);\n    }\n    file = fopen(name, \"rb\");\n    assert(file);\n    while (data_size > 0) {\n        data_size = fread(data, 1, BUFFER_SIZE, file);\n        assert(!ferror(file));\n        if (!data_size) break;\n        assert(fwrite(data, 1, data_size, stdout) == data_size);\n        total_size += data_size;\n        if (feof(file)) break;\n    }\n    fclose(file);\n    printf(\"#### (length: %ld)\\n\", (long)total_size);\n    printf(\"OUTPUT:\\n%s#### (length: %ld)\\n\", buffer, (long)size);\n    return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_138",
        "query_text": "The function takes an integer as input and returns an integer. It prints a usage message to the standard error stream, which provides guidance on how to execute a program. The message details optional arguments, including options for specific directives and control over execution flow, as well as the possibility of specifying an input file. After displaying the message, the function returns the provided integer value. The input is of type int, and the output is of type int.",
        "code_id": "c_group_1_id_138",
        "code_text": "int usage(int ret) {\n    fprintf(stderr, \"Usage: run-emitter-test-suite [--directive (1.1|1.2)] [--flow (on|off|keep)] [<input-file>]\\n\");\n    return ret;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_139",
        "query_text": "The function accepts a single integer input representing a value N and returns an integer. It computes the result by first calculating the logarithm of N divided by 2 with a base of 2, then dividing this value by a fixed constant factor (0.4875). The intermediate result is then cast to an integer to obtain the final output. The primary purpose of the function is to perform a scaled logarithmic transformation of the input value.",
        "code_id": "c_group_1_id_139",
        "code_text": "int getCWTScaleLength(int N) {\n\tint J;\n\tdouble temp,dj;\n\n\tdj = 0.4875;\n\n\ttemp = (log((double)N / 2.0) / log(2.0)) / dj;\n\tJ = (int)temp;\n\n\treturn J;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_140",
        "query_text": "The function takes three inputs: a pointer to an array of doubles, an integer indicating the total number of elements in the array, and another integer used as a control parameter. It iterates over the array starting at the index computed by doubling the control parameter, and for every element from that starting point, it multiplies the element with the one located a fixed offset earlier in the array (offset equal to twice the control parameter). These products are added together to form a cumulative sum, which is returned as a double-precision value representing the overall computed result.",
        "code_id": "c_group_1_id_140",
        "code_text": "double sum5(double *array, int N,int m) {\n    double sum;\n    int i;\n\n    sum = 0.0;\n    for (i = 2*m; i < N; i += 1) {\n        sum += array[i] * array[i-2*m];\n    }\n    return sum;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_141",
        "query_text": "The function accepts two integer inputs. It repeatedly performs integer division of the first input by the second input as long as the division results in a zero remainder. If the first input reduces to 1 after these successive divisions, the function returns 1, indicating that the original value is a complete power of the second input. Otherwise, it returns 0, signifying that such repeated division did not yield 1.",
        "code_id": "c_group_1_id_141",
        "code_text": "int divideby(int M,int d) {\n\twhile (M%d == 0) {\n\t\tM = M/d;\n\t}\n\tif (M == 1) {\n\t\treturn 1;\n\t}\n\t return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_142",
        "query_text": "The function accepts two input arrays along with their respective lengths and an output array intended to hold the convolution result, which has a length equal to the sum of the input lengths minus one. It computes a direct convolution by iterating through one array and, for each element, multiplying it by corresponding elements from the other array while accumulating the products. The function accounts for two scenarios: one where the first input array is at least as long as the second, and another where the second input array is longer. In each case, it processes the elements appropriately and stores the final accumulated sums directly into the output array. No value is returned, as the computation modifies the supplied output array in place.",
        "code_id": "c_group_1_id_142",
        "code_text": "void conv_direct(fft_type *inp1,int N, fft_type *inp2, int L,fft_type *oup) {\n\n\tint M,k,m,i;\n\tfft_type t1,tmin;\n\n\tM = N + L -1;\n\ti = 0;\n\n\tif (N >= L) {\n\n\t\tfor (k = 0; k < L; k++) {\n\t\t\toup[k] = 0.0;\n\t\t\tfor (m = 0; m <= k;m++) {\n\t\t\t\toup[k]+= inp1[m] * inp2[k-m];\n\t\t\t}\n\t\t}\n\n\t\tfor (k = L; k < M; k++) {\n\t\t\toup[k] = 0.0;\n\t\t\ti++;\n\t\t\tt1 = L + i;\n\t\t\ttmin = MIN(t1,N);\n\t\t\tfor (m = i; m < tmin;m++) {\n\t\t\t\toup[k]+= inp1[m] * inp2[k-m];\n\t\t\t}\n\t\t}\n\n\n\t} else {\n\t\tfor (k = 0; k < N; k++) {\n\t\t\toup[k] = 0.0;\n\t\t\tfor (m = 0; m <= k;m++) {\n\t\t\t\toup[k]+= inp2[m] * inp1[k-m];\n\t\t\t}\n\t\t}\n\n\t\tfor (k = N; k < M; k++) {\n\t\t\toup[k] = 0.0;\n\t\t\ti++;\n\t\t\tt1 = N + i;\n\t\t\ttmin = MIN(t1,L);\n\t\t\tfor (m = i; m < tmin;m++) {\n\t\t\t\toup[k]+= inp2[m] * inp1[k-m];\n\t\t\t}\n\t\t}\n\n\t}\n\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_143",
        "query_text": "The function accepts five parameters: two pointers to numeric arrays (one for each input array) along with two integers that specify the sizes of these arrays, as well as a pointer to a numeric array intended to store the convolution result. It first calculates the size of the output array as the sum of the two input sizes minus one, and then initializes each element of this output array to zero. The function proceeds to iterate over the range of the output array, and for each position, it sums the products of appropriate elements from the two input arrays\u2014ensuring that the indices used strictly fall within the limits of the second input array. The function does not return a value; instead, it directly modifies the output array in place.",
        "code_id": "c_group_1_id_143",
        "code_text": "void conv_directx(fft_type *inp1,int N, fft_type *inp2, int L,fft_type *oup){\n\tint M,k,n;\n\t\n\tM = N + L - 1;\n\t\n\tfor (k = 0; k < M;++k) {\n\t\toup[k] = 0.0;\n\t\tfor ( n = 0; n < N; ++n) {\n\t\t\tif ( (k-n) >= 0 && (k-n) < L ) {\n\t\t\t\toup[k]+= inp1[n] * inp2[k-n];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\t\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_144",
        "query_text": "The function takes three parameters: a pointer to an array of double-precision floating-point numbers, an integer specifying the number of elements in the array, and another pointer to an array of doubles where the result will be stored. It reverses the order of the elements from the input array such that the first element in the output array is the last element from the input array, the second element is the second-to-last, and so on. The function processes exactly the number of elements specified by the integer parameter and returns no value.",
        "code_id": "c_group_1_id_144",
        "code_text": "void copy_reverse(const double *in, int N,double *out)\n{\n    int count = 0;\n    for (count = 0; count < N; count++)\n        out[count] = in[N - count - 1];\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_145",
        "query_text": "This function accepts three parameters: an input array of type double, an integer representing the number of elements to process, and an output array of type double. The function iterates through the input array up to the specified count, copying each element into the output array so that its contents exactly mirror the input array for that range. It does not return a value.",
        "code_id": "c_group_1_id_145",
        "code_text": "void copy(const double *in, int N, double *out)\n{\n    int count = 0;\n    for (count = 0; count < N; count++)\n        out[count] = in[count];\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_146",
        "query_text": "The function takes several inputs: a pointer to an array of double-precision floating-point numbers, an integer representing the array's length, two pointers to arrays containing filter coefficients (one for low-pass and one for high-pass), an integer specifying the number of filter coefficients, a pointer to an output array for the approximation coefficients, an integer indicating the length of this output, a pointer to an output array for the detail coefficients, and two integers that define the stride for reading input and writing output. The function processes the input array by sliding a window\u2014with a center offset derived from the filter length\u2014across the data. For each position, it computes two weighted sums: one using the low-pass coefficients to produce an approximation coefficient and the other using the high-pass coefficients to produce a detail coefficient. If the filter window reaches beyond the bounds of the input array, the function handles the situation by wrapping or mirroring the input, depending on whether the length of the input array is even or odd. The computed values are then stored directly into the provided output arrays.",
        "code_id": "c_group_1_id_146",
        "code_text": "void dwt_per_stride(double *inp, int N, double *lpd,double*hpd,int lpd_len,double *cA, int len_cA, double *cD, int istride, int ostride) {\n\tint l, l2, isodd, i, t, len_avg,is,os;\n\n\tlen_avg = lpd_len;\n\tl2 = len_avg / 2;\n\tisodd = N % 2;\n\n\tfor (i = 0; i < len_cA; ++i) {\n\t\tt = 2 * i + l2;\n\t\tos = i *ostride;\n\t\tcA[os] = 0.0;\n\t\tcD[os] = 0.0;\n\t\tfor (l = 0; l < len_avg; ++l) {\n\t\t\tif ((t - l) >= l2 && (t - l) < N) {\n\t\t\t\tis = (t - l) * istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - l) < l2 && (t - l) >= 0) {\n\t\t\t\tis = (t - l) * istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - l) < 0 && isodd == 0) {\n\t\t\t\tis = (t - l + N) * istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - l) < 0 && isodd == 1) {\n\t\t\t\tif ((t - l) != -1) {\n\t\t\t\t\tis = (t - l + N + 1) * istride;\n\t\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tis = (N - 1) * istride;\n\t\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((t - l) >= N && isodd == 0) {\n\t\t\t\tis = (t - l - N) * istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - l) >= N && isodd == 1) {\n\t\t\t\tis = (t - l - (N + 1)) * istride;\n\t\t\t\tif (t - l != N) {\n\t\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tis = (N - 1) * istride;\n\t\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_147",
        "query_text": "This function processes an array of double-precision floating-point numbers to produce a downsampled version of the array. It takes as inputs a pointer to a floating-point array, the length of that array, an integer specifying the sampling interval, and a pointer to an output array. If the sampling interval is negative, the function immediately returns an error code (-1). When the interval is zero, the function copies each element from the input array to the output array and returns the original array length. For a positive interval, it calculates the length of the resulting downsampled array, then selects elements from the input array at positions determined by the interval, storing them in the output array. Finally, it returns the length of the downsampled array.",
        "code_id": "c_group_1_id_147",
        "code_text": "int downsamp(double *x, int lenx, int M, double *y) {\n\tint N, i;\n\n\tif (M < 0) {\n\t\treturn -1;\n\t}\n\tif (M == 0) {\n\t\tfor (i = 0; i < lenx; ++i) {\n\t\t\ty[i] = x[i];\n\t\t}\n\t\treturn lenx;\n\t}\n\n\tN = (lenx - 1) / M + 1;\n\n\tfor (i = 0; i < N; ++i) {\n\t\ty[i] = x[i*M];\n\t}\n\n\treturn N;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_148",
        "query_text": "The function takes an input array of double values and an integer indicating its length, along with an integer offset and an output array for storing results. It first copies the input array into the output array starting at the specified offset. If the length of the input array is odd, it duplicates the last element to ensure an even count. The function then extends the section of the output array by mirroring the copied values to both the beginning (before the offset) and the end (after the extended segment), thereby creating a symmetric, periodic repetition of the signal. Finally, the function returns an integer representing the length of the extended signal, which is either equal to the original length or incremented by one if the input length was odd.",
        "code_id": "c_group_1_id_148",
        "code_text": "int per_ext(double *sig, int len, int a, double *oup) {\n\tint i, len2;\n\tdouble temp1;\n\tdouble temp2;\n\tfor (i = 0; i < len; ++i) {\n\t\toup[a + i] = sig[i];\n\t}\n\tlen2 = len;\n\tif ((len % 2) != 0) {\n\t\tlen2 = len + 1;\n\t\toup[a + len] = sig[len - 1];\n\t}\n\tfor (i = 0; i < a; ++i) {\n\t\ttemp1 = oup[a + i];\n\t\ttemp2 = oup[a + len2 - 1 - i];\n\t\toup[a - 1 - i] = temp2;\n\t\toup[len2 + a + i] = temp1;\n\t}\n\treturn len2;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_149",
        "query_text": "The function takes four inputs: a double-precision floating-point array containing the original data, an integer denoting the number of elements in this array, an integer that specifies a position index used for the symmetric extension, and another double-precision floating-point array designated for the output. The function first copies the elements of the original array into a specific segment of the output array starting at the given index. It then mirrors these copied elements around this segment to achieve a symmetric extension of the input data. Finally, the function returns an integer corresponding to the length of the original input array.",
        "code_id": "c_group_1_id_149",
        "code_text": "int symm_ext(double *sig, int len, int a, double *oup) {\n\tint i, len2;\n\tdouble temp1;\n\tdouble temp2;\n\t\n\tfor (i = 0; i < len; ++i) {\n\t\toup[a + i] = sig[i];\n\t}\n\tlen2 = len;\n\tfor (i = 0; i < a; ++i) {\n\t\ttemp1 = oup[a + i];\n\t\ttemp2 = oup[a + len2 - 1 - i];\n\t\toup[a - 1 - i] = temp1;\n\t\toup[len2 + a + i] = temp2;\n\t}\n\n\treturn len2;\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_150",
        "query_text": "This function reconstructs signal coefficients from a set of wavelet coefficients using either periodic or symmetric signal extension methods. It accepts as input an array of wavelet coefficients along with their corresponding lengths for various levels of decomposition, a string indicating whether the coefficients represent approximations or details, and another string specifying the extension method. Additional inputs include the level of decomposition, parameters related to the filter such as the low-pass and high-pass coefficients and the filter length, and the overall signal length. The function iteratively processes the coefficients through successive filtering operations, performing computations that adjust the coefficients based on the selected extension method. Memory is dynamically allocated for intermediate buffers during these computations, and proper cleanup is ensured before the function outputs the final array of reconstructed coefficients.",
        "code_id": "c_group_1_id_150",
        "code_text": "static void getDWTRecCoeff(double *coeff, int *length, const char *ctype, const char *ext, int level, int J, double *lpr,\n\tdouble *hpr, int lf, int siglength, double *reccoeff) {\n\n\tint i, j, k, det_len, N, l, m, n, v, t, l2;\n\tdouble *out, *X_lp, *filt;\n\tout = (double*)malloc(sizeof(double)* (siglength + 1));\n\tl2 = lf / 2;\n\tm = -2;\n\tn = -1;\n\tif (!strcmp(ext, \"per\")) {\n\t\tif (!strcmp((ctype), \"appx\")) {\n\t\t\tdet_len = length[0];\n\t\t}\n\t\telse {\n\t\t\tdet_len = length[J - level + 1];\n\t\t}\n\n\t\tN = 2 * length[J];\n\n\t\tX_lp = (double*)malloc(sizeof(double)* (N + 2 * lf - 1));\n\n\t\tfor (i = 0; i < det_len; ++i) {\n\t\t\tout[i] = coeff[i];\n\t\t}\n\n\t\tfor (j = level; j > 0; --j) {\n\n\t\t\tif (!strcmp((ctype), \"det\") && j == level) {\n\t\t\t\tfilt = hpr;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfilt = lpr;\n\t\t\t}\n\n\t\t\tm = -2;\n\t\t\tn = -1;\n\n\t\t\tfor (i = 0; i < det_len + l2 - 1; ++i) {\n\t\t\t\tm += 2;\n\t\t\t\tn += 2;\n\t\t\t\tX_lp[m] = 0.0;\n\t\t\t\tX_lp[n] = 0.0;\n\t\t\t\tfor (l = 0; l < l2; ++l) {\n\t\t\t\t\tt = 2 * l;\n\t\t\t\t\tif ((i - l) >= 0 && (i - l) < det_len) {\n\t\t\t\t\t\tX_lp[m] += filt[t] * out[i - l];\n\t\t\t\t\t\tX_lp[n] += filt[t + 1] * out[i - l];\n\t\t\t\t\t}\n\t\t\t\t\telse if ((i - l) >= det_len && (i - l) < det_len + lf - 1) {\n\t\t\t\t\t\tX_lp[m] += filt[t] * out[i - l - det_len];\n\t\t\t\t\t\tX_lp[n] += filt[t + 1] * out[i - l - det_len];\n\t\t\t\t\t}\n\t\t\t\t\telse if ((i - l) < 0 && (i - l) > -l2) {\n\t\t\t\t\t\tX_lp[m] += filt[t] * out[det_len + i - l];\n\t\t\t\t\t\tX_lp[n] += filt[t + 1] * out[det_len + i - l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (k = lf / 2 - 1; k < 2 * det_len + lf / 2 - 1; ++k) {\n\t\t\t\tout[k - lf / 2 + 1] = X_lp[k];\n\t\t\t}\n\n\t\t\tif (j != 1) {\n\t\t\t\tdet_len = length[J - j + 2];\n\t\t\t}\n\t\t}\n\n\t\tfree(X_lp);\n\n\t}\n\telse if (!strcmp(ext, \"sym\")) {\n\t\tif (!strcmp((ctype), \"appx\")) {\n\t\t\tdet_len = length[0];\n\t\t}\n\t\telse {\n\t\t\tdet_len = length[J - level + 1];\n\t\t}\n\n\t\tN = 2 * length[J] - 1;\n\n\t\tX_lp = (double*)malloc(sizeof(double)* (N + 2 * lf - 1));\n\n\t\tfor (i = 0; i < det_len; ++i) {\n\t\t\tout[i] = coeff[i];\n\t\t}\n\n\t\tfor (j = level; j > 0; --j) {\n\n\t\t\tif (!strcmp((ctype), \"det\") && j == level) {\n\t\t\t\tfilt = hpr;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfilt = lpr;\n\t\t\t}\n\n\t\t\tm = -2;\n\t\t\tn = -1;\n\n\t\t\tfor (v = 0; v < det_len; ++v) {\n\t\t\t\ti = v;\n\t\t\t\tm += 2;\n\t\t\t\tn += 2;\n\t\t\t\tX_lp[m] = 0.0;\n\t\t\t\tX_lp[n] = 0.0;\n\t\t\t\tfor (l = 0; l < lf / 2; ++l) {\n\t\t\t\t\tt = 2 * l;\n\t\t\t\t\tif ((i - l) >= 0 && (i - l) < det_len) {\n\t\t\t\t\t\tX_lp[m] += filt[t] * out[i - l];\n\t\t\t\t\t\tX_lp[n] += filt[t + 1] * out[i - l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (k = lf - 2; k < 2 * det_len; ++k) {\n\t\t\t\tout[k - lf + 2] = X_lp[k];\n\t\t\t}\n\n\n\t\t\tif (j != 1) {\n\t\t\t\tdet_len = length[J - j + 2];\n\t\t\t}\n\t\t}\n\n\t\tfree(X_lp);\n\n\t}\n\telse {\n\t\tprintf(\"Signal extension can be either per or sym\");\n\t\texit(-1);\n\t}\n\n\tfor (i = 0; i < siglength; ++i) {\n\t\treccoeff[i] = out[i];\n\t}\n\n\tfree(out);\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_151",
        "query_text": "The function takes an integer as its input and produces an integer as its output. It computes 2 raised to the power specified by the input by initializing a base value to 1 and then multiplying it by 2 iteratively for a number of times equal to the input value. The final computed value is eventually returned as the output.",
        "code_id": "c_group_1_id_151",
        "code_text": "static int ipow2(int n) {\n\tint p,i;\n\tp = 1;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tp *= 2;\n\t}\n\n\treturn p;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_152",
        "query_text": "The function accepts two parameters: one is a reference to an input stream, and the other is a reference to a two-element tuple containing integers. It reads an integer from the stream, then discards a single character serving as a separator, and subsequently reads a second integer. The function stores these values in the tuple and returns the modified input stream, allowing for chaining of input operations.",
        "code_id": "c_group_1_id_152",
        "code_text": "std::istream& operator>>(std::istream& is, std::tuple<int, int>& ints)\n{\n    is >> std::get<0>(ints);\n    is.get();\n    is >> std::get<1>(ints);\n    return is;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_153",
        "query_text": "The function takes an unsigned 64-bit integer as input and returns an integer representing the number of contiguous zero bits at the least significant end of its binary representation. It is marked as noexcept, ensuring that no exceptions are thrown during execution. Internally, the function leverages a compiler-specific intrinsic to efficiently perform the bit-counting operation. It is important to note that if the input is zero, the behavior is undefined.",
        "code_id": "c_group_1_id_153",
        "code_text": "inline STRF_HD int countr_zero_ll(unsigned long long x) noexcept\n{\n    return __builtin_ctzll(x);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_154",
        "query_text": "This function accepts a 64\u2011bit unsigned integer as input and returns an integer value between 0 and 64. It examines the binary representation of the input and counts the number of leading zero bits before the first set bit. If the input is zero (all bits zero), the function returns 64. Otherwise, it uses a sequence of nested conditional checks to efficiently locate the most significant set bit and calculates the count of zeros preceding it. Additionally, the function is declared as a compile\u2011time constant expression, allowing its evaluation during compilation when provided with constant expressions.",
        "code_id": "c_group_1_id_154",
        "code_text": "constexpr int slow_countl_zero_ll(std::uint64_t x)\n{\n    if (x <= 0xffffffffULL) {\n        if (x <= 0xffffULL) {\n            if (x <= 0xffULL) {\n                if (x <= 0xfULL) {\n                    if (x <= 3U) {\n                        if (x == 0) {\n                            return 64;\n                        }\n                        return x <= 1U ? 63 : 62;\n                    }\n                    return x <= 7U ? 61 : 60;\n                }\n                if (x <= 0x3fU) {\n                    return x <= 0x1fU ? 59 : 58;\n                }\n                return x <= 0x7fU ? 57 : 56;\n            }\n            if (x <= 0xfffULL) {\n                if (x <= 0x3ffULL) {\n                    return x <= 0x1ffULL ? 55 :54;\n                }\n                return x <= 0x7ffULL ? 53 : 52;\n            }\n            if (x <= 0x3fffULL) {\n                return x <= 0x1fffULL ? 51 :50;\n            }\n            return x <= 0x7fffULL ? 49 : 48;\n        }\n        if (x <= 0xffffffULL) {\n            if (x <= 0xfffffULL) {\n                if (x <= 0x3ffffULL) {\n                    return x <= 0x1ffffULL ? 47 : 46;\n                }\n                return x <= 0x7ffffULL ? 45 : 44;\n            }\n            if (x <= 0x3fffffULL) {\n                return x <= 0x1fffffULL ? 43 : 42 ;\n            }\n            return x <= 0x7fffffULL ? 41 : 40 ;\n        }\n        if (x <= 0xfffffffULL) {\n            if (x <= 0x3ffffffULL) {\n                return x <= 0x1ffffffULL ? 39 : 38 ;\n            }\n            return x <= 0x7ffffffULL ? 37 : 36;\n        }\n        if (x <= 0x3fffffffULL) {\n            return x <= 0x1fffffffULL ? 35 : 34;\n        }\n        return x <= 0x7fffffffULL ? 33 : 32;\n    }\n    if (x <= 0xffffffffffffULL) {\n        if (x <= 0xffffffffffULL) {\n            if (x <= 0xfffffffffULL) {\n                if (x <= 0x3ffffffffULL) {\n                    return x <= 0x1ffffffffULL ? 31 : 30;\n                }\n                return x <= 0x7ffffffffULL ? 29 : 28;\n            }\n            if (x <= 0x3fffffffffULL) {\n                return x <= 0x1fffffffffULL ? 27 : 26;\n            }\n            return x <= 0x7fffffffffULL ? 25 : 24;\n        }\n        if (x <= 0xfffffffffffULL) {\n            if (x <= 0x3ffffffffffULL) {\n                return x <= 0x1ffffffffffULL ? 23 : 22;\n            }\n            return x <= 0x7ffffffffffULL ? 21 : 20;\n        }\n        if (x <= 0x3fffffffffffULL) {\n            return x <= 0x1fffffffffffULL ? 19 : 18;\n        }\n        return x <= 0x7fffffffffffULL ? 17 : 16;\n    }\n    if (x <= 0xffffffffffffffULL) {\n        if (x <= 0xfffffffffffffULL) {\n            if (x <= 0x3ffffffffffffULL) {\n                return x <= 0x1ffffffffffffULL ? 15 : 14;\n            }\n            return x <= 0x7ffffffffffffULL ? 13 : 12;\n        }\n        if (x <= 0x3fffffffffffffULL) {\n            return x <= 0x1fffffffffffffULL ? 11 : 10 ;\n        }\n        return x <= 0x7fffffffffffffULL ? 9 : 8 ;\n    }\n    if (x <= 0xfffffffffffffffULL) {\n        if (x <= 0x3ffffffffffffffULL) {\n            return x <= 0x1ffffffffffffffULL ? 7 : 6 ;\n        }\n        return x <= 0x7ffffffffffffffULL ? 5 : 4;\n    }\n    if (x <= 0x3fffffffffffffffULL) {\n        return x <= 0x1fffffffffffffffULL ? 3 : 2;\n    }\n    return x <= 0x7fffffffffffffffULL ? 1 : 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_155",
        "query_text": "The function takes three unsigned integers as input. It shifts the first input left by 12 bits, shifts the lower 6 bits of the second integer left by 6 bits, and then combines these results with the lower 6 bits of the third input using bitwise OR operations. The function returns a single unsigned integer encapsulating the combined bit pattern from the three inputs.",
        "code_id": "c_group_1_id_155",
        "code_text": "inline STRF_HD unsigned utf8_decode_last_2_of_4(unsigned x, unsigned ch2, unsigned ch3)\n{\n    return (x << 12) | ((ch2 & 0x3F) <<  6) | (ch3 & 0x3F);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_156",
        "query_text": "The function takes no input arguments and returns a pointer to a statically allocated constant character array. This array holds a concatenated sequence of two-digit numbers in ascending order from \"00\" to \"99\". The function is declared as inline and guarantees no exceptions, with the return type being const char*. Its purpose is to provide quick access to a precomputed lookup table that can be utilized for efficient string formatting or similar operations.",
        "code_id": "c_group_1_id_156",
        "code_text": "inline STRF_HD const char* chars_00_to_99() noexcept\n{\n    static const char array[] =\n        \"00010203040506070809\"\n        \"10111213141516171819\"\n        \"20212223242526272829\"\n        \"30313233343536373839\"\n        \"40414243444546474849\"\n        \"50515253545556575859\"\n        \"60616263646566676869\"\n        \"70717273747576777879\"\n        \"80818283848586878889\"\n        \"90919293949596979899\";\n\n    return array;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_157",
        "query_text": "This function takes a single character input and determines whether it represents a numerical digit. The input, of type char, is examined to see if it lies between the characters '0' and '9' inclusive. If the character is within this range, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_157",
        "code_text": "static inline bool is_integer(char c) {\n  return (c >= '0' && c <= '9');\n  \n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_158",
        "query_text": "The function accepts two inputs: a constant character pointer representing the input string, and a pointer to a double where the parsed floating-point value will be stored. It converts the numeric portion of the input string to a double-precision floating-point number, employing platform-specific variants that utilize appropriate locale settings for accurate parsing. If the conversion succeeds and the resulting value is finite (i.e., not infinity or NaN), the function returns a pointer to the character immediately following the parsed number in the input string; otherwise, it returns a null pointer.",
        "code_id": "c_group_1_id_158",
        "code_text": "static const char * parse_float_strtod(const char *ptr, double *outDouble) {\n  char *endptr;\n#if defined(FAST_DOUBLE_PARSER_SOLARIS) || defined(FAST_DOUBLE_PARSER_CYGWIN) \n  \n  *outDouble = cygwin_strtod_l(ptr, &endptr);\n#elif defined(_WIN32)\n  static _locale_t c_locale = _create_locale(LC_ALL, \"C\");\n  *outDouble = _strtod_l(ptr, &endptr, c_locale);\n#elif defined(__PASE__)\n  *outDouble = strtod(ptr, &endptr);\n#else\n  static locale_t c_locale = newlocale(LC_ALL_MASK, \"C\", NULL);\n  *outDouble = strtod_l(ptr, &endptr, c_locale);\n#endif\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if (!std::isfinite(*outDouble)) {\n    return nullptr;\n  }\n  return endptr;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_159",
        "query_text": "The function accepts a 64-bit unsigned integer as input and returns a 64-bit unsigned integer as output. It processes the input through multiple stages of transformation. Initially, the function applies a bitwise XOR combined with a right-shift operation. It then multiplies the intermediate value by a predefined constant. This sequence is repeated: after a second XOR shift, another multiplication with a different constant is performed, followed by a final XOR shift. The resulting value from these operations is returned as the function's output.",
        "code_id": "c_group_1_id_159",
        "code_text": "static inline uint64_t rng(uint64_t h) {\n  h ^= h >> 33;\n  h *= UINT64_C(0xff51afd7ed558ccd);\n  h ^= h >> 33;\n  h *= UINT64_C(0xc4ceb9fe1a85ec53);\n  h ^= h >> 33;\n  return h;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_160",
        "query_text": "The function receives a single-precision floating-point value as its input and returns a 32-bit integer. It performs the conversion by loading the input into a SIMD register and then using a dedicated SSE2 instruction to round the floating-point value to the nearest integer efficiently. The input is of type float, and the output is of type int.",
        "code_id": "c_group_1_id_160",
        "code_text": "static inline int\n#ifdef USE_TARGET_ATTRIBUTE\n__attribute__((target(\"sse2\")))\n#endif\npsf_lrintf (float x)\n{\n\treturn _mm_cvtss_si32 (_mm_load_ss (&x)) ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_161",
        "query_text": "The function accepts a double-precision floating-point number (type double) as input and returns a 32-bit signed integer (type int) as output. Internally, it leverages hardware-accelerated SIMD instructions available in the SSE2 instruction set to load the input value and directly convert it to an integer with accurate rounding to the nearest whole number. This efficient use of SIMD instructions ensures high-performance processing of the floating-point to integer conversion.",
        "code_id": "c_group_1_id_161",
        "code_text": "static inline int\n#ifdef USE_TARGET_ATTRIBUTE\n__attribute__((target(\"sse2\")))\n#endif\npsf_lrint (double x)\n{\n\treturn _mm_cvtsd_si32 (_mm_load_sd (&x)) ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_162",
        "query_text": "The function takes a double-precision floating-point number as input and returns an integer. It verifies whether the input lies within a valid range defined by a predetermined constant. Specifically, the function checks if the input is less than the reciprocal of this constant or greater than the constant itself. If the input falls outside this range, the function returns a non-zero value to indicate an invalid condition; otherwise, it returns zero, signifying that the input is within the acceptable bounds.",
        "code_id": "c_group_1_id_162",
        "code_text": "static inline int\nis_bad_src_ratio (double ratio)\n{\treturn (ratio < (1.0 / SRC_MAX_RATIO) || ratio > (1.0 * SRC_MAX_RATIO)) ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_163",
        "query_text": "The function accepts two integer parameters: the first is a non-negative integer, and the second is a positive integer. It calculates the ceiling of the division of the first parameter by the second, ensuring that any fractional result is rounded up to the next whole number. The function returns the computed result as an integer.",
        "code_id": "c_group_1_id_163",
        "code_text": "static inline int\nint_div_ceil (int divident, int divisor) \n{\tassert (divident >= 0 && divisor > 0) ; \n\treturn (divident + (divisor - 1)) / divisor ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_164",
        "query_text": "The function takes a single integer input that acts as a reset flag and returns an integer output corresponding to a block length. It maintains an internal state representing a fixed sequence of block lengths. When the reset flag is non-zero, the internal state is reinitialized so that the next output comes from the start of the sequence. When the reset flag is zero, the function outputs the subsequent block length in the sequence, wrapping around to the beginning once the end is reached.",
        "code_id": "c_group_1_id_164",
        "code_text": "static int\nnext_block_length (int reset)\n{\tstatic int block_lengths [] = \n\t{\t\n\t\t5, 400, 10, 300, 20, 200, 50, 100, 70\n\t\t} ;\n\tstatic int block_len_index = 0 ;\n\n\tif (reset)\n\t\tblock_len_index = 0 ;\n\telse\n\t\tblock_len_index = (block_len_index + 1) % ARRAY_LEN (block_lengths) ;\n\n\treturn block_lengths [block_len_index] ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_165",
        "query_text": "This function provides a static buffer of floats and its size to the caller. It takes two inputs: a generic pointer (unused) and a pointer to a pointer to a float. The function assigns the static float buffer to the provided pointer-to-pointer, enabling external access to the buffer. Finally, it returns the number of elements in the buffer as a long integer.",
        "code_id": "c_group_1_id_165",
        "code_text": "static long\ninput_callback (void *cb_data, float **data)\n{\n\tstatic float buffer [20] ;\n\n\t(void) cb_data ;\n\t*data = buffer ;\n\n\treturn ARRAY_LEN (buffer) ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_166",
        "query_text": "The function takes no arguments and returns no value. It conditionally disables logging by checking for a specific preprocessor directive. If the directive is defined, the function sets a flag to 0 to turn off logging; otherwise, it leaves the logging functionality unchanged.",
        "code_id": "c_group_1_id_166",
        "code_text": "void wolfSSL_Debugging_OFF(void)\n{\n#ifdef DEBUG_WOLFSSL\n    loggingEnabled = 0;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_167",
        "query_text": "The function takes a constant character string as input and, when a specific debugging flag is enabled, assigns the input string to an internal logging prefix used for debug output. If the debugging flag is not enabled, the input is disregarded and no action is taken. The function does not produce a return value.",
        "code_id": "c_group_1_id_167",
        "code_text": "void wolfSSL_SetLoggingPrefix(const char* prefix)\n{\n#ifdef DEBUG_WOLFSSL\n    log_prefix = prefix;\n#else\n    (void)prefix;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_168",
        "query_text": "The function accepts one input: a character. It outputs a signed 8-bit integer, representing the corresponding numeric value of the input if it is a valid hexadecimal digit (i.e. '0'-'9', 'A'-'F', or 'a'-'f'). If the character is not a valid hexadecimal digit, the function returns -1. The input type is char, while the output type is a signed char.",
        "code_id": "c_group_1_id_168",
        "code_text": "WC_MISC_STATIC WC_INLINE signed char HexCharToByte(char ch)\n{\n    signed char ret = (signed char)ch;\n    if (ret >= '0' && ret <= '9')\n        ret = (signed char)(ret - '0');\n    else if (ret >= 'A' && ret <= 'F')\n        ret = (signed char)(ret - ('A' - 10));\n    else if (ret >= 'a' && ret <= 'f')\n        ret = (signed char)(ret - ('a' - 10));\n    else\n        ret = -1; \n    return ret;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_169",
        "query_text": "This function examines an input character to determine if it qualifies as a whitespace character. It accepts a character (of type char) and checks if it is either a space, a tab, or a newline. If the character matches any of these, the function returns an integer value of 1; otherwise, it returns 0. The output is of type int, signifying a boolean-like indicator for whitespace detection.",
        "code_id": "c_group_1_id_169",
        "code_text": "WC_MISC_STATIC WC_INLINE int CharIsWhiteSpace(char ch)\n{\n    switch (ch) {\n        case ' ':\n        case '\\t':\n        case '\\n':\n            return 1;\n        default:\n            return 0;\n    }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_170",
        "query_text": "The function accepts an array of unsigned characters, represented by a pointer, along with an integer that specifies the length of this array. It checks whether the provided pointer is NULL; if it is, the function immediately terminates without making any modifications. Otherwise, it reverses the elements in the array in place by swapping the first element with the last, the second element with the second-to-last, and continuing this process until the entire array is reversed. The function does not return any value.",
        "code_id": "c_group_1_id_170",
        "code_text": "void mp_reverse(unsigned char *s, int len)\n{\n    int ix, iy;\n\n    if (s == NULL)\n        return;\n\n    ix = 0;\n    iy = len - 1;\n    while (ix < iy) {\n        unsigned char t = s[ix];\n        s[ix] = s[iy];\n        s[iy] = t;\n        ++ix;\n        --iy;\n    }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_171",
        "query_text": "The function is a void function that accepts no input parameters and returns no value. It initializes the error handling mechanism of the library by loading a set of predefined error strings. These error messages allow for error codes generated during execution to be translated into meaningful, human-readable descriptions.",
        "code_id": "c_group_1_id_171",
        "code_text": "void wolfSSL_load_error_strings(void)\n{\n    \n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_172",
        "query_text": "The function accepts a single unsigned long integer that represents an error code and returns a pointer to a constant character string. It is designed to generate a human-readable description of the library associated with the provided error code. When a specific compile-time flag is enabled, the function extracts a library identifier from the error code and then checks this identifier against known values. If it matches one of the predefined identifiers (such as those corresponding to routines for handling specific file formats or cryptographic operations), it returns a descriptive string for that library routine. If the identifier is unrecognized or the compile-time flag is not enabled, the function simply returns an empty string. This mechanism is primarily utilized for error logging and debugging purposes.",
        "code_id": "c_group_1_id_172",
        "code_text": "const char* wolfSSL_ERR_lib_error_string(unsigned long e)\n{\n    int libe = 0;\n\n    (void)libe;\n    (void)e;\n\n#if defined(OPENSSL_EXTRA)\n    libe = wolfSSL_ERR_GET_LIB(e);\n    switch (libe) {\n    case WOLFSSL_ERR_LIB_PEM:\n        return \"wolfSSL PEM routines\";\n    case WOLFSSL_ERR_LIB_EVP:\n        return \"wolfSSL digital envelope routines\";\n    default:\n        return \"\";\n    }\n#else\n    return \"\";\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_173",
        "query_text": "The function accepts two pointer inputs: one pointing to the start of a character array and the other pointing to its end. It sequentially examines each character from the beginning, skipping any occurrence of carriage return ('\\r') or newline ('\\n'). The function returns the pointer to the first character that is not a line-ending character.",
        "code_id": "c_group_1_id_173",
        "code_text": "static WC_INLINE const char* SkipEndOfLineChars(const char* line,\n                                                const char* endOfLine)\n{\n    \n    while (line < endOfLine &&\n              (line[0] == '\\r' || line[0] == '\\n')) {\n        line++;\n    }\n    return line;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_174",
        "query_text": "The function takes an integer input representing an alert type and logs a formatted alert message if debug mode is enabled. It first converts the integer to a string using a helper routine; if the conversion is successful, it incorporates the string into a predefined message format and logs the result. When debug mode is not enabled, the input is disregarded and no logging occurs. The function does not produce a return value.",
        "code_id": "c_group_1_id_174",
        "code_text": "static void LogAlert(int type)\n{\n#ifdef DEBUG_WOLFSSL\n    const char* typeStr;\n\n    typeStr = AlertTypeToString(type);\n    if (typeStr != NULL) {\n        char buff[60];\n        if (XSNPRINTF(buff, sizeof(buff), \"Alert type: %s\", typeStr)\n            >= (int)sizeof(buff))\n        {\n            buff[sizeof(buff) - 1] = 0;\n        }\n        WOLFSSL_MSG(buff);\n    }\n#else\n    (void)type;\n#endif \n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_175",
        "query_text": "The function takes two inputs: an integer representing an error value and a socket descriptor (which is often unused). It returns an integer that represents the last error code for a socket operation, following the platform-specific error retrieval mechanism. If the input error value is positive, the function returns 0 to indicate the absence of an error. Otherwise, it determines and returns the appropriate error code based on the current platform's implementation (such as for Windows, Linux kernel mode, or various embedded systems).",
        "code_id": "c_group_1_id_175",
        "code_text": "static WC_INLINE int wolfSSL_LastError(int err, SOCKET_T sd)\n{\n    (void)sd;\n\n    if (err > 0)\n        return 0;\n\n#ifdef USE_WINDOWS_API\n    return WSAGetLastError();\n#elif defined(EBSNET)\n    return xn_getlasterror();\n#elif defined(WOLFSSL_LINUXKM) || defined(WOLFSSL_EMNET)\n    return -err; \n#elif defined(FUSION_RTOS)\n    #include <fclerrno.h>\n    return FCL_GET_ERRNO;\n#elif defined(NUCLEUS_PLUS_2_3)\n    return Nucleus_Net_Errno;\n#elif defined(FREESCALE_MQX) || defined(FREESCALE_KSDK_MQX)\n    if ((err == 0) || (err == -SOCKET_EWOULDBLOCK)) {\n        return SOCKET_EWOULDBLOCK; \n    } else {\n        err = RTCS_geterror(sd);\n        if ((err == RTCSERR_TCP_CONN_CLOSING) ||\n            (err == RTCSERR_TCP_CONN_RLSD))\n        {\n            err = SOCKET_ECONNRESET;\n        }\n        return err;\n    }\n#elif defined(WOLFSSL_EMNET)\n    \n    IP_SOCK_getsockopt(sd, SOL_SOCKET, SO_ERROR, &err, (int)sizeof(old));\n    return err;\n#else\n    return errno;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_176",
        "query_text": "The function takes an input\u2014a constant C-string pointer that represents a directory path\u2014and attempts to remove the directory. It uses a platform-specific system call: on Windows (compiled with MSVC), it invokes one removal function; on other platforms, it uses a different standard removal function. If the removal is successful, the function returns 0; if it fails, the function returns -1. The input type is a const char pointer and the output type is an int.",
        "code_id": "c_group_1_id_176",
        "code_text": "int rem_dir(const char* dirName)\n{\n#ifdef _MSC_VER\n    if (_rmdir(dirName) != 0)\n        return -1;\n#else\n    if (rmdir(dirName) != 0)\n        return -1;\n#endif\n    return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_177",
        "query_text": "This function removes a file from the file system based on a provided string that specifies the file's name. It utilizes platform-specific system calls: on certain Windows compilers, it employs one call, whereas on other systems it uses an alternative call. If the deletion operation completes successfully, the function returns 0; if it fails, the function returns -1 to signal an error.",
        "code_id": "c_group_1_id_177",
        "code_text": "int rem_file(const char* fileName)\n{\n#ifdef _MSC_VER\n    if (_unlink(fileName) != 0)\n        return -1;\n#else\n    if (unlink(fileName) != 0)\n        return -1;\n#endif\n    return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_178",
        "query_text": "The function generates a formatted string that lists supported protocol versions and optional feature flags, and then prints this string to the console. It begins by initializing a fixed-size character array with zeros and then conditionally appends version identifiers (such as \"0:\", \"1:\", \"2:\", etc.) based on preprocessor definitions. Depending on the compilation configuration, it may also append additional markers like a downgrade flag or an either-side flag. The function does not accept any input parameters and does not return any value.",
        "code_id": "c_group_1_id_178",
        "code_text": "static void ShowVersions(void)\n{\n    char verStr[100];\n    XMEMSET(verStr, 0, sizeof(verStr));\n#ifndef NO_OLD_TLS\n    #ifdef WOLFSSL_ALLOW_SSLV3\n        XSTRNCAT(verStr, \"0:\", 3);\n    #endif\n    #ifdef WOLFSSL_ALLOW_TLSV10\n        XSTRNCAT(verStr, \"1:\", 3);\n    #endif\n    XSTRNCAT(verStr, \"2:\", 3);\n#endif \n#ifndef WOLFSSL_NO_TLS12\n    XSTRNCAT(verStr, \"3:\", 3);\n#endif\n#ifdef WOLFSSL_TLS13\n    XSTRNCAT(verStr, \"4:\", 3);\n#endif\n    XSTRNCAT(verStr, \"d(downgrade):\", 14);\n#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EITHER_SIDE)\n    XSTRNCAT(verStr, \"e(either):\", 11);\n#endif\n    \n    printf(\"%s\\n\", verStr);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_179",
        "query_text": "The function takes a pointer to an integer, representing a socket file descriptor, as its input. It first checks whether the socket is open by examining if the integer is not equal to -1. If the socket is open, the function proceeds to close the socket and then sets the file descriptor to -1 to mark it as invalid. Additionally, under a specific compilation condition, it resets a global status flag to 0. The function does not return any value; its main purpose is to safely close and clean up the socket.",
        "code_id": "c_group_1_id_179",
        "code_text": "static void CloseAndCleanupSocket(int* sockFd)\n{\n    if (*sockFd != -1) {\n        close(*sockFd);\n        *sockFd = -1;\n    }\n#ifdef WOLFSSL_DTLS\n    DoneHandShake = 0;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_180",
        "query_text": "The function takes a pointer to an integer as input. It begins by checking if the integer value is not equal to -1. If this condition is met, the function closes the resource associated with this value (such as a file descriptor or socket) and then resets the value to -1 to indicate the resource is no longer active. The function does not return a value.",
        "code_id": "c_group_1_id_180",
        "code_text": "static void CloseAndCleanupListenSocket(int* listenFd)\n{\n    if (*listenFd != -1) {\n        close(*listenFd);\n        *listenFd = -1;\n    }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_181",
        "query_text": "The function accepts a pointer to a double value representing a numerical quantity, and returns a constant C-string indicating a unit of measurement. It first evaluates compile-time flags to determine if a fixed unit should be used\u2014dividing the value accordingly by factors of 1,000,000,000, 1,000,000, or 1,000 for gigabytes, megabytes, or kilobytes respectively, or leaving the value unchanged for bytes. If no fixed unit is specified at compile time, the function adjusts the input value at runtime based on its magnitude: values larger than one million are scaled to megabytes, values larger than one thousand to kilobytes, and values below this threshold remain in bytes. Finally, a constant string denoting the unit (\"GB\", \"MB\", \"KB\", or \"bytes\") is returned.",
        "code_id": "c_group_1_id_181",
        "code_text": "static const char* get_blocktype_base10(double* blocks)\n{\n    const char* rt;\n\n#if (  defined(WOLFSSL_BENCHMARK_FIXED_UNITS_G) || \\\n       defined(WOLFSSL_BENCHMARK_FIXED_UNITS_GB))\n    *blocks /= (1000UL * 1000UL * 1000UL);\n    rt = \"GB\";\n#elif (defined(WOLFSSL_BENCHMARK_FIXED_UNITS_M) || \\\n       defined(WOLFSSL_BENCHMARK_FIXED_UNITS_MB))\n    *blocks /= (1000UL * 1000UL);\n    rt = \"MB\";\n#elif (defined(WOLFSSL_BENCHMARK_FIXED_UNITS_K) || \\\n       defined(WOLFSSL_BENCHMARK_FIXED_UNITS_KB))\n    *blocks /= (1000UL);\n    rt = \"KB\";\n#elif     defined (WOLFSSL_BENCHMARK_FIXED_UNITS_B)\n    (void)(*blocks); \n    rt = \"bytes\";\n#else\n    \n    if (*blocks > (1000UL * 1000UL)) {\n        *blocks /= (1000UL * 1000UL);\n        rt = \"MB\";\n    }\n    else if (*blocks > 1000) {\n        *blocks /= 1000; \n        rt = \"KB\";\n    }\n    else {\n        rt = \"bytes\";\n    }\n#endif\n\n    return rt;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_182",
        "query_text": "This function conditionally deallocates memory for a linked list of statistics data structures when a specific compilation flag is active. It iterates over the list starting from the head, freeing each node by invoking a custom memory deallocation routine. After traversing and freeing all nodes, the function resets both the head and tail pointers to null, thereby reinitializing the list. The function takes no inputs and returns no output (void), serving solely to clean up dynamically allocated memory associated with the statistics tracking system.",
        "code_id": "c_group_1_id_182",
        "code_text": "static WC_INLINE void bench_stats_free(void)\n{\n#ifdef WC_BENCH_TRACK_STATS\n    bench_stats_t* bstat;\n    for (bstat = bench_stats_head; bstat != NULL; ) {\n        bench_stats_t* next = bstat->next;\n        XFREE(bstat, NULL, DYNAMIC_TYPE_INFO);\n        bstat = next;\n    }\n    bench_stats_head = NULL;\n    bench_stats_tail = NULL;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_183",
        "query_text": "The function accepts as input a pointer to a constant character array (string) and a pointer to an integer representing the current line length. It outputs the string with proper indentation and line wrapping: initially adding an indentation when starting a new line, then printing the string while updating the line length counter. If the current line length exceeds a predefined maximum value, the function outputs a newline and resets the counter. The function returns no value (void); its purpose is to format and print text so that it adheres to a specified line width.",
        "code_id": "c_group_1_id_183",
        "code_text": "static void print_alg(const char* str, int* line)\n{\n    const char* const ident = \"             \";\n    if (*line == 0) {\n        printf(\"%s\", ident);\n        *line = (int)XSTRLEN(ident);\n    }\n    printf(\" %s\", str);\n    *line += (int)XSTRLEN(str) + 1;\n    if (*line > BENCH_MAX_LINE) {\n        printf(\"\\n\");\n        *line = 0;\n    }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_184",
        "query_text": "The function accepts two constant character arrays (strings) as inputs. It performs a case-sensitive exact string comparison and returns an integer value: it returns 1 if the strings are identical and 0 if they are not.",
        "code_id": "c_group_1_id_184",
        "code_text": "static int string_matches(const char* arg, const char* str)\n{\n    return XSTRCMP(arg, str) == 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_185",
        "query_text": "The function takes no input and returns a boolean value. It verifies whether the system or compiler correctly encodes a particular Unicode character in UTF-8 format. To do so, the function first checks if the byte-length of a string literal representing the character is three, which is the expected length for its UTF-8 encoding. It then confirms that the first two bytes of the string match the predetermined values required for the proper UTF-8 representation of the character. Based on these checks, the function returns true if both conditions are met, indicating that UTF-8 encoding is supported; otherwise, it returns false.",
        "code_id": "c_group_1_id_185",
        "code_text": "constexpr auto is_utf8_enabled() -> bool {\n  \n  using uchar = unsigned char;\n  return sizeof(\"\\u00A7\") == 3 && uchar(\"\\u00A7\"[0]) == 0xC2 &&\n         uchar(\"\\u00A7\"[1]) == 0xA7;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_186",
        "query_text": "The function takes three pointer parameters. The first parameter is a pointer to a UTF-8 encoded character array, the second is a pointer to an unsigned 32-bit integer that will hold the decoded Unicode code point, and the third is a pointer to an integer used to store error flags. The function begins by determining the byte-length of the current UTF-8 character, then decodes the character by applying bit masks and shifts to combine up to four bytes into a single Unicode code point. As it decodes, it also checks for several error conditions\u2014such as values below a minimum threshold, excessively large values, or improperly encoded continuation bytes\u2014by setting corresponding error flags. Finally, it returns a pointer to the next character in the input string, while updating the provided outputs with the decoded code point and any detected encoding errors.",
        "code_id": "c_group_1_id_186",
        "code_text": "FMT_CONSTEXPR inline auto utf8_decode(const char* s, uint32_t* c, int* e)\n    -> const char* {\n  constexpr const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};\n  constexpr const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};\n  constexpr const int shiftc[] = {0, 18, 12, 6, 0};\n  constexpr const int shifte[] = {0, 6, 4, 2, 0};\n\n  int len = \"\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\2\\2\\2\\2\\3\\3\\4\"\n      [static_cast<unsigned char>(*s) >> 3];\n  \n  \n  \n  const char* next = s + len + !len;\n\n  using uchar = unsigned char;\n\n  \n  \n  *c = uint32_t(uchar(s[0]) & masks[len]) << 18;\n  *c |= uint32_t(uchar(s[1]) & 0x3f) << 12;\n  *c |= uint32_t(uchar(s[2]) & 0x3f) << 6;\n  *c |= uint32_t(uchar(s[3]) & 0x3f) << 0;\n  *c >>= shiftc[len];\n\n  \n  *e = (*c < mins[len]) << 6;       \n  *e |= ((*c >> 11) == 0x1b) << 7;  \n  *e |= (*c > 0x10FFFF) << 8;       \n  *e |= (uchar(s[1]) & 0xc0) >> 2;\n  *e |= (uchar(s[2]) & 0xc0) >> 4;\n  *e |= uchar(s[3]) >> 6;\n  *e ^= 0x2a;  \n  *e >>= shifte[len];\n\n  return next;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_187",
        "query_text": "The function receives three inputs: a pointer to a memory location, a size indicating the number of bytes to write, and a file pointer. It writes the specified number of bytes from the memory location to the file using a file-writing mechanism determined by the platform and configuration. The function then returns a boolean (true or false) indicating whether the exact number of bytes were successfully written. Internally, it utilizes a platform-specific or standard file writing routine depending on the compilation environment.",
        "code_id": "c_group_1_id_187",
        "code_text": "bool fwrite_bytes(const void *ptr, const size_t n_bytes, FILE *fp) {\n    #if defined(_WIN32) && defined(SPDLOG_FWRITE_UNLOCKED)\n    return _fwrite_nolock(ptr, 1, n_bytes, fp) == n_bytes;\n    #elif defined(SPDLOG_FWRITE_UNLOCKED)\n    return ::fwrite_unlocked(ptr, 1, n_bytes, fp) == n_bytes;\n    #else\n    return std::fwrite(ptr, 1, n_bytes, fp) == n_bytes;\n    #endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_188",
        "query_text": "The function takes a modifiable string as input and removes any leading and trailing whitespace characters, including spaces, newline characters, carriage returns, and tabs. The operation alters the input string directly and returns the modified string. Both the input and output are of type std::string.",
        "code_id": "c_group_1_id_188",
        "code_text": "inline std::string &trim_(std::string &str) {\n    const char *spaces = \" \\n\\r\\t\";\n    str.erase(str.find_last_not_of(spaces) + 1);\n    str.erase(0, str.find_first_not_of(spaces));\n    return str;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_189",
        "query_text": "The function takes a C-style string and a size limit (of type std::size_t) as inputs. It computes the string's length up to the given limit, stopping if a null terminator is encountered. If the null terminator is found before reaching the limit, the function returns the number of characters before it; otherwise, it returns the specified size limit. The output is of type std::size_t, representing the computed length.",
        "code_id": "c_group_1_id_189",
        "code_text": "inline std::size_t catch_strnlen(const char *str, std::size_t n) {\n            auto ret = std::char_traits<char>::find(str, n, '\\0');\n            if (ret != nullptr) {\n                return static_cast<std::size_t>(ret - str);\n            }\n            return n;\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_190",
        "query_text": "The function is an inline function that takes no input arguments and returns no output values. It embeds an inline assembly instruction that serves as a compiler memory barrier, informing the compiler that the memory state may have changed. The embedded assembly code prevents the compiler from optimizing or reordering memory operations across the barrier. Its primary purpose is to enforce memory consistency and ensure that memory accesses are performed in the intended order.",
        "code_id": "c_group_1_id_190",
        "code_text": "inline void keep_memory() {\n            asm volatile(\"\" : : : \"memory\");\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_191",
        "query_text": "The function takes a floating-point number as input and computes the cumulative probability for a standard normal distribution. It utilizes the complementary error function to determine the probability that a standard normally distributed random variable is less than or equal to the input value, then scales the result to yield the correct CDF value, which is returned as a floating-point number.",
        "code_id": "c_group_1_id_191",
        "code_text": "inline double normal_cdf(double x) {\n                return std::erfc(-x / std::sqrt(2.0)) / 2.0;\n            }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_192",
        "query_text": "The function takes a single double-precision floating-point input and returns a double-precision floating-point result. It computes the inverse of the error function by employing a piecewise polynomial approximation. First, it calculates an intermediate value using the negative logarithm of the product of (1 minus the input) and (1 plus the input). Based on the magnitude of this computed value, the function branches into one of three cases, each applying a different polynomial expression with predetermined coefficients. In the first case when the intermediate value is below a certain threshold, it adjusts the value and evaluates the corresponding polynomial. In the next case, if the value falls between two thresholds, it computes a square root-based adjustment before applying another set of coefficients. In the final case, for the largest values, it again uses a square root-based transformation followed by its own distinct polynomial evaluation. The output is then obtained by scaling the polynomial result with the original input value, yielding the inverse error function output.",
        "code_id": "c_group_1_id_192",
        "code_text": "double erf_inv(double x) {\n        \n        double w, p;\n\n        w = -log((1.0 - x) * (1.0 + x));\n\n        if (w < 6.250000) {\n            w = w - 3.125000;\n            p = -3.6444120640178196996e-21;\n            p = -1.685059138182016589e-19 + p * w;\n            p = 1.2858480715256400167e-18 + p * w;\n            p = 1.115787767802518096e-17 + p * w;\n            p = -1.333171662854620906e-16 + p * w;\n            p = 2.0972767875968561637e-17 + p * w;\n            p = 6.6376381343583238325e-15 + p * w;\n            p = -4.0545662729752068639e-14 + p * w;\n            p = -8.1519341976054721522e-14 + p * w;\n            p = 2.6335093153082322977e-12 + p * w;\n            p = -1.2975133253453532498e-11 + p * w;\n            p = -5.4154120542946279317e-11 + p * w;\n            p = 1.051212273321532285e-09 + p * w;\n            p = -4.1126339803469836976e-09 + p * w;\n            p = -2.9070369957882005086e-08 + p * w;\n            p = 4.2347877827932403518e-07 + p * w;\n            p = -1.3654692000834678645e-06 + p * w;\n            p = -1.3882523362786468719e-05 + p * w;\n            p = 0.0001867342080340571352 + p * w;\n            p = -0.00074070253416626697512 + p * w;\n            p = -0.0060336708714301490533 + p * w;\n            p = 0.24015818242558961693 + p * w;\n            p = 1.6536545626831027356 + p * w;\n        } else if (w < 16.000000) {\n            w = sqrt(w) - 3.250000;\n            p = 2.2137376921775787049e-09;\n            p = 9.0756561938885390979e-08 + p * w;\n            p = -2.7517406297064545428e-07 + p * w;\n            p = 1.8239629214389227755e-08 + p * w;\n            p = 1.5027403968909827627e-06 + p * w;\n            p = -4.013867526981545969e-06 + p * w;\n            p = 2.9234449089955446044e-06 + p * w;\n            p = 1.2475304481671778723e-05 + p * w;\n            p = -4.7318229009055733981e-05 + p * w;\n            p = 6.8284851459573175448e-05 + p * w;\n            p = 2.4031110387097893999e-05 + p * w;\n            p = -0.0003550375203628474796 + p * w;\n            p = 0.00095328937973738049703 + p * w;\n            p = -0.0016882755560235047313 + p * w;\n            p = 0.0024914420961078508066 + p * w;\n            p = -0.0037512085075692412107 + p * w;\n            p = 0.005370914553590063617 + p * w;\n            p = 1.0052589676941592334 + p * w;\n            p = 3.0838856104922207635 + p * w;\n        } else {\n            w = sqrt(w) - 5.000000;\n            p = -2.7109920616438573243e-11;\n            p = -2.5556418169965252055e-10 + p * w;\n            p = 1.5076572693500548083e-09 + p * w;\n            p = -3.7894654401267369937e-09 + p * w;\n            p = 7.6157012080783393804e-09 + p * w;\n            p = -1.4960026627149240478e-08 + p * w;\n            p = 2.9147953450901080826e-08 + p * w;\n            p = -6.7711997758452339498e-08 + p * w;\n            p = 2.2900482228026654717e-07 + p * w;\n            p = -9.9298272942317002539e-07 + p * w;\n            p = 4.5260625972231537039e-06 + p * w;\n            p = -1.9681778105531670567e-05 + p * w;\n            p = 7.5995277030017761139e-05 + p * w;\n            p = -0.00021503011930044477347 + p * w;\n            p = -0.00013871931833623122026 + p * w;\n            p = 1.0103004648645343977 + p * w;\n            p = 4.8499064014085844221 + p * w;\n        }\n        return p * x;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_193",
        "query_text": "The function takes a single input character and returns a transformed character that is its lowercase equivalent. It first casts the input to an unsigned character to ensure proper processing by the standard library's lowercase conversion function, then converts the result back to a character before returning it.",
        "code_id": "c_group_1_id_193",
        "code_text": "char toLower(char c) {\n        return static_cast<char>(std::tolower(static_cast<unsigned char>(c)));\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_194",
        "query_text": "The function checks whether a string begins with a specified prefix. It accepts two strings as input and returns a boolean value. First, it verifies that the length of the input string is at least as long as the prefix. If this condition is met, the function extracts the beginning segment of the string\u2014matching the length of the prefix\u2014and compares it with the prefix. If these two values are identical, it returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_194",
        "code_text": "inline bool startsWith( std::string const& str, std::string const& prefix ) {\n            return str.size() >= prefix.size() && str.substr( 0, prefix.size() ) == prefix;\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_195",
        "query_text": "The function converts an array of C-style strings (typically used for command-line arguments) into a vector of strings. It accepts two parameters: an integer representing the number of elements and a pointer to an array of constant C-style strings. The function begins by initializing a vector of strings sized according to the provided integer. It then iterates over the C-style string array, copying each string into the corresponding index of the vector. Finally, the function returns the completed vector of strings.",
        "code_id": "c_group_1_id_195",
        "code_text": "inline std::vector<std::string> argsToVector( int argc, char const* const* const argv ) {\n        std::vector<std::string> args( static_cast<std::size_t>( argc ) );\n        for( std::size_t i = 0; i < static_cast<std::size_t>( argc ); ++i )\n            args[i] = argv[i];\n\n        return args;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_196",
        "query_text": "This function accepts two string inputs and produces a string output. It first checks whether the second input is either empty or represents an empty string (i.e., a string containing two double quotes). When this condition is met, it simply returns the first input. Otherwise, it concatenates the first input with a comma and a space followed by the second input, and then returns this concatenated string.",
        "code_id": "c_group_1_id_196",
        "code_text": "std::string capturedExpressionWithSecondArgument( std::string const& capturedExpression, std::string const& secondArg ) {\n        return secondArg.empty() || secondArg == \"\\\"\\\"\"\n            ? capturedExpression\n            : capturedExpression + \", \" + secondArg;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_197",
        "query_text": "The function takes a pointer to a null-terminated character array (string) as input. It iterates over the characters in the string, searching for the first occurrence of either a newline or a carriage return character. Once one of these characters is found, it is replaced with a null terminator, thereby truncating the string at that point. If no newline or carriage return is encountered, the string remains unmodified. The function does not return any value.",
        "code_id": "c_group_1_id_197",
        "code_text": "void NullLineEndings( char* p )\n{\n\twhile( p && *p ) {\n\t\tif ( *p == '\\n' || *p == '\\r' ) {\n\t\t\t*p = 0;\n\t\t\treturn;\n\t\t}\n\t\t++p;\n\t}\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_198",
        "query_text": "This function accepts a single input of type FILE*, representing a file stream. It begins by verifying that the input is valid (i.e., non-null). If the file pointer is valid, the function duplicates the current standard error file descriptor to preserve its original state. It then retrieves the file descriptor associated with the provided file stream and uses it to replace the standard error output via a redirection call. If the file descriptor retrieval fails (for example, if the file descriptor is -1), the function terminates the process immediately. Finally, it returns the saved original file descriptor for standard error. Conversely, if the input file pointer is null, the function returns -1, indicating an error condition.",
        "code_id": "c_group_1_id_198",
        "code_text": "static int\nmunit_replace_stderr(FILE* stderr_buf) {\n  if (stderr_buf != NULL) {\n    const int orig_stderr = dup(STDERR_FILENO);\n\n    int errfd = fileno(stderr_buf);\n    if (MUNIT_UNLIKELY(errfd == -1)) {\n      exit(EXIT_FAILURE);\n    }\n\n    dup2(errfd, STDERR_FILENO);\n\n    return orig_stderr;\n  }\n\n  return -1;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_199",
        "query_text": "The function takes an integer input that represents a file descriptor. If this input is valid (i.e., not -1), the function directs the standard error stream back to its original destination by duplicating this descriptor to the standard error output and subsequently closing the original descriptor. It returns no value, as its primary purpose is to restore the standard error stream to its prior state.",
        "code_id": "c_group_1_id_199",
        "code_text": "static void\nmunit_restore_stderr(int orig_stderr) {\n  if (orig_stderr != -1) {\n    dup2(orig_stderr, STDERR_FILENO);\n    close(orig_stderr);\n  }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_200",
        "query_text": "The function takes a pointer (of generic type, expected to reference an integer) as input and returns a pointer to a newly allocated integer. It first allocates dynamic memory for an integer and then, if both the allocation succeeds and the input pointer is not null, it copies the value from the referenced integer to the allocated location. Finally, it returns the pointer to this newly created integer.",
        "code_id": "c_group_1_id_200",
        "code_text": "void* copyfn(void* val)\n{\n    int* N = (int*)malloc(sizeof(int));\n    if (N && val) {\n        *N = *((int*)val);\n    }\n    return N;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_201",
        "query_text": "The function accepts two inputs of type constant void pointer, each expected to reference an integer value. It retrieves the integer values and compares them. It returns an integer: -1 if the first value is less than the second, 0 if they are equal, and 1 if the first value is greater than the second. This comparator function is commonly used in sorting and searching algorithms to determine the order between elements.",
        "code_id": "c_group_1_id_201",
        "code_text": "int cmp(void const* e1, void const* e2)\n{\n    int i = *((int*)e1); \n    int j = *((int*)e2);\n\n    if (i < j)\n        return -1;\n    if (i == j)\n        return 0;\n    return 1;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_202",
        "query_text": "The function accepts two constant void pointers as input. It first compares the two pointers to determine whether they refer to the same memory location. If the pointers are equal, it returns 0; if not, it returns 1. The return value is of type int.",
        "code_id": "c_group_1_id_202",
        "code_text": "int zero_if_ptr_eq(void const* e1, void const* e2)\n{\n    return !(e1 == e2);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_203",
        "query_text": "The function accepts three pointer parameters. Two of these pointers reference boolean values, and the third points to a memory location where the result is to be stored. It performs a logical AND operation on the two boolean values and writes the resulting boolean value to the output memory location. The function does not return any value.",
        "code_id": "c_group_1_id_203",
        "code_text": "void bool_and(void* e1, void* e2, void* res)\n{\n    bool p = *(bool*)e1;\n    bool q = *(bool*)e2;\n\n    *(bool*)res = p && q;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_204",
        "query_text": "The function takes two generic pointer inputs and compares the integer values they reference by subtracting the second from the first. It returns an int that is negative if the referenced value of the first pointer is smaller, zero if they are equal, and positive if the first value is larger. This design makes it suitable for use as a comparator in standard sorting routines.",
        "code_id": "c_group_1_id_204",
        "code_text": "static int comp2(const void* a, const void* b)\n{\n    return *((int*)a) - *((int*)b);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_205",
        "query_text": "This function receives a pointer to a character string as its input and processes the string by sequentially scanning numeric characters. It converts the sequence of digit characters into an integer value while advancing the pointer to the first non-digit character. The input is a pointer to a character string assumed to have valid numeric digits starting at the current position, and the output is an integer representing the parsed number.",
        "code_id": "c_group_1_id_205",
        "code_text": "inline int parseIntAndAdvance(const char*& c)\n{\n    int i = 0;\n    for (;*c >= '0' && *c <= '9'; ++c)\n        i = 10*i + (*c - '0');\n    return i;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_206",
        "query_text": "The function accepts an output stream reference and a pointer to a format string as its inputs. It iterates through the string character by character, writing the processed segment to the output stream. When the function encounters the null terminator (which marks the end of the string), it writes out the accumulated portion and returns a pointer to the end of the string. Alternatively, if it encounters a '%' character that is not immediately followed by another '%', it writes the processed portion up to that point and returns a pointer to the '%' character. In cases where the '%' is immediately followed by another '%', the function treats this as an escape sequence and continues processing the remaining characters.",
        "code_id": "c_group_1_id_206",
        "code_text": "inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)\n{\n    const char* c = fmt;\n    for (;; ++c) {\n        if (*c == '\\0') {\n            out.write(fmt, c - fmt);\n            return c;\n        }\n        else if (*c == '%') {\n            out.write(fmt, c - fmt);\n            if (*(c+1) != '%')\n                return c;\n            \n            fmt = ++c;\n        }\n    }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_207",
        "query_text": "The function accepts a single input, a non-negative integer representing the size of a memory block to be allocated. It allocates a memory block of the given size using a standard memory allocation mechanism, and returns a pointer referencing the beginning of the allocated block. If the allocation is unsuccessful, the function returns a null pointer.",
        "code_id": "c_group_1_id_207",
        "code_text": "void* default_allocate(size_t size)\n\t{\n\t\treturn malloc(size);\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_208",
        "query_text": "The function accepts a pointer to a memory block (expressed as a void pointer) and frees the allocated memory so that it can be reused in the future. It does not return any value.",
        "code_id": "c_group_1_id_208",
        "code_text": "void default_deallocate(void* ptr)\n\t{\n\t\tfree(ptr);\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_209",
        "query_text": "The function takes a 16-bit unsigned integer as input and returns a 16-bit unsigned integer with its byte order reversed. It swaps the two constituent bytes so that the least significant byte becomes the most significant and vice versa, which is useful for converting between big-endian and little-endian data formats.",
        "code_id": "c_group_1_id_209",
        "code_text": "inline uint16_t endian_swap(uint16_t value)\n\t{\n\t\treturn static_cast<uint16_t>(((value & 0xff) << 8) | (value >> 8));\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_210",
        "query_text": "The function takes no input parameters and determines the system's byte order. It initializes an integer with the value 1, then inspects the first byte of its memory representation. If that byte equals 1, the function concludes that the system is using little-endian byte ordering and returns true; otherwise, it returns false. The output is a boolean value.",
        "code_id": "c_group_1_id_210",
        "code_text": "bool is_little_endian()\n\t{\n\t\tunsigned int ui = 1;\n\n\t\treturn *reinterpret_cast<unsigned char*>(&ui) == 1;\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_211",
        "query_text": "The function accepts a pointer to a file stream object as input and calls the standard routine to close the associated file. It ensures that any buffered data is flushed to the file and that the file is no longer available for further operations. The function does not return any value.",
        "code_id": "c_group_1_id_211",
        "code_text": "void close_file(FILE* file)\n\t{\n\t\tfclose(file);\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_212",
        "query_text": "The function takes two string inputs: one representing the file path and the other indicating the file open mode (for example, \"r\" for read or \"w\" for write). It returns a pointer to a file object, which signifies that the file has been successfully opened. The function employs a platform-specific implementation: on certain platforms that support a secure file-opening method, it uses that for additional safety; on other platforms, it uses the standard file-opening routine. If the file cannot be opened, the function returns NULL.",
        "code_id": "c_group_1_id_212",
        "code_text": "FILE* open_file(const char* path, const char* mode)\n\t{\n#if defined(PUGI_IMPL_MSVC_CRT_VERSION) && PUGI_IMPL_MSVC_CRT_VERSION >= 1400\n\t\tFILE* file = NULL;\n\t\treturn fopen_s(&file, path, mode) == 0 ? file : NULL;\n#else\n\t\treturn fopen(path, mode);\n#endif\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_213",
        "query_text": "The function takes three inputs: a pointer to an array of pointers representing a hash table, an integer indicating the number of elements in the table, and a pointer representing a key. It computes a hash value from the key using bitwise operations and arithmetic, then uses this value to determine an initial index in the table. By employing a linear probing strategy, the function searches for an available slot to insert the key. If an empty position is found, the key is inserted and the function returns true. If the key is already present or the table is full, it returns false (with an assertion triggered in the event the table is full). The input consists of a pointer to a hash table, a non-negative integer, and a pointer, while the output is of type bool.",
        "code_id": "c_group_1_id_213",
        "code_text": "bool hash_insert(const void** table, size_t size, const void* key)\n\t{\n\t\tassert(key);\n\n\t\tunsigned int h = static_cast<unsigned int>(reinterpret_cast<uintptr_t>(key));\n\n\t\t\n\t\th ^= h >> 16;\n\t\th *= 0x85ebca6bu;\n\t\th ^= h >> 13;\n\t\th *= 0xc2b2ae35u;\n\t\th ^= h >> 16;\n\n\t\tsize_t hashmod = size - 1;\n\t\tsize_t bucket = h & hashmod;\n\n\t\tfor (size_t probe = 0; probe <= hashmod; ++probe)\n\t\t{\n\t\t\tif (table[bucket] == NULL)\n\t\t\t{\n\t\t\t\ttable[bucket] = key;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (table[bucket] == key)\n\t\t\t\treturn false;\n\n\t\t\t\n\t\t\tbucket = (bucket + probe + 1) & hashmod;\n\t\t}\n\n\t\tassert(false && \"Hash table is full\"); \n\t\treturn false;\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_214",
        "query_text": "The function accepts a floating-point input of type double and returns a boolean value. It determines whether the input is \u201cNot a Number\u201d (NaN) by using a platform-dependent strategy. Initially, the function checks for compiler-specific conditions: in certain environments (such as specific Microsoft or Borland compiler versions), it directly calls a built-in function to test for NaN. In other cases, it utilizes a classification method (comparing against a constant that denotes NaN) if such macros are available. As a final fallback, the function takes advantage of the fact that a NaN value does not compare equal to itself. If any of these methods confirm that the value is NaN, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_214",
        "code_text": "bool is_nan(double value)\n\t{\n\t#if defined(PUGI_IMPL_MSVC_CRT_VERSION) || defined(__BORLANDC__)\n\t\treturn !!_isnan(value);\n\t#elif defined(fpclassify) && defined(FP_NAN)\n\t\treturn fpclassify(value) == FP_NAN;\n\t#else\n\t\t\n\t\tconst volatile double v = value;\n\t\treturn v != v;\n\t#endif\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_215",
        "query_text": "The function takes two pointers that specify the bounds of a character array: one for the beginning and one for the end. It then iterates backwards from the end pointer, decrementing it as long as it has not reached the beginning and the character immediately before the end is a '0'. Once a character other than '0' is found (or the beginning is reached), the function writes a null character at the current end pointer position to mark the new end of the array. This process effectively removes any trailing '0' characters from the array.",
        "code_id": "c_group_1_id_215",
        "code_text": "void truncate_zeros(char* begin, char* end)\n\t{\n\t\twhile (begin != end && end[-1] == '0') end--;\n\n\t\t*end = 0;\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_216",
        "query_text": "The function accepts a double-precision floating-point number as input and returns a double-precision floating-point number that represents the nearest integer value to the input. It computes this result by adding 0.5 to the given value and then applying the floor operation to round down to the nearest integer.",
        "code_id": "c_group_1_id_216",
        "code_text": "double round_nearest(double value)\n\t{\n\t\treturn floor(value + 0.5);\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_217",
        "query_text": "The function receives a double-precision floating-point number as input and produces an output of type double. It evaluates the received value to determine if it falls between -0.5 and 0 (inclusive). If the value is within this range, the function rounds it towards zero using a ceiling operation; otherwise, it rounds the value to the nearest integer by applying a floor operation to the input value after adding an offset of 0.5. The final result, in double-precision, is then returned.",
        "code_id": "c_group_1_id_217",
        "code_text": "double round_nearest_nzero(double value)\n\t{\n\t\t\n\t\t\n\t\treturn (value >= -0.5 && value <= 0) ? ceil(value) : floor(value + 0.5);\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_218",
        "query_text": "The function takes two inputs: a pointer to an IPv6 address structure and a pointer to an IPv4 address structure. It first initializes the IPv4 address structure to zero. Then, it maps the lower 32 bits of the IPv6 address by copying the last four bytes from the IPv6 address into the corresponding bytes of the IPv4 address structure. The function does not return a value but modifies the IPv4 address structure directly.",
        "code_id": "c_group_1_id_218",
        "code_text": "void enet_inaddr_map6to4(const struct in6_addr *in, struct in_addr *out)\n    {\n        memset(out, 0, sizeof(struct in_addr));\n        ((uint8_t *)&out->s_addr)[0] = in->s6_addr[12];\n        ((uint8_t *)&out->s_addr)[1] = in->s6_addr[13];\n        ((uint8_t *)&out->s_addr)[2] = in->s6_addr[14];\n        ((uint8_t *)&out->s_addr)[3] = in->s6_addr[15];\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_219",
        "query_text": "The function takes a constant reference to a std::string as input and checks if the string contains no characters. It returns a boolean value: true if the string is empty, and false otherwise.",
        "code_id": "c_group_1_id_219",
        "code_text": "inline\nbool\nempty(const std::string& s)\n{\n  return s.empty();\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_220",
        "query_text": "The function accepts an integer as input, representing an error code, and checks it against a predefined set of error conditions that require additional parameters. It employs a switch mechanism: if the input error code matches any of these specific conditions, the function returns 1, indicating that further context is needed; if not, the function returns 0, signifying no additional parameters are required. The input is of type int, and the output is an int flag.",
        "code_id": "c_group_1_id_220",
        "code_text": "extern int\nonig_is_error_code_needs_param(int code)\n{\n  switch (code) {\n  case ONIGERR_UNDEFINED_NAME_REFERENCE:\n  case ONIGERR_UNDEFINED_GROUP_REFERENCE:\n  case ONIGERR_MULTIPLEX_DEFINED_NAME:\n  case ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL:\n  case ONIGERR_INVALID_GROUP_NAME:\n  case ONIGERR_INVALID_CHAR_IN_GROUP_NAME:\n  case ONIGERR_INVALID_CHAR_PROPERTY_NAME:\n    return 1;\n  default:\n    return 0;\n  }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_221",
        "query_text": "The function accepts two integer inputs representing positive numbers, and it returns their product as an integer. Initially, if either input is zero, the function immediately returns zero. Otherwise, it checks whether multiplying the two inputs would result in a value no greater than the maximum integer value. If the product is within this limit, it returns the product; if not, it returns -1 to indicate that an overflow would occur.",
        "code_id": "c_group_1_id_221",
        "code_text": "extern int\nonig_positive_int_multiply(int x, int y)\n{\n  if (x == 0 || y == 0) return 0;\n\n  if (x < ONIG_INT_MAX / y)\n    return x * y;\n  else\n    return -1;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_222",
        "query_text": "The function takes three inputs: a pointer to an input character array, a pointer to an output character array (which is modified in place), and an integer representing the length of the input array. It processes the input array in pairs of characters. For each pair, the function first examines the initial character. If this character is null (0), it then considers the second character. If this second character is either a non-printable ASCII character, a backslash, or a double quote, it encodes the character as an octal escape sequence (for example, \"\\123\") into the output array; otherwise, it copies the character directly. If the first character in the pair is not null, both characters are encoded as octal escape sequences and written to the output array. After processing all character pairs, the function appends a null terminator to the output array. The primary purpose of the function is to convert characters from the input into either their direct representation or an octal escape sequence in the output, following specific encoding rules.",
        "code_id": "c_group_1_id_222",
        "code_text": "static void uconv(char* from, char* to, int len)\n{\n  int i;\n  unsigned char c;\n  char *q;\n\n  q = to;\n\n  for (i = 0; i < len; i += 2) {\n    c = (unsigned char )from[i];\n    if (c == 0) {\n      c = (unsigned char )from[i+1];\n      if (c < 0x20 || c >= 0x7f || c == 0x5c || c == 0x22) {\n        sprintf(q, \"\\\\%03o\", (unsigned int )c);\n        q += 4;\n      }\n      else {\n        sprintf(q, \"%c\", c);\n        q++;\n      }\n    }\n    else {\n      sprintf(q, \"\\\\%03o\", (unsigned int )c);\n      q += 4;\n      c = (unsigned char )from[i+1];\n      sprintf(q, \"\\\\%03o\", (unsigned int )c);\n      q += 4;\n    }\n  }\n\n  *q = 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_223",
        "query_text": "The function receives two time values as inputs. It calculates their difference and converts this difference into seconds by dividing by the constant that specifies the number of clock ticks per second. The computed elapsed time is then returned as a double.",
        "code_id": "c_group_1_id_223",
        "code_text": "static double\nget_sec(clock_t start, clock_t end)\n{\n  double t;\n\n  t = (double )(end - start) / CLOCKS_PER_SEC;\n  return t;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_224",
        "query_text": "The function takes three inputs: an integer representing the count of elements in an array, and two arrays of character pointers. It begins by copying each element from the first array into the corresponding position of the second array. Then, the function shuffles the elements of the second array using a random swapping mechanism: it iterates backwards from the last element, and for each position, it selects a random index within the unshuffled portion of the array and swaps the element at the current position with the one at the random index, ensuring that every position is equally likely to be occupied by any element. The function performs this shuffling operation in-place and does not return any value.",
        "code_id": "c_group_1_id_224",
        "code_text": "static void\nfisher_yates_shuffle(int n, char* ps[], char* cps[])\n{\n#define GET_RAND(n)  (rand()%(n+1))\n#define SWAP(a,b)    { char* tmp = a; a = b; b = tmp; }\n\n  int i;\n\n  for (i = 0; i < n; i++)\n    cps[i] = ps[i];\n\n  for (i = n - 1; i > 0; i--) {\n    int x = GET_RAND(i);\n    SWAP(cps[i], cps[x]);\n  }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_225",
        "query_text": "The function accepts two inputs: a floating-point number of type long double and a size_t value that specifies the desired precision for its conversion into a string. If the precision parameter is zero, the function automatically substitutes it with the maximum number of significant digits available for a long double. It then converts the value into a string representation using the C locale to ensure that the formatting remains consistent regardless of locale-specific differences. The output is a string that reflects the formatted floating-point number.",
        "code_id": "c_group_1_id_225",
        "code_text": "std::string FpToString(long double v, size_t precision) {\n  std::stringstream ss;\n  ss.imbue(std::locale(\"C\"));\n  if (precision == 0) {\n     precision = std::numeric_limits<long double>::max_digits10;\n  }\n  ss.precision(precision);\n  ss << v;\n  return ss.str();\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_226",
        "query_text": "The function takes a pointer to an unsigned character as input and returns a pointer to a character. It uses a reinterpret cast to convert the pointer to the unsigned character buffer into a pointer to a character buffer, effectively allowing the same underlying data to be accessed as a sequence of characters. The input type is unsigned char*, and the output type is char*.",
        "code_id": "c_group_1_id_226",
        "code_text": "inline char* ReadBuffer(unsigned char* pBuffer) {\n  return reinterpret_cast<char*>(pBuffer);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_227",
        "query_text": "The function accepts a single parameter: a reference to an input stream (of type std::istream&). It reads all characters from the stream\u2014from the current position to the end\u2014and constructs a string containing the complete set of data read. The function then returns this string (of type std::string) holding the stream's content.",
        "code_id": "c_group_1_id_227",
        "code_text": "std::string read_stream(std::istream& in) {\n  return std::string((std::istreambuf_iterator<char>(in)),\n                     std::istreambuf_iterator<char>());\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_228",
        "query_text": "The function accepts a single character as input and returns a boolean value indicating whether the character represents a non-zero digit. It does so by verifying if the character falls within the ASCII range corresponding to the digits 1 through 9. If the character meets this criterion, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_228",
        "code_text": "static bool IsNonZeroDigit(const char d) {\n  return ('1' <= d) && (d <= '9');\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_229",
        "query_text": "The function takes two C-style strings as inputs\u2014one for the filename and one for the mode\u2014and returns a pointer to a FILE object. It opens the specified file using platform-specific logic: on Windows platforms (excluding MinGW), it uses a secure method to open the file, while on other platforms it uses the standard approach. The function returns the file pointer if the file is successfully opened, or a null pointer if the operation fails.",
        "code_id": "c_group_1_id_229",
        "code_text": "inline auto safe_fopen(const char* filename, const char* mode) -> FILE* {\n#if defined(_WIN32) && !defined(__MINGW32__)\n  \n  FILE* f = nullptr;\n  errno = fopen_s(&f, filename, mode);\n  return f;\n#else\n  return std::fopen(filename, mode);\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_230",
        "query_text": "The function accepts a single parameter of type char. It converts the provided character to an unsigned char for compatibility with the standard library's character classification routine, which is then used to determine if the character is a whitespace character. Based on this evaluation, the function returns a boolean value: true if the character is whitespace, and false otherwise.",
        "code_id": "c_group_1_id_230",
        "code_text": "inline bool IsSpace(char ch) {\n  return isspace(static_cast<unsigned char>(ch)) != 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_231",
        "query_text": "The function accepts a single character as its input and returns a boolean value indicating whether the input character is an uppercase letter. It operates by utilizing a standard library function to evaluate if the character belongs to the uppercase category, ultimately converting the non-zero result into a boolean true or false outcome. The primary purpose of this function is to determine the uppercase status of the provided character.",
        "code_id": "c_group_1_id_231",
        "code_text": "inline bool IsUpper(char ch) {\n  return isupper(static_cast<unsigned char>(ch)) != 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_232",
        "query_text": "The function takes two inputs: a byte size of type size_t and an integer flag for huge page usage. It attempts to allocate a memory block using the mmap system call, creating an anonymous and private memory mapping. If the flag for huge pages is enabled, the function sets the appropriate mapping flag. Upon successful allocation, it returns a pointer to the allocated memory block of type void*. If the allocation fails, it prints an error message to the standard error stream and terminates the program.",
        "code_id": "c_group_1_id_232",
        "code_text": "static void *\nalloc_bytes(size_t bytes, int hugetlb)\n{\n\tint map_flags;\n\tvoid *p;\n\tmap_flags = MAP_ANONYMOUS | MAP_PRIVATE;\n\tif (hugetlb)\n\t\tmap_flags |= MAP_HUGETLB;\n\tp = mmap(NULL, bytes, PROT_READ | PROT_WRITE, map_flags, -1, 0);\n\tif (p == MAP_FAILED) {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: unable to mmap memory for input: %s.\\n\",\n\t\t\tstrerror(errno));\n\t\texit(1);\n\t}\n\treturn p;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_233",
        "query_text": "The function accepts a single character input (of type char) representing a hexadecimal digit. It checks if the input is a decimal digit between '0' and '9'; if so, it converts it to its corresponding integer value (0\u20139) by subtracting the ASCII value for '0'. If the input is a lowercase letter between 'a' and 'f', it converts it to its equivalent hexadecimal value (10\u201315) by adjusting for the ASCII offset for 'a'. If the character does not fall within these valid ranges, the function terminates the program abruptly using abort(). The resulting output is an integer (of type int) corresponding to the numeric value of the hexadecimal digit if valid.",
        "code_id": "c_group_1_id_233",
        "code_text": "static int\nhex2int(char ch)\n{\n\tif (ch >= '0' && ch <= '9')\n\t\treturn ch - '0';\n\tif (ch >= 'a' && ch <= 'f')\n\t\treturn ch - 'a' + 10;\n\tabort();\n\treturn 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_234",
        "query_text": "The function takes two inputs: a pointer to an array of character pointers and an unsigned integer representing the number of elements in that array. It iterates over the array, freeing each allocated sub-array of characters. After processing all elements, it frees the memory allocated for the array itself. The function returns no value, and its purpose is to deallocate all memory associated with a dynamically allocated two-dimensional array of strings.",
        "code_id": "c_group_1_id_234",
        "code_text": "static void\nfree_pairs(char **pairs, unsigned pairs_cnt)\n{\n\tunsigned i;\n\tfor (i=0; i < pairs_cnt; ++i)\n\t\tfree(pairs[i]);\n\tfree(pairs);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_235",
        "query_text": "The function accepts three parameters: a pointer to a constant array of double-precision floating-point numbers, an integer representing the number of elements in the array, and a pointer to an array of doubles for the output. It iterates through the input array in reverse order, copying each element to the corresponding position in the output array; additionally, if the current index is odd, the function negates the copied value. The output array maintains the same size as the input array, and the function itself does not alter the original input array.",
        "code_id": "c_group_1_id_235",
        "code_text": "void qmf_even(const double *in, int N,double *out)\n{\n    int count = 0;\n    for (count = 0; count < N; count++)\n    {\n        out[count] = in[N - count - 1];\n        if (count % 2 != 0)\n        {\n            out[count] = -1 * out[count];\n        }\n    }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_236",
        "query_text": "The function accepts an array of double precision numbers along with two filter arrays used for transformation, as well as stride values for indexing. It processes the input array in discrete steps, computing two output arrays: one that represents a smoothed (averaged) version of the input and another that captures finer, detailed variations. For each step, the function multiplies elements from the input by corresponding filter coefficients, summing the results into the respective outputs. To correctly handle the boundaries of the input array, it employs modular arithmetic, ensuring indices wrap around as needed. The overall inputs include the input array's length, the filter arrays partitioned appropriately, and stride parameters, while the outputs are the two resulting arrays of double precision numbers.",
        "code_id": "c_group_1_id_236",
        "code_text": "void modwt_per_stride(int M, double *inp, int N, double *filt, int lpd_len, double *cA, int len_cA, double *cD, int istride, int ostride) {\n\tint l, i, t, len_avg;\n\tint is, os;\n\tlen_avg = lpd_len;\n\n\n\tfor (i = 0; i < len_cA; ++i) {\n\t\tt = i;\n\t\tos = i *ostride;\n\t\tis = t *istride;\n\t\tcA[os] = filt[0] * inp[is];\n\t\tcD[os] = filt[len_avg] * inp[is];\n\t\tfor (l = 1; l < len_avg; l++) {\n\t\t\tt -= M;\n\t\t\twhile (t >= len_cA) {\n\t\t\t\tt -= len_cA;\n\t\t\t}\n\t\t\twhile (t < 0) {\n\t\t\t\tt += len_cA;\n\t\t\t}\n\t\t\tos = i * ostride;\n\t\t\tis = t * istride;\n\t\t\tcA[os] += filt[l] * inp[is];\n\t\t\tcD[os] += filt[len_avg + l] * inp[is];\n\n\t\t}\n\t}\n\t\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_237",
        "query_text": "The function accepts an array of double values along with several integer parameters that define the lengths of both the input and output arrays as well as stride values for indexing. It also receives two separate arrays of double filter coefficients for low-pass and high-pass filtering. The function iterates over the specified indices of the output arrays and, for each position, computes weighted sums by applying both filters to the appropriately indexed elements of the input array. Special care is taken to handle boundary conditions, ensuring proper indexing even when the computed positions fall outside the usual range (by wrapping around or applying conditional adjustments). The computed values are stored in the output arrays in place, with no value returned by the function. The primary purpose of the function is to perform dual filtering on an input array and output the resulting low-pass and high-pass filtered arrays using the provided stride and boundary management.",
        "code_id": "c_group_1_id_237",
        "code_text": "void swt_per_stride(int M, double *inp, int N, double *lpd, double*hpd, int lpd_len, double *cA, int len_cA, double *cD, int istride, int ostride) {\n\tint l, l2, isodd, i, t, len_avg, j;\n\tint is, os;\n\tlen_avg = M * lpd_len;\n\tl2 = len_avg / 2;\n\tisodd = N % 2;\n\n\tfor (i = 0; i < len_cA; ++i) {\n\t\tt = i + l2;\n\t\tos = i *ostride;\n\t\tcA[os] = 0.0;\n\t\tcD[os] = 0.0;\n\t\tl = -1;\n\t\tfor (j = 0; j < len_avg; j += M) {\n\t\t\tl++;\n\t\t\twhile (j >= len_cA) {\n\t\t\t\tj -= len_cA;\n\t\t\t}\n\t\t\tif ((t - j) >= l2 && (t - j) < N) {\n\t\t\t\tis = (t - j)*istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - j) < l2 && (t - j) >= 0) {\n\t\t\t\tis = (t - j)*istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - j) < 0) {\n\t\t\t\tis = (t - j + N)*istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - j) >= N && isodd == 0) {\n\t\t\t\tis = (t - j - N)*istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - j) >= N && isodd == 1) {\n\t\t\t\tif (t - l != N) {\n\t\t\t\t\tis = (t - j - (N + 1))*istride;\n\t\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tis = (N - 1)*istride;\n\t\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\t\tcD[os] += hpd[l] * inp[N - 1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_238",
        "query_text": "The function takes several inputs that include two arrays of double-precision floating-point numbers and a filter array, along with various integer parameters to control stride and length. It processes the two input arrays by computing a weighted sum of their elements using the provided filter values, where the weights for the two arrays are taken from different segments of the filter array. The computation is performed using designated input and output strides, and the algorithm employs circular indexing to wrap around the input arrays as needed. The result of the transformation is stored in an output array of double-precision floating-point numbers. \n\nInputs:\n- An integer used as a multiplier for index transformation.\n- Two arrays of double-precision floating-point numbers for coefficients and details.\n- An integer representing the length of the first array.\n- An array of double-precision floating-point numbers representing filter weights.\n- An integer indicating the length of the filter array.\n- Two integers specifying the input and output strides.\n\nOutput:\n- An array of double-precision floating-point numbers containing the computed results.\n\nThe function serves as a black box to perform the transformation of the input arrays into an output array by applying the filter weights in a cyclic manner, without requiring knowledge of the underlying algorithm details.",
        "code_id": "c_group_1_id_238",
        "code_text": "void imodwt_per_stride(int M, double *cA, int len_cA, double *cD, double *filt,int lf,double *X,int istride, int ostride) {\n\tint len_avg, i, l, t;\n\tint is, os;\n\t\n\tlen_avg = lf;\n\n\tfor (i = 0; i < len_cA; ++i) {\n\t\tt = i;\n\t\tos = i * ostride;\n\t\tis = t *istride;\n\t\tX[os] = (filt[0] * cA[is]) + (filt[len_avg] * cD[is]);\n\t\tfor (l = 1; l < len_avg; l++) {\n\t\t\tt += M;\n\t\t\twhile (t >= len_cA) {\n\t\t\t\tt -= len_cA;\n\t\t\t}\n\t\t\twhile (t < 0) {\n\t\t\t\tt += len_cA;\n\t\t\t}\n\t\t\tis = t *istride;\n\t\t\tX[os] += (filt[l] * cA[is]) + (filt[len_avg + l] * cD[is]);\n\n\t\t}\n\t}\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_239",
        "query_text": "The function accepts an integer as input and returns an integer as output. It evaluates whether the provided integer is non-negative or negative. If the input is non-negative, the function returns 1, and if negative, it returns -1. Its primary purpose is to determine and output the sign of the input integer.",
        "code_id": "c_group_1_id_239",
        "code_text": "static int isign(int N) {\n\tint M;\n\tif (N >= 0) {\n\t\tM = 1;\n\t}\n\telse {\n\t\tM = -1;\n\t}\n\n\treturn M;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_240",
        "query_text": "The function takes an integer input and returns its absolute value as an integer. It first checks if the input is non-negative; if so, it returns the input directly. Otherwise, it returns the negated value, effectively converting any negative number into a positive one.",
        "code_id": "c_group_1_id_240",
        "code_text": "static int iabs(int N) {\n\tif (N >= 0) {\n\t\treturn N;\n\t}\n\telse {\n\t\treturn -N;\n\t}\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_241",
        "query_text": "The function accepts two inputs: pointers to double values provided via generic pointer types. It compares the underlying double values and returns an integer indicating their ordering. Specifically, it returns -1 if the first value is smaller than the second, 1 if the first value is larger, and 0 if the two values are equal. This comparator is typically used for sorting or searching operations.",
        "code_id": "c_group_1_id_241",
        "code_text": "int compare_double(const void* a, const void* b)\n{\n    double arg1 = *(const double*)a;\n    double arg2 = *(const double*)b;\n\n    if (arg1 < arg2) return -1;\n    if (arg1 > arg2) return 1;\n    return 0;\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_242",
        "query_text": "The function takes two inputs: a pointer to an array of double-precision floating-point values and an integer representing the count of elements in the array. It iterates over the array, summing all the values, and then divides the total by the number of elements, thereby computing the arithmetic mean. The result is returned as a double-precision floating-point number.",
        "code_id": "c_group_1_id_242",
        "code_text": "double mean(const double* vec, int N) {\n\tint i;\n\tdouble m;\n\tm = 0.0;\n\n\tfor (i = 0; i < N; ++i) {\n\t\tm+= vec[i];\n\t}\n\tm = m / N;\n\treturn m;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_243",
        "query_text": "The function accepts an array of double-precision floating-point numbers along with an integer indicating the array's size. It iterates through the array to find the smallest element, tracking the first occurrence in case of duplicate minimal values. After the traversal, the function returns an integer representing the index of this smallest element.",
        "code_id": "c_group_1_id_243",
        "code_text": "int minindex(const double *arr, int N) {\n\tdouble min;\n\tint index,i;\n\n\tmin = DBL_MAX;\n\tindex = 0;\n\tfor(i = 0; i < N;++i) {\n\t\tif (arr[i] < min) {\n\t\t\tmin = arr[i];\n\t\t\tindex = i;\n\t\t}\n\t}\n\n\treturn index;\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_244",
        "query_text": "The function takes no input parameters and returns no value. It starts by checking if a specific compile-time flag is defined; when this flag is active, it resets two pointer variables used for tracking statistics, effectively clearing any previous benchmarking data. Afterward, it initializes a cycle counter via a predefined macro, setting up performance measurement. Its overall purpose is to prepare the system for collecting benchmarking statistics and measuring execution cycles.",
        "code_id": "c_group_1_id_244",
        "code_text": "static WC_INLINE void bench_stats_init(void)\n{\n#ifdef WC_BENCH_TRACK_STATS\n    bench_stats_head = NULL;\n    bench_stats_tail = NULL;\n#endif\n    INIT_CYCLE_COUNTER\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_245",
        "query_text": "SUMMARY:  \nThe function takes a modifiable string as its input and processes it in place. It iteratively scans the string for a specific two-character substring (composed of two colons) and, upon finding it, replaces that occurrence with a single dot character. The search continues from just after each replacement until no further occurrences are detected. The input is of type std::string, and the function modifies it directly without returning a new string.",
        "code_id": "c_group_1_id_245",
        "code_text": "static void normalizeNamespaceMarkers(std::string& str) {\n            std::size_t pos = str.find( \"::\" );\n            while ( pos != str.npos ) {\n                str.replace( pos, 2, \".\" );\n                pos += 1;\n                pos = str.find( \"::\", pos );\n            }\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_246",
        "query_text": "The function takes no input parameters and returns a 64-bit unsigned integer. It begins by retrieving the current system time using a high-resolution clock. This time point is then interpreted as the duration elapsed since the epoch (typically January 1, 1970) and converted into a nanosecond count, which is finally returned as the output.",
        "code_id": "c_group_1_id_246",
        "code_text": "static auto getCurrentNanosecondsSinceEpoch() -> uint64_t {\n            return std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_247",
        "query_text": "The function rotates a 32-bit unsigned integer to the right by a given number of bit positions. It accepts two 32-bit unsigned integer inputs: one representing the value to be rotated, and the other indicating how many positions to rotate. The function begins by constraining the rotation count to the range 0 through 31 using a bitmask. It then shifts the value right by the specified count, while simultaneously shifting the value left by the complement of the count to capture any bits that \"fall off\" the right end. The two shifted results are then combined using a bitwise OR, yielding a new 32-bit unsigned integer with the bits rotated as specified.",
        "code_id": "c_group_1_id_247",
        "code_text": "uint32_t rotate_right(uint32_t val, uint32_t count) {\n            const uint32_t mask = 31;\n            count &= mask;\n            return (val >> count) | (val << (-count & mask));\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_248",
        "query_text": "The function takes a vector of pointers to unsigned characters and a pointer to a pointer to unsigned characters as inputs. It sequentially copies the elements from the vector into the memory location referenced by the second input using a standard library copy algorithm.",
        "code_id": "c_group_1_id_248",
        "code_text": "static inline void\ncopy(const std::vector<unsigned char*>& bucket, unsigned char** dst)\n{\n\tstd::copy(bucket.begin(), bucket.end(), dst);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_249",
        "query_text": "This function converts an angle from radians to degrees. It takes a single input in the form of a pointer to a floating-point value representing the angle in radians. The function processes the value in-place by multiplying it by the conversion factor (180.0 divided by \u03c0), thereby updating the original value to reflect the equivalent measure in degrees. Both the input and output utilize the floating-point type.",
        "code_id": "c_group_1_id_249",
        "code_text": "CGLM_INLINE\nvoid\nglm_make_deg(float *rad) {\n  *rad = *rad * 180.0f / GLM_PIf;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_250",
        "query_text": "The function resets the locale settings for the calling thread to a default or global state, adapting its approach based on the system capabilities. On Windows platforms (excluding certain environments like MinGW), it disables per-thread locale settings, thereby reverting to the global locale. On POSIX-compliant systems that support specific locale APIs, it switches the thread's locale to the global one and then releases the associated locale object. If neither mechanism is available, it outputs a warning that the thread's locale cannot be modified. The function neither accepts parameters nor returns a value.",
        "code_id": "c_group_1_id_250",
        "code_text": "static void __config_locale_restore(void)\n{\n#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32__)) \\\n  && ! defined(__MINGW32__)\n\n    _configthreadlocale(_DISABLE_PER_THREAD_LOCALE);\n\n#elif ((defined HAVE_USELOCALE) && (defined HAVE_FREELOCALE))\n\n  locale_t loc = uselocale(LC_GLOBAL_LOCALE);\n  freelocale(loc);\n\n#else\n\n#warning \"No way to modify calling thread's locale!\"\n\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_251",
        "query_text": "This function computes the number of leading zero bits in a 64-bit unsigned integer. It accepts a single unsigned integer input and returns an integer result reflecting the count of zeros preceding the first set bit. On Windows, the function branches into different implementations based on the system architecture, employing one intrinsic function for 64-bit builds and another for 32-bit builds. In contrast, on other platforms, it directly uses a compiler-provided intrinsic. The result is an integer in the range from 0 to 64, corresponding to the number of leading zeros in the input value.",
        "code_id": "c_group_1_id_251",
        "code_text": "inline int leading_zeroes(uint64_t input_num) {\n#ifdef _MSC_VER\n  unsigned long leading_zero = 0;\n  \n  \n#ifdef _WIN64\n  if (_BitScanReverse64(&leading_zero, input_num))\n    return (int)(63 - leading_zero);\n#else\n  if (_BitScanReverse(&leading_zero, (uint32_t)(input_num >> 32)))\n    return (int)(63 - (leading_zero + 32));\n  if (_BitScanReverse(&leading_zero, (uint32_t)input_num))\n    return (int)(63 - leading_zero);\n#endif \n#else\n  return __builtin_clzll(input_num);\n#endif \n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_252",
        "query_text": "The function takes four inputs: a pointer to the beginning of a memory block, the size of that block, a pointer to a second memory block to search for, and the size of this second block. It examines the first memory block for the initial occurrence of the second memory block. If it finds an exact match, the function returns a pointer to its starting position within the first block; if no match is found or if the search block is larger than the first block, it returns NULL. The inputs are of types const void* and size_t, while the output is of type void*.",
        "code_id": "c_group_1_id_252",
        "code_text": "static WC_MAYBE_UNUSED void *mymemmem(const void *haystack, size_t haystacklen,\n                                      const void *needle, size_t needlelen)\n{\n    size_t i, j;\n    const char* h = (const char*)haystack;\n    const char* n = (const char*)needle;\n    if (needlelen > haystacklen)\n        return NULL;\n    for (i = 0; i <= haystacklen - needlelen; i++) {\n        for (j = 0; j < needlelen; j++) {\n            if (h[i + j] != n[j])\n                break;\n        }\n        if (j == needlelen)\n            return (void*)(h + i);\n    }\n    return NULL;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_253",
        "query_text": "The function takes no inputs and returns an integer value representing the overall outcome of a series of tests. It starts by initializing a status variable used to monitor whether any test fails. Under a conditional compilation flag, the function displays a start message and then sequentially invokes several test routines\u2014each assessing a different aspect of QUIC functionality, such as cryptographic operations, handshake procedures, and session-related behaviors. If any test routine returns a non-zero value (indicating a failure), the function immediately halts further testing and proceeds to a final stage where it prints an error message highlighting the failure of one or more tests. A closing message is then printed, and the function returns the status variable; a return value of zero signifies that all tests have passed, while any non-zero value indicates that at least one test did not succeed. Additionally, some tests are conditionally executed based on preprocessor directives, allowing the function to adapt to different build configurations and feature sets.",
        "code_id": "c_group_1_id_253",
        "code_text": "int QuicTest(void)\n{\n    int ret = 0;\n#ifdef WOLFSSL_QUIC\n    int verbose = 0;\n    printf(\" Begin QUIC Tests\\n\");\n\n    if ((ret = test_set_quic_method()) != 0) goto leave;\n    if ((ret = test_provide_quic_data()) != 0) goto leave;\n    if ((ret = test_quic_crypt()) != 0) goto leave;\n    if ((ret = test_quic_client_hello(verbose)) != 0) goto leave;\n    if ((ret = test_quic_server_hello(verbose)) != 0) goto leave;\n#ifdef REALLY_HAVE_ALPN_AND_SNI\n    if ((ret = test_quic_alpn(verbose)) != 0) goto leave;\n#endif \n#ifdef HAVE_SESSION_TICKET\n    if ((ret = test_quic_key_share(verbose)) != 0) goto leave;\n    if ((ret = test_quic_resumption(verbose)) != 0) goto leave;\n#ifdef WOLFSSL_EARLY_DATA\n    if ((ret = test_quic_early_data(verbose)) != 0) goto leave;\n#endif \n    if ((ret = test_quic_session_export(verbose)) != 0) goto leave;\n#endif \n\nleave:\n    if (ret != 0)\n        printf(\"  FAILED: some tests did not pass.\\n\");\n    printf(\" End QUIC Tests\\n\");\n#endif\n    return ret;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_254",
        "query_text": "The function writes indentation to a file stream based on the provided depth and width parameters. It takes three inputs: a file stream, an integer representing the indentation depth, and an unsigned short representing the indentation width. If the width is non-zero, the function prints spaces to the file stream, where the number of spaces is computed as (depth - 1) times the width. If the width is zero, it prints tab characters instead, outputting one tab for each level of indentation (depth - 1). The function does not return a value; it directly modifies the file stream by outputting the appropriate indentation.",
        "code_id": "c_group_1_id_254",
        "code_text": "static void __config_indent(FILE *stream, int depth, unsigned short w)\n{\n  if(w)\n    fprintf(stream, \"%*s\", (depth - 1) * w, \" \");\n  else\n  {\n    int i;\n    for(i = 0; i < (depth - 1); ++i)\n      fputc('\\t', stream);\n  }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_255",
        "query_text": "The function takes two inputs. The first is a pointer to a block of memory, and the second is an integer value representing the size in bytes of that block. The function initializes the entire block by setting every byte to zero. It achieves this by either invoking a standard library function to fill the memory with zeros (if a certain macro is defined) or by manually iterating over each byte in the block to set it to zero. The function does not return any value.",
        "code_id": "c_group_1_id_255",
        "code_text": "void s_mp_zero_buf(void *mem, size_t size)\n{\n#ifdef MP_USE_MEMOPS\n   memset(mem, 0, size);\n#else\n   char *m = (char *)mem;\n   while (size-- > 0u) {\n      *m++ = '\\0';\n   }\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_256",
        "query_text": "The function accepts an array of character pointers and two integers marking a range within the array. It reverses the order of the elements in the specified subarray (starting at the first index and ending just before the second index), by swapping elements symmetrically from the ends toward the center. The operation is performed in place, modifying the original array without returning any value.",
        "code_id": "c_group_1_id_256",
        "code_text": "static void\nreverse(char *v[], int i, int j)\n{\n\twhile (j - i > 1) {\n\t\tchar *tmp = v[i];\n\t\tv[i] = v[j - 1];\n\t\tv[j - 1] = tmp;\n\t\t++i;\n\t\t--j;\n\t}\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_257",
        "query_text": "The function compares two integers indirectly through pointer dereferencing. It takes two inputs of type const void*, each expected to point to an int pointer. After dereferencing, the function compares the integer values: it returns -1 if the first integer is less than the second, 1 if it is greater, and 0 if both are equal. This comparison mechanism is designed for use in sorting or searching algorithms that require a callback for comparing elements.",
        "code_id": "c_group_1_id_257",
        "code_text": "int comp(void const* e1, void const* e2)\n{\n    int* i = *((int**)e1);\n    int* j = *((int**)e2);\n\n    if (*i < *j)\n        return -1;\n    if (*i > *j)\n        return 1;\n    return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_258",
        "query_text": "This function retrieves version information by constructing a formatted constant string. It takes no input arguments and produces an output that concatenates predefined constants representing the package and version details with a static copyright message. The function returns a pointer to a constant character array containing this version-related information.",
        "code_id": "c_group_1_id_258",
        "code_text": "const char *\nsrc_get_version (void)\n{\treturn PACKAGE \"-\" VERSION \" (c) 2002-2008 Erik de Castro Lopo\" ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_259",
        "query_text": "The function takes a single character of type char as input and returns a boolean value indicating whether the character is a whitespace character. It does so by comparing the input character against a fixed set of characters representing space, tab, newline, and carriage return. If the character is found within this set, the function returns true; otherwise, it returns false. The input is of type char, while the output is of type bool.",
        "code_id": "c_group_1_id_259",
        "code_text": "inline auto isWhitespace(char c) -> bool {\n\tstatic std::string chars = \" \\t\\n\\r\";\n\treturn chars.find(c) != std::string::npos;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_260",
        "query_text": "The function takes a boolean value as input and returns no value (void). It checks if the provided boolean is false; if so, it throws a runtime exception with the message \"bug\". Otherwise, if the boolean is true, it performs no action and simply returns. This design serves primarily as a debugging or assertion tool during program execution.",
        "code_id": "c_group_1_id_260",
        "code_text": "inline void Assert(bool Assertion) {\n  if (!Assertion)\n    throw std::runtime_error(\"bug\");\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_261",
        "query_text": "The function receives an unsigned integer and a boolean as inputs and returns a boolean value. It starts by checking if the boolean input is true; if so, it returns true immediately. If not, the function shifts the unsigned integer right by 5 bits and compares this result with the value 0x1B. If the shifted value is not equal to 0x1B, it returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_261",
        "code_text": "inline STRF_HD bool first_2_of_3_are_valid(unsigned x, bool lax_surrogate_policy)\n{\n    return (lax_surrogate_policy || (x >> 5) != 0x1B);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_262",
        "query_text": "The function reads a set number of bytes from a file descriptor into a provided buffer. It takes three inputs: an integer (representing the file descriptor), a pointer (pointing to the buffer where data will be stored), and an unsigned integer (specifying the number of bytes to read). Internally, it wraps the standard system call to perform the read operation and returns an integer indicating the actual number of bytes read or -1 if an error is encountered.",
        "code_id": "c_group_1_id_262",
        "code_text": "inline int Read(int fd, void* buf, unsigned int count) {\n  return static_cast<int>(read(fd, buf, count));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_263",
        "query_text": "The function accepts two floating-point inputs. It determines the closest representable floating-point value following the first input such that it advances in the direction indicated by the second input. The function returns this computed floating-point value.",
        "code_id": "c_group_1_id_263",
        "code_text": "float nextafter(float x, float y) {\n        return ::nextafterf(x, y);\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_264",
        "query_text": "The function takes two constant string inputs. It first checks if the length of the first string is at least as long as the length of the second string. If this condition is satisfied, the function compares the corresponding characters from the beginning of the first string with those from the second string. If all compared characters match, the function returns a boolean value of true; otherwise, it returns false. The primary functionality of the function is to determine whether the first string starts with the second string.",
        "code_id": "c_group_1_id_264",
        "code_text": "bool startsWith( std::string const& s, std::string const& prefix ) {\n        return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_265",
        "query_text": "The function takes a single character as input and returns a boolean value indicating whether the character is alphabetic (either uppercase or lowercase). Internally, it converts the input character to an unsigned representation and utilizes a standard library function to perform the alphabetic check. If the input character qualifies as a letter, the function returns true; otherwise, it returns false. The input is of type char and the output is of type bool.",
        "code_id": "c_group_1_id_265",
        "code_text": "inline bool IsAlpha(char ch) {\n  return isalpha(static_cast<unsigned char>(ch)) != 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_266",
        "query_text": "The function accepts two constant string references. It checks if the second string appears as a contiguous sequence of characters within the first string. The function returns a boolean value indicating the result, where \"true\" signifies that the second string is found and \"false\" indicates it is not.",
        "code_id": "c_group_1_id_266",
        "code_text": "bool contains( std::string const& s, std::string const& infix ) {\n        return s.find( infix ) != std::string::npos;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_267",
        "query_text": "The function accepts a floating-point input and checks whether the value is \u201cNot a Number\u201d (NaN). It returns a boolean value: true if the input is NaN and false otherwise. The primary purpose of this function is to serve as a simple utility for validating the numerical value of a floating-point variable. The input type is float and the output type is bool.",
        "code_id": "c_group_1_id_267",
        "code_text": "bool isnan(float f) {\n        return std::isnan(f);\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_268",
        "query_text": "The function accepts two integers: one representing an ASCII character and the other representing a radix (base). It begins by verifying that the provided character code corresponds to a decimal digit (i.e., between '0' and '9'). It then checks whether the numeric value of that digit (obtained by subtracting the ASCII value for '0') is less than the specified radix. Finally, the function returns a boolean value: it outputs true if both conditions are met, and false otherwise.",
        "code_id": "c_group_1_id_268",
        "code_text": "static bool inline IsDecimalDigitForRadix(int c, int radix) {\n  return '0' <= c && c <= '9' && (c - '0') < radix;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_269",
        "query_text": "The function takes an integer input representing a Unicode code point and returns a boolean value. It first checks whether the character is one of a set of explicitly defined symbols (for instance, certain punctuation marks, whitespace characters, and specific control characters) and immediately returns false for them\u2014with one exception where a particular control value results in true. If the input does not match these cases, the function performs a series of range checks: it rejects characters that fall into control ranges (i.e., below a given low threshold), ignores characters in a narrow range following the standard printable set, and then further excludes characters within specific invalid Unicode ranges (such as surrogate pairs, non-characters, and code points exceeding the Unicode maximum). Generally, printable ASCII characters and valid Unicode characters that do not trigger any of these conditions are accepted as anchor characters. \n\nInput: int (representing a Unicode code point)  \nOutput: bool (true if the character qualifies as an anchor character, false otherwise)",
        "code_id": "c_group_1_id_269",
        "code_text": "bool IsAnchorChar(int ch) {  \n  switch (ch) {\n    case ',':\n    case '[':\n    case ']':\n    case '{':\n    case '}':  \n    case ' ':\n    case '\\t':    \n    case 0xFEFF:  \n    case 0xA:\n    case 0xD:  \n      return false;\n    case 0x85:\n      return true;\n  }\n\n  if (ch < 0x20) {\n    return false;\n  }\n\n  if (ch < 0x7E) {\n    return true;\n  }\n\n  if (ch < 0xA0) {\n    return false;\n  }\n  if (ch >= 0xD800 && ch <= 0xDFFF) {\n    return false;\n  }\n  if ((ch & 0xFFFE) == 0xFFFE) {\n    return false;\n  }\n  if ((ch >= 0xFDD0) && (ch <= 0xFDEF)) {\n    return false;\n  }\n  if (ch > 0x10FFFF) {\n    return false;\n  }\n\n  return true;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_270",
        "query_text": "The function takes no input parameters and returns a boolean value indicating the support status of a specific mapping feature. It determines the availability based on whether a particular preprocessor directive is defined; if the directive is present, the function returns false, indicating that the mapping feature is disabled, otherwise, it returns true, signifying that the feature is enabled.",
        "code_id": "c_group_1_id_270",
        "code_text": "static inline bool hasDualMappingSupport() noexcept {\n#if defined(ASMJIT_NO_DUAL_MAPPING)\n  return false;\n#else\n  return true;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_271",
        "query_text": "The function takes two floating-point numbers as input. It compares the second input value with the first input value, treated as an edge threshold. If the second value is less than the edge, it returns 0.0; otherwise, it returns 1.0. Essentially, the function implements a step function that produces a binary output (0.0 or 1.0) based on whether the provided value is below or above the specified edge.",
        "code_id": "c_group_1_id_271",
        "code_text": "CGLM_INLINE\nfloat\nglm_step(float edge, float x) {\n  \n  return (x < edge) ? 0.0f : 1.0f;\n  \n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_272",
        "query_text": "The function receives three inputs: a pointer to a destination buffer, a pointer to a source string, and the size of the destination buffer. It iterates through the source string, copying each character to the destination buffer until either the null terminator of the source string is encountered or the destination buffer has been filled up to one less than its capacity. After copying, the function appends a null terminator to the destination buffer to ensure it forms a valid C-style string. Finally, the function returns a value of type size_t representing the number of characters copied (excluding the terminating null character).",
        "code_id": "c_group_1_id_272",
        "code_text": "size_t wc_strlcpy(char *dst, const char *src, size_t dstSize)\n{\n    size_t i;\n\n    if (!dstSize)\n        return 0;\n\n    \n    for (i = 0; i < (dstSize - 1) && *src != '\\0'; i++) {\n        *dst++ = *src++;\n    }\n    *dst = '\\0';\n\n    return i; \n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_273",
        "query_text": "The function accepts five floating-point arguments: one representing a scalar interpolation parameter and four representing control values that influence the smooth curve's behavior. Inside, it uses basic arithmetic operations\u2014such as multiplication and addition\u2014to compute several intermediate values. These computed values are then combined using a specific mathematical formula to perform the interpolation. The final result is a single floating-point value that represents the interpolated output. The function performs all calculations internally without relying on external dependencies, and its operation is fully deterministic, ensuring that identical inputs will always produce the same result.",
        "code_id": "c_group_1_id_273",
        "code_text": "CGLM_INLINE\nfloat\nglm_hermite(float s, float p0, float t0, float t1, float p1) {\n  float ss, d, a, b, c, e, f;\n\n  ss = s  * s;\n  a  = ss + ss;\n  c  = a  + ss;\n  b  = a  * s;\n  d  = s  * ss;\n  f  = d  - ss;\n  e  = b  - c;\n\n  return p0 * (e + 1.0f) + t0 * (f - ss + s) + t1 * f - p1 * e;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_274",
        "query_text": "The function takes three inputs: a pointer to a wide-character string, a wide-character separator, and a count of type size_t. It first verifies that the input string is not null and immediately returns the original string if the count is zero. If the count is non-zero, it searches for the first occurrence of the separator in the string. The function then iterates to locate the subsequent occurrences until it finds the nth occurrence. If the nth occurrence is found, it returns a pointer to the character immediately following that occurrence; otherwise, if any occurrence is missing or the string is empty, the function returns a null pointer.",
        "code_id": "c_group_1_id_274",
        "code_text": "FT_INTERNAL\nconst wchar_t *wstr_n_substring_beg(const wchar_t *str, wchar_t ch_separator, size_t n)\n{\n    if (str == NULL)\n        return NULL;\n\n    if (n == 0)\n        return str;\n\n    str = wcschr(str, ch_separator);\n    --n;\n    while (n > 0) {\n        if (str == NULL)\n            return NULL;\n        --n;\n        str++;\n        str = wcschr(str, ch_separator);\n    }\n    return str ? (str + 1) : NULL;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_275",
        "query_text": "The function takes a single input: a floating-point value that typically represents a normalized time or progress value between 0 and 1. It then computes and returns a floating-point output by evaluating the input against a series of four distinct intervals. For each interval, a different mathematical expression is applied\u2014beginning with the calculation of the input\u2019s square\u2014resulting in a smooth, non-linear transformation. This piecewise computation generates what is known as a \"bounce-out\" easing effect, which is commonly used in animations to simulate a deceleration with a bouncing motion as the transition nears completion.",
        "code_id": "c_group_1_id_275",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_bounce_out(float t) {\n  float tt;\n\n  tt = t * t;\n\n  if (t < (4.0f / 11.0f))\n    return (121.0f * tt) / 16.0f;\n\n  if (t < 8.0f / 11.0f)\n    return ((363.0f / 40.0f) * tt) - ((99.0f / 10.0f) * t) + (17.0f / 5.0f);\n\n  if (t < (9.0f / 10.0f))\n    return (4356.0f / 361.0f) * tt\n            - (35442.0f / 1805.0f) * t\n            + (16061.0f / 1805.0f);\n\n  return ((54.0f / 5.0f) * tt) - ((513.0f / 25.0f) * t) + (268.0f / 25.0f);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_276",
        "query_text": "The function computes the Root Mean Square (RMS) error between two arrays of double-precision floating-point numbers. It takes as input two arrays and an integer representing the number of elements in the arrays. The function iterates over the elements, calculates the squared difference between each pair of corresponding elements, and accumulates these values. It then divides the total by one less than the number of elements before taking the square root of the result. The output is a double-precision floating-point number representing the RMS error.",
        "code_id": "c_group_1_id_276",
        "code_text": "double RMS_Error(double *data, double *rec, int N) {\n    int i;\n    double sum = 0;\n    for (i = 0; i < N; ++i) {\n        sum += (data[i] - rec[i])*(data[i] - rec[i]);\n    }\n    return sqrt(sum/((double)N-1));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_277",
        "query_text": "The function takes two inputs: a pointer to a constant character string, and a pointer to a pointer to a constant character string. It checks whether the target string starts with the given prefix by comparing the beginning of the target string with the prefix. If the target string starts with the prefix, it advances the pointer to the target string by the length of the prefix and returns true; if not, it leaves the pointer unchanged and returns false. The input types are a pointer to a constant char and a pointer to a pointer to a constant char, and the output is of type bool.",
        "code_id": "c_group_1_id_277",
        "code_text": "bool SkipPrefix(const char* prefix, const char** pstr) {\n  const size_t prefix_len = strlen(prefix);\n  if (strncmp(*pstr, prefix, prefix_len) == 0) {\n    *pstr += prefix_len;\n    return true;\n  }\n  return false;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_278",
        "query_text": "The function accepts three parameters: an unsigned long integer, an unsigned char indicating the number of leading bits, and an unsigned char serving as a right shift amount. It first creates a header by computing a bit pattern where the specified number of highest-order bits are set. Then, it constructs a mask by right-shifting a full 8-bit value to leave room for the header. After shifting the integer by the provided amount and applying the mask to isolate the relevant bits, it combines these results using a bitwise OR operation. The final output is a char value that encodes the adjusted data based on the header and masked portion.",
        "code_id": "c_group_1_id_278",
        "code_text": "inline char Utf8Adjust(unsigned long ch, unsigned char lead_bits,\n                       unsigned char rshift) {\n  const unsigned char header =\n      static_cast<unsigned char>(((1 << lead_bits) - 1) << (8 - lead_bits));\n  const unsigned char mask = (0xFF >> (lead_bits + 1));\n  return static_cast<char>(\n      static_cast<unsigned char>(header | ((ch >> rshift) & mask)));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_279",
        "query_text": "The function receives three inputs: an array of string pointers (with each string represented by an array of unsigned characters), an integer specifying the count of strings in the array, and another integer that indicates the starting offset within each string for comparisons. It performs an in-place ascending order sort on the array using an insertion sort algorithm. The comparison process begins at the provided offset for each string and continues character by character until a discrepancy is detected or the end of a string is reached. This function does not return any value since it modifies the input array directly.",
        "code_id": "c_group_1_id_279",
        "code_text": "static\nvoid isort(unsigned char **a, int n, int d)\n{\n\tunsigned char **pi, **pj, *s, *t;\n\tfor (pi = a + 1; --n > 0; pi++)\n\t\tfor (pj = pi; pj > a; pj--) {\n\t\t\tfor (s=*(pj-1)+d, t=*pj+d;\n\t\t\t\t\t*s==*t && *s!=0; s++, t++) ;\n\t\t\tif (*s <= *t) break;\n\t\t\tt = *(pj); *(pj) = *(pj-1);\n\t\t\t*(pj-1) = t;\n\t\t}\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_280",
        "query_text": "The function takes a single input\u2014a pointer to a character array representing the program's name or path. It first extracts only the program name by removing any preceding directory path components if a '/' is present. Next, it prints a formatted message that details how to run the program, showing two examples: one for executing a single throughput test and another for running multiple tests (indicating the best result among them). Finally, the function terminates the program with an exit status of 0. The input is of type \"const char *\", and the function does not return any value (void).",
        "code_id": "c_group_1_id_280",
        "code_text": "static void\nusage_exit (const char * argv0)\n{\tconst char * cptr ;\n\n\tif ((cptr = strrchr (argv0, '/')) != NULL)\n\t\targv0 = cptr ;\n\n\tprintf (\n\t\t\"Usage :\\n\"\n\t \t\"    %s                 - Single run of the throughput test.\\n\"\n\t\t\"    %s --best-of N     - Do N runs of test a print bext result.\\n\"\n\t\t\"\\n\",\n\t\targv0, argv0) ;\n\n\texit (0) ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_281",
        "query_text": "The function accepts three floating-point inputs. The first two inputs define a range, while the third represents a value within or beyond this range. The function determines the relative position of the third value between the two endpoints. It starts by calculating the difference between the second and first values. If this difference is zero, meaning the range is degenerate, the function returns 1.0 to indicate that the third value is considered at the end of the range. Otherwise, it computes the ratio of the difference between the third value and the first value to that overall range, effectively expressing the position as a percentage. The function then returns this computed ratio as the output.",
        "code_id": "c_group_1_id_281",
        "code_text": "CGLM_INLINE\nfloat\nglm_percent(float from, float to, float current) {\n  float t;\n\n  if ((t = to - from) == 0.0f)\n    return 1.0f;\n\n  return (current - from) / t;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_282",
        "query_text": "The function accepts two parameters: a pointer to an array of floating-point numbers and an integer representing the number of elements in the array. It processes the array by swapping elements from opposite ends, starting with the first and last elements, gradually moving towards the center. This approach results in the entire array being reversed in place, meaning the original array is directly modified. The function does not return any value.",
        "code_id": "c_group_1_id_282",
        "code_text": "void\nreverse_data (float *data, int datalen)\n{\tint left, right ;\n\tfloat temp ;\n\n\tleft = 0 ;\n\tright = datalen - 1 ;\n\n\twhile (left < right)\n\t{\ttemp = data [left] ;\n\t\tdata [left] = data [right] ;\n\t\tdata [right] = temp ;\n\t\tleft ++ ;\n\t\tright -- ;\n\t\t} ;\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_283",
        "query_text": "This function is responsible for handling critical errors within a program. It accepts a single input\u2014a constant character pointer representing an error message. If the message is non-null, the function writes the message to the standard error stream with a fixed error prefix. Immediately after outputting the error message, the function terminates the program by calling for an exit with a failure status. The design of this function uses a non-returning attribute, indicating that it does not return any value and that its execution forces program termination.",
        "code_id": "c_group_1_id_283",
        "code_text": "static WC_INLINE\n#if defined(WOLFSSL_FORCE_MALLOC_FAIL_TEST) || defined(WOLFSSL_ZEPHYR)\nTHREAD_RETURN\n#else\nWC_NORETURN void\n#endif\nerr_sys(const char* msg)\n{\n#if !defined(__GNUC__)\n    \n    if (msg)\n#endif\n    {\n        fprintf(stderr, \"wolfSSL error: %s\\n\", msg);\n    }\n    XEXIT_T(EXIT_FAILURE);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_284",
        "query_text": "This function determines the length of a wide-character string by counting its characters until the null terminator is reached. It validates that the input pointer (of type const wide-character string pointer) is not null using an assertion. Depending on a compile-time flag, it either employs a standard library function to obtain the length or iterates manually through the string. The computed length, excluding the null termiantor, is returned as a value of type size_t.",
        "code_id": "c_group_1_id_284",
        "code_text": "size_t strlength_wide(const wchar_t* s)\n\t{\n\t\tassert(s);\n\n\t#ifdef PUGIXML_WCHAR_MODE\n\t\treturn wcslen(s);\n\t#else\n\t\tconst wchar_t* end = s;\n\t\twhile (*end) end++;\n\t\treturn static_cast<size_t>(end - s);\n\t#endif\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_285",
        "query_text": "The function takes no input arguments and does not return any value. It outputs a series of formatted messages to the console that provide usage instructions for a unit testing program. Specifically, it prints details on available command-line options, including displaying help information, listing available tests, running specific tests by either number or name, and specifying a file for cipher suite testing. This information serves as guidance on how to operate the unit testing tool.",
        "code_id": "c_group_1_id_285",
        "code_text": "static void UnitTest_Usage(void)\n{\n    printf(\"Usage: ./tests/unit.test <options>\\n\");\n    printf(\" -?, --help     Display this usage information.\\n\");\n    printf(\" --list         List the API tests.\\n\");\n    printf(\" --api          Only perform API tests.\\n\");\n    printf(\" -<number>      Run the API test identified by number.\\n\");\n    printf(\"                Can be specified multiple times.\\n\");\n    printf(\" -<string>      Run the API test identified by name.\\n\");\n    printf(\"                Can be specified multiple times.\\n\");\n    printf(\" <filename>     Name of cipher suite testing file.\\n\");\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_286",
        "query_text": "The function accepts an unsigned integer as input and returns an unsigned integer as output. It computes the base-2 logarithm of the input by determining the position of the most significant set bit, effectively finding the highest power of 2 that is less than or equal to the input value. This is achieved by counting the number of leading zero bits in the binary representation of the input using a compiler intrinsic, and then calculating the logarithm by adjusting this count.",
        "code_id": "c_group_1_id_286",
        "code_text": "static inline unsigned log2(unsigned n)\n{ return 8*sizeof(unsigned)-1-__builtin_clz(n); }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_287",
        "query_text": "The function takes no parameters and returns a std::string representing the temporary directory path, determined based on the operating system and environment. It first checks if a custom temporary directory function is defined via a specific macro; if so, it returns the result of that function. On Windows Mobile, it directly returns a hard-coded directory path (\"\\\\temp\\\\\"). For Windows systems, it retrieves an environment variable; if the variable is either unset or empty, it defaults to the same hard-coded path, and if it exists but lacks a trailing backslash, it appends one before returning. On Android, it returns a predefined path (\"/sdcard/\"), while for other systems such as Linux or Unix-like environments, it defaults to returning \"/tmp/\".",
        "code_id": "c_group_1_id_287",
        "code_text": "std::string TempDir() {\n#if defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_)\n  return GTEST_CUSTOM_TEMPDIR_FUNCTION_();\n#endif\n\n#if GTEST_OS_WINDOWS_MOBILE\n  return \"\\\\temp\\\\\";\n#elif GTEST_OS_WINDOWS\n  const char* temp_dir = internal::posix::GetEnv(\"TEMP\");\n  if (temp_dir == NULL || temp_dir[0] == '\\0')\n    return \"\\\\temp\\\\\";\n  else if (temp_dir[strlen(temp_dir) - 1] == '\\\\')\n    return temp_dir;\n  else\n    return std::string(temp_dir) + \"\\\\\";\n#elif GTEST_OS_LINUX_ANDROID\n  return \"/sdcard/\";\n#else\n  return \"/tmp/\";\n#endif  \n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_288",
        "query_text": "The function takes an integer as input, representing a signature algorithm identifier, and returns an integer indicating whether this algorithm is supported. It checks the input against a set of supported algorithms, which are conditionally included based on compile-time flags. If the input matches any one of these supported algorithms, the function returns 1; otherwise, it returns 0. The input is of type int and the output is also an int.",
        "code_id": "c_group_1_id_288",
        "code_text": "static int SigAlgoCachesMsgs(int sigAlgo)\n{\n    int ret;\n\n    (void)sigAlgo;\n\n#ifdef HAVE_ED25519\n    if (sigAlgo == ed25519_sa_algo) {\n        ret = 1;\n    }\n    else\n#endif\n#ifdef HAVE_ED448\n    if (sigAlgo == ed448_sa_algo) {\n        ret = 1;\n    }\n    else\n#endif\n#if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)\n    if (sigAlgo == sm2_sa_algo) {\n        ret = 1;\n    }\n    else\n#endif\n    {\n        ret = 0;\n    }\n\n    return ret;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_289",
        "query_text": "The function accepts a pointer to a double as its input and returns a value of type const char*. Its primary objective is to select and return the appropriate unit of measurement (for example, \"GiB\", \"MiB\", \"KiB\", or \"bytes\") based on the value pointed to by the input. Additionally, the function scales the numeric value in place by dividing it by the corresponding factor for the selected unit. In configurations where fixed units are specified via preprocessor directives, the function uses the predetermined unit and scaling factor. If no fixed unit is configured, it dynamically determines the unit based on whether the value exceeds certain thresholds (for instance, greater than 1024 or 1024\u00d71024), applying the corresponding division and returning the related unit string.",
        "code_id": "c_group_1_id_289",
        "code_text": "static const char* get_blocktype(double* blocks)\n{\n    const char* rt;\n\n#if (  defined(WOLFSSL_BENCHMARK_FIXED_UNITS_G) || \\\n       defined(WOLFSSL_BENCHMARK_FIXED_UNITS_GB))\n    #undef  WOLFSSL_FIXED_UNIT\n    #define WOLFSSL_FIXED_UNIT \"GB\"\n    *blocks /= (1024UL * 1024UL * 1024UL);\n    rt = \"GiB\";\n#elif (defined(WOLFSSL_BENCHMARK_FIXED_UNITS_M) || \\\n       defined(WOLFSSL_BENCHMARK_FIXED_UNITS_MB))\n    #undef  WOLFSSL_FIXED_UNIT\n    #define WOLFSSL_FIXED_UNIT \"MB\"\n    *blocks /= (1024UL * 1024UL);\n    rt = \"MiB\";\n#elif (defined(WOLFSSL_BENCHMARK_FIXED_UNITS_K) || \\\n       defined(WOLFSSL_BENCHMARK_FIXED_UNITS_KB))\n    #undef  WOLFSSL_FIXED_UNIT\n    #define WOLFSSL_FIXED_UNIT \"KB\"\n    *blocks /= 1024;\n    rt = \"KiB\";\n#elif  defined (WOLFSSL_BENCHMARK_FIXED_UNITS_B)\n    #undef  WOLFSSL_FIXED_UNIT\n    #define WOLFSSL_FIXED_UNIT \"bytes\"\n    (void)(*blocks); \n    rt = \"bytes\";\n#else\n    \n    if (*blocks > (1024UL * 1024UL)) {\n        *blocks /= (1024UL * 1024UL);\n        rt = \"MiB\";\n    }\n    else if (*blocks > 1024) {\n        *blocks /= 1024;\n        rt = \"KiB\";\n    }\n    else {\n        rt = \"bytes\";\n    }\n#endif\n\n    return rt;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_290",
        "query_text": "The function takes no input arguments and returns an unsigned 32-bit integer representing the number of available hardware threads (logical processors). It queries the system's online processor count using a standard system configuration call. If the call fails or returns a non-positive value, the function defaults to returning 1; otherwise, it returns the queried count.",
        "code_id": "c_group_1_id_290",
        "code_text": "static inline uint32_t detectHWThreadCount() noexcept {\n  long res = ::sysconf(_SC_NPROCESSORS_ONLN);\n  return res <= 0 ? uint32_t(1) : uint32_t(res);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_291",
        "query_text": "The function takes no input arguments and returns a constant string representing the version information of a specific library. The output is of type const char*, which points to a predefined constant string holding the version details. This function serves as a straightforward utility to retrieve the library's version without performing any additional processing.",
        "code_id": "c_group_1_id_291",
        "code_text": "const char* wolfSSL_lib_version(void)\n{\n    return LIBWOLFSSL_VERSION_STRING;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_292",
        "query_text": "The function takes an unsigned long integer as input and returns an integer. It starts by applying a built-in operation to count the consecutive zero bits in the binary representation of the input, scanning from the most significant bit until it reaches the first non-zero bit. The resulting count is then returned, and the function guarantees that no exceptions are thrown.",
        "code_id": "c_group_1_id_292",
        "code_text": "inline STRF_HD int countl_zero_l(unsigned long x) noexcept\n{\n    return __builtin_clzl(x);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_293",
        "query_text": "The function takes a single character as input and returns a character converted to lowercase. It first converts the input to an unsigned character to ensure safe handling of potential negative values, then applies a standard lowercase conversion routine, and finally casts the result back to a character. This process guarantees that the output is the lowercase equivalent of the input.",
        "code_id": "c_group_1_id_293",
        "code_text": "char toLowerCh(char c) {\n            return static_cast<char>( std::tolower( static_cast<unsigned char>(c) ) );\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_294",
        "query_text": "The function accepts an input of type const char*, representing the name of an environment variable. It queries the system's environment for the variable and returns a const char* representing the corresponding value if it exists and is non-empty. If the environment variable does not exist, is an empty string, or if the platform is unsupported, the function returns NULL.",
        "code_id": "c_group_1_id_294",
        "code_text": "inline const char* GetEnv(const char* name) {\n#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT\n  \n  static_cast<void>(name);  \n  return NULL;\n#elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)\n  \n  \n  const char* const env = getenv(name);\n  return (env != NULL && env[0] != '\\0') ? env : NULL;\n#else\n  return getenv(name);\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_295",
        "query_text": "The function takes three parameters: an integer representing the total number of elements, and two arrays containing double-precision floating-point numbers that hold the datasets to be compared. It calculates the squared differences between corresponding elements in the two arrays, accumulates these values, and then divides the total by the number of elements to compute the average of the squared differences. Finally, it takes the square root of this average to obtain the Root Mean Square Error (RMSE), which is returned as a double.",
        "code_id": "c_group_1_id_295",
        "code_text": "static double rmse(int N,double *x,double *y) {\n\tdouble rms;\n\tint i;\n\n\trms = 0.0;\n\n\tfor(i = 0; i < N;++i) {\n\t\trms += (x[i] - y[i]) * (x[i] - y[i]);\n\t}\n\n\trms = sqrt(rms/(double)N);\n\n\treturn rms;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_296",
        "query_text": "The function takes an array of floating-point numbers and an integer representing the array's length. It iterates over the array, calculates the absolute value of each element, and updates the current maximum when a larger absolute value is found. Finally, it returns the maximum absolute value as a floating-point number.",
        "code_id": "c_group_1_id_296",
        "code_text": "double absmax(double *array, int N) {\n\tdouble max;\n\tint i;\n\n\tmax = 0.0;\n\tfor (i = 0; i < N; ++i) {\n\t\tif (fabs(array[i]) >= max) {\n\t\t\tmax = fabs(array[i]);\n\t\t}\n\t}\n\n\treturn max;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_297",
        "query_text": "The function takes a single character (of type char) as input and returns its lowercase equivalent (of type char). It leverages the standard C++ locale facilities to perform the conversion according to the rules of the classic \"C\" locale.",
        "code_id": "c_group_1_id_297",
        "code_text": "inline char ToLower(char ch) {\n  static const std::ctype<char>& cType =\n      std::use_facet<std::ctype<char> >(std::locale::classic());\n  return cType.tolower(ch);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_298",
        "query_text": "The function returns a reference to a constant pointer to a stream buffer linked to the standard output stream. It takes no input arguments and employs a static variable to ensure the same pointer is reused on every call, thereby providing consistent access to the output stream's buffer.",
        "code_id": "c_group_1_id_298",
        "code_text": "inline const std::streambuf*& get_coutbuf()\n{\n  static const std::streambuf* pout = std::cout.rdbuf();\n  return pout;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_299",
        "query_text": "This function accepts a pointer to a character array along with its length as inputs. It iterates through each character in the array and checks if the character is an unprintable control character, while explicitly ignoring the tab, newline, and carriage return characters. If an unprintable control character is found, the function returns a boolean true immediately. If no such character is encountered after examining the entire string, it returns false.",
        "code_id": "c_group_1_id_299",
        "code_text": "bool ContainsUnprintableControlCodes(const char* str, size_t length) {\n  const unsigned char *s = reinterpret_cast<const unsigned char *>(str);\n\n  for (size_t i = 0; i < length; i++) {\n    unsigned char ch = *s++;\n    if (std::iscntrl(ch)) {\n        switch (ch) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n          break;\n        default:\n          return true;\n        }\n      }\n  }\n  return false;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_300",
        "query_text": "The function begins by receiving a string input that is meant to be converted to a 64-bit integer, along with a pointer to an integer that reflects the success or failure of this conversion. It attempts to perform the conversion using a standard library routine, and then examines any remaining characters or error flags to determine whether the conversion completed without issues. If extraneous characters are found or an error occurs, it sets the provided status pointer to indicate failure and returns a zero value. Otherwise, it marks the conversion as successful via the status pointer and returns the successfully parsed 64-bit integer.",
        "code_id": "c_group_1_id_300",
        "code_text": "long long libconfig_parse_integer(const char *s, int *ok)\n{\n  long long llval;\n  char *endptr;\n  int errsave = errno;\n  errno = 0;\n  llval = strtoll(s, &endptr, 0);\t\n  if(*endptr || errno)\n  {\n    errno = 0;\n    *ok = 0;\n    return(0);\t\n  }\n  errno = errsave;\n\n  *ok = 1;\n  return(llval);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_301",
        "query_text": "This description details a function that writes two arrays of double-precision numbers to a file formatted for compatibility with a numerical computing tool. The function takes five parameters: a filename specifying where to write the data, a pointer to a double array representing input values, an integer denoting the number of elements in the input array, a pointer to a double array representing output values, and an integer for the number of elements in the output array. Initially, the function attempts to open the specified file for writing. If the file cannot be opened, it exits immediately without performing any operations. Otherwise, it writes a header comment to indicate that the file was not generated by the numerical computing tool. It then writes metadata for the input dataset, including the type identifier, the row count (derived from the input array length), and a fixed column count, followed by the actual input data values. Next, it writes analogous metadata for the output dataset and sequentially writes the corresponding output data. Finally, the file is closed, and the function completes without returning any value.",
        "code_id": "c_group_1_id_301",
        "code_text": "void\nsave_oct_double (char *filename, double *input, int in_len, double *output, int out_len)\n{\tFILE \t*file ;\n\tint\t\tk ;\n\n\tprintf (\"Dumping input and output data to file : %s.\\n\\n\", filename) ;\n\n\tif (! (file = fopen (filename, \"w\")))\n\t\treturn ;\n\n\tfprintf (file, \"# Not created by Octave\\n\") ;\n\n\tfprintf (file, \"# name: input\\n\") ;\n\tfprintf (file, \"# type: matrix\\n\") ;\n\tfprintf (file, \"# rows: %d\\n\", in_len) ;\n\tfprintf (file, \"# columns: 1\\n\") ;\n\n\tfor (k = 0 ; k < in_len ; k++)\n\t\tfprintf (file, \"% g\\n\", input [k]) ;\n\n\tfprintf (file, \"# name: output\\n\") ;\n\tfprintf (file, \"# type: matrix\\n\") ;\n\tfprintf (file, \"# rows: %d\\n\", out_len) ;\n\tfprintf (file, \"# columns: 1\\n\") ;\n\n\tfor (k = 0 ; k < out_len ; k++)\n\t\tfprintf (file, \"% g\\n\", output [k]) ;\n\n\tfclose (file) ;\n\treturn ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_302",
        "query_text": "The function accepts a pointer to an array of constant C-style strings (of type const char* const*). It checks whether the input pointer is null; if it is, the function exits without performing any operations. Otherwise, it iterates over the array, deleting each string via a helper routine, and finally deletes the array itself using the same helper. The function does not return any value (void).",
        "code_id": "c_group_1_id_302",
        "code_text": "void libconfig_strvec_delete(const char *const *vec)\n{\n  const char *const *p;\n\n  if(!vec) return;\n\n  for(p = vec; *p; ++p)\n    __delete(*p);\n\n  __delete(vec);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_303",
        "query_text": "The function accepts two wide character inputs (of type wchar_t) and returns a boolean value (bool). It determines whether these characters form a valid UTF-16 surrogate pair. To do so, it ensures that the first character falls within the high surrogate range (0xD800\u20130xDBFF) and the second falls within the low surrogate range (0xDC00\u20130xDFFF), while also confirming that the size of wchar_t is exactly 2 bytes. If all checks pass, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_303",
        "code_text": "inline bool IsUtf16SurrogatePair(wchar_t first, wchar_t second) {\n  return sizeof(wchar_t) == 2 &&\n      (first & 0xFC00) == 0xD800 && (second & 0xFC00) == 0xDC00;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_304",
        "query_text": "The function accepts two characters as inputs. It computes the difference between their ASCII values and returns the result as an integer. A positive outcome indicates that the first character's ASCII value is greater, a negative outcome indicates it is lower, and zero signifies that both characters have the same ASCII value.",
        "code_id": "c_group_1_id_304",
        "code_text": "static int char_cmp(char c1, char c2)\n{\n    return c1 - c2;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_305",
        "query_text": "The function takes two unsigned integers as inputs: a 64-bit value to be manipulated and a 32-bit value that specifies the number of bit positions for the rotation. It first confines the rotation count to a valid range (0 to 63) by applying a mask. The function then performs a right bitwise rotation by shifting the 64-bit input to the right by the specified count and combining it with the input shifted to the left by the complementary number (64 minus the count). Finally, it returns the resulting 64-bit unsigned integer after the rotation.",
        "code_id": "c_group_1_id_305",
        "code_text": "FMT_CONSTEXPR inline auto rotr(uint64_t n, uint32_t r) noexcept -> uint64_t {\n  r &= 63;\n  return (n >> r) | (n << (64 - r));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_306",
        "query_text": "The function receives two inputs, each being a generic pointer that represents a constant string. It casts these generic inputs into string types and then compares them lexicographically using a standard library routine. The function returns an integer: a negative value indicates that the first string is lexicographically smaller than the second, zero indicates that they are equal, and a positive value indicates that the first string is lexicographically larger than the second.",
        "code_id": "c_group_1_id_306",
        "code_text": "int cc_common_cmp_str(const void *str1, const void *str2)\n{\n    return strcmp((const char*) str1, (const char*) str2);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_307",
        "query_text": "The function takes one input: an unsigned integer, and produces an output of type bool. It shifts the unsigned integer right by 10 bits and then verifies whether the resulting value does not equal the hexadecimal constant 0x36. If the condition is met, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_307",
        "code_text": "constexpr STRF_HD bool not_high_surrogate(unsigned codepoint)\n{\n    return codepoint >> 10 != 0x36;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_308",
        "query_text": "The function takes an unsigned integer as input and returns a string. It returns an empty string if the input is 1, \"both \" if the input is 2, and \"all \" if the input is greater than 2. The output is a string determined by the value of the input.",
        "code_id": "c_group_1_id_308",
        "code_text": "std::string bothOrAll( std::size_t count ) {\n        return count == 1 ? std::string() :\n               count == 2 ? \"both \" : \"all \" ;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_309",
        "query_text": "This description details a function that prints a failure notification along with contextual information to standard output. It accepts three parameters: a pointer to a null-terminated string representing a file identifier, an integer signifying a source code line number, and a formatted string with optional variable arguments. The function begins by outputting the file identifier and line number in a formatted manner, then proceeds to print the dynamically formatted message, and finally appends a newline character. Note that the function does not return any value (void).",
        "code_id": "c_group_1_id_309",
        "code_text": "void tt_fail(const char *file, int line, const char *message, ...)\n{\n  va_list vp;\n  va_start(vp, message);\n  printf(\"%s:%d: failed: \", file, line);\n  vprintf(message, vp);\n  va_end(vp);\n  putchar('\\n');\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_310",
        "query_text": "The function accepts a single parameter: a character. It first determines if the character corresponds to a valid hexadecimal digit\u2014specifically, one of the characters that represent the digits 0-9 or the letters A-F/a-f. Based on this check, it returns a boolean value: true if the character is a hexadecimal digit, or false otherwise.",
        "code_id": "c_group_1_id_310",
        "code_text": "inline bool IsXDigit(char ch) {\n  return isxdigit(static_cast<unsigned char>(ch)) != 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_311",
        "query_text": "The function accepts two inputs: a string and a character. It first checks if the string is non-empty. If the string is not empty, it compares the first character of the string with the provided character and returns a boolean value indicating whether they match. If the string is empty, the function returns false.",
        "code_id": "c_group_1_id_311",
        "code_text": "bool startsWith( std::string const& s, char prefix ) {\n        return !s.empty() && s[0] == prefix;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_312",
        "query_text": "The function takes two inputs: a constant string (passed by reference) and a character. It verifies that the string is not empty and then checks if the last character of the string is equal to the specified character. If the conditions are met, it returns a boolean value true; otherwise, it returns false.",
        "code_id": "c_group_1_id_312",
        "code_text": "bool endsWith( std::string const& s, char suffix ) {\n        return !s.empty() && s[s.size()-1] == suffix;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_313",
        "query_text": "The function accepts three double-precision floating-point numbers as inputs and returns a boolean value. It determines whether two floating-point numbers are approximately equal within a provided tolerance. To do this, it computes whether adding the tolerance to the first number results in a value that is at least as large as the second number, and similarly, whether adding the tolerance to the second number results in a value that is at least as large as the first. If both these conditions hold true, the function returns true; otherwise, it returns false. This behavior makes the function useful for comparing floating-point numbers while accounting for potential inaccuracies due to precision limitations.",
        "code_id": "c_group_1_id_313",
        "code_text": "bool marginComparison(double lhs, double rhs, double margin) {\n    return (lhs + margin >= rhs) && (rhs + margin >= lhs);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_314",
        "query_text": "The function accepts three integers as input: one representing the total number of partitions in a distributed testing framework, another indicating the current partition's index, and the last representing a test identifier. It computes the remainder of the test identifier divided by the total number of partitions and compares this result to the current partition index. If they match, the function returns a boolean true, signifying that the test associated with the identifier should execute on the given partition; otherwise, it returns false. The function's primary purpose is to distribute tests evenly across partitions using modulo arithmetic.",
        "code_id": "c_group_1_id_314",
        "code_text": "bool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id) {\n  return (test_id % total_shards) == shard_index;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_315",
        "query_text": "The function takes a boolean value as input and returns its corresponding string representation. Specifically, if the input is true, it returns the string \"true\"; if the input is false, it returns the string \"false.\" The input is of type bool, and the output is of type std::string.",
        "code_id": "c_group_1_id_315",
        "code_text": "std::string toString( bool value ) {\n    return value ? \"true\" : \"false\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_316",
        "query_text": "The function takes a single character as input and returns a boolean value. It checks whether the provided character matches the standard option prefix. On all platforms, it verifies if the character is a hyphen ('-'). Additionally, on Windows systems, it also checks if the character is a forward slash ('/'). If the input character meets any of these conditions, the function returns true; otherwise, it returns false. The input is of type char and the output is of type bool.",
        "code_id": "c_group_1_id_316",
        "code_text": "inline auto isOptPrefix( char c ) -> bool {\n        return c == '-'\n#ifdef CATCH_PLATFORM_WINDOWS\n            || c == '/'\n#endif\n        ;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_317",
        "query_text": "The function takes a pointer to an open file as input and ensures that any data buffered for that file is physically saved to the underlying storage device. On platforms like Windows, it performs this operation using a system-specific flush buffer call, while on other systems such as Linux, it utilizes a synchronization system call. The function returns a boolean value that indicates whether the flush operation was successful (true) or not (false).",
        "code_id": "c_group_1_id_317",
        "code_text": "bool fsync(FILE *fp) {\n#ifdef _WIN32\n    return FlushFileBuffers(reinterpret_cast<HANDLE>(_get_osfhandle(_fileno(fp)))) != 0;\n#else\n    return ::fsync(fileno(fp)) == 0;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_318",
        "query_text": "The function accepts a constant string reference as input and returns a new string with leading and trailing whitespace characters removed. It locates the first and last characters in the input that are not whitespace and extracts the substring between these positions. If the input string consists solely of whitespace, the function returns an empty string. The input is of type std::string (passed as a constant reference), and the output is of type std::string.",
        "code_id": "c_group_1_id_318",
        "code_text": "std::string trim( std::string const& str ) {\n        static char const* whitespaceChars = \"\\n\\r\\t \";\n        std::string::size_type start = str.find_first_not_of( whitespaceChars );\n        std::string::size_type end = str.find_last_not_of( whitespaceChars );\n\n        return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_319",
        "query_text": "The function takes four unsigned integers that represent individual bytes of a UTF-8 encoded character, and it outputs a single unsigned integer representing the decoded Unicode code point. It does so by first applying bit masks to each byte to extract the relevant bits, then shifting these bits to their correct positions, and finally combining them using bitwise OR operations.",
        "code_id": "c_group_1_id_319",
        "code_text": "constexpr STRF_HD unsigned utf8_decode(unsigned ch0, unsigned ch1, unsigned ch2, unsigned ch3)\n{\n    return (((ch0 & 0x07) << 18) |\n            ((ch1 & 0x3F) << 12) |\n            ((ch2 & 0x3F) <<  6) |\n            ((ch3 & 0x3F) <<  0));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_320",
        "query_text": "The function accepts two inputs of type float. It considers one input as the first value and the other as the second value, then compares them to determine which is larger. The function returns the greater float value as its output. Its primary purpose is to compute the maximum value between the two provided floating-point numbers.",
        "code_id": "c_group_1_id_320",
        "code_text": "CGLM_INLINE\nfloat\nglm_max(float a, float b) {\n  if (a > b)\n    return a;\n  return b;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_321",
        "query_text": "The function takes two parameters: one representing the number of seconds since the epoch (a time specification) and another, a pointer to a structure for holding the broken-down time. It converts the time specification into its broken-down format in a thread-safe and platform-independent manner. Depending on the platform, it uses different conversion routines: a secure conversion function on one platform, a fallback approach that manually copies the result on another, and a reentrant conversion function on the remaining systems. The function returns a boolean value indicating whether the conversion was successful.",
        "code_id": "c_group_1_id_321",
        "code_text": "static bool PortableLocaltime(time_t seconds, struct tm* out) {\n#if defined(_MSC_VER)\n  return localtime_s(out, &seconds) == 0;\n#elif defined(__MINGW32__) || defined(__MINGW64__)\n  \n  \n  struct tm* tm_ptr = localtime(&seconds);  \n  if (tm_ptr == NULL)\n    return false;\n  *out = *tm_ptr;\n  return true;\n#else\n  return localtime_r(&seconds, out) != NULL;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_322",
        "query_text": "The function receives one floating-point parameter, typically representing a normalized time value between 0 and 1, and returns a floating-point result. For input values below 0.5, it computes a quintic easing-in transformation by raising the input to the fifth power (after appropriate intermediate steps). For input values of 0.5 or greater, it calculates a quintic easing-out effect by first transforming the input and then applying a quintic formula. The outcome is a smoothly interpolated value that transitions from 0 to 1 with symmetric acceleration and deceleration around the midpoint, making it suitable for natural-looking animations and transitions.",
        "code_id": "c_group_1_id_322",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_quint_inout(float t) {\n  float f, g;\n\n  if (t < 0.5f) {\n    f = t * t;\n    return 16.0f * f * f * t;\n  }\n\n  f = 2.0f * t - 2.0f;\n  g = f * f;\n\n  return 0.5f * g * g * f + 1.0f;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_323",
        "query_text": "The function takes a pointer to an array of unsigned characters along with an integer representing the number of elements in the array. It reverses the order of the elements in place by swapping the first element with the last, the second with the second-to-last, and so on until the array is completely reversed. The function does not return any value (void). Its primary purpose is to modify the array directly by reversing its content.",
        "code_id": "c_group_1_id_323",
        "code_text": "void fp_reverse (unsigned char *s, int len)\n{\n  int     ix, iy;\n  unsigned char t;\n\n  ix = 0;\n  iy = len - 1;\n  while (ix < iy) {\n    t     = s[ix];\n    s[ix] = s[iy];\n    s[iy] = t;\n    ++ix;\n    --iy;\n  }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_324",
        "query_text": "The function accepts a single integer input representing a CPU index and returns an integer output. It assembles a file path referencing a system file in the CPU frequency directory by incorporating the CPU index into the path string. It then opens the file in read mode and attempts to read the minimum frequency setting from it. If the file cannot be opened or if the frequency value cannot be correctly retrieved, the function returns -1 to signal an error. Otherwise, it returns the obtained frequency value as an integer. Additionally, the function manages any necessary dynamic memory allocation for constructing the file path and ensures the file is closed properly after the operation.",
        "code_id": "c_group_1_id_324",
        "code_text": "int\ncpu_scaling_min_freq(int cpu)\n{\n\tint min_freq;\n\tFILE *fp;\n\tchar *filename = NULL;\n\tif (asprintf(&filename,\n\t\t\"/sys/devices/system/cpu/cpu%d/cpufreq/scaling_min_freq\",\n\t\t\tcpu) == -1) {\n\t\treturn -1;\n\t}\n\tfp = fopen(filename, \"r\");\n\tfree(filename);\n\tif (!fp)\n\t\treturn -1;\n\tif (fscanf(fp, \"%d\", &min_freq) != 1)\n\t\tmin_freq = -1;\n\tfclose(fp);\n\treturn min_freq;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_325",
        "query_text": "The function takes an integer as input, representing a day-of-week index (with 0 corresponding to Sunday and 6 to Saturday). It checks if the provided index falls within the valid range of 0 to 6. If the input is valid, the function returns a pointer to a constant string that holds the full name of the day. If the input is outside the valid range, it returns a pointer to a constant string containing a question mark (\"?\"). The input is of type int, and the output is of type const char*.",
        "code_id": "c_group_1_id_325",
        "code_text": "inline auto tm_wday_full_name(int wday) -> const char* {\n  static constexpr const char* full_name_list[] = {\n      \"Sunday\",   \"Monday\", \"Tuesday\", \"Wednesday\",\n      \"Thursday\", \"Friday\", \"Saturday\"};\n  return wday >= 0 && wday <= 6 ? full_name_list[wday] : \"?\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_326",
        "query_text": "The function takes a string as input and returns a boolean value. It evaluates the input string to determine if it is readable by checking two conditions: whether the string\u2019s length is 20 characters or fewer, or whether it does not contain the characters '<' or '('. If either condition is satisfied, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_326",
        "code_text": "inline bool IsReadableTypeName(const std::string& type_name) {\n  \n  \n  return (type_name.length() <= 20 ||\n          type_name.find_first_of(\"<(\") == std::string::npos);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_327",
        "query_text": "The function takes a reference to a string as input and modifies it in place by converting any uppercase letters to their corresponding lowercase letters. It achieves the conversion by iterating over each character and applying a transformation that checks if the character is uppercase; if so, it adjusts its value to the lowercase equivalent. Subsequently, the function returns the modified string, maintaining the input\u2019s type.",
        "code_id": "c_group_1_id_327",
        "code_text": "inline std::string &to_lower_(std::string &str) {\n    std::transform(str.begin(), str.end(), str.begin(), [](char ch) {\n        return static_cast<char>((ch >= 'A' && ch <= 'Z') ? ch + ('a' - 'A') : ch);\n    });\n    return str;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_328",
        "query_text": "The function accepts five floating-point inputs. The first represents a position along a curve (a value between 0 and 1), and the remaining four denote the points defining a cubic B\u00e9zier curve: the starting point, two control points, and the ending point. Internally, the function uses B\u00e9zier interpolation formulas to blend these points mathematically and calculates an intermediate value corresponding to the position on the curve at the specified parameter. It then returns this computed floating-point value as the output.",
        "code_id": "c_group_1_id_328",
        "code_text": "CGLM_INLINE\nfloat\nglm_bezier(float s, float p0, float c0, float c1, float p1) {\n  float x, xx, ss, xs3, a;\n\n  x   = 1.0f - s;\n  xx  = x * x;\n  ss  = s * s;\n  xs3 = (s - ss) * 3.0f;\n  a   = p0 * xx + c0 * xs3;\n\n  return a + s * (c1 * xs3 + p1 * ss - a);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_329",
        "query_text": "The function accepts three inputs: an integer denoting the number of elements, and two pointers to arrays of double-precision floating-point numbers. It begins by computing the mean of each dataset by iterating through each array and averaging the values. Using these means, the function calculates the covariance between the two datasets by summing the product of the differences from the mean for each pair of corresponding elements. Simultaneously, it determines the sum of squared differences for each dataset to evaluate the standard deviations. Finally, it computes the Pearson correlation coefficient by dividing the covariance by the product of the two standard deviations, and returns this value as a double representing the strength and direction of the linear relationship between the datasets.",
        "code_id": "c_group_1_id_329",
        "code_text": "static double corrcoef(int N,double *x,double *y) {\n\tdouble cc,xm,ym,tx,ty,num,den1,den2;\n\tint i;\n\txm = ym = 0.0;\n\tfor(i = 0; i < N;++i) {\n\t\txm += x[i];\n\t\tym += y[i];\n\t}\n\n\txm = xm/N;\n\tym = ym / N;\n\tnum = den1 = den2 = 0.0;\n\n\tfor(i = 0; i < N;++i) {\n\t\ttx = x[i] - xm;\n\t\tty = y[i] - ym;\n\t\tnum += (tx*ty);\n\t\tden1 += (tx*tx);\n\t\tden2 += (ty*ty);\n\t}\n\n\tcc = num / sqrt(den1*den2);\n\n\treturn cc;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_330",
        "query_text": "The function takes two integers as input and returns an integer. It computes a divisor by raising 2 to the power of the second input, then checks whether the first input is divisible by this divisor. If it is divisible, the function returns 1; otherwise, it returns 0.",
        "code_id": "c_group_1_id_330",
        "code_text": "int testSWTlength(int N, int J) {\n\tint ret,div,i;\n\tret = 1;\n\n\tdiv = 1;\n\tfor (i = 0; i < J; ++i) {\n\t\tdiv *= 2;\n\t}\n\n\tif (N % div) {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_331",
        "query_text": "The function takes a 64-bit unsigned integer as input and returns an integer that corresponds to the number of digits in that number. Internally, it leverages a precomputed lookup table that maps bit-level information to an initial digit count estimate, and it uses a table of powers of 10 to refine this count. The method avoids explicit loops or recursion, thereby optimizing performance. The output value ranges from 1 to 20, depending on the size of the input number.",
        "code_id": "c_group_1_id_331",
        "code_text": "inline auto do_count_digits(uint64_t n) -> int {\n  \n  \n  \n  \n  static constexpr uint8_t bsr2log10[] = {\n      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,\n      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,\n      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,\n      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};\n  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];\n  static constexpr const uint64_t zero_or_powers_of_10[] = {\n      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),\n      10000000000000000000ULL};\n  return t - (n < zero_or_powers_of_10[t]);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_332",
        "query_text": "The function accepts two 64-bit unsigned integers as inputs and returns a 64-bit unsigned integer output computed as the high-order 64 bits of their product. If the system provides native support for 128-bit integers, the function multiplies the inputs directly, shifts the result right by 64 bits to obtain the high-order portion, and performs a conditional adjustment based on the sign bit. Otherwise, the function manually performs the multiplication by splitting each input into higher and lower 32-bit segments, calculates the respective partial products, and combines them\u2014taking into account necessary carry-overs\u2014to yield the correct high-order bits of the overall product.",
        "code_id": "c_group_1_id_332",
        "code_text": "FMT_CONSTEXPR inline auto multiply(uint64_t lhs, uint64_t rhs) -> uint64_t {\n#if FMT_USE_INT128\n  auto product = static_cast<__uint128_t>(lhs) * rhs;\n  auto f = static_cast<uint64_t>(product >> 64);\n  return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;\n#else\n  \n  uint64_t mask = (1ULL << 32) - 1;\n  uint64_t a = lhs >> 32, b = lhs & mask;\n  uint64_t c = rhs >> 32, d = rhs & mask;\n  uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;\n  \n  uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);\n  return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_333",
        "query_text": "The function accepts a constant character pointer as input, representing a path to a directory. It checks if a directory actually exists at the specified path by inspecting the file system attributes of the path. If the path corresponds to an existing directory, the function returns 1; otherwise, if the directory does not exist or if the path points to a non-directory object, it returns 0. The input is of type const char*, and the output is an integer indicating the existence of a directory.",
        "code_id": "c_group_1_id_333",
        "code_text": "int dirExists(const char *path) {\n  struct stat info;\n\n  if (stat(path, &info) != 0)\n    return 0;\n  else if (info.st_mode & S_IFDIR)\n    return 1;\n  else\n    return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_334",
        "query_text": "The function accepts two arrays of double-precision floating-point numbers and an integer that indicates the number of elements in each array. It computes the relative error between the arrays by first calculating the square root of the cumulative squared differences between corresponding elements in the arrays, and then dividing this value by the square root of the cumulative squared values of the elements in the first array. The function returns the resulting double-precision floating-point number as the relative error.",
        "code_id": "c_group_1_id_334",
        "code_text": "double REL_Error(double *data, double *rec, int N) {\n    int i;\n    double sum1 = 0;\n    double sum2 = 0;\n    for (i = 0; i < N; ++i) {\n        sum1 += (data[i] - rec[i])*(data[i] - rec[i]);\n        sum2 += data[i] * data[i];\n    }\n    return sqrt(sum1)/sqrt(sum2);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_335",
        "query_text": "The function accepts four parameters: a pointer to floating-point input data representing deinterleaved multi-channel audio, a pointer to a floating-point output buffer for interleaved audio, an integer specifying the number of audio frames, and an integer specifying the number of channels. It iterates over each frame and then each channel, reordering the samples from the input buffer into the output buffer so that all channel samples for a given frame are stored contiguously. The output is the interleaved audio data arranged by frame and channel.",
        "code_id": "c_group_1_id_335",
        "code_text": "void\ninterleave_data (const float *in, float *out, int frames, int channels)\n{\tint fr, ch ;\n\n\tfor (fr = 0 ; fr < frames ; fr++)\n\t\tfor (ch = 0 ; ch < channels ; ch++)\n\t\t\tout [ch + channels * fr] = in [fr + frames * ch] ;\n\n\treturn ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_336",
        "query_text": "The function takes two inputs: a pointer to an array of floating-point numbers and an integer representing the number of elements in the array. It initializes a floating-point variable to hold a computed total. The function then iterates sequentially through the array, squaring each element and adding the resulting value to the total. After processing every element, it returns the final computed total, which represents the sum of the squares of the array's elements.",
        "code_id": "c_group_1_id_336",
        "code_text": "double sum4(double *array, int N) {\n    double sum;\n    int i;\n\n    sum = 0.0;\n    for (i = 0; i < N; i += 1) {\n        sum += array[i] * array[i];\n    }\n    return sum;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_337",
        "query_text": "The function accepts a single parameter: a pointer to a constant character string representing the name of an environment variable. It retrieves the corresponding value for that environment variable from the system using the standard runtime library, and returns a pointer to a constant character string containing the value. If the specified environment variable is not found, the function returns a null pointer. Its primary purpose is to access the environment variable's value based on its name.",
        "code_id": "c_group_1_id_337",
        "code_text": "char const* getEnv( char const* varName ) {\n#    if defined( _MSC_VER )\n#        pragma warning( push )\n#        pragma warning( disable : 4996 ) \n#    endif\n\n            return std::getenv( varName );\n\n#    if defined( _MSC_VER )\n#        pragma warning( pop )\n#    endif\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_338",
        "query_text": "This function outputs a two-dimensional array formatted as text. It accepts a one-dimensional array of double-precision values representing the matrix, along with integer parameters specifying the number of rows and columns. Initially, the function prints the matrix dimensions in a \"rows x columns\" format. It then iterates through each row, prefacing the row with its index and printing each element sequentially, followed by a closing row index. The result is a neatly formatted display on the console, and no value is returned.",
        "code_id": "c_group_1_id_338",
        "code_text": "void dispWT2Coeffs(double *A, int row, int col) {\n\tint i, j;\n\tprintf(\"\\n MATRIX Order : %d X %d \\n \\n\", row, col);\n\n\tfor (i = 0; i < row; i++) {\n\t\tprintf(\"R%d: \", i);\n\t\tfor (j = 0; j < col; j++) {\n\t\t\tprintf(\"%g \", A[i*col + j]);\n\t\t}\n\t\tprintf(\":R%d \\n\", i);\n\t}\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_339",
        "query_text": "The function accepts a single 64-bit unsigned integer as input and returns a 32-bit unsigned integer. It counts the number of trailing zero bits (i.e., the consecutive zeros starting from the least significant bit) present in the binary representation of the input. The function first attempts to use platform-specific optimizations, such as compiler intrinsics, to perform this calculation efficiently. If these optimizations are unavailable, it falls back to a bitwise algorithm to determine the count. The design emphasizes both performance and portability across different platforms and compilers.",
        "code_id": "c_group_1_id_339",
        "code_text": "static inline uint32_t ctz64(uint64_t n) {\n#if defined(__GNUC__) && UINT_MAX >= UINT32_MAX && ULLONG_MAX >= UINT64_MAX\n  return static_cast<uint32_t>(__builtin_ctzll(n));\n#elif defined(_WIN64) && defined(_MSC_VER) && _MSC_VER >= 1400 &&              \\\n    ULONG_MAX >= UINT64_MAX\n  uint32_t i;\n  _BitScanForward64((unsigned long *)&i, n);\n  return i;\n#else\n  uint32_t i = 1;\n  if ((n & static_cast<uint64_t>(4294967295)) == 0) {\n    n >>= 32;\n    i += 32;\n  }\n  if ((n & static_cast<uint64_t>(0x0000FFFFUL)) == 0) {\n    n >>= 16;\n    i += 16;\n  }\n\n  if ((n & static_cast<uint64_t>(0x000000FFUL)) == 0) {\n    n >>= 8;\n    i += 8;\n  }\n\n  if ((n & static_cast<uint64_t>(0x0000000FUL)) == 0) {\n    n >>= 4;\n    i += 4;\n  }\n\n  if ((n & static_cast<uint64_t>(0x00000003UL)) == 0) {\n    n >>= 2;\n    i += 2;\n  }\n  i -= (n & 0x1);\n  return i;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_340",
        "query_text": "The function accepts an array of double-precision values along with its length. It also takes two sets of filter coefficients\u2014one for low-pass and one for high-pass filtering\u2014along with information specifying their lengths and stride values for both input and output indexing. The function applies a symmetric discrete wavelet transform on the input array. It computes two separate output arrays: one storing approximation coefficients and the other storing detail coefficients derived from the transformation. To correctly handle cases where filter indices exceed the boundaries of the input array, the function mirrors the array values. This approach ensures that every computed coefficient is based on valid, reflected data.",
        "code_id": "c_group_1_id_340",
        "code_text": "void dwt_sym_stride(double *inp, int N, double *lpd, double*hpd, int lpd_len, double *cA, int len_cA, double *cD, int istride, int ostride) {\n\tint i, l, t, len_avg;\n\tint is, os;\n\tlen_avg = lpd_len;\n\n\tfor (i = 0; i < len_cA; ++i) {\n\t\tt = 2 * i + 1;\n\t\tos = i *ostride;\n\t\tcA[os] = 0.0;\n\t\tcD[os] = 0.0;\n\t\tfor (l = 0; l < len_avg; ++l) {\n\t\t\tif ((t - l) >= 0 && (t - l) < N) {\n\t\t\t\tis = (t - l) * istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - l) < 0) {\n\t\t\t\tis = (-t + l - 1) * istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - l) >= N) {\n\t\t\t\tis = (2 * N - t + l - 1) * istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\n\t\t}\n\t}\n\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_341",
        "query_text": "The function accepts a single integer parameter representing a file descriptor. It calculates the size of the file by moving the file pointer to the end and capturing the resulting offset as an off_t value. If moving the file pointer fails at any point, the function prints an error message to the standard error stream and terminates the program. After determining the file size, the function resets the file pointer back to the beginning before returning the computed size.",
        "code_id": "c_group_1_id_341",
        "code_text": "static off_t\nfile_size(int fd)\n{\n\toff_t size;\n\tsize = lseek(fd, 0, SEEK_END);\n\tif (size == -1) {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: unable to lseek() input file: %s.\\n\",\n\t\t\tstrerror(errno));\n\t\texit(1);\n\t}\n\tif (lseek(fd, 0, SEEK_SET) == -1) {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: unable to lseek() input file: %s.\\n\",\n\t\t\tstrerror(errno));\n\t\texit(1);\n\t}\n\treturn size;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_342",
        "query_text": "The function takes four inputs: an integer specifying the count of frequency values, a pointer to an array of double values representing these frequencies, a double value indicating the maximum amplitude, and an integer defining the length of a pre-allocated array of floating-point values for output. Initially, it computes an effective amplitude by dividing the maximum amplitude by the number of frequencies and sets all elements of the output array to zero. It then iterates over each frequency, checking that each value lies within a valid range (greater than 0 and less than 0.5). If a frequency falls outside this range, the function halts execution after outputting an error message. For every valid frequency, the function calculates a sine wave component using the frequency, a predetermined phase offset, and the effective amplitude, accumulating the result in the output array. Finally, a windowing function is applied to the entire output array to smooth the signal, and the modified array is returned as the final output.",
        "code_id": "c_group_1_id_342",
        "code_text": "void\ngen_windowed_sines (int freq_count, const double *freqs, double max, float *output, int output_len)\n{\tint \tk, freq ;\n\tdouble\tamplitude, phase ;\n\n\tamplitude = max / freq_count ;\n\n\tfor (k = 0 ; k < output_len ; k++)\n\t\toutput [k] = 0.0 ;\n\n\tfor (freq = 0 ; freq < freq_count ; freq++)\n\t{\tphase = 0.9 * M_PI / freq_count ;\n\n\t\tif (freqs [freq] <= 0.0 || freqs [freq] >= 0.5)\n\t\t{\tprintf (\"\\n%s : Error : freq [%d] == %g is out of range. Should be < 0.5.\\n\", __FILE__, freq, freqs [freq]) ;\n\t\t\texit (1) ;\n\t\t\t} ;\n\n\t\tfor (k = 0 ; k < output_len ; k++)\n\t\t\toutput [k] = (float) (output [k] + (amplitude * sin (freqs [freq] * (2 * k) * M_PI + phase))) ;\n\t\t} ;\n\n\t\n\tfor (k = 0 ; k < output_len ; k++)\n\t\toutput [k] = (float) (output [k] * (0.5 - 0.5 * cos ((2 * k) * M_PI / (output_len - 1)))) ;\n\n\t\n\n\treturn ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_343",
        "query_text": "The function accepts two generic pointers of type const void* as inputs and returns an integer. It compares the memory addresses pointed to by the two input parameters. If the addresses differ, the function yields an integer value of 1; if the addresses are identical, it yields 0. The input parameters are generic pointers (const void*), and the output is an integer reflecting whether the pointers reference different memory locations.",
        "code_id": "c_group_1_id_343",
        "code_text": "int pointer_equality(const void *k1, const void *k2)\n{\n    return !(k1 == k2);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_344",
        "query_text": "The function takes a 32-bit unsigned integer as input and returns a 32-bit unsigned integer as output. It reverses the byte order of the input value\u2014transforming the first byte into the last, the second byte into the third, the third byte into the second, and the last byte into the first\u2014effectively swapping between big-endian and little-endian representations. This is accomplished by isolating and rearranging the individual bytes using bitwise operations.",
        "code_id": "c_group_1_id_344",
        "code_text": "inline uint32_t endian_swap(uint32_t value)\n\t{\n\t\treturn ((value & 0xff) << 24) | ((value & 0xff00) << 8) | ((value & 0xff0000) >> 8) | (value >> 24);\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_345",
        "query_text": "The function takes no input parameters and returns a constant reference to a locale object representing the classic (or \"C\") locale. It uses a static local variable to ensure that the locale is initialized only once and then reused on subsequent calls, providing an efficient, shared access point to the minimal default locale settings.",
        "code_id": "c_group_1_id_345",
        "code_text": "inline auto get_classic_locale() -> const std::locale& {\n  static const auto& locale = std::locale::classic();\n  return locale;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_346",
        "query_text": "The function receives two strings as inputs and returns a boolean value. It begins by verifying that the length of the first string is at least as long as the second (serving as the suffix). If this condition is met, the function compares the characters at the end of the first string with those of the suffix by iterating over them in reverse order. The function ultimately returns true if all corresponding characters match, indicating that the first string indeed ends with the provided suffix; otherwise, it returns false.",
        "code_id": "c_group_1_id_346",
        "code_text": "bool endsWith( std::string const& s, std::string const& suffix ) {\n        return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_347",
        "query_text": "The function overloads the stream insertion operator to output a 128-bit unsigned integer to an output stream. It accepts two inputs: an output stream and a 128-bit unsigned integer. The function starts by initializing a temporary copy of the integer and preparing a character buffer to hold its decimal representation. It then iteratively computes the digits by repeatedly taking the remainder when divided by 10 and storing the corresponding character in the buffer in reverse order, until the entire number has been processed. Once the conversion is complete, the resulting string is written to the output stream. If the write operation does not successfully output the complete string, the function sets an error state on the stream. Finally, the output stream is returned to facilitate chained stream operations. The input types are an output stream and a 128-bit unsigned integer, and the output type is an output stream.",
        "code_id": "c_group_1_id_347",
        "code_text": "std::ostream &operator<<(std::ostream &dest, __uint128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    int len = int(std::end(buffer) - d);\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_348",
        "query_text": "The function takes a constant character string as input and does not return any value. Its sole purpose is to immediately trigger an exception by throwing an instance of a memory allocation failure exception, without utilizing the provided message.",
        "code_id": "c_group_1_id_348",
        "code_text": "static void __fatal_error_func(const char *message)\n{\n  \n  \n  throw std::bad_alloc();\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_349",
        "query_text": "The function takes a single character as input and determines if it is a lowercase letter according to the ASCII standard. It returns a boolean value that is true if the character falls within the range of lowercase letters ('a' to 'z'); otherwise, it returns false.",
        "code_id": "c_group_1_id_349",
        "code_text": "bool IsLower(char ch) { return 'a' <= ch && ch <= 'z'; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_350",
        "query_text": "The function accepts a single character as input and determines whether its value lies between 'A' and 'Z', inclusive. It returns true if the character is uppercase and false otherwise, effectively using the ASCII ordering of characters to perform the check.",
        "code_id": "c_group_1_id_350",
        "code_text": "bool IsUpper(char ch) { return 'A' <= ch && ch <= 'Z'; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_351",
        "query_text": "The function accepts a character and returns a boolean. It assesses whether the character is a trailing byte in a UTF-8 sequence by examining if its two most significant bits conform to the binary pattern 10. The character is treated as part of a potential multi-byte encoding, and if the bit pattern matches, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_351",
        "code_text": "bool IsTrailingByte(char ch) { return (ch & 0xC0) == 0x80; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_352",
        "query_text": "This function accepts an integer input that represents a Unicode code point and converts it into a UTF-16 surrogate pair. It generates the high surrogate by right-shifting the input and combining it with an offset constant, while the low surrogate is produced by applying a bitmask to the input and then merging it with a fixed bit pattern. The two 16-bit values, representing the high and low surrogates respectively, are returned together as a pair, thus ensuring proper encoding of characters outside the Basic Multilingual Plane according to the UTF-16 standard.",
        "code_id": "c_group_1_id_352",
        "code_text": "std::pair<uint16_t, uint16_t> EncodeUTF16SurrogatePair(int codePoint) {\n  const uint32_t leadOffset = 0xD800 - (0x10000 >> 10);\n\n  return {\n    leadOffset | (codePoint >> 10),\n    0xDC00 | (codePoint & 0x3FF),\n  };\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_353",
        "query_text": "The function converts an unsigned integer input into a single-character string output. It casts the unsigned integer to a character and constructs a new string comprised of that character. The output is of type std::string, encapsulating the converted character.",
        "code_id": "c_group_1_id_353",
        "code_text": "std::string Str(unsigned ch) { return std::string(1, static_cast<char>(ch)); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_354",
        "query_text": "The function does not return any value and accepts no input parameters. When called, it prints a usage guide to the standard error stream, describing the expected command-line arguments for a program. Specifically, the message outlines that the program may be invoked with an optional numeric argument, a boolean flag specified as either a short or a long option, and an optional filename.",
        "code_id": "c_group_1_id_354",
        "code_text": "void usage() { std::cerr << \"Usage: read [-n N] [-c, --cache] [filename]\\n\"; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_355",
        "query_text": "The function takes an integer as input and returns a constant string pointer. It checks the input value against a set of predefined error codes and returns the corresponding error message. If the input matches one of the specific error codes, the function outputs the associated message. Otherwise, if the input is a negative value, it returns \"Unknown error code\"; if the input is non-negative, it returns \"Success\". The input type is int, and the output type is a constant char pointer.",
        "code_id": "c_group_1_id_355",
        "code_text": "const char *ft_strerror(int error_code)\n{\n    switch (error_code) {\n        case FT_MEMORY_ERROR:\n            return \"Out of memory\";\n        case FT_GEN_ERROR:\n            return \"General error\";\n        case FT_EINVAL:\n            return \"Invalid argument\";\n        case FT_INTERN_ERROR:\n            return \"Internal libfort error\";\n        default:\n            if (error_code < 0)\n                return \"Unknown error code\";\n            else\n                return \"Success\";\n    }\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_356",
        "query_text": "The function accepts two pointers to sequences of unsigned characters and compares them byte by byte. It iterates through both sequences simultaneously until it encounters a null terminator in each. During the iteration, if a byte from the first sequence is less than the corresponding byte from the second sequence, it immediately returns -1; if that byte is greater, it returns 1. If the end of both strings is reached without any differences, it returns 0 to indicate the sequences are identical. Although designed for UTF-8 encoded strings, the function performs a simple byte-wise comparison without interpreting multi-byte characters.",
        "code_id": "c_group_1_id_356",
        "code_text": "int utf8cmp(const void *src1, const void *src2)\n{\n    const unsigned char *s1 = (const unsigned char *)src1;\n    const unsigned char *s2 = (const unsigned char *)src2;\n\n    while (('\\0' != *s1) || ('\\0' != *s2)) {\n        if (*s1 < *s2) {\n            return -1;\n        } else if (*s1 > *s2) {\n            return 1;\n        }\n\n        s1++;\n        s2++;\n    }\n\n    \n    return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_357",
        "query_text": "The function takes two input pointers: one pointing to a UTF-8 encoded source string and the other to a set of characters that should cause processing to cease. It iterates through the source string, decoding each UTF-8 character in turn. As it examines each character, it checks whether it appears in the reject set. If a character from the reject set is encountered, the function immediately stops processing and returns the count of UTF-8 characters processed up to that point. If it reaches the end of the source string without finding any rejected characters, it returns the total count of UTF-8 characters. The returned value is of type size_t, indicating the number of characters examined.",
        "code_id": "c_group_1_id_357",
        "code_text": "size_t utf8cspn(const void *src, const void *reject)\n{\n    const char *s = (const char *)src;\n    size_t chars = 0;\n\n    while ('\\0' != *s) {\n        const char *r = (const char *)reject;\n        size_t offset = 0;\n\n        while ('\\0' != *r) {\n            \n            \n            \n            if ((0x80 != (0xc0 & *r)) && (0 < offset)) {\n                return chars;\n            } else {\n                if (*r == s[offset]) {\n                    \n                    \n                    offset++;\n                    r++;\n                } else {\n                    \n                    \n\n                    do {\n                        r++;\n                    } while (0x80 == (0xc0 & *r));\n\n                    \n                    offset = 0;\n                }\n            }\n        }\n\n        \n        \n        \n        do {\n            s++;\n        } while ((0x80 == (0xc0 & *s)));\n        chars++;\n    }\n\n    return chars;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_358",
        "query_text": "The function receives three inputs: two pointers to constant memory blocks representing raw byte sequences and a size value indicating the maximum number of bytes to compare. It begins by casting the byte sequence pointers to pointers to unsigned characters so that it can process them one byte at a time. Then, it compares the two sequences lexicographically, examining corresponding bytes until either a null terminator is encountered in at least one sequence or the specified maximum byte count is reached. If it finds a byte in the first sequence that is less than its counterpart in the second, the function returns -1; if it is greater, it returns 1. If both sequences are identical for the compared portion or the comparison reaches the specified length, the function returns 0. Note that the function treats the inputs as raw byte arrays without any assumptions about character encoding.",
        "code_id": "c_group_1_id_358",
        "code_text": "int utf8ncmp(const void *src1, const void *src2, size_t n)\n{\n    const unsigned char *s1 = (const unsigned char *)src1;\n    const unsigned char *s2 = (const unsigned char *)src2;\n\n    while ((0 != n--) && (('\\0' != *s1) || ('\\0' != *s2))) {\n        if (*s1 < *s2) {\n            return -1;\n        } else if (*s1 > *s2) {\n            return 1;\n        }\n\n        s1++;\n        s2++;\n    }\n\n    \n    return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_359",
        "query_text": "This function accepts a pointer to a constant dataset that represents a sequence of characters. It determines the size of the string by iterating through the characters until a null terminator is encountered. After counting all the characters, the function increments the count by one to include the null terminator. Ultimately, it returns the computed size as a value of type size_t.",
        "code_id": "c_group_1_id_359",
        "code_text": "size_t utf8size(const void *str)\n{\n    const char *s = (const char *)str;\n    size_t size = 0;\n    while ('\\0' != s[size]) {\n        size++;\n    }\n\n    \n    size++;\n    return size;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_360",
        "query_text": "The function takes four inputs. The first input is a pointer to a mutable character array that serves as the destination buffer, the second is an unsigned integer that specifies the maximum length of that buffer, the third is an unsigned integer indicating the number of times the source string should be concatenated, and the fourth is a pointer to a constant character array representing the source string. The function first determines the length of the source string, then verifies whether the destination buffer is large enough to accommodate the source string repeated the specified number of times. It returns an error code (-1) if the buffer size is insufficient or if the total number of characters to be written exceeds the maximum integer value. If the repetition count is zero or the source string is empty, it returns zero immediately. Otherwise, the function concatenates the source string into the destination buffer the specified number of times and finally returns the total number of characters written.",
        "code_id": "c_group_1_id_360",
        "code_text": "static\nint snprint_n_strings_impl(char *buf, size_t length, size_t n, const char *str)\n{\n    size_t str_len = strlen(str);\n    if (length <= n * str_len)\n        return -1;\n\n    if (n == 0)\n        return 0;\n\n    \n    if (n * str_len > INT_MAX)\n        return -1;\n\n    if (str_len == 0)\n        return 0;\n\n    int status = snprintf(buf, length, \"%0*d\", (int)(n * str_len), 0);\n    if (status < 0)\n        return status;\n\n    size_t i = 0;\n    for (i = 0; i < n; ++i) {\n        const char *str_p = str;\n        while (*str_p)\n            *(buf++) = *(str_p++);\n    }\n    return (int)(n * str_len);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_361",
        "query_text": "The function accepts a buffer for wide characters, its size, a repetition count, and a narrow C-style string as input. It converts the narrow string into its wide-character representation and writes this result repeatedly into the provided buffer. The conversion handles both single-byte and multi-byte characters and validates the multi-byte sequences during processing. Prior to writing the repeated sequence, the function ensures that the resulting output fits within the allotted buffer size. On success, it returns the total number of wide characters written into the buffer; if an error occurs due to an invalid multi-byte sequence or insufficient buffer space, the function returns a negative value.",
        "code_id": "c_group_1_id_361",
        "code_text": "static\nint wsnprint_n_string(wchar_t *buf, size_t length, size_t n, const char *str)\n{\n    size_t str_len = strlen(str);\n\n    \n    if (str_len > 1) {\n        const unsigned char *p = (const unsigned char *)str;\n        while (*p) {\n            if (*p <= 127)\n                p++;\n            else {\n                wchar_t wcs[WCS_SIZE];\n                const char *ptr = str;\n                size_t wcs_len;\n                mbstate_t mbst;\n                memset(&mbst, 0, sizeof(mbst));\n                wcs_len = mbsrtowcs(wcs, (const char **)&ptr, WCS_SIZE, &mbst);\n                \n                if ((wcs_len == (size_t) - 1) || wcs_len > 1) {\n                    return -1;\n                } else {\n                    wcs[wcs_len] = L'\\0';\n                    size_t k = n;\n                    while (k) {\n                        *buf = *wcs;\n                        ++buf;\n                        --k;\n                    }\n                    buf[n] = L'\\0';\n                    return (int)n;\n                }\n            }\n        }\n    }\n\n    if (length <= n * str_len)\n        return -1;\n\n    if (n == 0)\n        return 0;\n\n    \n    if (n * str_len > INT_MAX)\n        return -1;\n\n    if (str_len == 0)\n        return 0;\n\n    int status = swprintf(buf, length, L\"%0*d\", (int)(n * str_len), 0);\n    if (status < 0)\n        return status;\n\n    size_t i = 0;\n    for (i = 0; i < n; ++i) {\n        const char *str_p = str;\n        while (*str_p)\n            *(buf++) = (wchar_t) * (str_p++);\n    }\n    return (int)(n * str_len);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_362",
        "query_text": "The function takes two inputs, each a pointer to a constant character representing positions in a string. The first pointer marks the start position, while the second pointer indicates the end position. The function calculates the distance between these two pointers, effectively determining the length of the substring defined by them. It returns this distance as a signed integer of type ptrdiff_t. An assertion ensures that the end pointer is not before the start pointer.",
        "code_id": "c_group_1_id_362",
        "code_text": "static ptrdiff_t str_iter_width(const char *beg, const char *end)\n{\n    assert(end >= beg);\n    return (end - beg);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_363",
        "query_text": "The function accepts three inputs: two pointers to memory locations (used to specify the beginning and end of a data block) and a pointer designated to store a computed size value. It compares the data between the two memory pointers with a predefined custom string. If the data matches the custom string, the function sets the size value to 25 and returns 0 to indicate success; otherwise, it returns 1 to indicate failure. The inputs are of type const void* for the memory locations and size_t* for the size value, and the output is an integer indicating whether the operation was successful (0) or not (1).",
        "code_id": "c_group_1_id_363",
        "code_text": "int u8strwid(const void *beg, const void *end, size_t *width)\n{\n    const char *custom_str = \"custom_string\";\n    const size_t raw_len = (const char *)end - (const char *)beg;\n    if (memcmp(beg, custom_str, MIN(strlen(custom_str), raw_len)) == 0) {\n        *width = 25;\n        return 0;\n    }\n    return 1;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_364",
        "query_text": "This function examines a contiguous block of memory to determine if it begins with any emoji characters from a predefined set. It accepts three inputs: two pointers that mark the start and end of the memory block, and a pointer to a size variable where the computed width will be stored. The function scans the beginning of the memory block for specific emoji sequences, and upon detecting one at the start, it sets the width to a fixed value and returns a success code. If no matching emoji is found, the function returns a failure code.",
        "code_id": "c_group_1_id_364",
        "code_text": "int u8strwid(const void *beg, const void *end, size_t *width)\n{\n    const char *emojis[] = {\"\ud83d\ude03\", \"\ud83d\ude0d\"};\n    const size_t sz = sizeof(emojis) / sizeof(emojis[0]);\n    const size_t raw_len = (const char *)end - (const char *)beg;\n\n    for (size_t i = 0; i < sz; ++i) {\n        if (memcmp(beg, emojis[i], std::min(strlen(emojis[i]), raw_len)) == 0) {\n            *width = 2; \n            return 0;\n        }\n    }\n    return 1;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_365",
        "query_text": "The function retrieves memory usage data for the current process by opening a system file that holds memory statistics. It reads a fixed number of bytes into a buffer and prints the retrieved string to the console. The function takes no parameters, returns no value, and ensures that the file is properly closed after reading.",
        "code_id": "c_group_1_id_365",
        "code_text": "inline void dump_mem_usage()\n{\n    FILE* f = fopen(\"/proc/self/statm\", \"rt\");\n    if (!f) return;\n    char   str[300];\n    size_t n = fread(str, 1, 200, f);\n    str[n]   = 0;\n    printf(\"MEM: %s\\n\", str);\n    fclose(f);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_366",
        "query_text": "The function takes no input arguments. It flushes all open output streams to ensure that any buffered data is immediately written out to their proper destinations. It does not return any value (void).",
        "code_id": "c_group_1_id_366",
        "code_text": "inline void FlushInfoLog() { fflush(NULL); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_367",
        "query_text": "The function accepts three parameters: a pointer to a destination character array, a pointer to a source character array, and a size value that specifies the maximum number of characters to copy. It copies characters from the source array to the destination array and, if the source is shorter than the specified limit, it pads the destination with null characters. The function then returns a pointer to the destination array.",
        "code_id": "c_group_1_id_367",
        "code_text": "inline const char* StrNCpy(char* dest, const char* src, size_t n) {\n  return strncpy(dest, src, n);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_368",
        "query_text": "The function accepts two inputs, each of type const char*, representing a file path and an operating mode (such as read, write, or append). It passes these arguments to a standard library function to open the file. The function returns a pointer to a FILE object if the file is successfully opened, and returns a null pointer if not.",
        "code_id": "c_group_1_id_368",
        "code_text": "inline FILE* FOpen(const char* path, const char* mode) {\n  return fopen(path, mode);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_369",
        "query_text": "The function takes no input and returns a pointer to an array of character pointers. Each element in the array represents a string corresponding to an environment variable. The function does not perform any additional processing and is implemented inline.",
        "code_id": "c_group_1_id_369",
        "code_text": "inline char** GetEnviron() { return environ; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_370",
        "query_text": "The function takes two inputs: a pointer to a generic memory location and a pointer to a boolean variable. Inside the function, a local variable is defined, and its memory address is compared with the provided pointer. The outcome of this comparison\u2014a boolean indicating whether the local variable's address is lower than the given address\u2014is stored in the boolean variable. No value is returned directly by the function.",
        "code_id": "c_group_1_id_370",
        "code_text": "static void StackLowerThanAddress(const void* ptr, bool* result) {\n  int dummy;\n  *result = (&dummy < ptr);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_371",
        "query_text": "The function takes no parameters and returns no value. Upon being called, it executes an empty body, meaning that it performs no operations or computations. Essentially, it is a no-op, serving as a placeholder or stub for potential future implementations.",
        "code_id": "c_group_1_id_371",
        "code_text": "void process(){}\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_372",
        "query_text": "This function accepts an integer as input and performs no operations on it. Its body is empty, and it returns no value (void). Essentially, it serves as a placeholder with no implemented functionality.",
        "code_id": "c_group_1_id_372",
        "code_text": "void process(int ){}\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_373",
        "query_text": "This function is a void function that accepts no input parameters and does not perform any operations. It serves solely as a placeholder with no effect when invoked, as it neither executes any computation nor returns a value.",
        "code_id": "c_group_1_id_373",
        "code_text": "void processNil(){}\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_374",
        "query_text": "The function accepts a single parameter: a pointer to a constant character array (const char*), representing a C-style string. It first computes the length of the string using a standard library function that counts characters. Prior to returning, the function includes a safety check to ensure that the computed length, originally of a size-type, can be safely converted to an integer without data loss. Once the check is successful, it returns the length as an integer.",
        "code_id": "c_group_1_id_374",
        "code_text": "inline int StrLength(const char* string) {\n  size_t length = strlen(string);\n  DOUBLE_CONVERSION_ASSERT(length == static_cast<size_t>(static_cast<int>(length)));\n  return static_cast<int>(length);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_375",
        "query_text": "The function accepts a single parameter of type char as input and simply returns that same character as output. It performs no modifications or transformations on the input, serving solely as a direct pass-through mechanism. The purpose of the function is to ensure that the input character is returned unchanged.",
        "code_id": "c_group_1_id_375",
        "code_text": "inline char Pass(char ch) {\n  return ch;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_376",
        "query_text": "The function takes one input: a boolean value. It returns a double-precision floating-point value. If the input is true, the function returns negative zero (i.e., -0.0), and if the input is false, it returns positive zero (i.e., 0.0). The function essentially determines the sign of zero based on the boolean input.",
        "code_id": "c_group_1_id_376",
        "code_text": "static double SignedZero(bool sign) {\n  return sign ? -0.0 : 0.0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_377",
        "query_text": "The function takes an unsigned 64-bit integer as input and returns an integer representing the count of bits set to 1 in the binary representation of the input. It computes what is commonly known as the Hamming weight or population count, utilizing an efficient built-in method provided by the compiler.",
        "code_id": "c_group_1_id_377",
        "code_text": "static inline int cbitset_hamming(unsigned long long input_num) { return __builtin_popcountll(input_num); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_378",
        "query_text": "The function accepts one parameter: a pointer to a constant character (of type const char*). It immediately returns this pointer without performing any modification or transformation on it. The function is marked for compile-time evaluation and is explicitly inlined for performance optimization. The input and output types are both const char*.",
        "code_id": "c_group_1_id_378",
        "code_text": "constexpr FMT_ALWAYS_INLINE const char* narrow(const char* s) { return s; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_379",
        "query_text": "The function takes a single size_t input (expected to be within the range 0 to 99) and returns a pointer to a constant character string representing the two-digit number corresponding to the input value. Internally, it uses a precomputed lookup table that contains contiguous pairs of digits for the numbers 00 through 99. By calculating an offset based on the input, the function retrieves and returns the appropriate two-character substring from this table. The function does not produce any output other than the returned pointer.",
        "code_id": "c_group_1_id_379",
        "code_text": "inline auto digits2(size_t value) -> const char* {\n  \n  \n  alignas(2) static const char data[] =\n      \"0001020304050607080910111213141516171819\"\n      \"2021222324252627282930313233343536373839\"\n      \"4041424344454647484950515253545556575859\"\n      \"6061626364656667686970717273747576777879\"\n      \"8081828384858687888990919293949596979899\";\n  return &data[value * 2];\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_380",
        "query_text": "The function accepts a single input of type std::size_t and simply returns that same value as its output. It performs no modifications or additional processing on the input, effectively acting as a pass-through function. The input and output types are both std::size_t.",
        "code_id": "c_group_1_id_380",
        "code_text": "inline std::size_t convert_rwcount(std::size_t count) { return count; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_381",
        "query_text": "The function takes no arguments and returns no value. It calls a standard library function with a null pointer to flush all open output streams, ensuring that any buffered data is promptly written to their respective destinations.",
        "code_id": "c_group_1_id_381",
        "code_text": "inline void FlushInfoLog() { fflush(nullptr); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_382",
        "query_text": "The function pauses the program's execution for a specified duration in milliseconds. It accepts an integer input representing the number of milliseconds to delay, converts this value into a timespec structure, and then calls a system-level function to suspend execution for that period. It does not return any value.",
        "code_id": "c_group_1_id_382",
        "code_text": "inline void SleepMilliseconds(int n) {\n  const timespec time = {\n    0,                  \n    n * 1000L * 1000L,  \n  };\n  nanosleep(&time, nullptr);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_383",
        "query_text": "The function accepts a string as its input and produces a string as its output. It first checks if the input string starts with a predetermined prefix. If the prefix is present, the function then searches for a specific delimiter that follows the prefix. When the delimiter is located, it removes a section of the string that lies between a defined static part of the prefix and the delimiter. If the input string does not start with the required prefix or if the delimiter is not found, the input string remains unmodified.",
        "code_id": "c_group_1_id_383",
        "code_text": "inline std::string CanonicalizeForStdLibVersioning(std::string s) {\n  static const char prefix[] = \"std::__\";\n  if (s.compare(0, strlen(prefix), prefix) == 0) {\n    std::string::size_type end = s.find(\"::\", strlen(prefix));\n    if (end != s.npos) {\n      \n      s.erase(strlen(\"std\"), end - strlen(\"std\"));\n    }\n  }\n  return s;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_384",
        "query_text": "The function takes no arguments and returns a boolean value. It is implemented as a constexpr function that consistently returns true. Its primary purpose is to serve as a marker indicating that a certain feature is deprecated. The function does not perform any additional computations or operations; it merely provides a constant boolean output to signal the deprecation status.",
        "code_id": "c_group_1_id_384",
        "code_text": "GTEST_INTERNAL_DEPRECATED(\n    \"REGISTER_TYPED_TEST_CASE_P is deprecated, please use \"\n    \"REGISTER_TYPED_TEST_SUITE_P\")\nconstexpr bool RegisterTypedTestCase_P_IsDeprecated() { return true; }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_385",
        "query_text": "The function receives a null pointer constant and a pointer to an output stream as inputs. It writes the string \"(nullptr)\" to the output stream, thereby providing a clear textual representation of a null pointer. The function does not return any value (void).",
        "code_id": "c_group_1_id_385",
        "code_text": "inline void PrintTo(std::nullptr_t, ::std::ostream* os) { *os << \"(nullptr)\"; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_386",
        "query_text": "The function takes a constant void pointer as its only input and returns the identical pointer without any alterations. The input and output are both of type \"const void*\". Essentially, the function acts as a pass-through, simply relaying the pointer that was provided.",
        "code_id": "c_group_1_id_386",
        "code_text": "inline const void* VoidifyPointer(const void* p) { return p; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_387",
        "query_text": "The function accepts two wide characters as input and returns a 32-bit unsigned integer. It initially checks whether the underlying wide-character type is 2 bytes (UTF-16). If so, it combines the two characters into a single Unicode code point by extracting lower-order bits from each character, shifting bits accordingly, and adding a fixed offset. Otherwise, when the wide-character type exceeds 2 bytes, the function simply converts and returns the first input character as a 32-bit unsigned integer.",
        "code_id": "c_group_1_id_387",
        "code_text": "inline uint32_t CreateCodePointFromUtf16SurrogatePair(wchar_t first,\n                                                      wchar_t second) {\n  const auto first_u = static_cast<uint32_t>(first);\n  const auto second_u = static_cast<uint32_t>(second);\n  const uint32_t mask = (1 << 10) - 1;\n  return (sizeof(wchar_t) == 2)\n             ? (((first_u & mask) << 10) | (second_u & mask)) + 0x10000\n             :\n             \n             \n             first_u;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_388",
        "query_text": "The function accepts a single input of type std::string. It then iterates over the string to locate newline characters that indicate the end of each line. For every identified line, the function prefixes it with a fixed text segment. If the end of the string is reached and a newline is not encountered, the remaining part of the string is treated as the final line and the prefix is still applied. Finally, the function returns a new std::string containing all the lines, each with the prefixed text.",
        "code_id": "c_group_1_id_388",
        "code_text": "static ::std::string FormatDeathTestOutput(const ::std::string& output) {\n  ::std::string ret;\n  for (size_t at = 0; ; ) {\n    const size_t line_end = output.find('\\n', at);\n    ret += \"[  DEATH   ] \";\n    if (line_end == ::std::string::npos) {\n      ret += output.substr(at);\n      break;\n    }\n    ret += output.substr(at, line_end + 1 - at);\n    at = line_end + 1;\n  }\n  return ret;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_389",
        "query_text": "The function accepts two inputs: a pointer to a constant void type and a pointer to a boolean variable. It defines a local integer variable and compares its memory address with the provided pointer. If the local variable's address is lower (i.e., precedes in memory) than the given address, the function sets the boolean output to true; otherwise, it assigns false. The function solely performs this comparison without modifying the input pointer or conducting any additional operations.",
        "code_id": "c_group_1_id_389",
        "code_text": "static void StackLowerThanAddress(const void* ptr, bool* result) {\n  int dummy = 0;\n  *result = std::less<const void*>()(&dummy, ptr);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_390",
        "query_text": "The function accepts a single character (of type char) as input and always returns a constant string (of type const char*). Regardless of the input provided, the function simply returns an empty string (\"\") without performing any additional operations or modifications.",
        "code_id": "c_group_1_id_390",
        "code_text": "static const char* GetCharWidthPrefix(char) {\n  return \"\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_391",
        "query_text": "The function accepts a single input of type signed char and returns a constant string pointer. Regardless of the input, it always returns an empty string (\"\"). The primary purpose of the function is to provide a fixed, unchanging string output independent of the parameter value.",
        "code_id": "c_group_1_id_391",
        "code_text": "static const char* GetCharWidthPrefix(signed char) {\n  return \"\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_392",
        "query_text": "The function receives an unsigned 8-bit integer (of type unsigned char) and produces an output of type constant character pointer (const char*). It returns a constant empty string (\"\") regardless of the input value, meaning that the function does not perform any computation or transformation on the provided input.",
        "code_id": "c_group_1_id_392",
        "code_text": "static const char* GetCharWidthPrefix(unsigned char) {\n  return \"\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_393",
        "query_text": "The function takes a single input\u2014a wide character (wchar_t)\u2014and always returns a pointer to a constant string. Regardless of the input value, the function produces the same constant output, the string literal \"L\" (of type const char*).",
        "code_id": "c_group_1_id_393",
        "code_text": "static const char* GetCharWidthPrefix(wchar_t) {\n  return \"L\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_394",
        "query_text": "The function takes three inputs: a string, a flag string, and a boolean indicating if the flag value is optional. It begins by constructing a prefix by concatenating a constant literal with the flag string and then checks if the input string starts with this prefix. If it does, the function examines the subsequent character(s): if the flag is marked as optional and the string ends immediately after the prefix, it returns a pointer to that position; otherwise, if the flag is expected to have a value, it verifies that an equals sign immediately follows the prefix and returns a pointer to the beginning of the value. If these conditions are not met, the function returns a null pointer. The output is a pointer to a constant character.",
        "code_id": "c_group_1_id_394",
        "code_text": "static const char* ParseGoogleMockFlagValue(const char* str,\n                                            const char* flag,\n                                            bool def_optional) {\n  \n  if (str == nullptr || flag == nullptr) return nullptr;\n\n  \n  const std::string flag_str = std::string(\"--gmock_\") + flag;\n  const size_t flag_len = flag_str.length();\n  if (strncmp(str, flag_str.c_str(), flag_len) != 0) return nullptr;\n\n  \n  const char* flag_end = str + flag_len;\n\n  \n  if (def_optional && (flag_end[0] == '\\0')) {\n    return flag_end;\n  }\n\n  \n  \n  \n  if (flag_end[0] != '=') return nullptr;\n\n  \n  return flag_end + 1;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_395",
        "query_text": "The function takes no input arguments and returns a reference to a constant pointer. It is defined inline and begins by initializing a static constant pointer that points to the stream buffer associated with the standard error stream. Finally, it returns a reference to this pointer, effectively giving access to the stream buffer without allowing modifications. The output of the function is a reference to a pointer of type std::streambuf*.",
        "code_id": "c_group_1_id_395",
        "code_text": "inline const std::streambuf*& get_cerrbuf()\n{\n  static const std::streambuf* perr = std::cerr.rdbuf();\n  return perr;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_396",
        "query_text": "The function accepts four parameters, all of type size_t. It converts the first three parameters into their string representations, appends a fixed suffix (\"   |\") to each string, and then prints these strings to the console with a specific field width determined by the fourth parameter. The formatted output is printed directly to standard output, and the function does not return any value.",
        "code_id": "c_group_1_id_396",
        "code_text": "void test_len(size_t len1, size_t len2, size_t len3, size_t wide)\n{\n  std::string str1, str2, str3;\n  std::stringstream ss;\n  ss << len1 << \" \" << len2 << \" \" << len3;\n  ss >> str1 >> str2 >> str3;\n  str1 += \"   |\";\n  std::cout << std::setw(wide) << str1;\n  str2 += \"   |\";\n  std::cout << std::setw(wide) << str2;\n  str3 += \"   |\";\n  std::cout << std::setw(wide) << str3 << \"\\n\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_397",
        "query_text": "The function takes no input parameters and returns an integer value. It calculates this value by simply returning a constant result, with no computations or conditional logic applied. The function always produces the same output, making it entirely deterministic, and its return type is int.",
        "code_id": "c_group_1_id_397",
        "code_text": "int  gen() { return 5; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_398",
        "query_text": "The function accepts an integer and performs a series of arithmetic transformations. Initially, it multiplies the input by a constant value, then adds a fixed offset to the result. Following this, it calculates the remainder when the sum is divided by a predetermined divisor. The final computed remainder is returned as an integer.",
        "code_id": "c_group_1_id_398",
        "code_text": "int  r(int i) { return (i * 5 + 1) % 9; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_399",
        "query_text": "The function accepts an integer input and determines whether the number is odd. It accomplishes this by performing a bitwise AND operation with the value 1. If the result equals 1, the function returns a boolean value of true, indicating that the input integer is odd; otherwise, it returns false, indicating that the input is even. The primary purpose of this function is to check the parity of the given integer.",
        "code_id": "c_group_1_id_399",
        "code_text": "bool is_odd(int i) { return i & 1; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_400",
        "query_text": "The function accepts an integer as input and returns a boolean value indicating whether the number is even. It determines evenness by inspecting the least significant bit of the integer; if this bit is not set, the function concludes that the number is even and returns true, otherwise it returns false. The input is of type integer, and the output is of type boolean.",
        "code_id": "c_group_1_id_400",
        "code_text": "bool is_even(int i) { return !(i & 1); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_401",
        "query_text": "The function accepts two integer values and returns a boolean result. It compares the two integers by checking if the second is smaller than the first. If this condition holds, it returns true; otherwise, it returns false. This comparison logic is typically employed to establish a custom ordering for operations such as sorting.",
        "code_id": "c_group_1_id_401",
        "code_text": "bool cmp(const int& a, const int& b) { return b < a; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_402",
        "query_text": "The function takes an integer input, increments its value by 1, and returns the updated integer as output. Both the input and the output are of type int.",
        "code_id": "c_group_1_id_402",
        "code_text": "int  unary_op(const int& x) { return x + 1; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_403",
        "query_text": "The function accepts two integer inputs and returns an integer computed by adding them together. It performs a straightforward arithmetic addition on the provided values and produces the resulting sum, leaving the original inputs unaltered.",
        "code_id": "c_group_1_id_403",
        "code_text": "int  binary_op(const int& x, const int& y) { return x + y; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_404",
        "query_text": "The function takes a single integer input and returns a boolean value. It determines whether the provided integer is odd by performing a bitwise AND operation with 1. If the outcome of the operation equals 1, the function concludes that the integer is odd and returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_404",
        "code_text": "bool is_odd(int x) { return x & 1; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_405",
        "query_text": "The function accepts an integer as input and returns an integer as output representing the sign of the input. It returns \u20131 if the input is negative, 1 if the input is positive, and 0 if the input equals zero. The determination of the sign is performed using bitwise operations that compare the sign bit of the input and its negation.",
        "code_id": "c_group_1_id_405",
        "code_text": "CGLM_INLINE\nint\nglm_sign(int val) {\n  return ((val >> 31) - (-val >> 31));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_406",
        "query_text": "The function takes a string as input (input type: const char*) and returns a pointer to a character array (output type: char*). It first copies the input string into a static buffer and then processes the copied string to extract the last component of a file path, returning the resulting substring.",
        "code_id": "c_group_1_id_406",
        "code_text": "static char *\nbazename(const char *fname)\n{\n\tstatic char buf[300];\n\tstrcpy(buf, fname);\n\treturn basename(buf);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_407",
        "query_text": "The function takes two inputs: a pointer to a pointer to unsigned char, representing an array of pointers, and a size_t value indicating the length of the memory block. It releases the memory block by invoking the munmap system call on the specified address and length. The function does not return any value.",
        "code_id": "c_group_1_id_407",
        "code_text": "static void\nfree_pointers(unsigned char **strings, size_t strings_len)\n{\n\tmunmap((void *)strings, strings_len);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_408",
        "query_text": "The function is defined with internal linkage and does not accept any input parameters. It returns no value. It is intended to output timing results in an XML format; however, its current implementation is empty and does not perform any operations or produce output.",
        "code_id": "c_group_1_id_408",
        "code_text": "static void\nprint_timing_results_xml(void)\n{\n\t\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_409",
        "query_text": "The function takes two unsigned character inputs and returns an unsigned integer. It begins by asserting that the two inputs are not equal, ensuring that this condition holds true during execution. However, it does not perform any further computations or comparisons on the inputs; they are effectively ignored. Ultimately, the function always returns the constant value 0, serving as a placeholder or stub implementation. The inputs are of type unsigned char, and the output is of type unsigned int.",
        "code_id": "c_group_1_id_409",
        "code_text": "static inline unsigned lcp(unsigned char a, unsigned char b)\n{\n\tassert(a != b);\n\t(void)a;\n\t(void)b;\n\treturn 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_410",
        "query_text": "This function is a stub that currently performs no operations. It accepts no input parameters and returns no value. Although marked as inline, its empty body indicates that it is intended as a placeholder for future implementation rather than providing any immediate functionality.",
        "code_id": "c_group_1_id_410",
        "code_text": "static inline void stat_try_cache()     {}\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_411",
        "query_text": "The function takes no input parameters and returns no output. It performs no operations when executed, acting as a no-operation (no-op) procedure. This function serves as a placeholder for situations where a function call is syntactically necessary but no functionality is required.",
        "code_id": "c_group_1_id_411",
        "code_text": "static inline void stat_cache_useless() {}\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_412",
        "query_text": "The function is a placeholder that accepts no parameters and returns no value. It is declared as an inline static function, indicating that its definition is provided in the header and may be substituted directly at the point of call. The empty function body signifies that no operations are performed when this function is invoked.",
        "code_id": "c_group_1_id_412",
        "code_text": "static inline void stat_print()         {}\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_413",
        "query_text": "The function takes a constant string as input and returns a dynamically allocated string as output. It opens a system file that contains information about the current process and reads it line by line. For each line, the function splits the line at a delimiter and compares the first part with the provided key. If a match is found, it extracts the corresponding value by trimming any leading whitespace and removing the trailing newline character, then returns a copy of this value. If no matching entry is found or an error occurs (such as the file failing to open), it returns a NULL pointer, indicating failure. The caller is responsible for deallocating the returned string when it is no longer needed.",
        "code_id": "c_group_1_id_413",
        "code_text": "static char *\nstatus_entry(const char *key)\n{\n\tchar *result = NULL;\n\tchar *line = NULL;\n\tsize_t line_n = 0;\n\tFILE *fp;\n\tfp = fopen(\"/proc/self/status\", \"r\");\n\tif (!fp)\n\t\tgoto done;\n\twhile (getline(&line, &line_n, fp) != -1) {\n\t\tchar *v;\n\t\tv = strchr(line, ':');\n\t\tif (!v || *v == '\\0')\n\t\t\tcontinue;\n\t\t*v = '\\0';\n\t\tif (strcmp(line, key) != 0)\n\t\t\tcontinue;\n\t\t++v;\n\t\twhile (*v == ' ' || *v == '\\t')\n\t\t\t++v;\n\t\tif (strlen(v) > 1)\n\t\t\tv[strlen(v)-1] = '\\0';\n\t\tif (*v == '\\0')\n\t\t\tgoto done;\n\t\tresult = line;\n\t\twhile ((*line++ = *v++))\n\t\t\t;\n\t\tgoto done;\n\t}\ndone:\n\tif (!result)\n\t\tfree(line);\n\tif (fp)\n\t\tfclose(fp);\n\treturn result;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_414",
        "query_text": "The function accepts three inputs: a character array that serves as a destination buffer, an array of character pointers representing strings, and an unsigned integer indicating the total number of strings. It iterates over the first half of the string array while pairing each element with a corresponding element from the second half. For each pair, the function removes the trailing newline (or similar character) from the first string, then appends it to the destination buffer with a set of spaces, followed by a separator and the paired string. If the total number of strings is odd, the leftover string (without a pair) is appended to the buffer without the separator. The function modifies the destination buffer directly and does not return any value.",
        "code_id": "c_group_1_id_414",
        "code_text": "static void\nadd_smaps(char *buf, char **pairs, unsigned pairs_cnt)\n{\n\tunsigned i, j;\n\tfor (i=0, j=pairs_cnt/2; i < pairs_cnt/2; ++i, ++j) {\n\t\tpairs[i][strlen(pairs[i])-1] = '\\0';\n\t\tstrcat(buf, \"    \");\n\t\tstrcat(buf, pairs[i]);\n\t\tstrcat(buf, \"  |  \");\n\t\tstrcat(buf, pairs[j]);\n\t}\n\tif (j < pairs_cnt) {\n\t\tstrcat(buf, \"    \");\n\t\tstrcat(buf, pairs[j]);\n\t}\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_415",
        "query_text": "The function accepts an integer input and processes it by consecutively dividing it by a predefined series of numbers. For each divisor in the sequence, the function divides the input repeatedly as long as the division yields no remainder. After iterating through all the specified divisors, the function checks the resulting value: if it has been reduced to 1, the function returns 1; otherwise, it returns 0. The input is an integer, and the output is an integer that indicates whether the input has been entirely factored by the given numbers.",
        "code_id": "c_group_1_id_415",
        "code_text": "int dividebyN(int N) {\n\twhile (N%53 == 0) {\n\t\tN = N/53;\n\t}\n\twhile (N%47 == 0) {\n\t\tN = N/47;\n\t}\n\twhile (N%43 == 0) {\n\t\tN = N/43;\n\t}\n\twhile (N%41 == 0) {\n\t\tN = N/41;\n\t}\n\twhile (N%37 == 0) {\n\t\tN = N/37;\n\t}\n\twhile (N%31 == 0) {\n\t\tN = N/31;\n\t}\n\twhile (N%29 == 0) {\n\t\tN = N/29;\n\t}\n\twhile (N%23 == 0) {\n\t\tN = N/23;\n\t}\n\twhile (N%17 == 0) {\n\t\tN = N/17;\n\t}\n\twhile (N%13 == 0) {\n\t\tN = N/13;\n\t}\n\twhile (N%11 == 0) {\n\t\tN = N/11;\n\t}\n\twhile (N%8 == 0) {\n\t\tN = N/8;\n\t}\n\twhile (N%7 == 0) {\n\t\tN = N/7;\n\t}\n\twhile (N%5 == 0) {\n\t\tN = N/5;\n\t}\n\twhile (N%4 == 0) {\n\t\tN = N/4;\n\t}\n\twhile (N%3 == 0) {\n\t\tN = N/3;\n\t}\n\twhile (N%2 == 0) {\n\t\tN = N/2;\n\t}\n\tif (N == 1) {\n\t\treturn 1;\n\t}\n\t return 0;\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_416",
        "query_text": "The function accepts two inputs. The first is an integer value, and the second is a pointer to an array of integers. The algorithm determines the prime factors of the given integer and sequentially stores each factor in the array. It first checks for divisibility by a series of specific larger primes in descending order (such as 53, 47, 43, etc.), then proceeds with checks for smaller primes (for example, 2, 3, 5, etc.). If the remaining quotient after these checks is greater than a particular threshold (31), the function switches to a generalized approach that iteratively tests for additional prime factors using a computed sequence of potential divisors. Finally, the function returns an integer representing the total number of prime factors found and stored in the array.",
        "code_id": "c_group_1_id_416",
        "code_text": "int factors(int M, int* arr) {\n\tint i,N,num,mult,m1,m2;\n\ti = 0;\n\tN = M;\n\twhile (N%53 == 0) {\n\t\tN = N/53;\n\t\tarr[i] = 53;\n\t\ti++;\n\t}\n\twhile (N%47 == 0) {\n\t\tN = N/47;\n\t\tarr[i] = 47;\n\t\ti++;\n\t}\n\twhile (N%43 == 0) {\n\t\tN = N/43;\n\t\tarr[i] = 43;\n\t\ti++;\n\t}\n\twhile (N%41 == 0) {\n\t\tN = N/41;\n\t\tarr[i] = 41;\n\t\ti++;\n\t}\n\twhile (N%37 == 0) {\n\t\tN = N/37;\n\t\tarr[i] = 37;\n\t\ti++;\n\t}\n\twhile (N%31 == 0) {\n\t\tN = N/31;\n\t\tarr[i] = 31;\n\t\ti++;\n\t}\n\twhile (N%29 == 0) {\n\t\tN = N/29;\n\t\tarr[i] = 29;\n\t\ti++;\n\t}\n\twhile (N%23 == 0) {\n\t\tN = N/23;\n\t\tarr[i] = 23;\n\t\ti++;\n\t}\n\twhile (N%19 == 0) {\n\t\tN = N/19;\n\t\tarr[i] = 19;\n\t\ti++;\n\t}\n\twhile (N%17 == 0) {\n\t\tN = N/17;\n\t\tarr[i] = 17;\n\t\ti++;\n\t}\n\twhile (N%13 == 0) {\n\t\tN = N/13;\n\t\tarr[i] = 13;\n\t\ti++;\n\t}\n\twhile (N%11 == 0) {\n\t\tN = N/11;\n\t\tarr[i] = 11;\n\t\ti++;\n\t}\n\twhile (N%8 == 0) {\n\t\tN = N/8;\n\t\tarr[i] = 8;\n\t\ti++;\n\t}\n\twhile (N%7 == 0) {\n\t\tN = N/7;\n\t\tarr[i] = 7;\n\t\ti++;\n\t}\n\twhile (N%5 == 0) {\n\t\tN = N/5;\n\t\tarr[i] = 5;\n\t\ti++;\n\t}\n\twhile (N%4 == 0) {\n\t\tN = N/4;\n\t\tarr[i] = 4;\n\t\ti++;\n\t}\n\twhile (N%3 == 0) {\n\t\tN = N/3;\n\t\tarr[i] = 3;\n\t\ti++;\n\t}\n\twhile (N%2 == 0) {\n\t\tN = N/2;\n\t\tarr[i] = 2;\n\t\ti++;\n\t}\n\tif (N > 31) {\n\t\tnum = 2;\n\n\t\twhile (N > 1) {\n\t\t\tmult = num*6;\n\t\t\tm1 = mult-1;\n\t\t\tm2 = mult+1;\n\t\t\twhile (N%m1 == 0 ) {\n\t\t\t\tarr[i] = m1;\n\t\t\t\ti++;\n\t\t\t\tN = N / m1;\n\t\t\t}\n\t\t\twhile (N%m2 == 0 ) {\n\t\t\t\tarr[i] = m2;\n\t\t\t\ti++;\n\t\t\t\tN = N / m2;\n\t\t\t}\n\t\t\tnum+=1;\n\n\t\t}\n\t}\n\treturn i;\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_417",
        "query_text": "The function accepts an integer input and systematically eliminates all occurrences of the factors 2, 3, 5, and 7. It does so by repeatedly performing integer division on the input with each of these divisors whenever the current value is divisible by them. Ultimately, the function returns the modified integer after all such factor removals have been applied. The input and output are both of type int.",
        "code_id": "c_group_1_id_417",
        "code_text": "int factorf(int M) {\n\tint N;\n\tN = M;\n\twhile (N%7 == 0){\n\t\t\tN = N/7;\n\t\t}\n\twhile (N%3 == 0){\n\t\t\tN = N/3;\n\t\t}\n\twhile (N%5 == 0){\n\t\t\tN = N/5;\n\t\t}\n\twhile (N%2 == 0){\n\t\t\tN = N/2;\n\t\t}\n\n\treturn N;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_418",
        "query_text": "This function accepts a floating-point number as input and returns an integer representing the rounded value. It adds 0.49999 to the input value, and then converts the result to an integer, which effectively rounds the input to the nearest whole number. The input is of type double, and the output is of type int.",
        "code_id": "c_group_1_id_418",
        "code_text": "int nint(double N) {\n\tint i;\n\n\ti = (int)(N + 0.49999);\n\n\treturn i;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_419",
        "query_text": "The function takes no input parameters and consistently returns an integer value of 42. The return type is int, and the function does not perform any operations apart from returning this constant value.",
        "code_id": "c_group_1_id_419",
        "code_text": "int foo() { return 42; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_420",
        "query_text": "The function takes no input parameters and directly returns the integer value 42. The output is of type int.",
        "code_id": "c_group_1_id_420",
        "code_text": "int bar() { return 42; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_421",
        "query_text": "The function accepts an unsigned integer as input and returns a boolean value. It evaluates whether the input is greater than 15 and less than 272, thereby determining if the value lies within the exclusive range of 16 to 271. If the input satisfies these conditions, the function returns true; otherwise, it returns false.",
        "code_id": "c_group_1_id_421",
        "code_text": "inline STRF_HD bool first_2_of_4_are_valid(unsigned x)\n{\n    return 0xF < x && x < 0x110;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_422",
        "query_text": "The function is a compile-time evaluable routine that accepts a variable number of arguments, although it does not process them in any way. It simply returns a boolean value of true without performing any computations or modifications based on the input. The routine is designed to be executed during compilation, as suggested by its constant expression attribute, and includes a modifier that may be specific to certain platforms.",
        "code_id": "c_group_1_id_422",
        "code_text": "constexpr STRF_HD bool get_constrainable(...)\n{\n    return true;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_423",
        "query_text": "The function takes three inputs: a pointer to an array of short integers, a pointer to an array of floats, and an integer representing the number of elements. It processes every element in the input array by dividing each short integer by the constant value 32768.0 (expressed as 0x8000 in hexadecimal) and casting the result to a float. The converted values are then stored sequentially in the output array. The input types are short integers and an int, and the output type is float.",
        "code_id": "c_group_1_id_423",
        "code_text": "void\nsrc_short_to_float_array (const short *in, float *out, int len)\n{\n\tfor (int i = 0 ; i < len ; i++)\n\t{\tout [i] = (float) (in [i] / (1.0 * 0x8000)) ;\n\t\t} ;\n\n\treturn ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_424",
        "query_text": "The function accepts an array of integers and its length as input, along with an array to store the output. It processes each element by dividing the integer by a constant value (computed as 8.0 multiplied by a large constant) and then casting the result to a floating-point number. The computed float is stored in the output array at the corresponding position. The input consists of an integer array and its length, and the function returns an array of floats after processing every element up to the specified length.",
        "code_id": "c_group_1_id_424",
        "code_text": "void\nsrc_int_to_float_array (const int *in, float *out, int len)\n{\n\tfor (int i = 0 ; i < len ; i++)\n\t{\tout [i] = (float) (in [i] / (8.0 * 0x10000000)) ;\n\t\t} ;\n\n\treturn ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_425",
        "query_text": "The function accepts three inputs: a pointer to an array of floats, an integer representing the number of elements in the array, and another integer that denotes an expected count of peaks. It returns a double that represents the signal-to-noise ratio (SNR). Instead of processing the inputs, the function immediately provides a constant double value of 200.0, serving as a placeholder or stub.",
        "code_id": "c_group_1_id_425",
        "code_text": "double\ncalculate_snr (float *data, int len, int expected_peaks)\n{\tdouble snr = 200.0 ;\n\n\tdata = data ;\n\tlen = len ;\n\texpected_peaks = expected_peaks ;\n\n\treturn snr ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_426",
        "query_text": "The function acts as a signal handler that is invoked when a particular signal is received. It accepts an integer input representing the signal number, although this input is not utilized within the function. Upon activation, it immediately prints an error message indicating that a hang has been detected within a callback reading function. Following the message display, the function terminates the program abnormally by calling an exit routine with a status code of 1.\n\n\u2022 Input: An integer representing a signal number (unused within the function).  \n\u2022 Output: None (void function).  \n\u2022 Functionality: The function serves as a signal handler; it outputs an error message alerting of a detected hang in a callback reading process and then forces program termination with an exit status of 1.",
        "code_id": "c_group_1_id_426",
        "code_text": "static void\nalarm_handler (int number)\n{\n\t(void) number ;\n\tprintf (\"\\n\\n    Error : Hang inside src_callback_read() detected. Exiting!\\n\\n\") ;\n\texit (1) ;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_427",
        "query_text": "The function takes a pointer to an integer and an integer value as inputs. It first retrieves the current value stored at the provided pointer, then adds the provided integer value to it, updating the original value atomically to ensure thread safety. Finally, the function returns the original integer value obtained before the addition.",
        "code_id": "c_group_1_id_427",
        "code_text": "static WC_INLINE int wolfSSL_Atomic_Int_FetchAdd(int *c, int i) {\n        int ret = *c;\n        *c += i;\n        return ret;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_428",
        "query_text": "The function takes two inputs: a pointer to an integer and an integer. It retrieves the current value from the integer pointed to by the pointer, subtracts the given integer from it, and then returns the original value before the subtraction occurred. The function returns an int.",
        "code_id": "c_group_1_id_428",
        "code_text": "static WC_INLINE int wolfSSL_Atomic_Int_FetchSub(int *c, int i) {\n        int ret = *c;\n        *c -= i;\n        return ret;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_429",
        "query_text": "The function takes an unsigned long integer as input and returns a constant character pointer (string). It ignores the numerical input and does not use it in any computation. Instead, it logs a debug message to inform the user that it does not provide the name of the function that failed, advising them to consult the debug logs for additional error details. The function always returns an empty string and does not supply any specific error-related information directly.",
        "code_id": "c_group_1_id_429",
        "code_text": "const char* wolfSSL_ERR_func_error_string(unsigned long e)\n{\n    (void)e;\n    WOLFSSL_MSG(\"wolfSSL_ERR_func_error_string does not return the name of \"\n                \"the function that failed. Please inspect the wolfSSL debug \"\n                \"logs to determine where the error occurred.\");\n    return \"\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_430",
        "query_text": "The function is defined as a static inline function that accepts no inputs and returns no output. It performs no operations and serves purely as a placeholder or no-op function, meant to be used in contexts where a function call is required despite no functional action being necessary.",
        "code_id": "c_group_1_id_430",
        "code_text": "static WC_INLINE void StackTrap(void)\n{\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_431",
        "query_text": "The function accepts three parameters: a pointer to an unsigned character array, an integer representing a size, and an integer representing a type. It ignores the unsigned character array and then prints a formatted message to the console that includes the size and type values, signaling that a specific cache add callback has been triggered. The function does not return any value.",
        "code_id": "c_group_1_id_431",
        "code_text": "static WC_INLINE void CaCb(unsigned char* der, int sz, int type)\n{\n    (void)der;\n    printf(\"Got CA cache add callback, derSz = %d, type = %d\\n\", sz, type);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_432",
        "query_text": "This function tests secure remote password protocol operations in a controlled environment. It is conditionally compiled to run only when both the secure remote password and SHA-512 features are enabled. The function takes no input parameters and returns no value. It first initializes the cryptographic library before sequentially testing various SRP operations such as context initialization, username and parameter setting, and\u2014if SHA is enabled\u2014password configuration, public key generation, shared key computation, and session proof verification. It also tests a callback mechanism for key generation before finally cleaning up the cryptographic library.",
        "code_id": "c_group_1_id_432",
        "code_text": "void SrpTest(void)\n{\n#if defined(WOLFCRYPT_HAVE_SRP) && defined(WOLFSSL_SHA512)\n    wolfCrypt_Init();\n    test_SrpInit();\n    test_SrpSetUsername();\n    test_SrpSetParams();\n#ifndef NO_SHA\n    test_SrpSetPassword();\n    test_SrpGetPublic();\n    test_SrpComputeKey();\n    test_SrpGetProofAndVerify();\n#endif \n    test_SrpKeyGenFunc_cb();\n    wolfCrypt_Cleanup();\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_433",
        "query_text": "The function takes no input arguments and returns an integer value. It immediately outputs a predefined constant that signifies that a particular test or operation has been skipped. The function performs no computations or modifications; its sole purpose is to serve as an indicator for the skipped functionality.",
        "code_id": "c_group_1_id_433",
        "code_text": "static int test_dual_alg_support(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_434",
        "query_text": "This function takes no input and returns an integer that signifies a test case has been intentionally skipped. It does not perform any operations besides immediately returning a predefined constant representing the skipped test status. The function serves as a marker or placeholder to indicate that the particular test is not executed during a testing run.",
        "code_id": "c_group_1_id_434",
        "code_text": "static int test_wolfSSL_CTX_set_max_proto_version(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_435",
        "query_text": "The function takes no input arguments and returns an integer indicating the outcome of its test. It conditionally tests the export functionality of TLS sessions by first verifying that the environment is configured to support session export for TLS version 1.2. If these conditions are met, it proceeds to execute tests for TLS 1.2 and, if further configured, for TLS 1.3. The integer output represents whether the tests passed, failed, or were skipped due to unmet preprocessor conditions.",
        "code_id": "c_group_1_id_435",
        "code_text": "static int test_wolfSSL_tls_export(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(WOLFSSL_SESSION_EXPORT) && !defined(WOLFSSL_NO_TLS12)\n    test_wolfSSL_tls_export_run(WOLFSSL_TLSV1_2);\n    #ifdef WOLFSSL_TLS13\n    test_wolfSSL_tls_export_run(WOLFSSL_TLSV1_3);\n    #endif\n    res = TEST_RES_CHECK(1);\n#endif\n\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_436",
        "query_text": "The function takes no explicit inputs and returns an integer representing a test outcome. It begins by initializing internal structures for a random number generator and an elliptic curve cryptography key. The function then validates error handling by invoking the key generation routine with invalid (null) parameters and verifying that the expected error codes are returned. Following these checks, it calls the key generation routine with proper inputs to create an SM2 key pair and confirms that the generated key corresponds to the designated SM2 curve. Finally, it frees the allocated resources and returns an integer result indicating whether the test passed, failed, or was skipped.",
        "code_id": "c_group_1_id_436",
        "code_text": "static int test_wc_ecc_sm2_make_key(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(HAVE_ECC) && defined(WOLFSSL_SM2)\n    EXPECT_DECLS;\n    WC_RNG  rng[1];\n    ecc_key key[1];\n\n    XMEMSET(rng, 0, sizeof(*rng));\n    XMEMSET(key, 0, sizeof(*key));\n\n    ExpectIntEQ(wc_InitRng(rng), 0);\n    ExpectIntEQ(wc_ecc_init(key), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_make_key(NULL, NULL, WC_ECC_FLAG_NONE),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_make_key(rng, NULL, WC_ECC_FLAG_NONE),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_make_key(NULL, key, WC_ECC_FLAG_NONE),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_ecc_sm2_make_key(rng, key, WC_ECC_FLAG_NONE), 0);\n    ExpectIntEQ(key->dp->id, ECC_SM2P256V1);\n\n    wc_ecc_free(key);\n    wc_FreeRng(rng);\n#ifdef FP_ECC\n    wc_ecc_fp_free();\n#endif\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_437",
        "query_text": "This function validates the process of generating a shared secret using an elliptic curve cryptography algorithm based on SM2. It begins by initializing a random number generator alongside two separate elliptic curve key pairs. It then performs key generation for both pairs and proceeds to compute shared secrets for each using the SM2 method. The function confirms that the shared secrets produced by the two key pairs are identical and do not exceed the expected maximum length. Additionally, it rigorously tests the error handling capabilities by providing various invalid input combinations to ensure that improper arguments are correctly rejected. Finally, the function returns a result indicating whether the test passed, failed, or was skipped due to missing dependencies.",
        "code_id": "c_group_1_id_437",
        "code_text": "static int test_wc_ecc_sm2_shared_secret(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(HAVE_ECC) && defined(WOLFSSL_SM2)\n    EXPECT_DECLS;\n    WC_RNG  rng[1];\n    ecc_key keyA[1];\n    ecc_key keyB[1];\n    byte outA[32];\n    byte outB[32];\n    word32 outALen = 32;\n    word32 outBLen = 32;\n\n    XMEMSET(rng, 0, sizeof(*rng));\n    XMEMSET(keyA, 0, sizeof(*keyA));\n    XMEMSET(keyB, 0, sizeof(*keyB));\n\n    ExpectIntEQ(wc_InitRng(rng), 0);\n    ExpectIntEQ(wc_ecc_init(keyA), 0);\n    ExpectIntEQ(wc_ecc_init(keyB), 0);\n    ExpectIntEQ(wc_ecc_sm2_make_key(rng, keyA, WC_ECC_FLAG_NONE), 0);\n    ExpectIntEQ(wc_ecc_sm2_make_key(rng, keyB, WC_ECC_FLAG_NONE), 0);\n\n#ifdef ECC_TIMING_RESISTANT\n    ExpectIntEQ(wc_ecc_set_rng(keyA, rng), 0);\n    ExpectIntEQ(wc_ecc_set_rng(keyB, rng), 0);\n#endif\n\n    \n    ExpectIntEQ(wc_ecc_sm2_shared_secret(NULL, NULL, NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyA, NULL, NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(NULL, keyB, NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(NULL, NULL, outA, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(NULL, NULL, NULL, &outALen),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(NULL, keyB, outA, &outALen),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyA, NULL, outA, &outALen),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyA, keyB, NULL, &outALen),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyA, keyB, outA, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyA, keyB, outA, &outALen), 0);\n    ExpectIntLE(outALen, 32);\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyB, keyA, outB, &outBLen), 0);\n    ExpectIntLE(outBLen, 32);\n    ExpectIntEQ(outALen, outBLen);\n    ExpectBufEQ(outA, outB, outALen);\n\n    wc_ecc_free(keyB);\n    wc_ecc_free(keyA);\n    wc_FreeRng(rng);\n#ifdef FP_ECC\n    wc_ecc_fp_free();\n#endif\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_438",
        "query_text": "The function is a test procedure that returns an integer test result indicating whether the test passed, failed, or was skipped. It operates as follows:\n\n1. Initialization: It sets up an elliptic curve key structure and prepares several input byte arrays, which include a public key, an identifier, and a message. Additionally, it determines the hash algorithm (choosing between two possible types based on compile-time configuration).\n\n2. Error Handling: It deliberately invokes a digest creation routine with various invalid or null inputs\u2014such as null pointers and incorrect buffer sizes\u2014to verify that the routine consistently returns appropriate error codes when supplied with invalid arguments.\n\n3. Digest Creation: It calls the digest creation routine with proper inputs to generate a cryptographic digest (hash). The resulting digest is then compared with a predefined expected hash value to ensure correctness.\n\n4. Cleanup: Any resources allocated during the initialization (such as the elliptic curve structure) are freed before the function returns.\n\nThe overall purpose is to thoroughly test the digest creation functionality under both valid and error conditions, with the function's inputs being byte arrays (for the public key, identifier, and message) plus an enumeration for hash type, and the output being a test result code (integer).",
        "code_id": "c_group_1_id_438",
        "code_text": "static int test_wc_ecc_sm2_create_digest(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(HAVE_ECC) && defined(WOLFSSL_SM2) && !defined(NO_HASH_WRAPPER) && \\\n    (defined(WOLFSSL_SM3) || !defined(NO_SHA256))\n    EXPECT_DECLS;\n    ecc_key key[1];\n    enum wc_HashType hashType;\n    unsigned char pub[] = {\n        0x04,\n        0x63, 0x7F, 0x1B, 0x13, 0x50, 0x36, 0xC9, 0x33,\n        0xDC, 0x3F, 0x7A, 0x8E, 0xBB, 0x1B, 0x7B, 0x2F,\n        0xD1, 0xDF, 0xBD, 0x26, 0x8D, 0x4F, 0x89, 0x4B,\n        0x5A, 0xD4, 0x7D, 0xBD, 0xBE, 0xCD, 0x55, 0x8F,\n        0xE8, 0x81, 0x01, 0xD0, 0x80, 0x48, 0xE3, 0x6C,\n        0xCB, 0xF6, 0x1C, 0xA3, 0x8D, 0xDF, 0x7A, 0xBA,\n        0x54, 0x2B, 0x44, 0x86, 0xE9, 0x9E, 0x49, 0xF3,\n        0xA7, 0x47, 0x0A, 0x85, 0x7A, 0x09, 0x64, 0x33\n    };\n    unsigned char id[] = {\n        0x01, 0x02, 0x03,\n    };\n    unsigned char msg[] = {\n        0x01, 0x02, 0x03,\n    };\n    unsigned char hash[32];\n#ifdef WOLFSSL_SM3\n    unsigned char expHash[32] = {\n        0xc1, 0xdd, 0x92, 0xc5, 0x60, 0xd3, 0x94, 0x28,\n        0xeb, 0x0f, 0x57, 0x79, 0x3f, 0xc9, 0x96, 0xc5,\n        0xfa, 0xf5, 0x90, 0xb2, 0x64, 0x2f, 0xaf, 0x9c,\n        0xc8, 0x57, 0x21, 0x6a, 0x52, 0x7e, 0xf1, 0x95\n    };\n#else\n    unsigned char expHash[32] = {\n        0xea, 0x41, 0x55, 0x21, 0x61, 0x00, 0x5c, 0x9a,\n        0x57, 0x35, 0x6b, 0x49, 0xca, 0x8f, 0x65, 0xc2,\n        0x0e, 0x29, 0x0c, 0xa0, 0x1d, 0xa7, 0xc4, 0xed,\n        0xdd, 0x51, 0x12, 0xf6, 0xe7, 0x55, 0xc5, 0xf4\n    };\n#endif\n\n#ifdef WOLFSSL_SM3\n    hashType = WC_HASH_TYPE_SM3;\n#else\n    hashType = WC_HASH_TYPE_SHA256;\n#endif\n\n    XMEMSET(key, 0, sizeof(*key));\n\n    ExpectIntEQ(wc_ecc_init(key), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        hashType, hash, sizeof(hash), key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    ExpectIntEQ(wc_ecc_import_x963_ex(pub, sizeof(pub), key, ECC_SM2P256V1), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_create_digest(NULL, sizeof(id), NULL, sizeof(msg),\n        hashType, NULL, sizeof(hash), NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), NULL, sizeof(msg),\n        hashType, NULL, sizeof(hash), NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(NULL, sizeof(id), msg, sizeof(msg),\n        hashType, NULL, sizeof(hash), NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(NULL, sizeof(id), NULL, sizeof(msg),\n        hashType, hash, sizeof(hash), NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(NULL, sizeof(id), NULL, sizeof(msg),\n        hashType, NULL, sizeof(hash), key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(NULL, sizeof(id), msg, sizeof(msg),\n        hashType, hash, sizeof(hash), key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), NULL, sizeof(msg),\n        hashType, hash, sizeof(hash), key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        hashType, NULL, sizeof(hash), key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        hashType, hash, sizeof(hash), NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    \n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        -1, hash, 0, key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    \n    \n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        hashType, hash, 0, key), WC_NO_ERR_TRACE(BUFFER_E));\n\n    \n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        hashType, hash, sizeof(hash), key), 0);\n    ExpectBufEQ(hash, expHash, sizeof(expHash));\n\n    wc_ecc_free(key);\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_439",
        "query_text": "The function takes no arguments and returns an integer status. It checks for a specific compile-time flag, and if present, it performs two cleanup operations: one on a certificate store context and another on a related trusted component. If the flag is defined, the function executes both cleanup routines and returns a success status; otherwise, it skips the operations and returns a skipped status.",
        "code_id": "c_group_1_id_439",
        "code_text": "static int test_wolfSSL_X509_STORE_CTX_trusted_stack_cleanup(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n    X509_STORE_CTX_cleanup(NULL);\n    X509_STORE_CTX_trusted_stack(NULL, NULL);\n\n    res = TEST_SUCCESS;\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_440",
        "query_text": "The function takes no input parameters and is designed to test an error queue mechanism in a multi-threaded context. It begins by clearing any existing error state and then creates and starts a number of threads that each perform a logging operation. After initializing the threads, the function waits for all of them to complete their execution. Depending on whether certain preprocessor conditions (such as multi-threading, error queue per thread support, and debug options) are met, the function returns an integer value that indicates either a successful test run or that the test was skipped. The output type is int.",
        "code_id": "c_group_1_id_440",
        "code_text": "static int test_error_queue_per_thread(void)\n{\n    int res = TEST_SKIPPED;\n#if !defined(SINGLE_THREADED) && defined(ERROR_QUEUE_PER_THREAD) && \\\n    !defined(NO_ERROR_QUEUE) && defined(OPENSSL_EXTRA) && \\\n    defined(DEBUG_WOLFSSL)\n    THREAD_TYPE loggingThreads[LOGGING_THREADS];\n    int i;\n\n    ERR_clear_error(); \n\n    loggingThreadsReady = 0;\n    for (i = 0; i < LOGGING_THREADS; i++)\n        start_thread(test_logging, NULL, &loggingThreads[i]);\n    loggingThreadsReady = 1;\n    for (i = 0; i < LOGGING_THREADS; i++)\n        join_thread(loggingThreads[i]);\n\n    res = TEST_SUCCESS;\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_441",
        "query_text": "The function performs a test to validate macro behavior under certain compile-time conditions. It begins by evaluating whether any of several preprocessor flags are defined. If at least one is active, the function invokes a macro using a predefined constant string. Upon successful execution of the macro call, it returns a code signifying success; otherwise, it returns a code indicating that the test was skipped. The function takes no input parameters and returns an integer representing the outcome of the test.",
        "code_id": "c_group_1_id_441",
        "code_text": "static int test_WOLFSSL_ERROR_MSG(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(DEBUG_WOLFSSL) || defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) ||\\\n    defined(WOLFSSL_HAPROXY) || defined(OPENSSL_EXTRA)\n    const char* msg = TEST_STRING;\n\n    WOLFSSL_ERROR_MSG(msg);\n\n    res = TEST_SUCCESS;\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_442",
        "query_text": "The function takes no input parameters. It initializes a result variable with a value that indicates the test is skipped. Then, when compiled with certain preprocessor flags defined, it invokes a function that removes or resets an error state and updates the result variable to show that the test was successful. Finally, the function returns the result variable. The primary purpose of the function is to test the removal of an error state under specific compilation conditions.",
        "code_id": "c_group_1_id_442",
        "code_text": "static int test_wc_ERR_remove_state(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE)\n    wc_ERR_remove_state();\n\n    res = TEST_SUCCESS;\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_443",
        "query_text": "The function takes no input parameters. It checks a specific compile-time condition: if a certain macro is defined, it calls a routine to load cryptographic error messages and then returns an integer constant representing success; otherwise, it directly returns an integer constant indicating that the operation was skipped. The function thereby returns an integer whose value depends on the defined macro.",
        "code_id": "c_group_1_id_443",
        "code_text": "static int test_ERR_load_crypto_strings(void)\n{\n#if defined(OPENSSL_ALL)\n    ERR_load_crypto_strings();\n    return TEST_SUCCESS;\n#else\n    return TEST_SKIPPED;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_444",
        "query_text": "The function takes no external inputs and returns an integer indicating the overall test result. It uses a fixed key, an initialization vector, a plaintext message, and additional authenticated data. The procedure is as follows:\n\n1. First, multiple encryption contexts are initialized for a Galois/Counter Mode cipher configured with three different key sizes. For each configuration, the function encrypts the plaintext by processing the additional authenticated data and obtains both the ciphertext and an authentication tag.\n\n2. Next, corresponding decryption contexts are set up. Each decryption process uses the fixed key and initialization vector to recover the original plaintext from the ciphertext while validating the authentication tag. Additionally, the function deliberately alters the authentication tag to verify that decryption fails when the tag is incorrect.\n\n3. Finally, after cleaning up the encryption and decryption contexts, the function returns an integer value representing whether the test passed, failed, or was skipped (e.g., if necessary features were unavailable).\n\nThe overall goal is to validate that the cipher's encryption and decryption operations function correctly and robustly across different configurations.",
        "code_id": "c_group_1_id_444",
        "code_text": "static int test_wolfssl_EVP_aria_gcm(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(HAVE_ARIA) && \\\n    !defined(HAVE_SELFTEST) && !defined(HAVE_FIPS)\n\n    \n    byte *key = (byte*)\"01234567890123456789012345678901\";\n    \n    byte *iv = (byte*)\"0123456789012345\";\n    int ivSz = ARIA_BLOCK_SIZE;\n    \n    const int plaintxtSz = 40;\n    byte plaintxt[WC_ARIA_GCM_GET_CIPHERTEXT_SIZE(plaintxtSz)];\n    XMEMCPY(plaintxt,\"for things to change you have to change\",plaintxtSz);\n    \n    byte *aad = (byte*)\"Don't spend major time on minor things.\";\n\n    unsigned char tag[ARIA_BLOCK_SIZE] = {0};\n    int aadSz = (int)XSTRLEN((char*)aad);\n    byte ciphertxt[WC_ARIA_GCM_GET_CIPHERTEXT_SIZE(plaintxtSz)];\n    byte decryptedtxt[plaintxtSz];\n    int ciphertxtSz = 0;\n    int decryptedtxtSz = 0;\n    int len = 0;\n    int i = 0;\n    #define TEST_ARIA_GCM_COUNT 6\n    EVP_CIPHER_CTX en[TEST_ARIA_GCM_COUNT];\n    EVP_CIPHER_CTX de[TEST_ARIA_GCM_COUNT];\n\n    for (i = 0; i < TEST_ARIA_GCM_COUNT; i++) {\n\n        EVP_CIPHER_CTX_init(&en[i]);\n        switch (i) {\n            case 0:\n                \n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_128_gcm(), NULL, key, iv));\n                break;\n            case 1:\n                \n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_192_gcm(), NULL, key, iv));\n                break;\n            case 2:\n                \n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_256_gcm(), NULL, key, iv));\n                break;\n            case 3:\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_128_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], NULL, NULL, key, iv));\n                break;\n            case 4:\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_192_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], NULL, NULL, key, iv));\n                break;\n            case 5:\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_256_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], NULL, NULL, key, iv));\n                break;\n        }\n        XMEMSET(ciphertxt,0,sizeof(ciphertxt));\n        AssertIntEQ(1, EVP_EncryptUpdate(&en[i], NULL, &len, aad, aadSz));\n        AssertIntEQ(1, EVP_EncryptUpdate(&en[i], ciphertxt, &len, plaintxt, plaintxtSz));\n        ciphertxtSz = len;\n        AssertIntEQ(1, EVP_EncryptFinal_ex(&en[i], ciphertxt, &len));\n        AssertIntNE(0, XMEMCMP(plaintxt, ciphertxt, plaintxtSz));\n        ciphertxtSz += len;\n        AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_GET_TAG, ARIA_BLOCK_SIZE, tag));\n        AssertIntEQ(wolfSSL_EVP_CIPHER_CTX_cleanup(&en[i]), 1);\n\n        EVP_CIPHER_CTX_init(&de[i]);\n        switch (i) {\n            case 0:\n                \n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_128_gcm(), NULL, key, iv));\n                break;\n            case 1:\n                \n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_192_gcm(), NULL, key, iv));\n                break;\n            case 2:\n                \n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_256_gcm(), NULL, key, iv));\n                break;\n            case 3:\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_128_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], NULL, NULL, key, iv));\n                break;\n            case 4:\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_192_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], NULL, NULL, key, iv));\n                break;\n            case 5:\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_256_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], NULL, NULL, key, iv));\n                break;\n        }\n        XMEMSET(decryptedtxt,0,sizeof(decryptedtxt));\n        AssertIntEQ(1, EVP_DecryptUpdate(&de[i], NULL, &len, aad, aadSz));\n        AssertIntEQ(1, EVP_DecryptUpdate(&de[i], decryptedtxt, &len, ciphertxt, ciphertxtSz));\n        decryptedtxtSz = len;\n        AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_TAG, ARIA_BLOCK_SIZE, tag));\n        AssertIntEQ(1, EVP_DecryptFinal_ex(&de[i], decryptedtxt, &len));\n        decryptedtxtSz += len;\n        AssertIntEQ(plaintxtSz, decryptedtxtSz);\n        AssertIntEQ(0, XMEMCMP(plaintxt, decryptedtxt, decryptedtxtSz));\n\n        XMEMSET(decryptedtxt,0,sizeof(decryptedtxt));\n        \n        tag[AES_BLOCK_SIZE-1]+=0xBB;\n        AssertIntEQ(1, EVP_DecryptUpdate(&de[i], NULL, &len, aad, aadSz));\n        AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_TAG, ARIA_BLOCK_SIZE, tag));\n        \n        AssertIntEQ(1, EVP_DecryptUpdate(&de[i], decryptedtxt, &len, ciphertxt, ciphertxtSz));\n        AssertIntEQ(0, EVP_DecryptFinal_ex(&de[i], decryptedtxt, &len));\n        AssertIntEQ(0, len);\n        AssertIntEQ(wolfSSL_EVP_CIPHER_CTX_cleanup(&de[i]), 1);\n    }\n\n    res = TEST_RES_CHECK(1);\n#endif \n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_445",
        "query_text": "This function verifies the encryption and decryption processes of an SM4-GCM algorithm when provided with an empty (zero-length) plaintext input. It begins by initializing separate contexts for both encryption and decryption, and it employs predetermined byte arrays for the key and initialization vector (IV). During encryption, the function processes the empty plaintext to produce an empty ciphertext and generates an authentication tag. This tag is then compared to a predefined expected value. In the decryption phase, it takes the empty ciphertext along with the same fixed key and IV, sets the authentication tag, and confirms that the decryption also results in an empty output. The function uses various integer variables to track data sizes and processing results, and finally, it returns a status indicating whether the test passed, was skipped, or failed.",
        "code_id": "c_group_1_id_445",
        "code_text": "static int test_wolfssl_EVP_sm4_gcm_zeroLen(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_SM4_GCM)\n    \n    EXPECT_DECLS;\n    byte key[] = {\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n    }; \n    byte iv[]  = {\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n    }; \n    byte plaintxt[1];\n    int ivSz  = 12;\n    int plaintxtSz = 0;\n    unsigned char tag[16];\n    unsigned char tag_kat[16] = {\n        0x23,0x2f,0x0c,0xfe,0x30,0x8b,0x49,0xea,\n        0x6f,0xc8,0x82,0x29,0xb5,0xdc,0x85,0x8d\n    };\n\n    byte ciphertxt[SM4_BLOCK_SIZE * 4] = {0};\n    byte decryptedtxt[SM4_BLOCK_SIZE * 4] = {0};\n    int ciphertxtSz = 0;\n    int decryptedtxtSz = 0;\n    int len = 0;\n\n    EVP_CIPHER_CTX *en = EVP_CIPHER_CTX_new();\n    EVP_CIPHER_CTX *de = EVP_CIPHER_CTX_new();\n\n    ExpectIntEQ(1, EVP_EncryptInit_ex(en, EVP_sm4_gcm(), NULL, key, iv));\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(en, EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n    ExpectIntEQ(1, EVP_EncryptUpdate(en, ciphertxt, &ciphertxtSz , plaintxt,\n        plaintxtSz));\n    ExpectIntEQ(1, EVP_EncryptFinal_ex(en, ciphertxt, &len));\n    ciphertxtSz += len;\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(en, EVP_CTRL_GCM_GET_TAG, 16, tag));\n    ExpectIntEQ(1, EVP_CIPHER_CTX_cleanup(en));\n\n    ExpectIntEQ(0, ciphertxtSz);\n    ExpectIntEQ(0, XMEMCMP(tag, tag_kat, sizeof(tag)));\n\n    EVP_CIPHER_CTX_init(de);\n    ExpectIntEQ(1, EVP_DecryptInit_ex(de, EVP_sm4_gcm(), NULL, key, iv));\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(de, EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n    ExpectIntEQ(1, EVP_DecryptUpdate(de, NULL, &len, ciphertxt, len));\n    decryptedtxtSz = len;\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(de, EVP_CTRL_GCM_SET_TAG, 16, tag));\n    ExpectIntEQ(1, EVP_DecryptFinal_ex(de, decryptedtxt, &len));\n    decryptedtxtSz += len;\n    ExpectIntEQ(0, decryptedtxtSz);\n\n    EVP_CIPHER_CTX_free(en);\n    EVP_CIPHER_CTX_free(de);\n\n    res = EXPECT_RESULT();\n#endif \n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_446",
        "query_text": "The function takes no explicit input parameters; instead, it utilizes internally defined constants for the encryption key, initialization vector (IV), plaintext, and additional authenticated data. It proceeds through the following steps:\n\n1. Encryption Phase:\n   - Initializes an encryption context for the SM4-GCM algorithm.\n   - Processes the additional authenticated data (AAD) and encrypts the plaintext using the key and IV.\n   - Finalizes the encryption to produce ciphertext and generates an authentication tag for integrity.\n\n2. Decryption Phase:\n   - Initializes a decryption context with the SM4-GCM algorithm.\n   - Uses the same key, IV, and AAD to decrypt the ciphertext.\n   - Verifies the integrity of the decrypted data by applying the authentication tag.\n\n3. Error Handling:\n   - Alters the authentication tag deliberately and attempts decryption again, ensuring the process fails as expected.\n\nThe function returns an integer value indicating the overall result of the performed tests, such as success, failure, or a skipped test. Internal variables include byte arrays for the cryptographic elements (key, IV, plaintext, ciphertext, decrypted text, and tag), various size indicators, and cryptographic context structures for managing encryption and decryption operations.",
        "code_id": "c_group_1_id_446",
        "code_text": "static int test_wolfssl_EVP_sm4_gcm(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_SM4_GCM)\n    EXPECT_DECLS;\n    byte *key = (byte*)\"0123456789012345\";\n    \n    byte *iv = (byte*)\"0123456789012345\";\n    int ivSz = SM4_BLOCK_SIZE;\n    \n    byte *plaintxt = (byte*)\"for things to change you have to change\";\n    \n    byte *aad = (byte*)\"Don't spend major time on minor things.\";\n\n    unsigned char tag[SM4_BLOCK_SIZE] = {0};\n    int plaintxtSz = (int)XSTRLEN((char*)plaintxt);\n    int aadSz = (int)XSTRLEN((char*)aad);\n    byte ciphertxt[SM4_BLOCK_SIZE * 4] = {0};\n    byte decryptedtxt[SM4_BLOCK_SIZE * 4] = {0};\n    int ciphertxtSz = 0;\n    int decryptedtxtSz = 0;\n    int len = 0;\n    int i = 0;\n    EVP_CIPHER_CTX en[2];\n    EVP_CIPHER_CTX de[2];\n\n    for (i = 0; i < 2; i++) {\n        EVP_CIPHER_CTX_init(&en[i]);\n\n        if (i == 0) {\n            \n            ExpectIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_sm4_gcm(), NULL, key,\n                iv));\n        }\n        else {\n            ExpectIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_sm4_gcm(), NULL, NULL,\n                NULL));\n             \n            ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_SET_IVLEN,\n                ivSz, NULL));\n            ExpectIntEQ(1, EVP_EncryptInit_ex(&en[i], NULL, NULL, key, iv));\n        }\n        ExpectIntEQ(1, EVP_EncryptUpdate(&en[i], NULL, &len, aad, aadSz));\n        ExpectIntEQ(1, EVP_EncryptUpdate(&en[i], ciphertxt, &len, plaintxt,\n            plaintxtSz));\n        ciphertxtSz = len;\n        ExpectIntEQ(1, EVP_EncryptFinal_ex(&en[i], ciphertxt, &len));\n        ciphertxtSz += len;\n        ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_GET_TAG,\n            SM4_BLOCK_SIZE, tag));\n        ExpectIntEQ(wolfSSL_EVP_CIPHER_CTX_cleanup(&en[i]), 1);\n\n        EVP_CIPHER_CTX_init(&de[i]);\n        if (i == 0) {\n            \n            ExpectIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_sm4_gcm(), NULL, key,\n                iv));\n        }\n        else {\n            ExpectIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_sm4_gcm(), NULL, NULL,\n                NULL));\n            \n            ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_IVLEN,\n                ivSz, NULL));\n            ExpectIntEQ(1, EVP_DecryptInit_ex(&de[i], NULL, NULL, key, iv));\n\n        }\n        ExpectIntEQ(1, EVP_DecryptUpdate(&de[i], NULL, &len, aad, aadSz));\n        ExpectIntEQ(1, EVP_DecryptUpdate(&de[i], decryptedtxt, &len, ciphertxt,\n            ciphertxtSz));\n        decryptedtxtSz = len;\n        ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_TAG,\n            SM4_BLOCK_SIZE, tag));\n        ExpectIntEQ(1, EVP_DecryptFinal_ex(&de[i], decryptedtxt, &len));\n        decryptedtxtSz += len;\n        ExpectIntEQ(ciphertxtSz, decryptedtxtSz);\n        ExpectIntEQ(0, XMEMCMP(plaintxt, decryptedtxt, decryptedtxtSz));\n\n        \n        tag[SM4_BLOCK_SIZE-1]+=0xBB;\n        ExpectIntEQ(1, EVP_DecryptUpdate(&de[i], NULL, &len, aad, aadSz));\n        ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_TAG,\n            SM4_BLOCK_SIZE, tag));\n        \n        ExpectIntEQ(1, EVP_DecryptUpdate(&de[i], decryptedtxt, &len, ciphertxt,\n            ciphertxtSz));\n        ExpectIntEQ(0, EVP_DecryptFinal_ex(&de[i], decryptedtxt, &len));\n        ExpectIntEQ(0, len);\n        ExpectIntEQ(wolfSSL_EVP_CIPHER_CTX_cleanup(&de[i]), 1);\n    }\n\n    res = EXPECT_RESULT();\n#endif \n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_447",
        "query_text": "The function takes no parameters and returns an integer that indicates the test outcome. It first creates an original stack of certificate names and populates it with three entries. It then duplicates this stack using a duplication function and verifies that the duplicated stack has the same size as the original. Additionally, the function tests edge cases by providing null inputs and attempting to pop elements from both a null stack and an empty stack. Finally, it frees all allocated resources and returns an integer value representing success, failure, or skip status.",
        "code_id": "c_group_1_id_447",
        "code_text": "static int test_wolfSSL_dup_CA_list(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_ALL)\n    EXPECT_DECLS;\n    STACK_OF(X509_NAME) *originalStack = NULL;\n    STACK_OF(X509_NAME) *copyStack = NULL;\n    int originalCount = 0;\n    int copyCount = 0;\n    X509_NAME *name = NULL;\n    int i;\n\n    originalStack = sk_X509_NAME_new_null();\n    ExpectNotNull(originalStack);\n\n    for (i = 0; i < 3; i++) {\n        name = X509_NAME_new();\n        ExpectNotNull(name);\n        ExpectIntEQ(sk_X509_NAME_push(originalStack, name), i+1);\n        if (EXPECT_FAIL()) {\n            X509_NAME_free(name);\n        }\n    }\n\n    copyStack = SSL_dup_CA_list(originalStack);\n    ExpectNotNull(copyStack);\n    ExpectIntEQ(sk_X509_NAME_num(NULL), BAD_FUNC_ARG);\n    originalCount = sk_X509_NAME_num(originalStack);\n    copyCount = sk_X509_NAME_num(copyStack);\n\n    ExpectIntEQ(originalCount, copyCount);\n    sk_X509_NAME_pop_free(originalStack, X509_NAME_free);\n    sk_X509_NAME_pop_free(copyStack, X509_NAME_free);\n\n    originalStack = NULL;\n    copyStack = NULL;\n\n    originalStack = sk_X509_NAME_new_null();\n    ExpectNull(sk_X509_NAME_pop(NULL));\n    ExpectNull(sk_X509_NAME_pop(originalStack));\n    for (i = 0; i < 3; i++) {\n        name = X509_NAME_new();\n        ExpectNotNull(name);\n        ExpectIntEQ(sk_X509_NAME_push(originalStack, name), i+1);\n        if (EXPECT_FAIL()) {\n            X509_NAME_free(name);\n        }\n        name = NULL;\n    }\n    ExpectNotNull(name = sk_X509_NAME_pop(originalStack));\n    X509_NAME_free(name);\n    wolfSSL_sk_X509_NAME_set_cmp_func(NULL, NULL);\n    wolfSSL_sk_X509_NAME_set_cmp_func(originalStack, NULL);\n    wolfSSL_sk_X509_NAME_pop_free(originalStack, X509_NAME_free);\n\n    res = EXPECT_RESULT();\n#endif \n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_448",
        "query_text": "The function checks if it should run based on a compile-time condition. When the condition is met, it first performs a cleanup by freeing all configuration modules. It then executes three unload operations with different parameter values (0, 1, and -1) to ensure that the modules are fully released. If the compile-time condition is defined and all operations succeed, the function returns a success status; otherwise, it returns a skipped status. The function does not take any inputs and returns an integer indicating the test outcome.",
        "code_id": "c_group_1_id_448",
        "code_text": "static int test_CONF_modules_xxx(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n    CONF_modules_free();\n\n    CONF_modules_unload(0);\n    CONF_modules_unload(1);\n    CONF_modules_unload(-1);\n\n    res = TEST_SUCCESS;\n#endif \n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_449",
        "query_text": "The function tests the mechanism for setting dynamic lock callbacks in a cryptographic context. It only performs its actions when a particular macro is defined. Under that condition, the function assigns three types of dynamic lock callbacks\u2014creation, destruction, and locking\u2014by invoking their respective setter functions twice each: once with a null pointer and once with a non-zero integer cast as a function pointer. If the macro is not defined, the function skips its operations and returns a code indicating that the test was not executed. Otherwise, it returns a code representing success. The function takes no input parameters and returns an integer that indicates the outcome of the test.",
        "code_id": "c_group_1_id_449",
        "code_text": "static int test_CRYPTO_set_dynlock_xxx(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n    CRYPTO_set_dynlock_create_callback(\n        (struct CRYPTO_dynlock_value *(*)(const char*, int))NULL);\n\n    CRYPTO_set_dynlock_create_callback(\n        (struct CRYPTO_dynlock_value *(*)(const char*, int))1);\n\n    CRYPTO_set_dynlock_destroy_callback(\n        (void (*)(struct CRYPTO_dynlock_value*, const char*, int))NULL);\n\n    CRYPTO_set_dynlock_destroy_callback(\n        (void (*)(struct CRYPTO_dynlock_value*, const char*, int))1);\n\n    CRYPTO_set_dynlock_lock_callback(\n        (void (*)(int, struct CRYPTO_dynlock_value *, const char*, int))NULL);\n\n    CRYPTO_set_dynlock_lock_callback(\n        (void (*)(int, struct CRYPTO_dynlock_value *, const char*, int))1);\n\n    res = TEST_SUCCESS;\n#endif \n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_450",
        "query_text": "The function performs a conditional cleanup operation related to an external module, but only when a specific compile-time macro is defined. It accepts no input parameters and returns an integer status code. Initially, the function sets the status to indicate a skipped operation. If the macro is defined, it invokes a cleanup routine from the module and updates the status to indicate a successful operation. Finally, the function returns the appropriate status, reflecting whether the cleanup was executed.",
        "code_id": "c_group_1_id_450",
        "code_text": "static int test_ENGINE_cleanup(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n    ENGINE_cleanup();\n\n    res = TEST_SUCCESS;\n#endif \n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_451",
        "query_text": "The function does not accept any parameters and returns an integer value. Its sole operation is to return a predefined constant that signifies that the associated test has been intentionally skipped. The function does not execute any further steps or computations.",
        "code_id": "c_group_1_id_451",
        "code_text": "static int test_wolfSSL_dtls_plaintext(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_452",
        "query_text": "The function takes no inputs and returns an integer. It is designed to simply return a predefined constant integer value that indicates a test has been skipped. The function's behavior does not depend on any parameters and does not perform additional operations beyond returning the constant value. The return type is int.",
        "code_id": "c_group_1_id_452",
        "code_text": "static int test_wolfSSL_dtls_fragments(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_453",
        "query_text": "This function takes no input arguments and returns an integer indicating a test status. Specifically, it always returns a predefined constant that signifies the associated test has been skipped. The function does not perform any further processing or calculations, and its return type is an integer.",
        "code_id": "c_group_1_id_453",
        "code_text": "static int test_wolfSSL_ignore_alert_before_cookie(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_454",
        "query_text": "The function takes no input arguments and returns an integer. It simply returns a constant value that signifies that the associated test is intentionally skipped. The function does not perform any additional operations or computations.",
        "code_id": "c_group_1_id_454",
        "code_text": "static int test_wolfSSL_dtls_bad_record(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_455",
        "query_text": "The function takes no input arguments and returns an output of type int. It simply produces a predefined constant value that signifies a skipped test and does not perform any other computations.",
        "code_id": "c_group_1_id_455",
        "code_text": "static int test_wolfSSL_dtls_AEAD_limit(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_456",
        "query_text": "The function accepts no input parameters and returns an integer value. It indicates that a specific DTLS (Datagram Transport Layer Security) test within a particular security library is skipped by directly returning a predefined constant that signifies the test is not executed. The function does not perform any internal computations or processing; it simply provides the test's skipped status via its integer return value.",
        "code_id": "c_group_1_id_456",
        "code_text": "static int test_wolfSSL_dtls_stateless(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_457",
        "query_text": "This function returns a fixed integer constant indicating that a particular test has been intentionally skipped. It takes no input arguments and performs no additional processing or computations. The returned value is of type int, serving solely as a marker to bypass the execution of the test scenario.",
        "code_id": "c_group_1_id_457",
        "code_text": "static int test_wolfSSL_SESSION_get_ex_new_index(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_458",
        "query_text": "The function performs a test of a hash algorithm's implementation. It initializes a hashing context, then iteratively updates this context with fixed-size byte array data using varying sizes\u2014including edge cases such as null inputs and zero-length data\u2014and finalizes the hash computation. Throughout the process, it validates error handling and ensures the computed hash matches an expected fixed-size hash value. Additionally, it checks the proper cleanup and deallocation of resources. The procedure returns an integer result that indicates whether the tests passed, failed, or were skipped.",
        "code_id": "c_group_1_id_458",
        "code_text": "static int test_wolfSSL_EVP_sm3(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_SM3)\n    EXPECT_DECLS;\n    const EVP_MD* md = NULL;\n    EVP_MD_CTX* mdCtx = NULL;\n    byte data[WC_SM3_BLOCK_SIZE * 4];\n    byte hash[WC_SM3_DIGEST_SIZE];\n    byte calcHash[WC_SM3_DIGEST_SIZE];\n    byte expHash[WC_SM3_DIGEST_SIZE] = {\n        0x38, 0x48, 0x15, 0xa7, 0x0e, 0xae, 0x0b, 0x27,\n        0x5c, 0xde, 0x9d, 0xa5, 0xd1, 0xa4, 0x30, 0xa1,\n        0xca, 0xd4, 0x54, 0x58, 0x44, 0xa2, 0x96, 0x1b,\n        0xd7, 0x14, 0x80, 0x3f, 0x80, 0x1a, 0x07, 0xb6\n    };\n    word32 chunk;\n    word32 i;\n    unsigned int sz;\n    int ret;\n\n    XMEMSET(data, 0, sizeof(data));\n\n    md = EVP_sm3();\n    ExpectTrue(md != NULL);\n    ExpectIntEQ(XSTRNCMP(md, \"SM3\", XSTRLEN(\"SM3\")), 0);\n    mdCtx = EVP_MD_CTX_new();\n    ExpectTrue(mdCtx != NULL);\n\n    \n    ExpectIntEQ(EVP_DigestInit(NULL, md), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    \n    ExpectIntEQ(EVP_DigestInit(mdCtx, md), WOLFSSL_SUCCESS);\n\n    ExpectIntEQ(EVP_DigestUpdate(NULL, NULL, 1), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, NULL, 1), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestUpdate(NULL, data, 1), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n\n    \n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, NULL, 0), WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, 1), WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, 1), WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, WC_SM3_BLOCK_SIZE),\n        WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, WC_SM3_BLOCK_SIZE - 2),\n        WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, WC_SM3_BLOCK_SIZE * 2),\n        WOLFSSL_SUCCESS);\n    \n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, WC_SM3_PAD_SIZE),\n        WOLFSSL_SUCCESS);\n\n    \n    ExpectIntEQ(EVP_DigestFinal(NULL, NULL, NULL), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestFinal(mdCtx, NULL, NULL), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestFinal(NULL, hash, NULL), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestFinal(NULL, hash, NULL), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestFinal(mdCtx, NULL, NULL), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n\n    \n    ExpectIntEQ(EVP_DigestFinal(mdCtx, hash, NULL), WOLFSSL_SUCCESS);\n    ExpectBufEQ(hash, expHash, WC_SM3_DIGEST_SIZE);\n\n    \n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, sizeof(data)), WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestFinal(mdCtx, calcHash, &sz), WOLFSSL_SUCCESS);\n    ExpectIntEQ(sz, WC_SM3_DIGEST_SIZE);\n    for (chunk = 1; chunk <= WC_SM3_BLOCK_SIZE + 1; chunk++) {\n        for (i = 0; i + chunk <= (word32)sizeof(data); i += chunk) {\n            ExpectIntEQ(EVP_DigestUpdate(mdCtx, data + i, chunk),\n                WOLFSSL_SUCCESS);\n        }\n        if (i < (word32)sizeof(data)) {\n            ExpectIntEQ(EVP_DigestUpdate(mdCtx, data + i,\n                (word32)sizeof(data) - i), WOLFSSL_SUCCESS);\n        }\n        ExpectIntEQ(EVP_DigestFinal(mdCtx, hash, NULL), WOLFSSL_SUCCESS);\n        ExpectBufEQ(hash, calcHash, WC_SM3_DIGEST_SIZE);\n    }\n\n    \n\n    ret = EVP_MD_CTX_cleanup(mdCtx);\n    ExpectIntEQ(ret, WOLFSSL_SUCCESS);\n    wolfSSL_EVP_MD_CTX_free(mdCtx);\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_459",
        "query_text": "The function takes no input arguments and returns an integer that indicates the outcome of a test. It is intended to verify the mechanism for iterating over all available message digest algorithms from a cryptographic library, but only if a specific conditional compilation macro is defined. In that case, it first invokes a utility to display all message digest algorithms by passing a null callback and a standard error stream as parameters. Next, it repeats the invocation using a particular callback function to list the algorithms. If both iterations succeed, the function produces a success status. If the macro is not defined, it returns a status indicating that the test was skipped.",
        "code_id": "c_group_1_id_459",
        "code_text": "static int test_EVP_MD_do_all(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n    EVP_MD_do_all(NULL, stderr);\n\n    EVP_MD_do_all(list_md_fn, stderr);\n\n    res = TEST_SUCCESS;\n#endif\n\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_460",
        "query_text": "The function, which takes no parameters, is conditionally compiled to execute only when a specific macro is defined. Initially, it sets a status variable to indicate that the test has been skipped. Within the conditional block, the function invokes an internal operation several times with various combinations of parameters. These invocations include passing predefined constant types, a callback function pointer, a file stream, and sometimes a NULL value to represent an absent callback or stream. If all the intended calls execute properly, the function updates the status to indicate success. Ultimately, the function returns an integer status value reflecting whether the test was skipped or successfully completed, serving as a black-box test for verifying the behavior of the underlying operation across different scenarios.",
        "code_id": "c_group_1_id_460",
        "code_text": "static int test_OBJ_NAME_do_all(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_MD_METH, NULL, NULL);\n\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_CIPHER_METH, NULL, stderr);\n\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_MD_METH, obj_name_t, stderr);\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_PKEY_METH, obj_name_t, stderr);\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_COMP_METH, obj_name_t, stderr);\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_NUM, obj_name_t, stderr);\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_UNDEF, obj_name_t, stderr);\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_CIPHER_METH, obj_name_t, stderr);\n    OBJ_NAME_do_all(-1, obj_name_t, stderr);\n\n    res = TEST_SUCCESS;\n#endif\n\n    return res;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_461",
        "query_text": "The function takes no input arguments and returns an integer value. It performs a single operation: returning a predefined constant that signifies a test was skipped. No additional computations or operations are performed.",
        "code_id": "c_group_1_id_461",
        "code_text": "static int test_WOLFSSL_dtls_version_alert(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_462",
        "query_text": "The function takes no input arguments and returns an integer value. It is a static function that simply returns a predefined constant, which indicates that a particular test or operation has been skipped. No further computations or operations are performed beyond returning this constant value.",
        "code_id": "c_group_1_id_462",
        "code_text": "static int test_ticket_ret_create(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_463",
        "query_text": "The function takes no input arguments and returns an integer value. It unconditionally returns a predefined constant indicating that the associated test is skipped, without performing any additional computations or operations.",
        "code_id": "c_group_1_id_463",
        "code_text": "static int test_ticket_and_psk_mixing(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_464",
        "query_text": "The function does not accept any input arguments and returns an integer value. Its only operation is to return a predefined constant that signifies a particular test was skipped. The output is specifically of type int, and the function performs no other computations.",
        "code_id": "c_group_1_id_464",
        "code_text": "static int test_prioritize_psk(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_465",
        "query_text": "This function takes no input arguments and returns an integer value. Its only operation is to immediately return a predefined constant that indicates a specific test is skipped. There is no further computation, processing, or side effects; the function simply serves to signal that the particular test is not executed.",
        "code_id": "c_group_1_id_465",
        "code_text": "static int test_wolfSSL_CTX_set_ciphersuites(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_466",
        "query_text": "The function accepts no input parameters and returns an integer. Its sole operation is to immediately return a predefined constant that signifies the associated test has been skipped. No additional computations are performed, and the output solely indicates that the test is inactive.",
        "code_id": "c_group_1_id_466",
        "code_text": "static int test_wolfSSL_CRL_CERT_REVOKED_alert(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_467",
        "query_text": "The function takes no input arguments and returns an integer value. It simply indicates that a certain test is skipped by returning a predefined constant. The function does not perform any processing or computation; its sole purpose is to signal that the test case is not run by returning an integer constant that represents the skipped status.",
        "code_id": "c_group_1_id_467",
        "code_text": "static int test_TLS_13_ticket_different_ciphers(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_468",
        "query_text": "The function takes no input arguments and returns an integer value. It performs no computations aside from returning a predefined constant that denotes a skipped test or operation.",
        "code_id": "c_group_1_id_468",
        "code_text": "static int test_extra_alerts_wrong_cs(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_469",
        "query_text": "The function takes no input parameters and returns an integer value. Its sole purpose is to immediately return a predefined constant that indicates a test or operation has been skipped. No additional computations or operations are performed.",
        "code_id": "c_group_1_id_469",
        "code_text": "static int test_extra_alerts_skip_hs(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_470",
        "query_text": "This function accepts no input arguments and directly returns a predefined constant (of type int) that signifies a particular test case or operation was skipped. The output is an int representing this status.",
        "code_id": "c_group_1_id_470",
        "code_text": "static int test_extra_alerts_bad_psk(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_471",
        "query_text": "The function takes no input arguments and returns a value of type int. It is implemented as a static function whose primary purpose is to indicate that a specific test case has been skipped. Instead of performing any computation or operations, the function directly returns a predetermined constant value that signifies the test was not executed.",
        "code_id": "c_group_1_id_471",
        "code_text": "static int test_multiple_alerts_EAGAIN(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_472",
        "query_text": "The function takes no input arguments and returns an integer value. It serves to indicate that an associated test case is intentionally bypassed. Upon invocation, it simply returns a constant value designated to represent \"skipped,\" without performing any additional operations or computations.",
        "code_id": "c_group_1_id_472",
        "code_text": "static int test_harden_no_secure_renegotiation(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_473",
        "query_text": "This function does not take any input arguments and returns an integer value. Its only operation is to provide a constant result that signifies that a specific test or operation has been skipped. No additional computations or modifications are performed.",
        "code_id": "c_group_1_id_473",
        "code_text": "static int test_override_alt_cert_chain(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_474",
        "query_text": "The function takes no input arguments and returns an integer output. Its sole operation is to immediately return a predefined constant that signifies a certain test case is skipped. No additional computations or operations are performed.",
        "code_id": "c_group_1_id_474",
        "code_text": "static int test_dtls13_bad_epoch_ch(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_475",
        "query_text": "The function takes no input arguments and returns an integer value. It simply returns a predefined constant indicating that a test\u2014specifically one related to a DTLS 1.3 configuration using a null cipher\u2014is skipped. No computation or additional processing is performed within the function.",
        "code_id": "c_group_1_id_475",
        "code_text": "static int test_wolfSSL_dtls13_null_cipher(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_476",
        "query_text": "The function takes no inputs and returns an integer value. When invoked, it provides a predefined constant that indicates a specific test case is skipped. Essentially, the function serves as a placeholder to mark that the associated test is intentionally bypassed.",
        "code_id": "c_group_1_id_476",
        "code_text": "static int test_dtls_msg_from_other_peer(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_477",
        "query_text": "The function takes no input parameters and returns an integer value. It indicates that a specific DTLS over IPv6 test is skipped by immediately returning a predefined constant that represents a skipped state. The output is an integer signaling that the test is not executed.",
        "code_id": "c_group_1_id_477",
        "code_text": "static int test_dtls_ipv6_check(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_478",
        "query_text": "The function takes no input arguments and returns an integer value. The returned integer represents a predefined constant that indicates a test case is intentionally skipped. Its primary purpose is to serve as a placeholder or marker for a test that is not executed during the testing process.",
        "code_id": "c_group_1_id_478",
        "code_text": "static int test_wolfSSL_SCR_after_resumption(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_479",
        "query_text": "The function takes no inputs and immediately returns an integer value that corresponds to a predefined constant indicating that a specific test has been skipped. It performs no further operations or computations.",
        "code_id": "c_group_1_id_479",
        "code_text": "static int test_ocsp_callback_fails(void)\n{\n    return TEST_SKIPPED;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_480",
        "query_text": "The function takes no input parameters and returns no value. It is designated as a static, void-returning function primarily intended to perform setup operations for initializing or configuring a test environment or related resources. However, the current implementation is empty, serving merely as a placeholder for potential future setup functionality.",
        "code_id": "c_group_1_id_480",
        "code_text": "static void TestSetup(void)\n{\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_481",
        "query_text": "The function is a static void function that takes no input parameters and returns no value. It conditionally clears accumulated error information within a library by invoking an internal error-clearing routine, but only when specific compilation flags are set. If either of these flags is defined during compilation, the error information is cleared; otherwise, the function performs no operations.",
        "code_id": "c_group_1_id_481",
        "code_text": "static void TestCleanup(void)\n{\n#if defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE)\n    \n    wolfSSL_ERR_clear_error();\n#endif \n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_482",
        "query_text": "The function processes a string to extract an integer version number based on a specific pattern. It begins by searching for a designated substring within the input. Once the substring is found, the pointer is advanced past the pattern, and, if the subsequent character meets certain conditions, it is moved further by a fixed offset. The function then converts the remaining portion of the string to an integer. If the substring is not found, the function returns a predefined error indicator. The input is a string and the output is an integer.",
        "code_id": "c_group_1_id_482",
        "code_text": "static int GetTlsVersion(const char* line)\n{\n    int version = -1;\n    const char* find = \"-v \";\n    const char* begin = strstr(line, find);\n\n    if (begin) {\n        begin += 3;\n        if (*begin == 'd' || *begin == 'e')\n            begin += 2;\n\n        version = atoi(begin);\n    }\n    return version;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_483",
        "query_text": "The function accepts a pointer to a time value and returns a time value. If the pointer is not NULL, it sets the time value at the pointed memory location to 99. Regardless of whether the pointer is NULL or not, the function always returns 99.",
        "code_id": "c_group_1_id_483",
        "code_text": "static time_t time_cb(time_t* t)\n{\n    if (t != NULL) {\n        *t = 99;\n    }\n\n    return 99;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_484",
        "query_text": "The function takes six parameters: a pointer to an integer, a pointer to a void type, an integer, a pointer to an integer, another integer, and a second pointer to an integer. It explicitly casts all these inputs to void to indicate they are unused. Independently of the provided arguments, the function always returns the integer value 1. The output is of type int.",
        "code_id": "c_group_1_id_484",
        "code_text": "static WC_INLINE int bench_async_check(int* ret, void* asyncDev,\n        int callAgain, int* times, int limit, int* pending)\n    {\n        (void)ret;\n        (void)asyncDev;\n        (void)callAgain;\n        (void)times;\n        (void)limit;\n        (void)pending;\n\n        return 1;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_485",
        "query_text": "The function accepts five inputs: a pointer to an integer, a pointer to a void type, an integer, and two additional pointers to integers. It disregards the second, third, and fifth inputs by casting them to void. The function evaluates whether the value referenced by the first pointer is non-negative. If so, it increments the value referenced by the fourth pointer and returns 1; if not, it returns 0. The output is of type int, reflecting the result of this check.",
        "code_id": "c_group_1_id_485",
        "code_text": "static WC_INLINE int bench_async_handle(int* ret, void* asyncDev,\n        int callAgain, int* times, int* pending)\n    {\n        (void)asyncDev;\n        (void)callAgain;\n        (void)pending;\n\n        if (*ret >= 0) {\n            \n            (*times)++;\n            return 1;\n        }\n        return 0;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_486",
        "query_text": "The function receives a size_t value as its input and outputs a pointer to a constant character string. It treats the input as an index into a pre-constructed string containing every two-digit combination from \"00\" to \"99\". By multiplying the input by 2, it determines the correct starting position of the desired pair of digits within the string. Finally, the function returns a pointer to that specific two-character substring.",
        "code_id": "c_group_1_id_486",
        "code_text": "constexpr auto digits2(size_t value) -> const char* {\n  \n  return &\"0001020304050607080910111213141516171819\"\n         \"2021222324252627282930313233343536373839\"\n         \"4041424344454647484950515253545556575859\"\n         \"6061626364656667686970717273747576777879\"\n         \"8081828384858687888990919293949596979899\"[value * 2];\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_487",
        "query_text": "The function takes a structure representing time (with an hour component) as input and determines whether the time is in the \"AM\" or \"PM\" period. It evaluates the hour field: if it is 12 or greater, the function returns the constant string \"PM\"; otherwise, it returns \"AM\". The input is a time structure, and the output is a pointer to a constant character string.",
        "code_id": "c_group_1_id_487",
        "code_text": "static const char *ampm(const tm &t) { return t.tm_hour >= 12 ? \"PM\" : \"AM\"; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_488",
        "query_text": "The function converts a 24-hour format time into a 12-hour format based solely on the hour field from a time structure. Initially, it examines the hour value stored within the structure. If the hour is greater than 12, the function subtracts 12 to effectively convert the value from 24-hour to 12-hour notation; otherwise, it leaves the hour unchanged. The function then returns this final hour as an integer.",
        "code_id": "c_group_1_id_488",
        "code_text": "static int to12h(const tm &t) { return t.tm_hour > 12 ? t.tm_hour - 12 : t.tm_hour; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_489",
        "query_text": "The function takes a boolean value as input and returns that same value without any modifications. The input and output are of type bool.",
        "code_id": "c_group_1_id_489",
        "code_text": "inline bool isTrue( bool value ){ return value; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_490",
        "query_text": "This function accepts a single parameter of type std::nullptr_t and returns a value of the same type. Its operation is straightforward: regardless of the input, it always returns a constant null pointer value (nullptr). Essentially, the function serves as a no-operation wrapper for null pointer values, ensuring that the null pointer is passed through unchanged.",
        "code_id": "c_group_1_id_490",
        "code_text": "inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_491",
        "query_text": "The function takes a single character as input and outputs its string representation. It first checks if the character is one of the special control characters (specifically carriage return, form feed, newline, or tab) and, if so, returns a string containing the corresponding escape sequence. If the character is another non-printable control character (with an ASCII value between 0 and 31, excluding the aforementioned cases), the function converts it to an unsigned integer and recursively processes it to obtain its string representation. For all other printable characters, it returns a string that encloses the character within single quotes.",
        "code_id": "c_group_1_id_491",
        "code_text": "std::string toString( char value ) {\n    if ( value == '\\r' )\n        return \"'\\\\r'\";\n    if ( value == '\\f' )\n        return \"'\\\\f'\";\n    if ( value == '\\n' )\n        return \"'\\\\n'\";\n    if ( value == '\\t' )\n        return \"'\\\\t'\";\n    if ( '\\0' <= value && value < ' ' )\n        return toString( static_cast<unsigned int>( value ) );\n    char chstr[] = \"' '\";\n    chstr[1] = value;\n    return chstr;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_492",
        "query_text": "The function accepts a single input of type std::nullptr_t, representing a null pointer literal. It returns a std::string that contains the text \"nullptr\", effectively converting the null pointer literal into its string representation. The input type is std::nullptr_t, while the output type is std::string.",
        "code_id": "c_group_1_id_492",
        "code_text": "std::string toString( std::nullptr_t ) {\n    return \"nullptr\";\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_493",
        "query_text": "The function accepts two strings as inputs: one provided as a constant reference, representing the source string, and the other as a modifiable reference, representing the destination string. It copies the entire content of the source string into the destination string. The function does not return a value; its purpose is solely to replicate the source content into the destination.",
        "code_id": "c_group_1_id_493",
        "code_text": "inline void convertInto( std::string const& _source, std::string& _dest ) {\n            _dest = _source;\n        }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_494",
        "query_text": "The function accepts no input parameters and returns no value. It is designed to initialize or configure global settings, but its current implementation is empty and does not perform any operations.",
        "code_id": "c_group_1_id_494",
        "code_text": "void cc_global_init()\n{\n\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_495",
        "query_text": "The function accepts three parameters: a pointer to a character array allocated dynamically, and two pointers to constant characters representing other strings. It first checks whether the dynamically allocated string is not the same as either of the constant strings. If this condition is met, it frees the memory associated with the dynamically allocated string. The function does not return a value (void) and is designed solely to conditionally release memory based on the relationship between the inputs.",
        "code_id": "c_group_1_id_495",
        "code_text": "static void\nmunit_maybe_free_concat(char* s, const char* prefix, const char* suffix) {\n  if (prefix != s && suffix != s)\n    free(s);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_496",
        "query_text": "The function accepts three pointers: two that may reference integer values (or be null) and one that designates the destination for storing an integer result. It first verifies whether each of the first two pointers is non-null, in which case it retrieves the integer value pointed to; if a pointer is null, it substitutes a value of 0. It then adds the two integer values and stores the sum in the memory location indicated by the third pointer. The function does not return any value, with the computed sum being stored directly via the result pointer.",
        "code_id": "c_group_1_id_496",
        "code_text": "void reduce_add(void* e1, void* e2, void* result)\n{\n    int el1 = e1 ? *((int*)e1) : 0;\n    int el2 = e2 ? *((int*)e2) : 0;\n    *((int*)result) = el1 + el2;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_497",
        "query_text": "The function takes a pointer to an integer as input. It retrieves the integer value stored at the referenced memory location, multiplies it by 2, and updates that same location with the computed result. The function does not return any value, as it performs the operation in-place. The input is a pointer to an integer, and there is no explicit output value.",
        "code_id": "c_group_1_id_497",
        "code_text": "void map_double(void* e)\n{\n    int* val = (int*)e;\n    *val = *val * 2;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_498",
        "query_text": "This function accepts three pointer arguments referring to memory locations. The first two pointers supply integer values, which are retrieved by dereferencing. The function then computes the sum of these integers and writes the result into the memory location indicated by the third pointer. No value is returned by the function, as the computed sum is stored directly via the provided output pointer.",
        "code_id": "c_group_1_id_498",
        "code_text": "void sum_reduce(void* e1, void* e2, void* res)\n{\n    int i = *(int*)e1;\n    int j = *(int*)e2;\n\n    *(int*)res = i + j;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_499",
        "query_text": "The function accepts two constant void pointers as inputs and treats them as pointers to character arrays. It compares these arrays byte by byte over a fixed length of 28 bytes (equivalent to 7 times the size of an int). During this process, if any byte differs between the two arrays, the function returns 1, indicating inequality. If all 28 bytes match exactly, it returns 0, signifying that the memory regions are identical. The function operates solely by checking the specified range without modifying any input data and returns an integer result that reflects the outcome of the comparison.",
        "code_id": "c_group_1_id_499",
        "code_text": "static int cmp_k(const void* k1, const void* k2)\n{\n    char* key1 = (char*)k1;\n    char* key2 = (char*)k2;\n    int i;\n    for (i = 0; i < (sizeof(int) * 7); i++) {\n        if (*key1 != *key2)\n            return 1;\n        key1++;\n        key2++;\n    }\n    return 0;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_500",
        "query_text": "The function accepts two inputs: a pointer to an array of unsigned 8-bit integers and a size indicator that specifies the number of elements in the array. It sequentially examines each element in the array, checking whether the value of the current byte exceeds 127. If it finds a byte with a value greater than 127, the function immediately returns the index of that byte. If no byte exceeding 127 is encountered after traversing the entire array, the function returns the total size of the array. The output is of type size_t, which represents either the index of the first byte exceeding 127 or the array's length if all bytes are within the limit.",
        "code_id": "c_group_1_id_500",
        "code_text": "size_t get_latin1_7bit_prefix_length(const uint8_t* data, size_t size)\n\t{\n\t\tfor (size_t i = 0; i < size; ++i)\n\t\t\tif (data[i] > 127)\n\t\t\t\treturn i;\n\n\t\treturn size;\n\t}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_501",
        "query_text": "The function accepts no input arguments. It returns an integer value of 0, using this value to indicate a successful or default initialization state. The function does not perform any additional computations or operations.",
        "code_id": "c_group_1_id_501",
        "code_text": "int enet_initialize(void) {\n        return 0;\n    }",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_502",
        "query_text": "The function takes no input parameters and returns no value. It is a no-operation (no-op) function that does not perform any actions or modifications when invoked.",
        "code_id": "c_group_1_id_502",
        "code_text": "void enet_deinitialize(void) {}\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_503",
        "query_text": "The function takes a constant string reference as its input and copies its content to another string reference provided as the output. It effectively performs a direct assignment, duplicating the input string without modification. The input is a constant string (std::string) and the output is also a string (std::string).",
        "code_id": "c_group_1_id_503",
        "code_text": "inline\nvoid\nparse_value(const std::string& text, std::string& value)\n{\n  value = text;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_504",
        "query_text": "The function takes one input of type const char pointer. It performs no operations or computations on the input and does not produce any output or return any value. The parameter is explicitly marked as unused, indicating that the function serves as a no-op (no operation) placeholder across translation units.",
        "code_id": "c_group_1_id_504",
        "code_text": "extern void onig_null_warn(const char* s ARG_UNUSED) { }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_505",
        "query_text": "The function accepts an integer as input and returns an integer as output. It operates by comparing the input value against a predefined set of constants. If the input matches any one of these constants, the function returns 0; if no match is found, it returns 1.",
        "code_id": "c_group_1_id_505",
        "code_text": "static int\nis_left(int a)\n{\n  if (a == ANCR_END_BUF  || a == ANCR_SEMI_END_BUF ||\n      a == ANCR_END_LINE || a == ANCR_PREC_READ || a == ANCR_PREC_READ_NOT)\n    return 0;\n\n  return 1;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_506",
        "query_text": "The function takes a single integer input that represents a file descriptor. It then determines whether this descriptor is associated with a terminal device by calling a standard library function. The function immediately returns a result that is non-zero if the descriptor refers to a terminal, or zero if it does not.",
        "code_id": "c_group_1_id_506",
        "code_text": "inline int DoIsATTY(int fd);\ninline int DoIsATTY(int fd) { return isatty(fd); }\n",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_507",
        "query_text": "The function takes a 32-bit unsigned integer as input and computes the number of consecutive zero bits starting from the least significant bit in its binary representation. It utilizes platform-specific optimizations (such as compiler intrinsics or assembly instructions) when available for maximum efficiency, and otherwise resorts to a bitwise shifting and checking method. The computed count, returned as a 32-bit unsigned integer, represents the trailing zero bits in the input value, with the behavior being undefined if the input is zero.",
        "code_id": "c_group_1_id_507",
        "code_text": "static inline uint32_t ctz32(uint32_t n);\nstatic inline uint32_t ctz32(uint32_t n) {\n#if defined(__GNUC__) && UINT_MAX >= UINT32_MAX\n  return static_cast<uint32_t>(__builtin_ctz(n));\n\n#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))\n  uint32_t i;\n  __asm__(\"bsfl %1, %0\" : \"=r\"(i) : \"rm\"(n));\n  return i;\n\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\n  uint32_t i;\n  _BitScanForward((unsigned long *)&i, n);\n  return i;\n\n#else\n  uint32_t i = 1;\n\n  if ((n & static_cast<uint32_t>(0x0000FFFF)) == 0) {\n    n >>= 16;\n    i += 16;\n  }\n\n  if ((n & static_cast<uint32_t>(0x000000FF)) == 0) {\n    n >>= 8;\n    i += 8;\n  }\n\n  if ((n & static_cast<uint32_t>(0x0000000F)) == 0) {\n    n >>= 4;\n    i += 4;\n  }\n\n  if ((n & static_cast<uint32_t>(0x00000003)) == 0) {\n    n >>= 2;\n    i += 2;\n  }\n\n  i -= (n & 1);\n\n  return i;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_508",
        "query_text": "The function takes a 16-bit unsigned integer as input and counts the number of trailing zeros in its binary representation. It returns a 32-bit unsigned integer that represents the count of the least significant bits set to zero. The implementation utilizes platform-specific optimizations\u2014such as compiler intrinsics or inline assembly instructions\u2014when available for improved performance and falls back to a bitwise shift-and-check approach otherwise.",
        "code_id": "c_group_1_id_508",
        "code_text": "static inline uint32_t ctz16(uint16_t n);\nstatic inline uint32_t ctz16(uint16_t n) {\n#if defined(__GNUC__) && UINT_MAX >= UINT32_MAX\n  return static_cast<uint32_t>(__builtin_ctz(n));\n\n#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))\n  uint32_t i;\n  __asm__(\"bsfl %1, %0\" : \"=r\"(i) : \"rm\"(n));\n  return i;\n\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\n  uint32_t i;\n  _BitScanForward((unsigned long *)&i, n);\n  return i;\n\n#else\n  uint32_t i = 1;\n\n  if ((n & static_cast<uint16_t>(0x000000FF)) == 0) {\n    n >>= 8;\n    i += 8;\n  }\n\n  if ((n & static_cast<uint16_t>(0x0000000F)) == 0) {\n    n >>= 4;\n    i += 4;\n  }\n\n  if ((n & static_cast<uint16_t>(0x00000003)) == 0) {\n    n >>= 2;\n    i += 2;\n  }\n  i -= (n & 1);\n\n  return i;\n#endif\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_509",
        "query_text": "The function accepts a floating-point value as its input and returns a floating-point number as output. It calculates the output by squaring the input value, thereby implementing a quadratic ease-in effect. This produces a smooth, accelerating progression beginning from zero, with the intensity increasing quadratically as the input value grows.",
        "code_id": "c_group_1_id_509",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_quad_in(float t);\nCGLM_INLINE\nfloat\nglm_ease_quad_in(float t) {\n  return t * t;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_510",
        "query_text": "This function accepts a floating-point input that is expected to be within a normalized range (e.g., [0, 1]). It returns a floating-point result obtained by applying a quadratic easing-out transformation\u2014a process where the change is initially rapid and then gradually decelerates as the value approaches its maximum. The operation is purely mathematical and independent of any external state or supplementary parameters.",
        "code_id": "c_group_1_id_510",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_quad_out(float t);\nCGLM_INLINE\nfloat\nglm_ease_quad_out(float t) {\n  return -(t * (t - 2.0f));\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_511",
        "query_text": "This function takes a floating-point input that is expected to be between 0 and 1 and computes a quadratic easing effect with distinct accelerating and decelerating phases. For values less than 0.5, it applies an accelerating quadratic transformation; for values 0.5 or greater, it applies a decelerating quadratic transformation. The design guarantees a smooth, continuous transition at the midpoint, and the function returns a floating-point result that remains within the 0 to 1 range.",
        "code_id": "c_group_1_id_511",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_quad_inout(float t);\nCGLM_INLINE\nfloat\nglm_ease_quad_inout(float t) {\n  float tt;\n\n  tt = t * t;\n  if (t < 0.5f)\n    return 2.0f * tt;\n\n  return (-2.0f * tt) + (4.0f * t) - 1.0f;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_512",
        "query_text": "The function takes a floating-point input and returns the cubic easing result for that value. It calculates a smooth acceleration effect by computing the cube of the input. The output is of type float, and the function operates purely in a mathematical context without relying on any external state.",
        "code_id": "c_group_1_id_512",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_cubic_in(float t);\nCGLM_INLINE\nfloat\nglm_ease_cubic_in(float t) {\n  return t * t * t;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_513",
        "query_text": "The function takes a floating-point number as input and computes a result based on a cubic easing operation. It first shifts the input by subtracting 1.0, then raises the resulting value to the power of three, and finally adds 1.0 to obtain the output. Designed to provide a smooth deceleration effect for animations or transitions, the function expects an input typically in the range of 0 to 1 and returns a value that usually remains within this range, although a slight overshoot is possible due to the cubic calculation.",
        "code_id": "c_group_1_id_513",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_cubic_out(float t);\nCGLM_INLINE\nfloat\nglm_ease_cubic_out(float t) {\n  float f;\n  f = t - 1.0f;\n  return f * f * f + 1.0f;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_514",
        "query_text": "The function takes a floating-point input (ranging from 0.0 to 1.0) that represents the progress of a transition. It employs a cubic easing algorithm to compute a smooth in-out motion. Specifically, it accelerates the transition for progress values below 0.5 and decelerates for values of 0.5 or greater, ensuring a gradual start and finish. The computed value is also a floating-point number normalized within the range 0.0 to 1.0.",
        "code_id": "c_group_1_id_514",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_cubic_inout(float t);\nCGLM_INLINE\nfloat\nglm_ease_cubic_inout(float t) {\n  float f;\n\n  if (t < 0.5f)\n    return 4.0f * t * t * t;\n\n  f = 2.0f * t - 2.0f;\n\n  return 0.5f * f * f * f + 1.0f;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_515",
        "query_text": "The function accepts a single floating-point value as input and applies a quart-in easing operation by computing its fourth power. It begins by squaring the input value to produce an intermediate result, and then squares that intermediate result to achieve the final output. The function returns the resulting floating-point value after performing this computation.",
        "code_id": "c_group_1_id_515",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_quart_in(float t);\nCGLM_INLINE\nfloat\nglm_ease_quart_in(float t) {\n  float f;\n  f = t * t;\n  return f * f;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_516",
        "query_text": "The function accepts a single floating-point value as an input, typically within the interval [0.0, 1.0], and applies a quartic easing transformation that decelerates smoothly toward the endpoint. Internally, it subtracts one from the input, raises the result to the third power, multiplies it by the complement of the original input, and finally adds one to produce a transformed value. This effect is commonly used in animations or transitions to create a smooth slowdown. The function returns the computed floating-point result without modifying the original input.",
        "code_id": "c_group_1_id_516",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_quart_out(float t);\nCGLM_INLINE\nfloat\nglm_ease_quart_out(float t) {\n  float f;\n\n  f = t - 1.0f;\n\n  return f * f * f * (1.0f - t) + 1.0f;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_517",
        "query_text": "The function takes a single floating-point input, which is expected to be in the range of 0 to 1, and applies a smooth quartic easing transition. It first checks whether the input is in the first half (less than 0.5) or the second half (0.5 or greater) of the progression. For inputs below 0.5, it computes an accelerated, quartic-in easing; for inputs of 0.5 or more, it computes a decelerated, quartic-out easing. The function returns a floating-point output\u2014also in the range of 0 to 1\u2014that reflects this symmetric easing effect. Additionally, the logic implicitly clamps the input to ensure a smooth and valid result even if the provided value is outside the expected range.",
        "code_id": "c_group_1_id_517",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_quart_inout(float t);\nCGLM_INLINE\nfloat\nglm_ease_quart_inout(float t) {\n  float f, g;\n\n  if (t < 0.5f) {\n    f = t * t;\n    return 8.0f * f * f;\n  }\n\n  f = t - 1.0f;\n  g = f * f;\n\n  return -8.0f * g * g + 1.0f;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_518",
        "query_text": "This function takes a floating-point value as its input and returns a floating-point value representing the result of applying a quintic easing-in transformation. It internally computes the square of the input, then multiplies that squared value by itself and by the original input, effectively raising the input to the fifth power. This produces an easing effect where the progression starts slowly and accelerates sharply, yielding a smooth, non-linear transition.",
        "code_id": "c_group_1_id_518",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_quint_in(float t);\nCGLM_INLINE\nfloat\nglm_ease_quint_in(float t) {\n  float f;\n  f = t * t;\n  return f * f * t;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_519",
        "query_text": "The function takes a single floating-point value as input and produces a floating-point value as output. It applies a quintic easing-out transformation to the input, calculated by subtracting one from the input, squaring the result, and using this squared value repeatedly to compute a fifth-power term before adding one. Consequently, when the input is within the range [0, 1], the output is also guaranteed to be within [0, 1]. This easing operation is typically used in animations and transitions to create a smooth deceleration effect toward the end of a movement or change.",
        "code_id": "c_group_1_id_519",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_quint_out(float t);\nCGLM_INLINE\nfloat\nglm_ease_quint_out(float t) {\n  float f, g;\n\n  f = t - 1.0f;\n  g = f * f;\n\n  return g * g * f + 1.0f;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_520",
        "query_text": "The function accepts a floating-point input representing a normalized value (typically within the range [0, 1]) used to indicate progress, time, or an interpolation factor. It computes a transformation that simulates a \u201cback-in\u201d easing effect\u2014initiating motion gradually, overshooting the target slightly, and then settling towards the final value. The function returns a float that embodies this modified progress, making it useful for creating smooth animations or transitions. Both the input and output are of type float.",
        "code_id": "c_group_1_id_520",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_back_in(float t);\nCGLM_INLINE\nfloat\nglm_ease_back_in(float t) {\n  float o, z;\n\n  o = 1.70158f;\n  z = ((o + 1.0f) * t) - o;\n\n  return t * t * z;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_521",
        "query_text": "The function accepts one input of type float and returns a float value. It processes the input by applying an easing transformation that produces a smooth animation effect with a slight overshoot before settling. Essentially, the transformation modifies the input value\u2014assumed to typically lie within the range [0, 1]\u2014to create a more natural motion, where the output may temporarily exceed 1 due to the overshooting. No checks are performed to constrain the input value within any specific bounds.",
        "code_id": "c_group_1_id_521",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_back_out(float t);\nCGLM_INLINE\nfloat\nglm_ease_back_out(float t) {\n  float o, z, n;\n\n  o = 1.70158f;\n  n = t - 1.0f;\n  z = (o + 1.0f) * n + o;\n\n  return n * n * z + 1.0f;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_522",
        "query_text": "The function takes a single floating-point number as input, which represents a normalized progress value typically ranging from 0 to 1. It computes an eased output value by applying a symmetric easing effect that combines both an initial \"back-in\" motion and a final \"back-out\" motion, creating a smooth transition with slight overshoots at both ends. The function returns the computed floating-point value to be used for animations or interpolations, while implicitly handling inputs outside the standard range.",
        "code_id": "c_group_1_id_522",
        "code_text": "CGLM_INLINE\nfloat\nglm_ease_back_inout(float t);\nCGLM_INLINE\nfloat\nglm_ease_back_inout(float t) {\n  float o, z, n, m, s, x;\n\n  o = 1.70158f;\n  s = o * 1.525f;\n  x = 0.5f;\n  n = t / 0.5f;\n\n  if (n < 1.0f) {\n    z = (s + 1) * n - s;\n    m = n * n * z;\n    return x * m;\n  }\n\n  n -= 2.0f;\n  z  = (s + 1.0f) * n + s;\n  m  = (n * n * z) + 2;\n\n  return x * m;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_523",
        "query_text": "The function accepts an error description as a string input (represented as a constant character pointer). It then prints this error message\u2014supplemented by the corresponding system error description if available\u2014to the standard error stream. Following this, the function terminates the program execution with a failure status and does not return any value. Although some behavior may differ slightly depending on platform-specific configurations or compiler attributes, the primary functionality remains consistent. The input is of type const char*, and there is no output since the function exits the program (void).",
        "code_id": "c_group_1_id_523",
        "code_text": "static WC_INLINE\n#if defined(WOLFSSL_FORCE_MALLOC_FAIL_TEST) || defined(WOLFSSL_ZEPHYR)\nTHREAD_RETURN\n#else\nWC_NORETURN void\n#endif\nerr_sys_with_errno(const char* msg);\nstatic WC_INLINE\n#if defined(WOLFSSL_FORCE_MALLOC_FAIL_TEST) || defined(WOLFSSL_ZEPHYR)\nTHREAD_RETURN\n#else\nWC_NORETURN void\n#endif\nerr_sys_with_errno(const char* msg)\n{\n#if !defined(__GNUC__)\n    /* scan-build (which pretends to be gnuc) can get confused and think the\n     * msg pointer can be null even when hardcoded and then it won't exit,\n     * making null pointer checks above the err_sys() call useless.\n     * We could just always exit() but some compilers will complain about no\n     * possible return, with gcc we know the attribute to handle that with\n     * WC_NORETURN. */\n    if (msg)\n#endif\n    {\n#if defined(HAVE_STRING_H) && defined(HAVE_ERRNO_H)\n        fprintf(stderr, \"wolfSSL error: %s: %s\\n\", msg, strerror(errno));\n#else\n        fprintf(stderr, \"wolfSSL error: %s\\n\", msg);\n#endif\n    }\n    XEXIT_T(EXIT_FAILURE);\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_524",
        "query_text": "The function accepts a time value as a time_t input and converts it into a broken-down calendar time structure (tm) in Coordinated Universal Time (UTC). Internally, it handles platform-specific differences to ensure thread safety by using a secure conversion routine on Windows and a reentrant version on other systems. The input is of type time_t, and the output is a tm structure containing detailed time components such as year, month, and day. The function is guaranteed not to throw exceptions.",
        "code_id": "c_group_1_id_524",
        "code_text": "std::tm gmtime(const std::time_t &time_tt) SPDLOG_NOEXCEPT;\nstd::tm gmtime(const std::time_t &time_tt) SPDLOG_NOEXCEPT {\n#ifdef _WIN32\n    std::tm tm;\n    ::gmtime_s(&tm, &time_tt);\n#else\n    std::tm tm;\n    ::gmtime_r(&time_tt, &tm);\n#endif\n    return tm;\n}",
        "relevance": 2
    },
    {
        "query_id": "q_group_1_id_525",
        "query_text": "This function obtains the unique identifier of the currently executing thread in a platform-independent manner. It takes no input parameters and returns the thread ID as an unsigned size_t value. The implementation conditionally selects the appropriate system call or library function based on the operating system (e.g., Windows, Linux, macOS, BSD variants, etc.), thereby abstracting away platform-specific details to provide a consistent interface for retrieving the thread identifier.",
        "code_id": "c_group_1_id_525",
        "code_text": "size_t _thread_id() SPDLOG_NOEXCEPT;\nsize_t _thread_id() SPDLOG_NOEXCEPT {\n#ifdef _WIN32\n    return static_cast<size_t>(::GetCurrentThreadId());\n#elif defined(__linux__)\n    #if defined(__ANDROID__) && defined(__ANDROID_API__) && (__ANDROID_API__ < 21)\n        #define SYS_gettid __NR_gettid\n    #endif\n    return static_cast<size_t>(::syscall(SYS_gettid));\n#elif defined(_AIX)\n    struct __pthrdsinfo buf;\n    int reg_size = 0;\n    pthread_t pt = pthread_self();\n    int retval = pthread_getthrds_np(&pt, PTHRDSINFO_QUERY_TID, &buf, sizeof(buf), NULL, &reg_size);\n    int tid = (!retval) ? buf.__pi_tid : 0;\n    return static_cast<size_t>(tid);\n#elif defined(__DragonFly__) || defined(__FreeBSD__)\n    return static_cast<size_t>(::pthread_getthreadid_np());\n#elif defined(__NetBSD__)\n    return static_cast<size_t>(::_lwp_self());\n#elif defined(__OpenBSD__)\n    return static_cast<size_t>(::getthrid());\n#elif defined(__sun)\n    return static_cast<size_t>(::thr_self());\n#elif __APPLE__\n    uint64_t tid;\n    // There is no pthread_threadid_np prior to Mac OS X 10.6, and it is not supported on any PPC,\n    // including 10.6.8 Rosetta. __POWERPC__ is Apple-specific define encompassing ppc and ppc64.\n    #ifdef MAC_OS_X_VERSION_MAX_ALLOWED\n    {\n        #if (MAC_OS_X_VERSION_MAX_ALLOWED < 1060) || defined(__POWERPC__)\n        tid = pthread_mach_thread_np(pthread_self());\n        #elif MAC_OS_X_VERSION_MIN_REQUIRED < 1060\n        if (&pthread_threadid_np) {\n            pthread_threadid_np(nullptr, &tid);\n        } else {\n            tid = pthread_mach_thread_np(pthread_self());\n        }\n        #else\n        pthread_threadid_np(nullptr, &tid);\n        #endif\n    }\n    #else\n    pthread_threadid_np(nullptr, &tid);\n    #endif\n    return static_cast<size_t>(tid);\n#else  // Default to standard C++11 (other Unix)\n    return static_cast<size_t>(std::hash<std::thread::id>()(std::this_thread::get_id()));\n#endif\n}",
        "relevance": 2
    }
]